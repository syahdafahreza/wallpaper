var kw = Object.defineProperty;
var Dw = (r, e, t) =>
  e in r
    ? kw(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
    : (r[e] = t);
var Lw = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports);
var T = (r, e, t) => Dw(r, typeof e != "symbol" ? e + "" : e, t);
var OU = Lw((Rr, Mr) => {
  (function () {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload")) return;
    for (const s of document.querySelectorAll('link[rel="modulepreload"]'))
      i(s);
    new MutationObserver((s) => {
      for (const n of s)
        if (n.type === "childList")
          for (const a of n.addedNodes)
            a.tagName === "LINK" && a.rel === "modulepreload" && i(a);
    }).observe(document, { childList: !0, subtree: !0 });
    function t(s) {
      const n = {};
      return (
        s.integrity && (n.integrity = s.integrity),
        s.referrerPolicy && (n.referrerPolicy = s.referrerPolicy),
        s.crossOrigin === "use-credentials"
          ? (n.credentials = "include")
          : s.crossOrigin === "anonymous"
          ? (n.credentials = "omit")
          : (n.credentials = "same-origin"),
        n
      );
    }
    function i(s) {
      if (s.ep) return;
      s.ep = !0;
      const n = t(s);
      fetch(s.href, n);
    }
  })();
  /**
   * @vue/shared v3.5.4
   * (c) 2018-present Yuxi (Evan) You and Vue contributors
   * @license MIT
   **/ /*! #__NO_SIDE_EFFECTS__ */ function Xf(r) {
    const e = Object.create(null);
    for (const t of r.split(",")) e[t] = 1;
    return (t) => t in e;
  }
  const ft = {},
    ma = [],
    ar = () => {},
    Nw = () => !1,
    pc = (r) =>
      r.charCodeAt(0) === 111 &&
      r.charCodeAt(1) === 110 &&
      (r.charCodeAt(2) > 122 || r.charCodeAt(2) < 97),
    zf = (r) => r.startsWith("onUpdate:"),
    Bt = Object.assign,
    Wf = (r, e) => {
      const t = r.indexOf(e);
      t > -1 && r.splice(t, 1);
    },
    Uw = Object.prototype.hasOwnProperty,
    nt = (r, e) => Uw.call(r, e),
    Oe = Array.isArray,
    ga = (r) => nl(r) === "[object Map]",
    dy = (r) => nl(r) === "[object Set]",
    vm = (r) => nl(r) === "[object Date]",
    Fe = (r) => typeof r == "function",
    Ge = (r) => typeof r == "string",
    Xi = (r) => typeof r == "symbol",
    Qe = (r) => r !== null && typeof r == "object",
    Sh = (r) => (Qe(r) || Fe(r)) && Fe(r.then) && Fe(r.catch),
    fy = Object.prototype.toString,
    nl = (r) => fy.call(r),
    Vw = (r) => nl(r).slice(8, -1),
    py = (r) => nl(r) === "[object Object]",
    Yf = (r) =>
      Ge(r) && r !== "NaN" && r[0] !== "-" && "" + parseInt(r, 10) === r,
    So = Xf(
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    ),
    mc = (r) => {
      const e = Object.create(null);
      return (t) => e[t] || (e[t] = r(t));
    },
    $w = /-(\w)/g,
    Xr = mc((r) => r.replace($w, (e, t) => (t ? t.toUpperCase() : ""))),
    Gw = /\B([A-Z])/g,
    qs = mc((r) => r.replace(Gw, "-$1").toLowerCase()),
    gc = mc((r) => r.charAt(0).toUpperCase() + r.slice(1)),
    jc = mc((r) => (r ? `on${gc(r)}` : "")),
    zs = (r, e) => !Object.is(r, e),
    lh = (r, ...e) => {
      for (let t = 0; t < r.length; t++) r[t](...e);
    },
    my = (r, e, t, i = !1) => {
      Object.defineProperty(r, e, {
        configurable: !0,
        enumerable: !1,
        writable: i,
        value: t,
      });
    },
    Hw = (r) => {
      const e = parseFloat(r);
      return isNaN(e) ? r : e;
    },
    Xw = (r) => {
      const e = Ge(r) ? Number(r) : NaN;
      return isNaN(e) ? r : e;
    };
  let ym;
  const gy = () =>
    ym ||
    (ym =
      typeof globalThis < "u"
        ? globalThis
        : typeof self < "u"
        ? self
        : typeof window < "u"
        ? window
        : typeof global < "u"
        ? global
        : {});
  function Et(r) {
    if (Oe(r)) {
      const e = {};
      for (let t = 0; t < r.length; t++) {
        const i = r[t],
          s = Ge(i) ? jw(i) : Et(i);
        if (s) for (const n in s) e[n] = s[n];
      }
      return e;
    } else if (Ge(r) || Qe(r)) return r;
  }
  const zw = /;(?![^(]*\))/g,
    Ww = /:([^]+)/,
    Yw = /\/\*[^]*?\*\//g;
  function jw(r) {
    const e = {};
    return (
      r
        .replace(Yw, "")
        .split(zw)
        .forEach((t) => {
          if (t) {
            const i = t.split(Ww);
            i.length > 1 && (e[i[0].trim()] = i[1].trim());
          }
        }),
      e
    );
  }
  function ce(r) {
    let e = "";
    if (Ge(r)) e = r;
    else if (Oe(r))
      for (let t = 0; t < r.length; t++) {
        const i = ce(r[t]);
        i && (e += i + " ");
      }
    else if (Qe(r)) for (const t in r) r[t] && (e += t + " ");
    return e.trim();
  }
  const qw =
      "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    Kw = Xf(qw);
  function vy(r) {
    return !!r || r === "";
  }
  function Zw(r, e) {
    if (r.length !== e.length) return !1;
    let t = !0;
    for (let i = 0; t && i < r.length; i++) t = Ah(r[i], e[i]);
    return t;
  }
  function Ah(r, e) {
    if (r === e) return !0;
    let t = vm(r),
      i = vm(e);
    if (t || i) return t && i ? r.getTime() === e.getTime() : !1;
    if (((t = Xi(r)), (i = Xi(e)), t || i)) return r === e;
    if (((t = Oe(r)), (i = Oe(e)), t || i)) return t && i ? Zw(r, e) : !1;
    if (((t = Qe(r)), (i = Qe(e)), t || i)) {
      if (!t || !i) return !1;
      const s = Object.keys(r).length,
        n = Object.keys(e).length;
      if (s !== n) return !1;
      for (const a in r) {
        const o = r.hasOwnProperty(a),
          l = e.hasOwnProperty(a);
        if ((o && !l) || (!o && l) || !Ah(r[a], e[a])) return !1;
      }
    }
    return String(r) === String(e);
  }
  const yy = (r) => !!(r && r.__v_isRef === !0),
    Ut = (r) =>
      Ge(r)
        ? r
        : r == null
        ? ""
        : Oe(r) || (Qe(r) && (r.toString === fy || !Fe(r.toString)))
        ? yy(r)
          ? Ut(r.value)
          : JSON.stringify(r, by, 2)
        : String(r),
    by = (r, e) =>
      yy(e)
        ? by(r, e.value)
        : ga(e)
        ? {
            [`Map(${e.size})`]: [...e.entries()].reduce(
              (t, [i, s], n) => ((t[qc(i, n) + " =>"] = s), t),
              {}
            ),
          }
        : dy(e)
        ? { [`Set(${e.size})`]: [...e.values()].map((t) => qc(t)) }
        : Xi(e)
        ? qc(e)
        : Qe(e) && !Oe(e) && !py(e)
        ? String(e)
        : e,
    qc = (r, e = "") => {
      var t;
      return Xi(r) ? `Symbol(${(t = r.description) != null ? t : e})` : r;
    };
  /**
   * @vue/reactivity v3.5.4
   * (c) 2018-present Yuxi (Evan) You and Vue contributors
   * @license MIT
   **/ let cr;
  class xy {
    constructor(e = !1) {
      (this.detached = e),
        (this._active = !0),
        (this.effects = []),
        (this.cleanups = []),
        (this._isPaused = !1),
        (this.parent = cr),
        !e &&
          cr &&
          (this.index = (cr.scopes || (cr.scopes = [])).push(this) - 1);
    }
    get active() {
      return this._active;
    }
    pause() {
      if (this._active) {
        this._isPaused = !0;
        let e, t;
        if (this.scopes)
          for (e = 0, t = this.scopes.length; e < t; e++)
            this.scopes[e].pause();
        for (e = 0, t = this.effects.length; e < t; e++)
          this.effects[e].pause();
      }
    }
    resume() {
      if (this._active && this._isPaused) {
        this._isPaused = !1;
        let e, t;
        if (this.scopes)
          for (e = 0, t = this.scopes.length; e < t; e++)
            this.scopes[e].resume();
        for (e = 0, t = this.effects.length; e < t; e++)
          this.effects[e].resume();
      }
    }
    run(e) {
      if (this._active) {
        const t = cr;
        try {
          return (cr = this), e();
        } finally {
          cr = t;
        }
      }
    }
    on() {
      cr = this;
    }
    off() {
      cr = this.parent;
    }
    stop(e) {
      if (this._active) {
        let t, i;
        for (t = 0, i = this.effects.length; t < i; t++) this.effects[t].stop();
        for (t = 0, i = this.cleanups.length; t < i; t++) this.cleanups[t]();
        if (this.scopes)
          for (t = 0, i = this.scopes.length; t < i; t++)
            this.scopes[t].stop(!0);
        if (!this.detached && this.parent && !e) {
          const s = this.parent.scopes.pop();
          s &&
            s !== this &&
            ((this.parent.scopes[this.index] = s), (s.index = this.index));
        }
        (this.parent = void 0), (this._active = !1);
      }
    }
  }
  function Jw(r) {
    return new xy(r);
  }
  function _y() {
    return cr;
  }
  function Qw(r, e = !1) {
    cr && cr.cleanups.push(r);
  }
  let dt;
  const Kc = new WeakSet();
  class wy {
    constructor(e) {
      (this.fn = e),
        (this.deps = void 0),
        (this.depsTail = void 0),
        (this.flags = 5),
        (this.nextEffect = void 0),
        (this.cleanup = void 0),
        (this.scheduler = void 0),
        cr && cr.active && cr.effects.push(this);
    }
    pause() {
      this.flags |= 64;
    }
    resume() {
      this.flags & 64 &&
        ((this.flags &= -65),
        Kc.has(this) && (Kc.delete(this), this.trigger()));
    }
    notify() {
      (this.flags & 2 && !(this.flags & 32)) ||
        this.flags & 8 ||
        ((this.flags |= 8), (this.nextEffect = Ao), (Ao = this));
    }
    run() {
      if (!(this.flags & 1)) return this.fn();
      (this.flags |= 2), bm(this), Ey(this);
      const e = dt,
        t = li;
      (dt = this), (li = !0);
      try {
        return this.fn();
      } finally {
        Sy(this), (dt = e), (li = t), (this.flags &= -3);
      }
    }
    stop() {
      if (this.flags & 1) {
        for (let e = this.deps; e; e = e.nextDep) Kf(e);
        (this.deps = this.depsTail = void 0),
          bm(this),
          this.onStop && this.onStop(),
          (this.flags &= -2);
      }
    }
    trigger() {
      this.flags & 64
        ? Kc.add(this)
        : this.scheduler
        ? this.scheduler()
        : this.runIfDirty();
    }
    runIfDirty() {
      ud(this) && this.run();
    }
    get dirty() {
      return ud(this);
    }
  }
  let Ty = 0,
    Ao;
  function jf() {
    Ty++;
  }
  function qf() {
    if (--Ty > 0) return;
    let r;
    for (; Ao; ) {
      let e = Ao;
      for (Ao = void 0; e; ) {
        const t = e.nextEffect;
        if (((e.nextEffect = void 0), (e.flags &= -9), e.flags & 1))
          try {
            e.trigger();
          } catch (i) {
            r || (r = i);
          }
        e = t;
      }
    }
    if (r) throw r;
  }
  function Ey(r) {
    for (let e = r.deps; e; e = e.nextDep)
      (e.version = -1),
        (e.prevActiveLink = e.dep.activeLink),
        (e.dep.activeLink = e);
  }
  function Sy(r) {
    let e,
      t = r.depsTail;
    for (let i = t; i; i = i.prevDep)
      i.version === -1 ? (i === t && (t = i.prevDep), Kf(i), eT(i)) : (e = i),
        (i.dep.activeLink = i.prevActiveLink),
        (i.prevActiveLink = void 0);
    (r.deps = e), (r.depsTail = t);
  }
  function ud(r) {
    for (let e = r.deps; e; e = e.nextDep)
      if (
        e.dep.version !== e.version ||
        (e.dep.computed && Ay(e.dep.computed)) ||
        e.dep.version !== e.version
      )
        return !0;
    return !!r._dirty;
  }
  function Ay(r) {
    if (
      (r.flags & 4 && !(r.flags & 16)) ||
      ((r.flags &= -17), r.globalVersion === Vo)
    )
      return;
    r.globalVersion = Vo;
    const e = r.dep;
    if (((r.flags |= 2), e.version > 0 && !r.isSSR && !ud(r))) {
      r.flags &= -3;
      return;
    }
    const t = dt,
      i = li;
    (dt = r), (li = !0);
    try {
      Ey(r);
      const s = r.fn(r._value);
      (e.version === 0 || zs(s, r._value)) && ((r._value = s), e.version++);
    } catch (s) {
      throw (e.version++, s);
    } finally {
      (dt = t), (li = i), Sy(r), (r.flags &= -3);
    }
  }
  function Kf(r) {
    const { dep: e, prevSub: t, nextSub: i } = r;
    if (
      (t && ((t.nextSub = i), (r.prevSub = void 0)),
      i && ((i.prevSub = t), (r.nextSub = void 0)),
      e.subs === r && (e.subs = t),
      !e.subs && e.computed)
    ) {
      e.computed.flags &= -5;
      for (let s = e.computed.deps; s; s = s.nextDep) Kf(s);
    }
  }
  function eT(r) {
    const { prevDep: e, nextDep: t } = r;
    e && ((e.nextDep = t), (r.prevDep = void 0)),
      t && ((t.prevDep = e), (r.nextDep = void 0));
  }
  let li = !0;
  const Cy = [];
  function Ks() {
    Cy.push(li), (li = !1);
  }
  function Zs() {
    const r = Cy.pop();
    li = r === void 0 ? !0 : r;
  }
  function bm(r) {
    const { cleanup: e } = r;
    if (((r.cleanup = void 0), e)) {
      const t = dt;
      dt = void 0;
      try {
        e();
      } finally {
        dt = t;
      }
    }
  }
  let Vo = 0;
  class Zf {
    constructor(e) {
      (this.computed = e),
        (this.version = 0),
        (this.activeLink = void 0),
        (this.subs = void 0);
    }
    track(e) {
      if (!dt || !li || dt === this.computed) return;
      let t = this.activeLink;
      if (t === void 0 || t.sub !== dt)
        (t = this.activeLink =
          {
            dep: this,
            sub: dt,
            version: this.version,
            nextDep: void 0,
            prevDep: void 0,
            nextSub: void 0,
            prevSub: void 0,
            prevActiveLink: void 0,
          }),
          dt.deps
            ? ((t.prevDep = dt.depsTail),
              (dt.depsTail.nextDep = t),
              (dt.depsTail = t))
            : (dt.deps = dt.depsTail = t),
          dt.flags & 4 && Iy(t);
      else if (t.version === -1 && ((t.version = this.version), t.nextDep)) {
        const i = t.nextDep;
        (i.prevDep = t.prevDep),
          t.prevDep && (t.prevDep.nextDep = i),
          (t.prevDep = dt.depsTail),
          (t.nextDep = void 0),
          (dt.depsTail.nextDep = t),
          (dt.depsTail = t),
          dt.deps === t && (dt.deps = i);
      }
      return t;
    }
    trigger(e) {
      this.version++, Vo++, this.notify(e);
    }
    notify(e) {
      jf();
      try {
        for (let t = this.subs; t; t = t.prevSub) t.sub.notify();
      } finally {
        qf();
      }
    }
  }
  function Iy(r) {
    const e = r.dep.computed;
    if (e && !r.dep.subs) {
      e.flags |= 20;
      for (let i = e.deps; i; i = i.nextDep) Iy(i);
    }
    const t = r.dep.subs;
    t !== r && ((r.prevSub = t), t && (t.nextSub = r)), (r.dep.subs = r);
  }
  const Ch = new WeakMap(),
    xn = Symbol(""),
    dd = Symbol(""),
    $o = Symbol("");
  function or(r, e, t) {
    if (li && dt) {
      let i = Ch.get(r);
      i || Ch.set(r, (i = new Map()));
      let s = i.get(t);
      s || i.set(t, (s = new Zf())), s.track();
    }
  }
  function ds(r, e, t, i, s, n) {
    const a = Ch.get(r);
    if (!a) {
      Vo++;
      return;
    }
    const o = (l) => {
      l && l.trigger();
    };
    if ((jf(), e === "clear")) a.forEach(o);
    else {
      const l = Oe(r),
        h = l && Yf(t);
      if (l && t === "length") {
        const c = Number(i);
        a.forEach((u, d) => {
          (d === "length" || d === $o || (!Xi(d) && d >= c)) && o(u);
        });
      } else
        switch ((t !== void 0 && o(a.get(t)), h && o(a.get($o)), e)) {
          case "add":
            l ? h && o(a.get("length")) : (o(a.get(xn)), ga(r) && o(a.get(dd)));
            break;
          case "delete":
            l || (o(a.get(xn)), ga(r) && o(a.get(dd)));
            break;
          case "set":
            ga(r) && o(a.get(xn));
            break;
        }
    }
    qf();
  }
  function tT(r, e) {
    var t;
    return (t = Ch.get(r)) == null ? void 0 : t.get(e);
  }
  function Xn(r) {
    const e = tt(r);
    return e === r ? e : (or(e, "iterate", $o), $r(r) ? e : e.map(rr));
  }
  function vc(r) {
    return or((r = tt(r)), "iterate", $o), r;
  }
  const rT = {
    __proto__: null,
    [Symbol.iterator]() {
      return Zc(this, Symbol.iterator, rr);
    },
    concat(...r) {
      return Xn(this).concat(...r.map((e) => (Oe(e) ? Xn(e) : e)));
    },
    entries() {
      return Zc(this, "entries", (r) => ((r[1] = rr(r[1])), r));
    },
    every(r, e) {
      return Ki(this, "every", r, e, void 0, arguments);
    },
    filter(r, e) {
      return Ki(this, "filter", r, e, (t) => t.map(rr), arguments);
    },
    find(r, e) {
      return Ki(this, "find", r, e, rr, arguments);
    },
    findIndex(r, e) {
      return Ki(this, "findIndex", r, e, void 0, arguments);
    },
    findLast(r, e) {
      return Ki(this, "findLast", r, e, rr, arguments);
    },
    findLastIndex(r, e) {
      return Ki(this, "findLastIndex", r, e, void 0, arguments);
    },
    forEach(r, e) {
      return Ki(this, "forEach", r, e, void 0, arguments);
    },
    includes(...r) {
      return Jc(this, "includes", r);
    },
    indexOf(...r) {
      return Jc(this, "indexOf", r);
    },
    join(r) {
      return Xn(this).join(r);
    },
    lastIndexOf(...r) {
      return Jc(this, "lastIndexOf", r);
    },
    map(r, e) {
      return Ki(this, "map", r, e, void 0, arguments);
    },
    pop() {
      return so(this, "pop");
    },
    push(...r) {
      return so(this, "push", r);
    },
    reduce(r, ...e) {
      return xm(this, "reduce", r, e);
    },
    reduceRight(r, ...e) {
      return xm(this, "reduceRight", r, e);
    },
    shift() {
      return so(this, "shift");
    },
    some(r, e) {
      return Ki(this, "some", r, e, void 0, arguments);
    },
    splice(...r) {
      return so(this, "splice", r);
    },
    toReversed() {
      return Xn(this).toReversed();
    },
    toSorted(r) {
      return Xn(this).toSorted(r);
    },
    toSpliced(...r) {
      return Xn(this).toSpliced(...r);
    },
    unshift(...r) {
      return so(this, "unshift", r);
    },
    values() {
      return Zc(this, "values", rr);
    },
  };
  function Zc(r, e, t) {
    const i = vc(r),
      s = i[e]();
    return (
      i !== r &&
        !$r(r) &&
        ((s._next = s.next),
        (s.next = () => {
          const n = s._next();
          return n.value && (n.value = t(n.value)), n;
        })),
      s
    );
  }
  const iT = Array.prototype;
  function Ki(r, e, t, i, s, n) {
    const a = vc(r),
      o = a !== r && !$r(r),
      l = a[e];
    if (l !== iT[e]) {
      const u = l.apply(r, n);
      return o ? rr(u) : u;
    }
    let h = t;
    a !== r &&
      (o
        ? (h = function (u, d) {
            return t.call(this, rr(u), d, r);
          })
        : t.length > 2 &&
          (h = function (u, d) {
            return t.call(this, u, d, r);
          }));
    const c = l.call(a, h, i);
    return o && s ? s(c) : c;
  }
  function xm(r, e, t, i) {
    const s = vc(r);
    let n = t;
    return (
      s !== r &&
        ($r(r)
          ? t.length > 3 &&
            (n = function (a, o, l) {
              return t.call(this, a, o, l, r);
            })
          : (n = function (a, o, l) {
              return t.call(this, a, rr(o), l, r);
            })),
      s[e](n, ...i)
    );
  }
  function Jc(r, e, t) {
    const i = tt(r);
    or(i, "iterate", $o);
    const s = i[e](...t);
    return (s === -1 || s === !1) && rp(t[0])
      ? ((t[0] = tt(t[0])), i[e](...t))
      : s;
  }
  function so(r, e, t = []) {
    Ks(), jf();
    const i = tt(r)[e].apply(r, t);
    return qf(), Zs(), i;
  }
  const sT = Xf("__proto__,__v_isRef,__isVue"),
    Py = new Set(
      Object.getOwnPropertyNames(Symbol)
        .filter((r) => r !== "arguments" && r !== "caller")
        .map((r) => Symbol[r])
        .filter(Xi)
    );
  function nT(r) {
    Xi(r) || (r = String(r));
    const e = tt(this);
    return or(e, "has", r), e.hasOwnProperty(r);
  }
  class Ry {
    constructor(e = !1, t = !1) {
      (this._isReadonly = e), (this._isShallow = t);
    }
    get(e, t, i) {
      const s = this._isReadonly,
        n = this._isShallow;
      if (t === "__v_isReactive") return !s;
      if (t === "__v_isReadonly") return s;
      if (t === "__v_isShallow") return n;
      if (t === "__v_raw")
        return i === (s ? (n ? yT : Oy) : n ? By : Fy).get(e) ||
          Object.getPrototypeOf(e) === Object.getPrototypeOf(i)
          ? e
          : void 0;
      const a = Oe(e);
      if (!s) {
        let l;
        if (a && (l = rT[t])) return l;
        if (t === "hasOwnProperty") return nT;
      }
      const o = Reflect.get(e, t, Mt(e) ? e : i);
      return (Xi(t) ? Py.has(t) : sT(t)) || (s || or(e, "get", t), n)
        ? o
        : Mt(o)
        ? a && Yf(t)
          ? o
          : o.value
        : Qe(o)
        ? s
          ? ep(o)
          : vi(o)
        : o;
    }
  }
  class My extends Ry {
    constructor(e = !1) {
      super(!1, e);
    }
    set(e, t, i, s) {
      let n = e[t];
      if (!this._isShallow) {
        const l = Pn(n);
        if (
          (!$r(i) && !Pn(i) && ((n = tt(n)), (i = tt(i))),
          !Oe(e) && Mt(n) && !Mt(i))
        )
          return l ? !1 : ((n.value = i), !0);
      }
      const a = Oe(e) && Yf(t) ? Number(t) < e.length : nt(e, t),
        o = Reflect.set(e, t, i, Mt(e) ? e : s);
      return (
        e === tt(s) &&
          (a ? zs(i, n) && ds(e, "set", t, i) : ds(e, "add", t, i)),
        o
      );
    }
    deleteProperty(e, t) {
      const i = nt(e, t);
      e[t];
      const s = Reflect.deleteProperty(e, t);
      return s && i && ds(e, "delete", t, void 0), s;
    }
    has(e, t) {
      const i = Reflect.has(e, t);
      return (!Xi(t) || !Py.has(t)) && or(e, "has", t), i;
    }
    ownKeys(e) {
      return or(e, "iterate", Oe(e) ? "length" : xn), Reflect.ownKeys(e);
    }
  }
  class aT extends Ry {
    constructor(e = !1) {
      super(!0, e);
    }
    set(e, t) {
      return !0;
    }
    deleteProperty(e, t) {
      return !0;
    }
  }
  const oT = new My(),
    lT = new aT(),
    hT = new My(!0),
    Jf = (r) => r,
    yc = (r) => Reflect.getPrototypeOf(r);
  function wl(r, e, t = !1, i = !1) {
    r = r.__v_raw;
    const s = tt(r),
      n = tt(e);
    t || (zs(e, n) && or(s, "get", e), or(s, "get", n));
    const { has: a } = yc(s),
      o = i ? Jf : t ? ip : rr;
    if (a.call(s, e)) return o(r.get(e));
    if (a.call(s, n)) return o(r.get(n));
    r !== s && r.get(e);
  }
  function Tl(r, e = !1) {
    const t = this.__v_raw,
      i = tt(t),
      s = tt(r);
    return (
      e || (zs(r, s) && or(i, "has", r), or(i, "has", s)),
      r === s ? t.has(r) : t.has(r) || t.has(s)
    );
  }
  function El(r, e = !1) {
    return (
      (r = r.__v_raw), !e && or(tt(r), "iterate", xn), Reflect.get(r, "size", r)
    );
  }
  function _m(r, e = !1) {
    !e && !$r(r) && !Pn(r) && (r = tt(r));
    const t = tt(this);
    return yc(t).has.call(t, r) || (t.add(r), ds(t, "add", r, r)), this;
  }
  function wm(r, e, t = !1) {
    !t && !$r(e) && !Pn(e) && (e = tt(e));
    const i = tt(this),
      { has: s, get: n } = yc(i);
    let a = s.call(i, r);
    a || ((r = tt(r)), (a = s.call(i, r)));
    const o = n.call(i, r);
    return (
      i.set(r, e), a ? zs(e, o) && ds(i, "set", r, e) : ds(i, "add", r, e), this
    );
  }
  function Tm(r) {
    const e = tt(this),
      { has: t, get: i } = yc(e);
    let s = t.call(e, r);
    s || ((r = tt(r)), (s = t.call(e, r))), i && i.call(e, r);
    const n = e.delete(r);
    return s && ds(e, "delete", r, void 0), n;
  }
  function Em() {
    const r = tt(this),
      e = r.size !== 0,
      t = r.clear();
    return e && ds(r, "clear", void 0, void 0), t;
  }
  function Sl(r, e) {
    return function (i, s) {
      const n = this,
        a = n.__v_raw,
        o = tt(a),
        l = e ? Jf : r ? ip : rr;
      return (
        !r && or(o, "iterate", xn),
        a.forEach((h, c) => i.call(s, l(h), l(c), n))
      );
    };
  }
  function Al(r, e, t) {
    return function (...i) {
      const s = this.__v_raw,
        n = tt(s),
        a = ga(n),
        o = r === "entries" || (r === Symbol.iterator && a),
        l = r === "keys" && a,
        h = s[r](...i),
        c = t ? Jf : e ? ip : rr;
      return (
        !e && or(n, "iterate", l ? dd : xn),
        {
          next() {
            const { value: u, done: d } = h.next();
            return d
              ? { value: u, done: d }
              : { value: o ? [c(u[0]), c(u[1])] : c(u), done: d };
          },
          [Symbol.iterator]() {
            return this;
          },
        }
      );
    };
  }
  function Ts(r) {
    return function (...e) {
      return r === "delete" ? !1 : r === "clear" ? void 0 : this;
    };
  }
  function cT() {
    const r = {
        get(n) {
          return wl(this, n);
        },
        get size() {
          return El(this);
        },
        has: Tl,
        add: _m,
        set: wm,
        delete: Tm,
        clear: Em,
        forEach: Sl(!1, !1),
      },
      e = {
        get(n) {
          return wl(this, n, !1, !0);
        },
        get size() {
          return El(this);
        },
        has: Tl,
        add(n) {
          return _m.call(this, n, !0);
        },
        set(n, a) {
          return wm.call(this, n, a, !0);
        },
        delete: Tm,
        clear: Em,
        forEach: Sl(!1, !0),
      },
      t = {
        get(n) {
          return wl(this, n, !0);
        },
        get size() {
          return El(this, !0);
        },
        has(n) {
          return Tl.call(this, n, !0);
        },
        add: Ts("add"),
        set: Ts("set"),
        delete: Ts("delete"),
        clear: Ts("clear"),
        forEach: Sl(!0, !1),
      },
      i = {
        get(n) {
          return wl(this, n, !0, !0);
        },
        get size() {
          return El(this, !0);
        },
        has(n) {
          return Tl.call(this, n, !0);
        },
        add: Ts("add"),
        set: Ts("set"),
        delete: Ts("delete"),
        clear: Ts("clear"),
        forEach: Sl(!0, !0),
      };
    return (
      ["keys", "values", "entries", Symbol.iterator].forEach((n) => {
        (r[n] = Al(n, !1, !1)),
          (t[n] = Al(n, !0, !1)),
          (e[n] = Al(n, !1, !0)),
          (i[n] = Al(n, !0, !0));
      }),
      [r, t, e, i]
    );
  }
  const [uT, dT, fT, pT] = cT();
  function Qf(r, e) {
    const t = e ? (r ? pT : fT) : r ? dT : uT;
    return (i, s, n) =>
      s === "__v_isReactive"
        ? !r
        : s === "__v_isReadonly"
        ? r
        : s === "__v_raw"
        ? i
        : Reflect.get(nt(t, s) && s in i ? t : i, s, n);
  }
  const mT = { get: Qf(!1, !1) },
    gT = { get: Qf(!1, !0) },
    vT = { get: Qf(!0, !1) },
    Fy = new WeakMap(),
    By = new WeakMap(),
    Oy = new WeakMap(),
    yT = new WeakMap();
  function bT(r) {
    switch (r) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function xT(r) {
    return r.__v_skip || !Object.isExtensible(r) ? 0 : bT(Vw(r));
  }
  function vi(r) {
    return Pn(r) ? r : tp(r, !1, oT, mT, Fy);
  }
  function _T(r) {
    return tp(r, !1, hT, gT, By);
  }
  function ep(r) {
    return tp(r, !0, lT, vT, Oy);
  }
  function tp(r, e, t, i, s) {
    if (!Qe(r) || (r.__v_raw && !(e && r.__v_isReactive))) return r;
    const n = s.get(r);
    if (n) return n;
    const a = xT(r);
    if (a === 0) return r;
    const o = new Proxy(r, a === 2 ? i : t);
    return s.set(r, o), o;
  }
  function va(r) {
    return Pn(r) ? va(r.__v_raw) : !!(r && r.__v_isReactive);
  }
  function Pn(r) {
    return !!(r && r.__v_isReadonly);
  }
  function $r(r) {
    return !!(r && r.__v_isShallow);
  }
  function rp(r) {
    return r ? !!r.__v_raw : !1;
  }
  function tt(r) {
    const e = r && r.__v_raw;
    return e ? tt(e) : r;
  }
  function fd(r) {
    return (
      !nt(r, "__v_skip") && Object.isExtensible(r) && my(r, "__v_skip", !0), r
    );
  }
  const rr = (r) => (Qe(r) ? vi(r) : r),
    ip = (r) => (Qe(r) ? ep(r) : r);
  function Mt(r) {
    return r ? r.__v_isRef === !0 : !1;
  }
  function he(r) {
    return ky(r, !1);
  }
  function _n(r) {
    return ky(r, !0);
  }
  function ky(r, e) {
    return Mt(r) ? r : new wT(r, e);
  }
  class wT {
    constructor(e, t) {
      (this.dep = new Zf()),
        (this.__v_isRef = !0),
        (this.__v_isShallow = !1),
        (this._rawValue = t ? e : tt(e)),
        (this._value = t ? e : rr(e)),
        (this.__v_isShallow = t);
    }
    get value() {
      return this.dep.track(), this._value;
    }
    set value(e) {
      const t = this._rawValue,
        i = this.__v_isShallow || $r(e) || Pn(e);
      (e = i ? e : tt(e)),
        zs(e, t) &&
          ((this._rawValue = e),
          (this._value = i ? e : rr(e)),
          this.dep.trigger());
    }
  }
  function S(r) {
    return Mt(r) ? r.value : r;
  }
  const TT = {
    get: (r, e, t) => (e === "__v_raw" ? r : S(Reflect.get(r, e, t))),
    set: (r, e, t, i) => {
      const s = r[e];
      return Mt(s) && !Mt(t) ? ((s.value = t), !0) : Reflect.set(r, e, t, i);
    },
  };
  function Dy(r) {
    return va(r) ? r : new Proxy(r, TT);
  }
  function Ra(r) {
    const e = Oe(r) ? new Array(r.length) : {};
    for (const t in r) e[t] = Ly(r, t);
    return e;
  }
  class ET {
    constructor(e, t, i) {
      (this._object = e),
        (this._key = t),
        (this._defaultValue = i),
        (this.__v_isRef = !0),
        (this._value = void 0);
    }
    get value() {
      const e = this._object[this._key];
      return (this._value = e === void 0 ? this._defaultValue : e);
    }
    set value(e) {
      this._object[this._key] = e;
    }
    get dep() {
      return tT(tt(this._object), this._key);
    }
  }
  class ST {
    constructor(e) {
      (this._getter = e),
        (this.__v_isRef = !0),
        (this.__v_isReadonly = !0),
        (this._value = void 0);
    }
    get value() {
      return (this._value = this._getter());
    }
  }
  function ni(r, e, t) {
    return Mt(r)
      ? r
      : Fe(r)
      ? new ST(r)
      : Qe(r) && arguments.length > 1
      ? Ly(r, e, t)
      : he(r);
  }
  function Ly(r, e, t) {
    const i = r[e];
    return Mt(i) ? i : new ET(r, e, t);
  }
  class AT {
    constructor(e, t, i) {
      (this.fn = e),
        (this.setter = t),
        (this._value = void 0),
        (this.dep = new Zf(this)),
        (this.__v_isRef = !0),
        (this.deps = void 0),
        (this.depsTail = void 0),
        (this.flags = 16),
        (this.globalVersion = Vo - 1),
        (this.effect = this),
        (this.__v_isReadonly = !t),
        (this.isSSR = i);
    }
    notify() {
      (this.flags |= 16), dt !== this && this.dep.notify();
    }
    get value() {
      const e = this.dep.track();
      return Ay(this), e && (e.version = this.dep.version), this._value;
    }
    set value(e) {
      this.setter && this.setter(e);
    }
  }
  function CT(r, e, t = !1) {
    let i, s;
    return Fe(r) ? (i = r) : ((i = r.get), (s = r.set)), new AT(i, s, t);
  }
  const Cl = {},
    Ih = new WeakMap();
  let hn;
  function IT(r, e = !1, t = hn) {
    if (t) {
      let i = Ih.get(t);
      i || Ih.set(t, (i = [])), i.push(r);
    }
  }
  function PT(r, e, t = ft) {
    const {
        immediate: i,
        deep: s,
        once: n,
        scheduler: a,
        augmentJob: o,
        call: l,
      } = t,
      h = (y) => (s ? y : $r(y) || s === !1 || s === 0 ? os(y, 1) : os(y));
    let c,
      u,
      d,
      f,
      p = !1,
      m = !1;
    if (
      (Mt(r)
        ? ((u = () => r.value), (p = $r(r)))
        : va(r)
        ? ((u = () => h(r)), (p = !0))
        : Oe(r)
        ? ((m = !0),
          (p = r.some((y) => va(y) || $r(y))),
          (u = () =>
            r.map((y) => {
              if (Mt(y)) return y.value;
              if (va(y)) return h(y);
              if (Fe(y)) return l ? l(y, 2) : y();
            })))
        : Fe(r)
        ? e
          ? (u = l ? () => l(r, 2) : r)
          : (u = () => {
              if (d) {
                Ks();
                try {
                  d();
                } finally {
                  Zs();
                }
              }
              const y = hn;
              hn = c;
              try {
                return l ? l(r, 3, [f]) : r(f);
              } finally {
                hn = y;
              }
            })
        : (u = ar),
      e && s)
    ) {
      const y = u,
        _ = s === !0 ? 1 / 0 : s;
      u = () => os(y(), _);
    }
    const v = _y(),
      g = () => {
        c.stop(), v && Wf(v.effects, c);
      };
    if (n)
      if (e) {
        const y = e;
        e = (..._) => {
          y(..._), g();
        };
      } else {
        const y = u;
        u = () => {
          y(), g();
        };
      }
    let x = m ? new Array(r.length).fill(Cl) : Cl;
    const b = (y) => {
      if (!(!(c.flags & 1) || (!c.dirty && !y)))
        if (e) {
          const _ = c.run();
          if (s || p || (m ? _.some((w, E) => zs(w, x[E])) : zs(_, x))) {
            d && d();
            const w = hn;
            hn = c;
            try {
              const E = [_, x === Cl ? void 0 : m && x[0] === Cl ? [] : x, f];
              l ? l(e, 3, E) : e(...E), (x = _);
            } finally {
              hn = w;
            }
          }
        } else c.run();
    };
    return (
      o && o(b),
      (c = new wy(u)),
      (c.scheduler = a ? () => a(b, !1) : b),
      (f = (y) => IT(y, !1, c)),
      (d = c.onStop =
        () => {
          const y = Ih.get(c);
          if (y) {
            if (l) l(y, 4);
            else for (const _ of y) _();
            Ih.delete(c);
          }
        }),
      e ? (i ? b(!0) : (x = c.run())) : a ? a(b.bind(null, !0), !0) : c.run(),
      (g.pause = c.pause.bind(c)),
      (g.resume = c.resume.bind(c)),
      (g.stop = g),
      g
    );
  }
  function os(r, e = 1 / 0, t) {
    if (e <= 0 || !Qe(r) || r.__v_skip || ((t = t || new Set()), t.has(r)))
      return r;
    if ((t.add(r), e--, Mt(r))) os(r.value, e, t);
    else if (Oe(r)) for (let i = 0; i < r.length; i++) os(r[i], e, t);
    else if (dy(r) || ga(r))
      r.forEach((i) => {
        os(i, e, t);
      });
    else if (py(r)) {
      for (const i in r) os(r[i], e, t);
      for (const i of Object.getOwnPropertySymbols(r))
        Object.prototype.propertyIsEnumerable.call(r, i) && os(r[i], e, t);
    }
    return r;
  }
  /**
   * @vue/runtime-core v3.5.4
   * (c) 2018-present Yuxi (Evan) You and Vue contributors
   * @license MIT
   **/ function al(r, e, t, i) {
    try {
      return i ? r(...i) : r();
    } catch (s) {
      bc(s, e, t);
    }
  }
  function pi(r, e, t, i) {
    if (Fe(r)) {
      const s = al(r, e, t, i);
      return (
        s &&
          Sh(s) &&
          s.catch((n) => {
            bc(n, e, t);
          }),
        s
      );
    }
    if (Oe(r)) {
      const s = [];
      for (let n = 0; n < r.length; n++) s.push(pi(r[n], e, t, i));
      return s;
    }
  }
  function bc(r, e, t, i = !0) {
    const s = e ? e.vnode : null,
      { errorHandler: n, throwUnhandledErrorInProduction: a } =
        (e && e.appContext.config) || ft;
    if (e) {
      let o = e.parent;
      const l = e.proxy,
        h = `https://vuejs.org/error-reference/#runtime-${t}`;
      for (; o; ) {
        const c = o.ec;
        if (c) {
          for (let u = 0; u < c.length; u++) if (c[u](r, l, h) === !1) return;
        }
        o = o.parent;
      }
      if (n) {
        Ks(), al(n, null, 10, [r, l, h]), Zs();
        return;
      }
    }
    RT(r, t, s, i, a);
  }
  function RT(r, e, t, i = !0, s = !1) {
    if (s) throw r;
    console.error(r);
  }
  let Go = !1,
    pd = !1;
  const ur = [];
  let Pi = 0;
  const ya = [];
  let Ms = null,
    Qn = 0;
  const Ny = Promise.resolve();
  let sp = null;
  function _t(r) {
    const e = sp || Ny;
    return r ? e.then(this ? r.bind(this) : r) : e;
  }
  function MT(r) {
    let e = Go ? Pi + 1 : 0,
      t = ur.length;
    for (; e < t; ) {
      const i = (e + t) >>> 1,
        s = ur[i],
        n = Ho(s);
      n < r || (n === r && s.flags & 2) ? (e = i + 1) : (t = i);
    }
    return e;
  }
  function np(r) {
    if (!(r.flags & 1)) {
      const e = Ho(r),
        t = ur[ur.length - 1];
      !t || (!(r.flags & 2) && e >= Ho(t))
        ? ur.push(r)
        : ur.splice(MT(e), 0, r),
        (r.flags |= 1),
        Uy();
    }
  }
  function Uy() {
    !Go && !pd && ((pd = !0), (sp = Ny.then($y)));
  }
  function FT(r) {
    Oe(r)
      ? ya.push(...r)
      : Ms && r.id === -1
      ? Ms.splice(Qn + 1, 0, r)
      : r.flags & 1 || (ya.push(r), (r.flags |= 1)),
      Uy();
  }
  function Sm(r, e, t = Go ? Pi + 1 : 0) {
    for (; t < ur.length; t++) {
      const i = ur[t];
      if (i && i.flags & 2) {
        if (r && i.id !== r.uid) continue;
        ur.splice(t, 1),
          t--,
          i.flags & 4 && (i.flags &= -2),
          i(),
          (i.flags &= -2);
      }
    }
  }
  function Vy(r) {
    if (ya.length) {
      const e = [...new Set(ya)].sort((t, i) => Ho(t) - Ho(i));
      if (((ya.length = 0), Ms)) {
        Ms.push(...e);
        return;
      }
      for (Ms = e, Qn = 0; Qn < Ms.length; Qn++) {
        const t = Ms[Qn];
        t.flags & 4 && (t.flags &= -2), t.flags & 8 || t(), (t.flags &= -2);
      }
      (Ms = null), (Qn = 0);
    }
  }
  const Ho = (r) => (r.id == null ? (r.flags & 2 ? -1 : 1 / 0) : r.id);
  function $y(r) {
    (pd = !1), (Go = !0);
    try {
      for (Pi = 0; Pi < ur.length; Pi++) {
        const e = ur[Pi];
        e &&
          !(e.flags & 8) &&
          (e.flags & 4 && (e.flags &= -2),
          al(e, e.i, e.i ? 15 : 14),
          (e.flags &= -2));
      }
    } finally {
      for (; Pi < ur.length; Pi++) {
        const e = ur[Pi];
        e && (e.flags &= -2);
      }
      (Pi = 0),
        (ur.length = 0),
        Vy(),
        (Go = !1),
        (sp = null),
        (ur.length || ya.length) && $y();
    }
  }
  let Wt = null,
    Gy = null;
  function Ph(r) {
    const e = Wt;
    return (Wt = r), (Gy = (r && r.type.__scopeId) || null), e;
  }
  function be(r, e = Wt, t) {
    if (!e || r._n) return r;
    const i = (...s) => {
      i._d && Lm(-1);
      const n = Ph(e);
      let a;
      try {
        a = r(...s);
      } finally {
        Ph(n), i._d && Lm(1);
      }
      return a;
    };
    return (i._n = !0), (i._c = !0), (i._d = !0), i;
  }
  function Ws(r, e) {
    if (Wt === null) return r;
    const t = Ec(Wt),
      i = r.dirs || (r.dirs = []);
    for (let s = 0; s < e.length; s++) {
      let [n, a, o, l = ft] = e[s];
      n &&
        (Fe(n) && (n = { mounted: n, updated: n }),
        n.deep && os(a),
        i.push({
          dir: n,
          instance: t,
          value: a,
          oldValue: void 0,
          arg: o,
          modifiers: l,
        }));
    }
    return r;
  }
  function rn(r, e, t, i) {
    const s = r.dirs,
      n = e && e.dirs;
    for (let a = 0; a < s.length; a++) {
      const o = s[a];
      n && (o.oldValue = n[a].value);
      let l = o.dir[i];
      l && (Ks(), pi(l, t, 8, [r.el, o, r, e]), Zs());
    }
  }
  const Hy = Symbol("_vte"),
    Xy = (r) => r.__isTeleport,
    Co = (r) => r && (r.disabled || r.disabled === ""),
    BT = (r) => r && (r.defer || r.defer === ""),
    Am = (r) => typeof SVGElement < "u" && r instanceof SVGElement,
    Cm = (r) =>
      typeof MathMLElement == "function" && r instanceof MathMLElement,
    md = (r, e) => {
      const t = r && r.to;
      return Ge(t) ? (e ? e(t) : null) : t;
    },
    OT = {
      name: "Teleport",
      __isTeleport: !0,
      process(r, e, t, i, s, n, a, o, l, h) {
        const {
            mc: c,
            pc: u,
            pbc: d,
            o: { insert: f, querySelector: p, createText: m, createComment: v },
          } = h,
          g = Co(e.props);
        let { shapeFlag: x, children: b, dynamicChildren: y } = e;
        if (r == null) {
          const _ = (e.el = m("")),
            w = (e.anchor = m(""));
          f(_, t, i), f(w, t, i);
          const E = (C, F) => {
              x & 16 && c(b, C, F, s, n, a, o, l);
            },
            A = () => {
              const C = (e.target = md(e.props, p)),
                F = zy(C, e, m, f);
              C &&
                (a !== "svg" && Am(C)
                  ? (a = "svg")
                  : a !== "mathml" && Cm(C) && (a = "mathml"),
                g || (E(C, F), hh(e)));
            };
          g && (E(t, w), hh(e)), BT(e.props) ? gr(A, n) : A();
        } else {
          (e.el = r.el), (e.targetStart = r.targetStart);
          const _ = (e.anchor = r.anchor),
            w = (e.target = r.target),
            E = (e.targetAnchor = r.targetAnchor),
            A = Co(r.props),
            C = A ? t : w,
            F = A ? _ : E;
          if (
            (a === "svg" || Am(w)
              ? (a = "svg")
              : (a === "mathml" || Cm(w)) && (a = "mathml"),
            y
              ? (d(r.dynamicChildren, y, C, s, n, a, o), up(r, e, !0))
              : l || u(r, e, C, F, s, n, a, o, !1),
            g)
          )
            A
              ? e.props &&
                r.props &&
                e.props.to !== r.props.to &&
                (e.props.to = r.props.to)
              : Il(e, t, _, h, 1);
          else if ((e.props && e.props.to) !== (r.props && r.props.to)) {
            const B = (e.target = md(e.props, p));
            B && Il(e, B, null, h, 0);
          } else A && Il(e, w, E, h, 1);
          hh(e);
        }
      },
      remove(r, e, t, { um: i, o: { remove: s } }, n) {
        const {
          shapeFlag: a,
          children: o,
          anchor: l,
          targetStart: h,
          targetAnchor: c,
          target: u,
          props: d,
        } = r;
        if ((u && (s(h), s(c)), n && s(l), a & 16)) {
          const f = n || !Co(d);
          for (let p = 0; p < o.length; p++) {
            const m = o[p];
            i(m, e, t, f, !!m.dynamicChildren);
          }
        }
      },
      move: Il,
      hydrate: kT,
    };
  function Il(r, e, t, { o: { insert: i }, m: s }, n = 2) {
    n === 0 && i(r.targetAnchor, e, t);
    const { el: a, anchor: o, shapeFlag: l, children: h, props: c } = r,
      u = n === 2;
    if ((u && i(a, e, t), (!u || Co(c)) && l & 16))
      for (let d = 0; d < h.length; d++) s(h[d], e, t, 2);
    u && i(o, e, t);
  }
  function kT(
    r,
    e,
    t,
    i,
    s,
    n,
    {
      o: {
        nextSibling: a,
        parentNode: o,
        querySelector: l,
        insert: h,
        createText: c,
      },
    },
    u
  ) {
    const d = (e.target = md(e.props, l));
    if (d) {
      const f = d._lpa || d.firstChild;
      if (e.shapeFlag & 16)
        if (Co(e.props))
          (e.anchor = u(a(r), e, o(r), t, i, s, n)),
            (e.targetStart = f),
            (e.targetAnchor = f && a(f));
        else {
          e.anchor = a(r);
          let p = f;
          for (; p; ) {
            if (p && p.nodeType === 8) {
              if (p.data === "teleport start anchor") e.targetStart = p;
              else if (p.data === "teleport anchor") {
                (e.targetAnchor = p),
                  (d._lpa = e.targetAnchor && a(e.targetAnchor));
                break;
              }
            }
            p = a(p);
          }
          e.targetAnchor || zy(d, e, c, h), u(f && a(f), e, d, t, i, s, n);
        }
      hh(e);
    }
    return e.anchor && a(e.anchor);
  }
  const DT = OT;
  function hh(r) {
    const e = r.ctx;
    if (e && e.ut) {
      let t = r.targetStart;
      for (; t && t !== r.targetAnchor; )
        t.nodeType === 1 && t.setAttribute("data-v-owner", e.uid),
          (t = t.nextSibling);
      e.ut();
    }
  }
  function zy(r, e, t, i) {
    const s = (e.targetStart = t("")),
      n = (e.targetAnchor = t(""));
    return (s[Hy] = n), r && (i(s, r), i(n, r)), n;
  }
  const Fs = Symbol("_leaveCb"),
    Pl = Symbol("_enterCb");
  function Wy() {
    const r = {
      isMounted: !1,
      isLeaving: !1,
      isUnmounting: !1,
      leavingVNodes: new Map(),
    };
    return (
      Rt(() => {
        r.isMounted = !0;
      }),
      Or(() => {
        r.isUnmounting = !0;
      }),
      r
    );
  }
  const Dr = [Function, Array],
    Yy = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      onBeforeEnter: Dr,
      onEnter: Dr,
      onAfterEnter: Dr,
      onEnterCancelled: Dr,
      onBeforeLeave: Dr,
      onLeave: Dr,
      onAfterLeave: Dr,
      onLeaveCancelled: Dr,
      onBeforeAppear: Dr,
      onAppear: Dr,
      onAfterAppear: Dr,
      onAppearCancelled: Dr,
    },
    jy = (r) => {
      const e = r.subTree;
      return e.component ? jy(e.component) : e;
    },
    LT = {
      name: "BaseTransition",
      props: Yy,
      setup(r, { slots: e }) {
        const t = Br(),
          i = Wy();
        return () => {
          const s = e.default && ap(e.default(), !0);
          if (!s || !s.length) return;
          const n = qy(s),
            a = tt(r),
            { mode: o } = a;
          if (i.isLeaving) return Qc(n);
          const l = Im(n);
          if (!l) return Qc(n);
          let h = Xo(l, a, i, t, (d) => (h = d));
          l.type !== ir && Rn(l, h);
          const c = t.subTree,
            u = c && Im(c);
          if (u && u.type !== ir && !mn(l, u) && jy(t).type !== ir) {
            const d = Xo(u, a, i, t);
            if ((Rn(u, d), o === "out-in" && l.type !== ir))
              return (
                (i.isLeaving = !0),
                (d.afterLeave = () => {
                  (i.isLeaving = !1),
                    t.job.flags & 8 || t.update(),
                    delete d.afterLeave;
                }),
                Qc(n)
              );
            o === "in-out" &&
              l.type !== ir &&
              (d.delayLeave = (f, p, m) => {
                const v = Ky(i, u);
                (v[String(u.key)] = u),
                  (f[Fs] = () => {
                    p(), (f[Fs] = void 0), delete h.delayedLeave;
                  }),
                  (h.delayedLeave = m);
              });
          }
          return n;
        };
      },
    };
  function qy(r) {
    let e = r[0];
    if (r.length > 1) {
      for (const t of r)
        if (t.type !== ir) {
          e = t;
          break;
        }
    }
    return e;
  }
  const NT = LT;
  function Ky(r, e) {
    const { leavingVNodes: t } = r;
    let i = t.get(e.type);
    return i || ((i = Object.create(null)), t.set(e.type, i)), i;
  }
  function Xo(r, e, t, i, s) {
    const {
        appear: n,
        mode: a,
        persisted: o = !1,
        onBeforeEnter: l,
        onEnter: h,
        onAfterEnter: c,
        onEnterCancelled: u,
        onBeforeLeave: d,
        onLeave: f,
        onAfterLeave: p,
        onLeaveCancelled: m,
        onBeforeAppear: v,
        onAppear: g,
        onAfterAppear: x,
        onAppearCancelled: b,
      } = e,
      y = String(r.key),
      _ = Ky(t, r),
      w = (C, F) => {
        C && pi(C, i, 9, F);
      },
      E = (C, F) => {
        const B = F[1];
        w(C, F),
          Oe(C) ? C.every((R) => R.length <= 1) && B() : C.length <= 1 && B();
      },
      A = {
        mode: a,
        persisted: o,
        beforeEnter(C) {
          let F = l;
          if (!t.isMounted)
            if (n) F = v || l;
            else return;
          C[Fs] && C[Fs](!0);
          const B = _[y];
          B && mn(r, B) && B.el[Fs] && B.el[Fs](), w(F, [C]);
        },
        enter(C) {
          let F = h,
            B = c,
            R = u;
          if (!t.isMounted)
            if (n) (F = g || h), (B = x || c), (R = b || u);
            else return;
          let I = !1;
          const P = (C[Pl] = (M) => {
            I ||
              ((I = !0),
              M ? w(R, [C]) : w(B, [C]),
              A.delayedLeave && A.delayedLeave(),
              (C[Pl] = void 0));
          });
          F ? E(F, [C, P]) : P();
        },
        leave(C, F) {
          const B = String(r.key);
          if ((C[Pl] && C[Pl](!0), t.isUnmounting)) return F();
          w(d, [C]);
          let R = !1;
          const I = (C[Fs] = (P) => {
            R ||
              ((R = !0),
              F(),
              P ? w(m, [C]) : w(p, [C]),
              (C[Fs] = void 0),
              _[B] === r && delete _[B]);
          });
          (_[B] = r), f ? E(f, [C, I]) : I();
        },
        clone(C) {
          const F = Xo(C, e, t, i, s);
          return s && s(F), F;
        },
      };
    return A;
  }
  function Qc(r) {
    if (xc(r)) return (r = ms(r)), (r.children = null), r;
  }
  function Im(r) {
    if (!xc(r)) return Xy(r.type) && r.children ? qy(r.children) : r;
    const { shapeFlag: e, children: t } = r;
    if (t) {
      if (e & 16) return t[0];
      if (e & 32 && Fe(t.default)) return t.default();
    }
  }
  function Rn(r, e) {
    r.shapeFlag & 6 && r.component
      ? ((r.transition = e), Rn(r.component.subTree, e))
      : r.shapeFlag & 128
      ? ((r.ssContent.transition = e.clone(r.ssContent)),
        (r.ssFallback.transition = e.clone(r.ssFallback)))
      : (r.transition = e);
  }
  function ap(r, e = !1, t) {
    let i = [],
      s = 0;
    for (let n = 0; n < r.length; n++) {
      let a = r[n];
      const o =
        t == null ? a.key : String(t) + String(a.key != null ? a.key : n);
      a.type === ot
        ? (a.patchFlag & 128 && s++, (i = i.concat(ap(a.children, e, o))))
        : (e || a.type !== ir) && i.push(o != null ? ms(a, { key: o }) : a);
    }
    if (s > 1) for (let n = 0; n < i.length; n++) i[n].patchFlag = -2;
    return i;
  }
  /*! #__NO_SIDE_EFFECTS__ */ function ge(r, e) {
    return Fe(r) ? Bt({ name: r.name }, e, { setup: r }) : r;
  }
  function Zy(r) {
    r.ids = [r.ids[0] + r.ids[2]++ + "-", 0, 0];
  }
  function gd(r, e, t, i, s = !1) {
    if (Oe(r)) {
      r.forEach((p, m) => gd(p, e && (Oe(e) ? e[m] : e), t, i, s));
      return;
    }
    if (ba(i) && !s) return;
    const n = i.shapeFlag & 4 ? Ec(i.component) : i.el,
      a = s ? null : n,
      { i: o, r: l } = r,
      h = e && e.r,
      c = o.refs === ft ? (o.refs = {}) : o.refs,
      u = o.setupState,
      d = tt(u),
      f = u === ft ? () => !1 : (p) => nt(d, p);
    if (
      (h != null &&
        h !== l &&
        (Ge(h)
          ? ((c[h] = null), f(h) && (u[h] = null))
          : Mt(h) && (h.value = null)),
      Fe(l))
    )
      al(l, o, 12, [a, c]);
    else {
      const p = Ge(l),
        m = Mt(l);
      if (p || m) {
        const v = () => {
          if (r.f) {
            const g = p ? (f(l) ? u[l] : c[l]) : l.value;
            s
              ? Oe(g) && Wf(g, n)
              : Oe(g)
              ? g.includes(n) || g.push(n)
              : p
              ? ((c[l] = [n]), f(l) && (u[l] = c[l]))
              : ((l.value = [n]), r.k && (c[r.k] = l.value));
          } else
            p
              ? ((c[l] = a), f(l) && (u[l] = a))
              : m && ((l.value = a), r.k && (c[r.k] = a));
        };
        a ? ((v.id = -1), gr(v, t)) : v();
      }
    }
  }
  const ba = (r) => !!r.type.__asyncLoader,
    xc = (r) => r.type.__isKeepAlive;
  function Jy(r, e) {
    eb(r, "a", e);
  }
  function Qy(r, e) {
    eb(r, "da", e);
  }
  function eb(r, e, t = Kt) {
    const i =
      r.__wdc ||
      (r.__wdc = () => {
        let s = t;
        for (; s; ) {
          if (s.isDeactivated) return;
          s = s.parent;
        }
        return r();
      });
    if ((_c(e, i, t), t)) {
      let s = t.parent;
      for (; s && s.parent; )
        xc(s.parent.vnode) && UT(i, e, t, s), (s = s.parent);
    }
  }
  function UT(r, e, t, i) {
    const s = _c(e, r, i, !0);
    op(() => {
      Wf(i[e], s);
    }, t);
  }
  function _c(r, e, t = Kt, i = !1) {
    if (t) {
      const s = t[r] || (t[r] = []),
        n =
          e.__weh ||
          (e.__weh = (...a) => {
            Ks();
            const o = ll(t),
              l = pi(e, t, r, a);
            return o(), Zs(), l;
          });
      return i ? s.unshift(n) : s.push(n), n;
    }
  }
  const bs =
      (r) =>
      (e, t = Kt) => {
        (!Tc || r === "sp") && _c(r, (...i) => e(...i), t);
      },
    tb = bs("bm"),
    Rt = bs("m"),
    VT = bs("bu"),
    ol = bs("u"),
    Or = bs("bum"),
    op = bs("um"),
    $T = bs("sp"),
    GT = bs("rtg"),
    HT = bs("rtc");
  function XT(r, e = Kt) {
    _c("ec", r, e);
  }
  const zT = "components",
    rb = Symbol.for("v-ndc");
  function qt(r) {
    return Ge(r) ? WT(zT, r, !1) || r : r || rb;
  }
  function WT(r, e, t = !0, i = !1) {
    const s = Wt || Kt;
    if (s) {
      const n = s.type;
      {
        const o = RE(n, !1);
        if (o && (o === e || o === Xr(e) || o === gc(Xr(e)))) return n;
      }
      const a = Pm(s[r] || n[r], e) || Pm(s.appContext[r], e);
      return !a && i ? n : a;
    }
  }
  function Pm(r, e) {
    return r && (r[e] || r[Xr(e)] || r[gc(Xr(e))]);
  }
  function Io(r, e, t, i) {
    let s;
    const n = t,
      a = Oe(r);
    if (a || Ge(r)) {
      const o = a && va(r);
      let l = !1;
      o && ((l = !$r(r)), (r = vc(r))), (s = new Array(r.length));
      for (let h = 0, c = r.length; h < c; h++)
        s[h] = e(l ? rr(r[h]) : r[h], h, void 0, n);
    } else if (typeof r == "number") {
      s = new Array(r);
      for (let o = 0; o < r; o++) s[o] = e(o + 1, o, void 0, n);
    } else if (Qe(r))
      if (r[Symbol.iterator]) s = Array.from(r, (o, l) => e(o, l, void 0, n));
      else {
        const o = Object.keys(r);
        s = new Array(o.length);
        for (let l = 0, h = o.length; l < h; l++) {
          const c = o[l];
          s[l] = e(r[c], c, l, n);
        }
      }
    else s = [];
    return s;
  }
  function Xe(r, e, t = {}, i, s) {
    if (Wt.ce || (Wt.parent && ba(Wt.parent) && Wt.parent.ce))
      return (
        e !== "default" && (t.name = e),
        j(),
        Me(ot, null, [ne("slot", t, i && i())], 64)
      );
    let n = r[e];
    n && n._c && (n._d = !1), j();
    const a = n && ib(n(t)),
      o = Me(
        ot,
        { key: (t.key || (a && a.key) || `_${e}`) + (!a && i ? "_fb" : "") },
        a || (i ? i() : []),
        a && r._ === 1 ? 64 : -2
      );
    return (
      o.scopeId && (o.slotScopeIds = [o.scopeId + "-s"]),
      n && n._c && (n._d = !0),
      o
    );
  }
  function ib(r) {
    return r.some((e) =>
      Mh(e) ? !(e.type === ir || (e.type === ot && !ib(e.children))) : !0
    )
      ? r
      : null;
  }
  const vd = (r) => (r ? (Eb(r) ? Ec(r) : vd(r.parent)) : null),
    Po = Bt(Object.create(null), {
      $: (r) => r,
      $el: (r) => r.vnode.el,
      $data: (r) => r.data,
      $props: (r) => r.props,
      $attrs: (r) => r.attrs,
      $slots: (r) => r.slots,
      $refs: (r) => r.refs,
      $parent: (r) => vd(r.parent),
      $root: (r) => vd(r.root),
      $host: (r) => r.ce,
      $emit: (r) => r.emit,
      $options: (r) => hp(r),
      $forceUpdate: (r) =>
        r.f ||
        (r.f = () => {
          np(r.update);
        }),
      $nextTick: (r) => r.n || (r.n = _t.bind(r.proxy)),
      $watch: (r) => fE.bind(r),
    }),
    eu = (r, e) => r !== ft && !r.__isScriptSetup && nt(r, e),
    YT = {
      get({ _: r }, e) {
        if (e === "__v_skip") return !0;
        const {
          ctx: t,
          setupState: i,
          data: s,
          props: n,
          accessCache: a,
          type: o,
          appContext: l,
        } = r;
        let h;
        if (e[0] !== "$") {
          const f = a[e];
          if (f !== void 0)
            switch (f) {
              case 1:
                return i[e];
              case 2:
                return s[e];
              case 4:
                return t[e];
              case 3:
                return n[e];
            }
          else {
            if (eu(i, e)) return (a[e] = 1), i[e];
            if (s !== ft && nt(s, e)) return (a[e] = 2), s[e];
            if ((h = r.propsOptions[0]) && nt(h, e)) return (a[e] = 3), n[e];
            if (t !== ft && nt(t, e)) return (a[e] = 4), t[e];
            yd && (a[e] = 0);
          }
        }
        const c = Po[e];
        let u, d;
        if (c) return e === "$attrs" && or(r.attrs, "get", ""), c(r);
        if ((u = o.__cssModules) && (u = u[e])) return u;
        if (t !== ft && nt(t, e)) return (a[e] = 4), t[e];
        if (((d = l.config.globalProperties), nt(d, e))) return d[e];
      },
      set({ _: r }, e, t) {
        const { data: i, setupState: s, ctx: n } = r;
        return eu(s, e)
          ? ((s[e] = t), !0)
          : i !== ft && nt(i, e)
          ? ((i[e] = t), !0)
          : nt(r.props, e) || (e[0] === "$" && e.slice(1) in r)
          ? !1
          : ((n[e] = t), !0);
      },
      has(
        {
          _: {
            data: r,
            setupState: e,
            accessCache: t,
            ctx: i,
            appContext: s,
            propsOptions: n,
          },
        },
        a
      ) {
        let o;
        return (
          !!t[a] ||
          (r !== ft && nt(r, a)) ||
          eu(e, a) ||
          ((o = n[0]) && nt(o, a)) ||
          nt(i, a) ||
          nt(Po, a) ||
          nt(s.config.globalProperties, a)
        );
      },
      defineProperty(r, e, t) {
        return (
          t.get != null
            ? (r._.accessCache[e] = 0)
            : nt(t, "value") && this.set(r, e, t.value, null),
          Reflect.defineProperty(r, e, t)
        );
      },
    };
  function lp() {
    return nb().slots;
  }
  function sb() {
    return nb().attrs;
  }
  function nb() {
    const r = Br();
    return r.setupContext || (r.setupContext = Ab(r));
  }
  function Rm(r) {
    return Oe(r) ? r.reduce((e, t) => ((e[t] = null), e), {}) : r;
  }
  let yd = !0;
  function jT(r) {
    const e = hp(r),
      t = r.proxy,
      i = r.ctx;
    (yd = !1), e.beforeCreate && Mm(e.beforeCreate, r, "bc");
    const {
      data: s,
      computed: n,
      methods: a,
      watch: o,
      provide: l,
      inject: h,
      created: c,
      beforeMount: u,
      mounted: d,
      beforeUpdate: f,
      updated: p,
      activated: m,
      deactivated: v,
      beforeDestroy: g,
      beforeUnmount: x,
      destroyed: b,
      unmounted: y,
      render: _,
      renderTracked: w,
      renderTriggered: E,
      errorCaptured: A,
      serverPrefetch: C,
      expose: F,
      inheritAttrs: B,
      components: R,
      directives: I,
      filters: P,
    } = e;
    if ((h && qT(h, i, null), a))
      for (const U in a) {
        const V = a[U];
        Fe(V) && (i[U] = V.bind(t));
      }
    if (s) {
      const U = s.call(t, t);
      Qe(U) && (r.data = vi(U));
    }
    if (((yd = !0), n))
      for (const U in n) {
        const V = n[U],
          z = Fe(V) ? V.bind(t, t) : Fe(V.get) ? V.get.bind(t, t) : ar,
          N = !Fe(V) && Fe(V.set) ? V.set.bind(t) : ar,
          O = X({ get: z, set: N });
        Object.defineProperty(i, U, {
          enumerable: !0,
          configurable: !0,
          get: () => O.value,
          set: (H) => (O.value = H),
        });
      }
    if (o) for (const U in o) ab(o[U], i, t, U);
    if (l) {
      const U = Fe(l) ? l.call(t) : l;
      Reflect.ownKeys(U).forEach((V) => {
        Fr(V, U[V]);
      });
    }
    c && Mm(c, r, "c");
    function L(U, V) {
      Oe(V) ? V.forEach((z) => U(z.bind(t))) : V && U(V.bind(t));
    }
    if (
      (L(tb, u),
      L(Rt, d),
      L(VT, f),
      L(ol, p),
      L(Jy, m),
      L(Qy, v),
      L(XT, A),
      L(HT, w),
      L(GT, E),
      L(Or, x),
      L(op, y),
      L($T, C),
      Oe(F))
    )
      if (F.length) {
        const U = r.exposed || (r.exposed = {});
        F.forEach((V) => {
          Object.defineProperty(U, V, {
            get: () => t[V],
            set: (z) => (t[V] = z),
          });
        });
      } else r.exposed || (r.exposed = {});
    _ && r.render === ar && (r.render = _),
      B != null && (r.inheritAttrs = B),
      R && (r.components = R),
      I && (r.directives = I),
      C && Zy(r);
  }
  function qT(r, e, t = ar) {
    Oe(r) && (r = bd(r));
    for (const i in r) {
      const s = r[i];
      let n;
      Qe(s)
        ? "default" in s
          ? (n = rt(s.from || i, s.default, !0))
          : (n = rt(s.from || i))
        : (n = rt(s)),
        Mt(n)
          ? Object.defineProperty(e, i, {
              enumerable: !0,
              configurable: !0,
              get: () => n.value,
              set: (a) => (n.value = a),
            })
          : (e[i] = n);
    }
  }
  function Mm(r, e, t) {
    pi(Oe(r) ? r.map((i) => i.bind(e.proxy)) : r.bind(e.proxy), e, t);
  }
  function ab(r, e, t, i) {
    let s = i.includes(".") ? bb(t, i) : () => t[i];
    if (Ge(r)) {
      const n = e[r];
      Fe(n) && De(s, n);
    } else if (Fe(r)) De(s, r.bind(t));
    else if (Qe(r))
      if (Oe(r)) r.forEach((n) => ab(n, e, t, i));
      else {
        const n = Fe(r.handler) ? r.handler.bind(t) : e[r.handler];
        Fe(n) && De(s, n, r);
      }
  }
  function hp(r) {
    const e = r.type,
      { mixins: t, extends: i } = e,
      {
        mixins: s,
        optionsCache: n,
        config: { optionMergeStrategies: a },
      } = r.appContext,
      o = n.get(e);
    let l;
    return (
      o
        ? (l = o)
        : !s.length && !t && !i
        ? (l = e)
        : ((l = {}),
          s.length && s.forEach((h) => Rh(l, h, a, !0)),
          Rh(l, e, a)),
      Qe(e) && n.set(e, l),
      l
    );
  }
  function Rh(r, e, t, i = !1) {
    const { mixins: s, extends: n } = e;
    n && Rh(r, n, t, !0), s && s.forEach((a) => Rh(r, a, t, !0));
    for (const a in e)
      if (!(i && a === "expose")) {
        const o = KT[a] || (t && t[a]);
        r[a] = o ? o(r[a], e[a]) : e[a];
      }
    return r;
  }
  const KT = {
    data: Fm,
    props: Bm,
    emits: Bm,
    methods: mo,
    computed: mo,
    beforeCreate: hr,
    created: hr,
    beforeMount: hr,
    mounted: hr,
    beforeUpdate: hr,
    updated: hr,
    beforeDestroy: hr,
    beforeUnmount: hr,
    destroyed: hr,
    unmounted: hr,
    activated: hr,
    deactivated: hr,
    errorCaptured: hr,
    serverPrefetch: hr,
    components: mo,
    directives: mo,
    watch: JT,
    provide: Fm,
    inject: ZT,
  };
  function Fm(r, e) {
    return e
      ? r
        ? function () {
            return Bt(
              Fe(r) ? r.call(this, this) : r,
              Fe(e) ? e.call(this, this) : e
            );
          }
        : e
      : r;
  }
  function ZT(r, e) {
    return mo(bd(r), bd(e));
  }
  function bd(r) {
    if (Oe(r)) {
      const e = {};
      for (let t = 0; t < r.length; t++) e[r[t]] = r[t];
      return e;
    }
    return r;
  }
  function hr(r, e) {
    return r ? [...new Set([].concat(r, e))] : e;
  }
  function mo(r, e) {
    return r ? Bt(Object.create(null), r, e) : e;
  }
  function Bm(r, e) {
    return r
      ? Oe(r) && Oe(e)
        ? [...new Set([...r, ...e])]
        : Bt(Object.create(null), Rm(r), Rm(e ?? {}))
      : e;
  }
  function JT(r, e) {
    if (!r) return e;
    if (!e) return r;
    const t = Bt(Object.create(null), r);
    for (const i in e) t[i] = hr(r[i], e[i]);
    return t;
  }
  function ob() {
    return {
      app: null,
      config: {
        isNativeTag: Nw,
        performance: !1,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {},
      },
      mixins: [],
      components: {},
      directives: {},
      provides: Object.create(null),
      optionsCache: new WeakMap(),
      propsCache: new WeakMap(),
      emitsCache: new WeakMap(),
    };
  }
  let QT = 0;
  function eE(r, e) {
    return function (i, s = null) {
      Fe(i) || (i = Bt({}, i)), s != null && !Qe(s) && (s = null);
      const n = ob(),
        a = new WeakSet(),
        o = [];
      let l = !1;
      const h = (n.app = {
        _uid: QT++,
        _component: i,
        _props: s,
        _container: null,
        _context: n,
        _instance: null,
        version: FE,
        get config() {
          return n.config;
        },
        set config(c) {},
        use(c, ...u) {
          return (
            a.has(c) ||
              (c && Fe(c.install)
                ? (a.add(c), c.install(h, ...u))
                : Fe(c) && (a.add(c), c(h, ...u))),
            h
          );
        },
        mixin(c) {
          return n.mixins.includes(c) || n.mixins.push(c), h;
        },
        component(c, u) {
          return u ? ((n.components[c] = u), h) : n.components[c];
        },
        directive(c, u) {
          return u ? ((n.directives[c] = u), h) : n.directives[c];
        },
        mount(c, u, d) {
          if (!l) {
            const f = h._ceVNode || ne(i, s);
            return (
              (f.appContext = n),
              d === !0 ? (d = "svg") : d === !1 && (d = void 0),
              u && e ? e(f, c) : r(f, c, d),
              (l = !0),
              (h._container = c),
              (c.__vue_app__ = h),
              Ec(f.component)
            );
          }
        },
        onUnmount(c) {
          o.push(c);
        },
        unmount() {
          l &&
            (pi(o, h._instance, 16),
            r(null, h._container),
            delete h._container.__vue_app__);
        },
        provide(c, u) {
          return (n.provides[c] = u), h;
        },
        runWithContext(c) {
          const u = xa;
          xa = h;
          try {
            return c();
          } finally {
            xa = u;
          }
        },
      });
      return h;
    };
  }
  let xa = null;
  function Fr(r, e) {
    if (Kt) {
      let t = Kt.provides;
      const i = Kt.parent && Kt.parent.provides;
      i === t && (t = Kt.provides = Object.create(i)), (t[r] = e);
    }
  }
  function rt(r, e, t = !1) {
    const i = Kt || Wt;
    if (i || xa) {
      const s = xa
        ? xa._context.provides
        : i
        ? i.parent == null
          ? i.vnode.appContext && i.vnode.appContext.provides
          : i.parent.provides
        : void 0;
      if (s && r in s) return s[r];
      if (arguments.length > 1) return t && Fe(e) ? e.call(i && i.proxy) : e;
    }
  }
  const lb = {},
    hb = () => Object.create(lb),
    cb = (r) => Object.getPrototypeOf(r) === lb;
  function tE(r, e, t, i = !1) {
    const s = {},
      n = hb();
    (r.propsDefaults = Object.create(null)), ub(r, e, s, n);
    for (const a in r.propsOptions[0]) a in s || (s[a] = void 0);
    t
      ? (r.props = i ? s : _T(s))
      : r.type.props
      ? (r.props = s)
      : (r.props = n),
      (r.attrs = n);
  }
  function rE(r, e, t, i) {
    const {
        props: s,
        attrs: n,
        vnode: { patchFlag: a },
      } = r,
      o = tt(s),
      [l] = r.propsOptions;
    let h = !1;
    if ((i || a > 0) && !(a & 16)) {
      if (a & 8) {
        const c = r.vnode.dynamicProps;
        for (let u = 0; u < c.length; u++) {
          let d = c[u];
          if (wc(r.emitsOptions, d)) continue;
          const f = e[d];
          if (l)
            if (nt(n, d)) f !== n[d] && ((n[d] = f), (h = !0));
            else {
              const p = Xr(d);
              s[p] = xd(l, o, p, f, r, !1);
            }
          else f !== n[d] && ((n[d] = f), (h = !0));
        }
      }
    } else {
      ub(r, e, s, n) && (h = !0);
      let c;
      for (const u in o)
        (!e || (!nt(e, u) && ((c = qs(u)) === u || !nt(e, c)))) &&
          (l
            ? t &&
              (t[u] !== void 0 || t[c] !== void 0) &&
              (s[u] = xd(l, o, u, void 0, r, !0))
            : delete s[u]);
      if (n !== o)
        for (const u in n) (!e || !nt(e, u)) && (delete n[u], (h = !0));
    }
    h && ds(r.attrs, "set", "");
  }
  function ub(r, e, t, i) {
    const [s, n] = r.propsOptions;
    let a = !1,
      o;
    if (e)
      for (let l in e) {
        if (So(l)) continue;
        const h = e[l];
        let c;
        s && nt(s, (c = Xr(l)))
          ? !n || !n.includes(c)
            ? (t[c] = h)
            : ((o || (o = {}))[c] = h)
          : wc(r.emitsOptions, l) ||
            ((!(l in i) || h !== i[l]) && ((i[l] = h), (a = !0)));
      }
    if (n) {
      const l = tt(t),
        h = o || ft;
      for (let c = 0; c < n.length; c++) {
        const u = n[c];
        t[u] = xd(s, l, u, h[u], r, !nt(h, u));
      }
    }
    return a;
  }
  function xd(r, e, t, i, s, n) {
    const a = r[t];
    if (a != null) {
      const o = nt(a, "default");
      if (o && i === void 0) {
        const l = a.default;
        if (a.type !== Function && !a.skipFactory && Fe(l)) {
          const { propsDefaults: h } = s;
          if (t in h) i = h[t];
          else {
            const c = ll(s);
            (i = h[t] = l.call(null, e)), c();
          }
        } else i = l;
        s.ce && s.ce._setProp(t, i);
      }
      a[0] &&
        (n && !o ? (i = !1) : a[1] && (i === "" || i === qs(t)) && (i = !0));
    }
    return i;
  }
  const iE = new WeakMap();
  function db(r, e, t = !1) {
    const i = t ? iE : e.propsCache,
      s = i.get(r);
    if (s) return s;
    const n = r.props,
      a = {},
      o = [];
    let l = !1;
    if (!Fe(r)) {
      const c = (u) => {
        l = !0;
        const [d, f] = db(u, e, !0);
        Bt(a, d), f && o.push(...f);
      };
      !t && e.mixins.length && e.mixins.forEach(c),
        r.extends && c(r.extends),
        r.mixins && r.mixins.forEach(c);
    }
    if (!n && !l) return Qe(r) && i.set(r, ma), ma;
    if (Oe(n))
      for (let c = 0; c < n.length; c++) {
        const u = Xr(n[c]);
        Om(u) && (a[u] = ft);
      }
    else if (n)
      for (const c in n) {
        const u = Xr(c);
        if (Om(u)) {
          const d = n[c],
            f = (a[u] = Oe(d) || Fe(d) ? { type: d } : Bt({}, d)),
            p = f.type;
          let m = !1,
            v = !0;
          if (Oe(p))
            for (let g = 0; g < p.length; ++g) {
              const x = p[g],
                b = Fe(x) && x.name;
              if (b === "Boolean") {
                m = !0;
                break;
              } else b === "String" && (v = !1);
            }
          else m = Fe(p) && p.name === "Boolean";
          (f[0] = m), (f[1] = v), (m || nt(f, "default")) && o.push(u);
        }
      }
    const h = [a, o];
    return Qe(r) && i.set(r, h), h;
  }
  function Om(r) {
    return r[0] !== "$" && !So(r);
  }
  const fb = (r) => r[0] === "_" || r === "$stable",
    cp = (r) => (Oe(r) ? r.map(Bi) : [Bi(r)]),
    sE = (r, e, t) => {
      if (e._n) return e;
      const i = be((...s) => cp(e(...s)), t);
      return (i._c = !1), i;
    },
    pb = (r, e, t) => {
      const i = r._ctx;
      for (const s in r) {
        if (fb(s)) continue;
        const n = r[s];
        if (Fe(n)) e[s] = sE(s, n, i);
        else if (n != null) {
          const a = cp(n);
          e[s] = () => a;
        }
      }
    },
    mb = (r, e) => {
      const t = cp(e);
      r.slots.default = () => t;
    },
    gb = (r, e, t) => {
      for (const i in e) (t || i !== "_") && (r[i] = e[i]);
    },
    nE = (r, e, t) => {
      const i = (r.slots = hb());
      if (r.vnode.shapeFlag & 32) {
        const s = e._;
        s ? (gb(i, e, t), t && my(i, "_", s, !0)) : pb(e, i);
      } else e && mb(r, e);
    },
    aE = (r, e, t) => {
      const { vnode: i, slots: s } = r;
      let n = !0,
        a = ft;
      if (i.shapeFlag & 32) {
        const o = e._;
        o
          ? t && o === 1
            ? (n = !1)
            : gb(s, e, t)
          : ((n = !e.$stable), pb(e, s)),
          (a = e);
      } else e && (mb(r, e), (a = { default: 1 }));
      if (n) for (const o in s) !fb(o) && a[o] == null && delete s[o];
    },
    gr = xE;
  function oE(r) {
    return lE(r);
  }
  function lE(r, e) {
    const t = gy();
    t.__VUE__ = !0;
    const {
        insert: i,
        remove: s,
        patchProp: n,
        createElement: a,
        createText: o,
        createComment: l,
        setText: h,
        setElementText: c,
        parentNode: u,
        nextSibling: d,
        setScopeId: f = ar,
        insertStaticContent: p,
      } = r,
      m = (
        k,
        D,
        W,
        te = null,
        J = null,
        Q = null,
        de = void 0,
        oe = null,
        se = !!D.dynamicChildren
      ) => {
        if (k === D) return;
        k && !mn(k, D) && ((te = ie(k)), H(k, J, Q, !0), (k = null)),
          D.patchFlag === -2 && ((se = !1), (D.dynamicChildren = null));
        const { type: re, ref: Pe, shapeFlag: fe } = D;
        switch (re) {
          case Wa:
            v(k, D, W, te);
            break;
          case ir:
            g(k, D, W, te);
            break;
          case iu:
            k == null && x(D, W, te, de);
            break;
          case ot:
            R(k, D, W, te, J, Q, de, oe, se);
            break;
          default:
            fe & 1
              ? _(k, D, W, te, J, Q, de, oe, se)
              : fe & 6
              ? I(k, D, W, te, J, Q, de, oe, se)
              : (fe & 64 || fe & 128) &&
                re.process(k, D, W, te, J, Q, de, oe, se, ye);
        }
        Pe != null && J && gd(Pe, k && k.ref, Q, D || k, !D);
      },
      v = (k, D, W, te) => {
        if (k == null) i((D.el = o(D.children)), W, te);
        else {
          const J = (D.el = k.el);
          D.children !== k.children && h(J, D.children);
        }
      },
      g = (k, D, W, te) => {
        k == null ? i((D.el = l(D.children || "")), W, te) : (D.el = k.el);
      },
      x = (k, D, W, te) => {
        [k.el, k.anchor] = p(k.children, D, W, te, k.el, k.anchor);
      },
      b = ({ el: k, anchor: D }, W, te) => {
        let J;
        for (; k && k !== D; ) (J = d(k)), i(k, W, te), (k = J);
        i(D, W, te);
      },
      y = ({ el: k, anchor: D }) => {
        let W;
        for (; k && k !== D; ) (W = d(k)), s(k), (k = W);
        s(D);
      },
      _ = (k, D, W, te, J, Q, de, oe, se) => {
        D.type === "svg" ? (de = "svg") : D.type === "math" && (de = "mathml"),
          k == null ? w(D, W, te, J, Q, de, oe, se) : C(k, D, J, Q, de, oe, se);
      },
      w = (k, D, W, te, J, Q, de, oe) => {
        let se, re;
        const { props: Pe, shapeFlag: fe, transition: Y, dirs: Te } = k;
        if (
          ((se = k.el = a(k.type, Q, Pe && Pe.is, Pe)),
          fe & 8
            ? c(se, k.children)
            : fe & 16 && A(k.children, se, null, te, J, tu(k, Q), de, oe),
          Te && rn(k, null, te, "created"),
          E(se, k, k.scopeId, de, te),
          Pe)
        ) {
          for (const it in Pe)
            it !== "value" && !So(it) && n(se, it, null, Pe[it], Q, te);
          "value" in Pe && n(se, "value", null, Pe.value, Q),
            (re = Pe.onVnodeBeforeMount) && wi(re, te, k);
        }
        Te && rn(k, null, te, "beforeMount");
        const Ue = hE(J, Y);
        Ue && Y.beforeEnter(se),
          i(se, D, W),
          ((re = Pe && Pe.onVnodeMounted) || Ue || Te) &&
            gr(() => {
              re && wi(re, te, k),
                Ue && Y.enter(se),
                Te && rn(k, null, te, "mounted");
            }, J);
      },
      E = (k, D, W, te, J) => {
        if ((W && f(k, W), te)) for (let Q = 0; Q < te.length; Q++) f(k, te[Q]);
        if (J) {
          let Q = J.subTree;
          if (
            D === Q ||
            (_b(Q.type) && (Q.ssContent === D || Q.ssFallback === D))
          ) {
            const de = J.vnode;
            E(k, de, de.scopeId, de.slotScopeIds, J.parent);
          }
        }
      },
      A = (k, D, W, te, J, Q, de, oe, se = 0) => {
        for (let re = se; re < k.length; re++) {
          const Pe = (k[re] = oe ? Bs(k[re]) : Bi(k[re]));
          m(null, Pe, D, W, te, J, Q, de, oe);
        }
      },
      C = (k, D, W, te, J, Q, de) => {
        const oe = (D.el = k.el);
        let { patchFlag: se, dynamicChildren: re, dirs: Pe } = D;
        se |= k.patchFlag & 16;
        const fe = k.props || ft,
          Y = D.props || ft;
        let Te;
        if (
          (W && sn(W, !1),
          (Te = Y.onVnodeBeforeUpdate) && wi(Te, W, D, k),
          Pe && rn(D, k, W, "beforeUpdate"),
          W && sn(W, !0),
          ((fe.innerHTML && Y.innerHTML == null) ||
            (fe.textContent && Y.textContent == null)) &&
            c(oe, ""),
          re
            ? F(k.dynamicChildren, re, oe, W, te, tu(D, J), Q)
            : de || V(k, D, oe, null, W, te, tu(D, J), Q, !1),
          se > 0)
        ) {
          if (se & 16) B(oe, fe, Y, W, J);
          else if (
            (se & 2 && fe.class !== Y.class && n(oe, "class", null, Y.class, J),
            se & 4 && n(oe, "style", fe.style, Y.style, J),
            se & 8)
          ) {
            const Ue = D.dynamicProps;
            for (let it = 0; it < Ue.length; it++) {
              const st = Ue[it],
                _r = fe[st],
                er = Y[st];
              (er !== _r || st === "value") && n(oe, st, _r, er, J, W);
            }
          }
          se & 1 && k.children !== D.children && c(oe, D.children);
        } else !de && re == null && B(oe, fe, Y, W, J);
        ((Te = Y.onVnodeUpdated) || Pe) &&
          gr(() => {
            Te && wi(Te, W, D, k), Pe && rn(D, k, W, "updated");
          }, te);
      },
      F = (k, D, W, te, J, Q, de) => {
        for (let oe = 0; oe < D.length; oe++) {
          const se = k[oe],
            re = D[oe],
            Pe =
              se.el && (se.type === ot || !mn(se, re) || se.shapeFlag & 70)
                ? u(se.el)
                : W;
          m(se, re, Pe, null, te, J, Q, de, !0);
        }
      },
      B = (k, D, W, te, J) => {
        if (D !== W) {
          if (D !== ft)
            for (const Q in D)
              !So(Q) && !(Q in W) && n(k, Q, D[Q], null, J, te);
          for (const Q in W) {
            if (So(Q)) continue;
            const de = W[Q],
              oe = D[Q];
            de !== oe && Q !== "value" && n(k, Q, oe, de, J, te);
          }
          "value" in W && n(k, "value", D.value, W.value, J);
        }
      },
      R = (k, D, W, te, J, Q, de, oe, se) => {
        const re = (D.el = k ? k.el : o("")),
          Pe = (D.anchor = k ? k.anchor : o(""));
        let { patchFlag: fe, dynamicChildren: Y, slotScopeIds: Te } = D;
        Te && (oe = oe ? oe.concat(Te) : Te),
          k == null
            ? (i(re, W, te),
              i(Pe, W, te),
              A(D.children || [], W, Pe, J, Q, de, oe, se))
            : fe > 0 && fe & 64 && Y && k.dynamicChildren
            ? (F(k.dynamicChildren, Y, W, J, Q, de, oe),
              (D.key != null || (J && D === J.subTree)) && up(k, D, !0))
            : V(k, D, W, Pe, J, Q, de, oe, se);
      },
      I = (k, D, W, te, J, Q, de, oe, se) => {
        (D.slotScopeIds = oe),
          k == null
            ? D.shapeFlag & 512
              ? J.ctx.activate(D, W, te, de, se)
              : P(D, W, te, J, Q, de, se)
            : M(k, D, se);
      },
      P = (k, D, W, te, J, Q, de) => {
        const oe = (k.component = AE(k, te, J));
        if ((xc(k) && (oe.ctx.renderer = ye), CE(oe, !1, de), oe.asyncDep)) {
          if ((J && J.registerDep(oe, L, de), !k.el)) {
            const se = (oe.subTree = ne(ir));
            g(null, se, D, W);
          }
        } else L(oe, k, D, W, J, Q, de);
      },
      M = (k, D, W) => {
        const te = (D.component = k.component);
        if (yE(k, D, W))
          if (te.asyncDep && !te.asyncResolved) {
            U(te, D, W);
            return;
          } else (te.next = D), te.update();
        else (D.el = k.el), (te.vnode = D);
      },
      L = (k, D, W, te, J, Q, de) => {
        const oe = () => {
          if (k.isMounted) {
            let { next: fe, bu: Y, u: Te, parent: Ue, vnode: it } = k;
            {
              const wr = vb(k);
              if (wr) {
                fe && ((fe.el = it.el), U(k, fe, de)),
                  wr.asyncDep.then(() => {
                    k.isUnmounted || oe();
                  });
                return;
              }
            }
            let st = fe,
              _r;
            sn(k, !1),
              fe ? ((fe.el = it.el), U(k, fe, de)) : (fe = it),
              Y && lh(Y),
              (_r = fe.props && fe.props.onVnodeBeforeUpdate) &&
                wi(_r, Ue, fe, it),
              sn(k, !0);
            const er = ru(k),
              qr = k.subTree;
            (k.subTree = er),
              m(qr, er, u(qr.el), ie(qr), k, J, Q),
              (fe.el = er.el),
              st === null && bE(k, er.el),
              Te && gr(Te, J),
              (_r = fe.props && fe.props.onVnodeUpdated) &&
                gr(() => wi(_r, Ue, fe, it), J);
          } else {
            let fe;
            const { el: Y, props: Te } = D,
              { bm: Ue, m: it, parent: st, root: _r, type: er } = k,
              qr = ba(D);
            if (
              (sn(k, !1),
              Ue && lh(Ue),
              !qr && (fe = Te && Te.onVnodeBeforeMount) && wi(fe, st, D),
              sn(k, !0),
              Y && ke)
            ) {
              const wr = () => {
                (k.subTree = ru(k)), ke(Y, k.subTree, k, J, null);
              };
              qr && er.__asyncHydrate ? er.__asyncHydrate(Y, k, wr) : wr();
            } else {
              _r.ce && _r.ce._injectChildStyle(er);
              const wr = (k.subTree = ru(k));
              m(null, wr, W, te, k, J, Q), (D.el = wr.el);
            }
            if ((it && gr(it, J), !qr && (fe = Te && Te.onVnodeMounted))) {
              const wr = D;
              gr(() => wi(fe, st, wr), J);
            }
            (D.shapeFlag & 256 ||
              (st && ba(st.vnode) && st.vnode.shapeFlag & 256)) &&
              k.a &&
              gr(k.a, J),
              (k.isMounted = !0),
              (D = W = te = null);
          }
        };
        k.scope.on();
        const se = (k.effect = new wy(oe));
        k.scope.off();
        const re = (k.update = se.run.bind(se)),
          Pe = (k.job = se.runIfDirty.bind(se));
        (Pe.i = k),
          (Pe.id = k.uid),
          (se.scheduler = () => np(Pe)),
          sn(k, !0),
          re();
      },
      U = (k, D, W) => {
        D.component = k;
        const te = k.vnode.props;
        (k.vnode = D),
          (k.next = null),
          rE(k, D.props, te, W),
          aE(k, D.children, W),
          Ks(),
          Sm(k),
          Zs();
      },
      V = (k, D, W, te, J, Q, de, oe, se = !1) => {
        const re = k && k.children,
          Pe = k ? k.shapeFlag : 0,
          fe = D.children,
          { patchFlag: Y, shapeFlag: Te } = D;
        if (Y > 0) {
          if (Y & 128) {
            N(re, fe, W, te, J, Q, de, oe, se);
            return;
          } else if (Y & 256) {
            z(re, fe, W, te, J, Q, de, oe, se);
            return;
          }
        }
        Te & 8
          ? (Pe & 16 && ue(re, J, Q), fe !== re && c(W, fe))
          : Pe & 16
          ? Te & 16
            ? N(re, fe, W, te, J, Q, de, oe, se)
            : ue(re, J, Q, !0)
          : (Pe & 8 && c(W, ""), Te & 16 && A(fe, W, te, J, Q, de, oe, se));
      },
      z = (k, D, W, te, J, Q, de, oe, se) => {
        (k = k || ma), (D = D || ma);
        const re = k.length,
          Pe = D.length,
          fe = Math.min(re, Pe);
        let Y;
        for (Y = 0; Y < fe; Y++) {
          const Te = (D[Y] = se ? Bs(D[Y]) : Bi(D[Y]));
          m(k[Y], Te, W, null, J, Q, de, oe, se);
        }
        re > Pe ? ue(k, J, Q, !0, !1, fe) : A(D, W, te, J, Q, de, oe, se, fe);
      },
      N = (k, D, W, te, J, Q, de, oe, se) => {
        let re = 0;
        const Pe = D.length;
        let fe = k.length - 1,
          Y = Pe - 1;
        for (; re <= fe && re <= Y; ) {
          const Te = k[re],
            Ue = (D[re] = se ? Bs(D[re]) : Bi(D[re]));
          if (mn(Te, Ue)) m(Te, Ue, W, null, J, Q, de, oe, se);
          else break;
          re++;
        }
        for (; re <= fe && re <= Y; ) {
          const Te = k[fe],
            Ue = (D[Y] = se ? Bs(D[Y]) : Bi(D[Y]));
          if (mn(Te, Ue)) m(Te, Ue, W, null, J, Q, de, oe, se);
          else break;
          fe--, Y--;
        }
        if (re > fe) {
          if (re <= Y) {
            const Te = Y + 1,
              Ue = Te < Pe ? D[Te].el : te;
            for (; re <= Y; )
              m(
                null,
                (D[re] = se ? Bs(D[re]) : Bi(D[re])),
                W,
                Ue,
                J,
                Q,
                de,
                oe,
                se
              ),
                re++;
          }
        } else if (re > Y) for (; re <= fe; ) H(k[re], J, Q, !0), re++;
        else {
          const Te = re,
            Ue = re,
            it = new Map();
          for (re = Ue; re <= Y; re++) {
            const Tr = (D[re] = se ? Bs(D[re]) : Bi(D[re]));
            Tr.key != null && it.set(Tr.key, re);
          }
          let st,
            _r = 0;
          const er = Y - Ue + 1;
          let qr = !1,
            wr = 0;
          const io = new Array(er);
          for (re = 0; re < er; re++) io[re] = 0;
          for (re = Te; re <= fe; re++) {
            const Tr = k[re];
            if (_r >= er) {
              H(Tr, J, Q, !0);
              continue;
            }
            let _i;
            if (Tr.key != null) _i = it.get(Tr.key);
            else
              for (st = Ue; st <= Y; st++)
                if (io[st - Ue] === 0 && mn(Tr, D[st])) {
                  _i = st;
                  break;
                }
            _i === void 0
              ? H(Tr, J, Q, !0)
              : ((io[_i - Ue] = re + 1),
                _i >= wr ? (wr = _i) : (qr = !0),
                m(Tr, D[_i], W, null, J, Q, de, oe, se),
                _r++);
          }
          const mm = qr ? cE(io) : ma;
          for (st = mm.length - 1, re = er - 1; re >= 0; re--) {
            const Tr = Ue + re,
              _i = D[Tr],
              gm = Tr + 1 < Pe ? D[Tr + 1].el : te;
            io[re] === 0
              ? m(null, _i, W, gm, J, Q, de, oe, se)
              : qr && (st < 0 || re !== mm[st] ? O(_i, W, gm, 2) : st--);
          }
        }
      },
      O = (k, D, W, te, J = null) => {
        const {
          el: Q,
          type: de,
          transition: oe,
          children: se,
          shapeFlag: re,
        } = k;
        if (re & 6) {
          O(k.component.subTree, D, W, te);
          return;
        }
        if (re & 128) {
          k.suspense.move(D, W, te);
          return;
        }
        if (re & 64) {
          de.move(k, D, W, ye);
          return;
        }
        if (de === ot) {
          i(Q, D, W);
          for (let fe = 0; fe < se.length; fe++) O(se[fe], D, W, te);
          i(k.anchor, D, W);
          return;
        }
        if (de === iu) {
          b(k, D, W);
          return;
        }
        if (te !== 2 && re & 1 && oe)
          if (te === 0) oe.beforeEnter(Q), i(Q, D, W), gr(() => oe.enter(Q), J);
          else {
            const { leave: fe, delayLeave: Y, afterLeave: Te } = oe,
              Ue = () => i(Q, D, W),
              it = () => {
                fe(Q, () => {
                  Ue(), Te && Te();
                });
              };
            Y ? Y(Q, Ue, it) : it();
          }
        else i(Q, D, W);
      },
      H = (k, D, W, te = !1, J = !1) => {
        const {
          type: Q,
          props: de,
          ref: oe,
          children: se,
          dynamicChildren: re,
          shapeFlag: Pe,
          patchFlag: fe,
          dirs: Y,
          cacheIndex: Te,
        } = k;
        if (
          (fe === -2 && (J = !1),
          oe != null && gd(oe, null, W, k, !0),
          Te != null && (D.renderCache[Te] = void 0),
          Pe & 256)
        ) {
          D.ctx.deactivate(k);
          return;
        }
        const Ue = Pe & 1 && Y,
          it = !ba(k);
        let st;
        if (
          (it && (st = de && de.onVnodeBeforeUnmount) && wi(st, D, k), Pe & 6)
        )
          K(k.component, W, te);
        else {
          if (Pe & 128) {
            k.suspense.unmount(W, te);
            return;
          }
          Ue && rn(k, null, D, "beforeUnmount"),
            Pe & 64
              ? k.type.remove(k, D, W, ye, te)
              : re && !re.hasOnce && (Q !== ot || (fe > 0 && fe & 64))
              ? ue(re, D, W, !1, !0)
              : ((Q === ot && fe & 384) || (!J && Pe & 16)) && ue(se, D, W),
            te && G(k);
        }
        ((it && (st = de && de.onVnodeUnmounted)) || Ue) &&
          gr(() => {
            st && wi(st, D, k), Ue && rn(k, null, D, "unmounted");
          }, W);
      },
      G = (k) => {
        const { type: D, el: W, anchor: te, transition: J } = k;
        if (D === ot) {
          q(W, te);
          return;
        }
        if (D === iu) {
          y(k);
          return;
        }
        const Q = () => {
          s(W), J && !J.persisted && J.afterLeave && J.afterLeave();
        };
        if (k.shapeFlag & 1 && J && !J.persisted) {
          const { leave: de, delayLeave: oe } = J,
            se = () => de(W, Q);
          oe ? oe(k.el, Q, se) : se();
        } else Q();
      },
      q = (k, D) => {
        let W;
        for (; k !== D; ) (W = d(k)), s(k), (k = W);
        s(D);
      },
      K = (k, D, W) => {
        const {
          bum: te,
          scope: J,
          job: Q,
          subTree: de,
          um: oe,
          m: se,
          a: re,
        } = k;
        km(se),
          km(re),
          te && lh(te),
          J.stop(),
          Q && ((Q.flags |= 8), H(de, k, D, W)),
          oe && gr(oe, D),
          gr(() => {
            k.isUnmounted = !0;
          }, D),
          D &&
            D.pendingBranch &&
            !D.isUnmounted &&
            k.asyncDep &&
            !k.asyncResolved &&
            k.suspenseId === D.pendingId &&
            (D.deps--, D.deps === 0 && D.resolve());
      },
      ue = (k, D, W, te = !1, J = !1, Q = 0) => {
        for (let de = Q; de < k.length; de++) H(k[de], D, W, te, J);
      },
      ie = (k) => {
        if (k.shapeFlag & 6) return ie(k.component.subTree);
        if (k.shapeFlag & 128) return k.suspense.next();
        const D = d(k.anchor || k.el),
          W = D && D[Hy];
        return W ? d(W) : D;
      };
    let ee = !1;
    const ve = (k, D, W) => {
        k == null
          ? D._vnode && H(D._vnode, null, null, !0)
          : m(D._vnode || null, k, D, null, null, null, W),
          (D._vnode = k),
          ee || ((ee = !0), Sm(), Vy(), (ee = !1));
      },
      ye = {
        p: m,
        um: H,
        m: O,
        r: G,
        mt: P,
        mc: A,
        pc: V,
        pbc: F,
        n: ie,
        o: r,
      };
    let _e, ke;
    return { render: ve, hydrate: _e, createApp: eE(ve, _e) };
  }
  function tu({ type: r, props: e }, t) {
    return (t === "svg" && r === "foreignObject") ||
      (t === "mathml" &&
        r === "annotation-xml" &&
        e &&
        e.encoding &&
        e.encoding.includes("html"))
      ? void 0
      : t;
  }
  function sn({ effect: r, job: e }, t) {
    t ? ((r.flags |= 32), (e.flags |= 4)) : ((r.flags &= -33), (e.flags &= -5));
  }
  function hE(r, e) {
    return (!r || (r && !r.pendingBranch)) && e && !e.persisted;
  }
  function up(r, e, t = !1) {
    const i = r.children,
      s = e.children;
    if (Oe(i) && Oe(s))
      for (let n = 0; n < i.length; n++) {
        const a = i[n];
        let o = s[n];
        o.shapeFlag & 1 &&
          !o.dynamicChildren &&
          ((o.patchFlag <= 0 || o.patchFlag === 32) &&
            ((o = s[n] = Bs(s[n])), (o.el = a.el)),
          !t && o.patchFlag !== -2 && up(a, o)),
          o.type === Wa && (o.el = a.el);
      }
  }
  function cE(r) {
    const e = r.slice(),
      t = [0];
    let i, s, n, a, o;
    const l = r.length;
    for (i = 0; i < l; i++) {
      const h = r[i];
      if (h !== 0) {
        if (((s = t[t.length - 1]), r[s] < h)) {
          (e[i] = s), t.push(i);
          continue;
        }
        for (n = 0, a = t.length - 1; n < a; )
          (o = (n + a) >> 1), r[t[o]] < h ? (n = o + 1) : (a = o);
        h < r[t[n]] && (n > 0 && (e[i] = t[n - 1]), (t[n] = i));
      }
    }
    for (n = t.length, a = t[n - 1]; n-- > 0; ) (t[n] = a), (a = e[a]);
    return t;
  }
  function vb(r) {
    const e = r.subTree.component;
    if (e) return e.asyncDep && !e.asyncResolved ? e : vb(e);
  }
  function km(r) {
    if (r) for (let e = 0; e < r.length; e++) r[e].flags |= 8;
  }
  const uE = Symbol.for("v-scx"),
    dE = () => rt(uE);
  function De(r, e, t) {
    return yb(r, e, t);
  }
  function yb(r, e, t = ft) {
    const { immediate: i, deep: s, flush: n, once: a } = t,
      o = Bt({}, t);
    let l;
    if (Tc)
      if (n === "sync") {
        const d = dE();
        l = d.__watcherHandles || (d.__watcherHandles = []);
      } else if (!e || i) o.once = !0;
      else return { stop: ar, resume: ar, pause: ar };
    const h = Kt;
    o.call = (d, f, p) => pi(d, h, f, p);
    let c = !1;
    n === "post"
      ? (o.scheduler = (d) => {
          gr(d, h && h.suspense);
        })
      : n !== "sync" &&
        ((c = !0),
        (o.scheduler = (d, f) => {
          f ? d() : np(d);
        })),
      (o.augmentJob = (d) => {
        e && (d.flags |= 4),
          c && ((d.flags |= 2), h && ((d.id = h.uid), (d.i = h)));
      });
    const u = PT(r, e, o);
    return l && l.push(u), u;
  }
  function fE(r, e, t) {
    const i = this.proxy,
      s = Ge(r) ? (r.includes(".") ? bb(i, r) : () => i[r]) : r.bind(i, i);
    let n;
    Fe(e) ? (n = e) : ((n = e.handler), (t = e));
    const a = ll(this),
      o = yb(s, n.bind(i), t);
    return a(), o;
  }
  function bb(r, e) {
    const t = e.split(".");
    return () => {
      let i = r;
      for (let s = 0; s < t.length && i; s++) i = i[t[s]];
      return i;
    };
  }
  const pE = (r, e) =>
    e === "modelValue" || e === "model-value"
      ? r.modelModifiers
      : r[`${e}Modifiers`] || r[`${Xr(e)}Modifiers`] || r[`${qs(e)}Modifiers`];
  function mE(r, e, ...t) {
    if (r.isUnmounted) return;
    const i = r.vnode.props || ft;
    let s = t;
    const n = e.startsWith("update:"),
      a = n && pE(i, e.slice(7));
    a &&
      (a.trim && (s = t.map((c) => (Ge(c) ? c.trim() : c))),
      a.number && (s = t.map(Hw)));
    let o,
      l = i[(o = jc(e))] || i[(o = jc(Xr(e)))];
    !l && n && (l = i[(o = jc(qs(e)))]), l && pi(l, r, 6, s);
    const h = i[o + "Once"];
    if (h) {
      if (!r.emitted) r.emitted = {};
      else if (r.emitted[o]) return;
      (r.emitted[o] = !0), pi(h, r, 6, s);
    }
  }
  function xb(r, e, t = !1) {
    const i = e.emitsCache,
      s = i.get(r);
    if (s !== void 0) return s;
    const n = r.emits;
    let a = {},
      o = !1;
    if (!Fe(r)) {
      const l = (h) => {
        const c = xb(h, e, !0);
        c && ((o = !0), Bt(a, c));
      };
      !t && e.mixins.length && e.mixins.forEach(l),
        r.extends && l(r.extends),
        r.mixins && r.mixins.forEach(l);
    }
    return !n && !o
      ? (Qe(r) && i.set(r, null), null)
      : (Oe(n) ? n.forEach((l) => (a[l] = null)) : Bt(a, n),
        Qe(r) && i.set(r, a),
        a);
  }
  function wc(r, e) {
    return !r || !pc(e)
      ? !1
      : ((e = e.slice(2).replace(/Once$/, "")),
        nt(r, e[0].toLowerCase() + e.slice(1)) || nt(r, qs(e)) || nt(r, e));
  }
  function ru(r) {
    const {
        type: e,
        vnode: t,
        proxy: i,
        withProxy: s,
        propsOptions: [n],
        slots: a,
        attrs: o,
        emit: l,
        render: h,
        renderCache: c,
        props: u,
        data: d,
        setupState: f,
        ctx: p,
        inheritAttrs: m,
      } = r,
      v = Ph(r);
    let g, x;
    try {
      if (t.shapeFlag & 4) {
        const y = s || i,
          _ = y;
        (g = Bi(h.call(_, y, c, u, f, d, p))), (x = o);
      } else {
        const y = e;
        (g = Bi(
          y.length > 1 ? y(u, { attrs: o, slots: a, emit: l }) : y(u, null)
        )),
          (x = e.props ? o : gE(o));
      }
    } catch (y) {
      (Ro.length = 0), bc(y, r, 1), (g = ne(ir));
    }
    let b = g;
    if (x && m !== !1) {
      const y = Object.keys(x),
        { shapeFlag: _ } = b;
      y.length &&
        _ & 7 &&
        (n && y.some(zf) && (x = vE(x, n)), (b = ms(b, x, !1, !0)));
    }
    return (
      t.dirs &&
        ((b = ms(b, null, !1, !0)),
        (b.dirs = b.dirs ? b.dirs.concat(t.dirs) : t.dirs)),
      t.transition && Rn(b, t.transition),
      (g = b),
      Ph(v),
      g
    );
  }
  const gE = (r) => {
      let e;
      for (const t in r)
        (t === "class" || t === "style" || pc(t)) &&
          ((e || (e = {}))[t] = r[t]);
      return e;
    },
    vE = (r, e) => {
      const t = {};
      for (const i in r) (!zf(i) || !(i.slice(9) in e)) && (t[i] = r[i]);
      return t;
    };
  function yE(r, e, t) {
    const { props: i, children: s, component: n } = r,
      { props: a, children: o, patchFlag: l } = e,
      h = n.emitsOptions;
    if (e.dirs || e.transition) return !0;
    if (t && l >= 0) {
      if (l & 1024) return !0;
      if (l & 16) return i ? Dm(i, a, h) : !!a;
      if (l & 8) {
        const c = e.dynamicProps;
        for (let u = 0; u < c.length; u++) {
          const d = c[u];
          if (a[d] !== i[d] && !wc(h, d)) return !0;
        }
      }
    } else
      return (s || o) && (!o || !o.$stable)
        ? !0
        : i === a
        ? !1
        : i
        ? a
          ? Dm(i, a, h)
          : !0
        : !!a;
    return !1;
  }
  function Dm(r, e, t) {
    const i = Object.keys(e);
    if (i.length !== Object.keys(r).length) return !0;
    for (let s = 0; s < i.length; s++) {
      const n = i[s];
      if (e[n] !== r[n] && !wc(t, n)) return !0;
    }
    return !1;
  }
  function bE({ vnode: r, parent: e }, t) {
    for (; e; ) {
      const i = e.subTree;
      if (
        (i.suspense && i.suspense.activeBranch === r && (i.el = r.el), i === r)
      )
        ((r = e.vnode).el = t), (e = e.parent);
      else break;
    }
  }
  const _b = (r) => r.__isSuspense;
  function xE(r, e) {
    e && e.pendingBranch
      ? Oe(r)
        ? e.effects.push(...r)
        : e.effects.push(r)
      : FT(r);
  }
  const ot = Symbol.for("v-fgt"),
    Wa = Symbol.for("v-txt"),
    ir = Symbol.for("v-cmt"),
    iu = Symbol.for("v-stc"),
    Ro = [];
  let Ir = null;
  function j(r = !1) {
    Ro.push((Ir = r ? null : []));
  }
  function _E() {
    Ro.pop(), (Ir = Ro[Ro.length - 1] || null);
  }
  let zo = 1;
  function Lm(r) {
    (zo += r), r < 0 && Ir && (Ir.hasOnce = !0);
  }
  function wb(r) {
    return (
      (r.dynamicChildren = zo > 0 ? Ir || ma : null),
      _E(),
      zo > 0 && Ir && Ir.push(r),
      r
    );
  }
  function xe(r, e, t, i, s, n) {
    return wb(Se(r, e, t, i, s, n, !0));
  }
  function Me(r, e, t, i, s) {
    return wb(ne(r, e, t, i, s, !0));
  }
  function Mh(r) {
    return r ? r.__v_isVNode === !0 : !1;
  }
  function mn(r, e) {
    return r.type === e.type && r.key === e.key;
  }
  const Tb = ({ key: r }) => r ?? null,
    ch = ({ ref: r, ref_key: e, ref_for: t }) => (
      typeof r == "number" && (r = "" + r),
      r != null
        ? Ge(r) || Mt(r) || Fe(r)
          ? { i: Wt, r, k: e, f: !!t }
          : r
        : null
    );
  function Se(
    r,
    e = null,
    t = null,
    i = 0,
    s = null,
    n = r === ot ? 0 : 1,
    a = !1,
    o = !1
  ) {
    const l = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: r,
      props: e,
      key: e && Tb(e),
      ref: e && ch(e),
      scopeId: Gy,
      slotScopeIds: null,
      children: t,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag: n,
      patchFlag: i,
      dynamicProps: s,
      dynamicChildren: null,
      appContext: null,
      ctx: Wt,
    };
    return (
      o
        ? (dp(l, t), n & 128 && r.normalize(l))
        : t && (l.shapeFlag |= Ge(t) ? 8 : 16),
      zo > 0 &&
        !a &&
        Ir &&
        (l.patchFlag > 0 || n & 6) &&
        l.patchFlag !== 32 &&
        Ir.push(l),
      l
    );
  }
  const ne = wE;
  function wE(r, e = null, t = null, i = 0, s = null, n = !1) {
    if (((!r || r === rb) && (r = ir), Mh(r))) {
      const o = ms(r, e, !0);
      return (
        t && dp(o, t),
        zo > 0 &&
          !n &&
          Ir &&
          (o.shapeFlag & 6 ? (Ir[Ir.indexOf(r)] = o) : Ir.push(o)),
        (o.patchFlag = -2),
        o
      );
    }
    if ((ME(r) && (r = r.__vccOpts), e)) {
      e = TE(e);
      let { class: o, style: l } = e;
      o && !Ge(o) && (e.class = ce(o)),
        Qe(l) && (rp(l) && !Oe(l) && (l = Bt({}, l)), (e.style = Et(l)));
    }
    const a = Ge(r) ? 1 : _b(r) ? 128 : Xy(r) ? 64 : Qe(r) ? 4 : Fe(r) ? 2 : 0;
    return Se(r, e, t, i, s, a, n, !0);
  }
  function TE(r) {
    return r ? (rp(r) || cb(r) ? Bt({}, r) : r) : null;
  }
  function ms(r, e, t = !1, i = !1) {
    const { props: s, ref: n, patchFlag: a, children: o, transition: l } = r,
      h = e ? Gr(s || {}, e) : s,
      c = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: r.type,
        props: h,
        key: h && Tb(h),
        ref:
          e && e.ref
            ? t && n
              ? Oe(n)
                ? n.concat(ch(e))
                : [n, ch(e)]
              : ch(e)
            : n,
        scopeId: r.scopeId,
        slotScopeIds: r.slotScopeIds,
        children: o,
        target: r.target,
        targetStart: r.targetStart,
        targetAnchor: r.targetAnchor,
        staticCount: r.staticCount,
        shapeFlag: r.shapeFlag,
        patchFlag: e && r.type !== ot ? (a === -1 ? 16 : a | 16) : a,
        dynamicProps: r.dynamicProps,
        dynamicChildren: r.dynamicChildren,
        appContext: r.appContext,
        dirs: r.dirs,
        transition: l,
        component: r.component,
        suspense: r.suspense,
        ssContent: r.ssContent && ms(r.ssContent),
        ssFallback: r.ssFallback && ms(r.ssFallback),
        el: r.el,
        anchor: r.anchor,
        ctx: r.ctx,
        ce: r.ce,
      };
    return l && i && Rn(c, l.clone(c)), c;
  }
  function vr(r = " ", e = 0) {
    return ne(Wa, null, r, e);
  }
  function Re(r = "", e = !1) {
    return e ? (j(), Me(ir, null, r)) : ne(ir, null, r);
  }
  function Bi(r) {
    return r == null || typeof r == "boolean"
      ? ne(ir)
      : Oe(r)
      ? ne(ot, null, r.slice())
      : typeof r == "object"
      ? Bs(r)
      : ne(Wa, null, String(r));
  }
  function Bs(r) {
    return (r.el === null && r.patchFlag !== -1) || r.memo ? r : ms(r);
  }
  function dp(r, e) {
    let t = 0;
    const { shapeFlag: i } = r;
    if (e == null) e = null;
    else if (Oe(e)) t = 16;
    else if (typeof e == "object")
      if (i & 65) {
        const s = e.default;
        s && (s._c && (s._d = !1), dp(r, s()), s._c && (s._d = !0));
        return;
      } else {
        t = 32;
        const s = e._;
        !s && !cb(e)
          ? (e._ctx = Wt)
          : s === 3 &&
            Wt &&
            (Wt.slots._ === 1 ? (e._ = 1) : ((e._ = 2), (r.patchFlag |= 1024)));
      }
    else
      Fe(e)
        ? ((e = { default: e, _ctx: Wt }), (t = 32))
        : ((e = String(e)), i & 64 ? ((t = 16), (e = [vr(e)])) : (t = 8));
    (r.children = e), (r.shapeFlag |= t);
  }
  function Gr(...r) {
    const e = {};
    for (let t = 0; t < r.length; t++) {
      const i = r[t];
      for (const s in i)
        if (s === "class")
          e.class !== i.class && (e.class = ce([e.class, i.class]));
        else if (s === "style") e.style = Et([e.style, i.style]);
        else if (pc(s)) {
          const n = e[s],
            a = i[s];
          a &&
            n !== a &&
            !(Oe(n) && n.includes(a)) &&
            (e[s] = n ? [].concat(n, a) : a);
        } else s !== "" && (e[s] = i[s]);
    }
    return e;
  }
  function wi(r, e, t, i = null) {
    pi(r, e, 7, [t, i]);
  }
  const EE = ob();
  let SE = 0;
  function AE(r, e, t) {
    const i = r.type,
      s = (e ? e.appContext : r.appContext) || EE,
      n = {
        uid: SE++,
        vnode: r,
        type: i,
        parent: e,
        appContext: s,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        job: null,
        scope: new xy(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: e ? e.provides : Object.create(s.provides),
        ids: e ? e.ids : ["", 0, 0],
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: db(i, s),
        emitsOptions: xb(i, s),
        emit: null,
        emitted: null,
        propsDefaults: ft,
        inheritAttrs: i.inheritAttrs,
        ctx: ft,
        data: ft,
        props: ft,
        attrs: ft,
        slots: ft,
        refs: ft,
        setupState: ft,
        setupContext: null,
        suspense: t,
        suspenseId: t ? t.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null,
      };
    return (
      (n.ctx = { _: n }),
      (n.root = e ? e.root : n),
      (n.emit = mE.bind(null, n)),
      r.ce && r.ce(n),
      n
    );
  }
  let Kt = null;
  const Br = () => Kt || Wt;
  let Fh, _d;
  {
    const r = gy(),
      e = (t, i) => {
        let s;
        return (
          (s = r[t]) || (s = r[t] = []),
          s.push(i),
          (n) => {
            s.length > 1 ? s.forEach((a) => a(n)) : s[0](n);
          }
        );
      };
    (Fh = e("__VUE_INSTANCE_SETTERS__", (t) => (Kt = t))),
      (_d = e("__VUE_SSR_SETTERS__", (t) => (Tc = t)));
  }
  const ll = (r) => {
      const e = Kt;
      return (
        Fh(r),
        r.scope.on(),
        () => {
          r.scope.off(), Fh(e);
        }
      );
    },
    Nm = () => {
      Kt && Kt.scope.off(), Fh(null);
    };
  function Eb(r) {
    return r.vnode.shapeFlag & 4;
  }
  let Tc = !1;
  function CE(r, e = !1, t = !1) {
    e && _d(e);
    const { props: i, children: s } = r.vnode,
      n = Eb(r);
    tE(r, i, n, e), nE(r, s, t);
    const a = n ? IE(r, e) : void 0;
    return e && _d(!1), a;
  }
  function IE(r, e) {
    const t = r.type;
    (r.accessCache = Object.create(null)), (r.proxy = new Proxy(r.ctx, YT));
    const { setup: i } = t;
    if (i) {
      const s = (r.setupContext = i.length > 1 ? Ab(r) : null),
        n = ll(r);
      Ks();
      const a = al(i, r, 0, [r.props, s]);
      if ((Zs(), n(), Sh(a))) {
        if ((ba(r) || Zy(r), a.then(Nm, Nm), e))
          return a
            .then((o) => {
              Um(r, o, e);
            })
            .catch((o) => {
              bc(o, r, 0);
            });
        r.asyncDep = a;
      } else Um(r, a, e);
    } else Sb(r, e);
  }
  function Um(r, e, t) {
    Fe(e)
      ? r.type.__ssrInlineRender
        ? (r.ssrRender = e)
        : (r.render = e)
      : Qe(e) && (r.setupState = Dy(e)),
      Sb(r, t);
  }
  let Vm;
  function Sb(r, e, t) {
    const i = r.type;
    if (!r.render) {
      if (!e && Vm && !i.render) {
        const s = i.template || hp(r).template;
        if (s) {
          const { isCustomElement: n, compilerOptions: a } =
              r.appContext.config,
            { delimiters: o, compilerOptions: l } = i,
            h = Bt(Bt({ isCustomElement: n, delimiters: o }, a), l);
          i.render = Vm(s, h);
        }
      }
      r.render = i.render || ar;
    }
    {
      const s = ll(r);
      Ks();
      try {
        jT(r);
      } finally {
        Zs(), s();
      }
    }
  }
  const PE = {
    get(r, e) {
      return or(r, "get", ""), r[e];
    },
  };
  function Ab(r) {
    const e = (t) => {
      r.exposed = t || {};
    };
    return {
      attrs: new Proxy(r.attrs, PE),
      slots: r.slots,
      emit: r.emit,
      expose: e,
    };
  }
  function Ec(r) {
    return r.exposed
      ? r.exposeProxy ||
          (r.exposeProxy = new Proxy(Dy(fd(r.exposed)), {
            get(e, t) {
              if (t in e) return e[t];
              if (t in Po) return Po[t](r);
            },
            has(e, t) {
              return t in e || t in Po;
            },
          }))
      : r.proxy;
  }
  function RE(r, e = !0) {
    return Fe(r) ? r.displayName || r.name : r.name || (e && r.__name);
  }
  function ME(r) {
    return Fe(r) && "__vccOpts" in r;
  }
  const X = (r, e) => CT(r, e, Tc);
  function Cb(r, e, t) {
    const i = arguments.length;
    return i === 2
      ? Qe(e) && !Oe(e)
        ? Mh(e)
          ? ne(r, null, [e])
          : ne(r, e)
        : ne(r, null, e)
      : (i > 3
          ? (t = Array.prototype.slice.call(arguments, 2))
          : i === 3 && Mh(t) && (t = [t]),
        ne(r, e, t));
  }
  const FE = "3.5.4",
    BE = ar;
  /**
   * @vue/runtime-dom v3.5.4
   * (c) 2018-present Yuxi (Evan) You and Vue contributors
   * @license MIT
   **/ let wd;
  const $m = typeof window < "u" && window.trustedTypes;
  if ($m)
    try {
      wd = $m.createPolicy("vue", { createHTML: (r) => r });
    } catch {}
  const Ib = wd ? (r) => wd.createHTML(r) : (r) => r,
    OE = "http://www.w3.org/2000/svg",
    kE = "http://www.w3.org/1998/Math/MathML",
    ts = typeof document < "u" ? document : null,
    Gm = ts && ts.createElement("template"),
    DE = {
      insert: (r, e, t) => {
        e.insertBefore(r, t || null);
      },
      remove: (r) => {
        const e = r.parentNode;
        e && e.removeChild(r);
      },
      createElement: (r, e, t, i) => {
        const s =
          e === "svg"
            ? ts.createElementNS(OE, r)
            : e === "mathml"
            ? ts.createElementNS(kE, r)
            : t
            ? ts.createElement(r, { is: t })
            : ts.createElement(r);
        return (
          r === "select" &&
            i &&
            i.multiple != null &&
            s.setAttribute("multiple", i.multiple),
          s
        );
      },
      createText: (r) => ts.createTextNode(r),
      createComment: (r) => ts.createComment(r),
      setText: (r, e) => {
        r.nodeValue = e;
      },
      setElementText: (r, e) => {
        r.textContent = e;
      },
      parentNode: (r) => r.parentNode,
      nextSibling: (r) => r.nextSibling,
      querySelector: (r) => ts.querySelector(r),
      setScopeId(r, e) {
        r.setAttribute(e, "");
      },
      insertStaticContent(r, e, t, i, s, n) {
        const a = t ? t.previousSibling : e.lastChild;
        if (s && (s === n || s.nextSibling))
          for (
            ;
            e.insertBefore(s.cloneNode(!0), t),
              !(s === n || !(s = s.nextSibling));

          );
        else {
          Gm.innerHTML = Ib(
            i === "svg"
              ? `<svg>${r}</svg>`
              : i === "mathml"
              ? `<math>${r}</math>`
              : r
          );
          const o = Gm.content;
          if (i === "svg" || i === "mathml") {
            const l = o.firstChild;
            for (; l.firstChild; ) o.appendChild(l.firstChild);
            o.removeChild(l);
          }
          e.insertBefore(o, t);
        }
        return [
          a ? a.nextSibling : e.firstChild,
          t ? t.previousSibling : e.lastChild,
        ];
      },
    },
    Es = "transition",
    no = "animation",
    Ma = Symbol("_vtc"),
    Pb = {
      name: String,
      type: String,
      css: { type: Boolean, default: !0 },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String,
    },
    Rb = Bt({}, Yy, Pb),
    LE = (r) => ((r.displayName = "Transition"), (r.props = Rb), r),
    fp = LE((r, { slots: e }) => Cb(NT, Mb(r), e)),
    nn = (r, e = []) => {
      Oe(r) ? r.forEach((t) => t(...e)) : r && r(...e);
    },
    Hm = (r) => (r ? (Oe(r) ? r.some((e) => e.length > 1) : r.length > 1) : !1);
  function Mb(r) {
    const e = {};
    for (const R in r) R in Pb || (e[R] = r[R]);
    if (r.css === !1) return e;
    const {
        name: t = "v",
        type: i,
        duration: s,
        enterFromClass: n = `${t}-enter-from`,
        enterActiveClass: a = `${t}-enter-active`,
        enterToClass: o = `${t}-enter-to`,
        appearFromClass: l = n,
        appearActiveClass: h = a,
        appearToClass: c = o,
        leaveFromClass: u = `${t}-leave-from`,
        leaveActiveClass: d = `${t}-leave-active`,
        leaveToClass: f = `${t}-leave-to`,
      } = r,
      p = NE(s),
      m = p && p[0],
      v = p && p[1],
      {
        onBeforeEnter: g,
        onEnter: x,
        onEnterCancelled: b,
        onLeave: y,
        onLeaveCancelled: _,
        onBeforeAppear: w = g,
        onAppear: E = x,
        onAppearCancelled: A = b,
      } = e,
      C = (R, I, P) => {
        Cs(R, I ? c : o), Cs(R, I ? h : a), P && P();
      },
      F = (R, I) => {
        (R._isLeaving = !1), Cs(R, u), Cs(R, f), Cs(R, d), I && I();
      },
      B = (R) => (I, P) => {
        const M = R ? E : x,
          L = () => C(I, R, P);
        nn(M, [I, L]),
          Xm(() => {
            Cs(I, R ? l : n), es(I, R ? c : o), Hm(M) || zm(I, i, m, L);
          });
      };
    return Bt(e, {
      onBeforeEnter(R) {
        nn(g, [R]), es(R, n), es(R, a);
      },
      onBeforeAppear(R) {
        nn(w, [R]), es(R, l), es(R, h);
      },
      onEnter: B(!1),
      onAppear: B(!0),
      onLeave(R, I) {
        R._isLeaving = !0;
        const P = () => F(R, I);
        es(R, u),
          es(R, d),
          Bb(),
          Xm(() => {
            R._isLeaving && (Cs(R, u), es(R, f), Hm(y) || zm(R, i, v, P));
          }),
          nn(y, [R, P]);
      },
      onEnterCancelled(R) {
        C(R, !1), nn(b, [R]);
      },
      onAppearCancelled(R) {
        C(R, !0), nn(A, [R]);
      },
      onLeaveCancelled(R) {
        F(R), nn(_, [R]);
      },
    });
  }
  function NE(r) {
    if (r == null) return null;
    if (Qe(r)) return [su(r.enter), su(r.leave)];
    {
      const e = su(r);
      return [e, e];
    }
  }
  function su(r) {
    return Xw(r);
  }
  function es(r, e) {
    e.split(/\s+/).forEach((t) => t && r.classList.add(t)),
      (r[Ma] || (r[Ma] = new Set())).add(e);
  }
  function Cs(r, e) {
    e.split(/\s+/).forEach((i) => i && r.classList.remove(i));
    const t = r[Ma];
    t && (t.delete(e), t.size || (r[Ma] = void 0));
  }
  function Xm(r) {
    requestAnimationFrame(() => {
      requestAnimationFrame(r);
    });
  }
  let UE = 0;
  function zm(r, e, t, i) {
    const s = (r._endId = ++UE),
      n = () => {
        s === r._endId && i();
      };
    if (t) return setTimeout(n, t);
    const { type: a, timeout: o, propCount: l } = Fb(r, e);
    if (!a) return i();
    const h = a + "end";
    let c = 0;
    const u = () => {
        r.removeEventListener(h, d), n();
      },
      d = (f) => {
        f.target === r && ++c >= l && u();
      };
    setTimeout(() => {
      c < l && u();
    }, o + 1),
      r.addEventListener(h, d);
  }
  function Fb(r, e) {
    const t = window.getComputedStyle(r),
      i = (p) => (t[p] || "").split(", "),
      s = i(`${Es}Delay`),
      n = i(`${Es}Duration`),
      a = Wm(s, n),
      o = i(`${no}Delay`),
      l = i(`${no}Duration`),
      h = Wm(o, l);
    let c = null,
      u = 0,
      d = 0;
    e === Es
      ? a > 0 && ((c = Es), (u = a), (d = n.length))
      : e === no
      ? h > 0 && ((c = no), (u = h), (d = l.length))
      : ((u = Math.max(a, h)),
        (c = u > 0 ? (a > h ? Es : no) : null),
        (d = c ? (c === Es ? n.length : l.length) : 0));
    const f =
      c === Es && /\b(transform|all)(,|$)/.test(i(`${Es}Property`).toString());
    return { type: c, timeout: u, propCount: d, hasTransform: f };
  }
  function Wm(r, e) {
    for (; r.length < e.length; ) r = r.concat(r);
    return Math.max(...e.map((t, i) => Ym(t) + Ym(r[i])));
  }
  function Ym(r) {
    return r === "auto" ? 0 : Number(r.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function Bb() {
    return document.body.offsetHeight;
  }
  function VE(r, e, t) {
    const i = r[Ma];
    i && (e = (e ? [e, ...i] : [...i]).join(" ")),
      e == null
        ? r.removeAttribute("class")
        : t
        ? r.setAttribute("class", e)
        : (r.className = e);
  }
  const Bh = Symbol("_vod"),
    Ob = Symbol("_vsh"),
    pp = {
      beforeMount(r, { value: e }, { transition: t }) {
        (r[Bh] = r.style.display === "none" ? "" : r.style.display),
          t && e ? t.beforeEnter(r) : ao(r, e);
      },
      mounted(r, { value: e }, { transition: t }) {
        t && e && t.enter(r);
      },
      updated(r, { value: e, oldValue: t }, { transition: i }) {
        !e != !t &&
          (i
            ? e
              ? (i.beforeEnter(r), ao(r, !0), i.enter(r))
              : i.leave(r, () => {
                  ao(r, !1);
                })
            : ao(r, e));
      },
      beforeUnmount(r, { value: e }) {
        ao(r, e);
      },
    };
  function ao(r, e) {
    (r.style.display = e ? r[Bh] : "none"), (r[Ob] = !e);
  }
  const $E = Symbol(""),
    GE = /(^|;)\s*display\s*:/;
  function HE(r, e, t) {
    const i = r.style,
      s = Ge(t);
    let n = !1;
    if (t && !s) {
      if (e)
        if (Ge(e))
          for (const a of e.split(";")) {
            const o = a.slice(0, a.indexOf(":")).trim();
            t[o] == null && uh(i, o, "");
          }
        else for (const a in e) t[a] == null && uh(i, a, "");
      for (const a in t) a === "display" && (n = !0), uh(i, a, t[a]);
    } else if (s) {
      if (e !== t) {
        const a = i[$E];
        a && (t += ";" + a), (i.cssText = t), (n = GE.test(t));
      }
    } else e && r.removeAttribute("style");
    Bh in r && ((r[Bh] = n ? i.display : ""), r[Ob] && (i.display = "none"));
  }
  const jm = /\s*!important$/;
  function uh(r, e, t) {
    if (Oe(t)) t.forEach((i) => uh(r, e, i));
    else if ((t == null && (t = ""), e.startsWith("--"))) r.setProperty(e, t);
    else {
      const i = XE(r, e);
      jm.test(t)
        ? r.setProperty(qs(i), t.replace(jm, ""), "important")
        : (r[i] = t);
    }
  }
  const qm = ["Webkit", "Moz", "ms"],
    nu = {};
  function XE(r, e) {
    const t = nu[e];
    if (t) return t;
    let i = Xr(e);
    if (i !== "filter" && i in r) return (nu[e] = i);
    i = gc(i);
    for (let s = 0; s < qm.length; s++) {
      const n = qm[s] + i;
      if (n in r) return (nu[e] = n);
    }
    return e;
  }
  const Km = "http://www.w3.org/1999/xlink";
  function Zm(r, e, t, i, s, n = Kw(e)) {
    i && e.startsWith("xlink:")
      ? t == null
        ? r.removeAttributeNS(Km, e.slice(6, e.length))
        : r.setAttributeNS(Km, e, t)
      : t == null || (n && !vy(t))
      ? r.removeAttribute(e)
      : r.setAttribute(e, n ? "" : Xi(t) ? String(t) : t);
  }
  function zE(r, e, t, i) {
    if (e === "innerHTML" || e === "textContent") {
      t != null && (r[e] = e === "innerHTML" ? Ib(t) : t);
      return;
    }
    const s = r.tagName;
    if (e === "value" && s !== "PROGRESS" && !s.includes("-")) {
      const a = s === "OPTION" ? r.getAttribute("value") || "" : r.value,
        o = t == null ? (r.type === "checkbox" ? "on" : "") : String(t);
      (a !== o || !("_value" in r)) && (r.value = o),
        t == null && r.removeAttribute(e),
        (r._value = t);
      return;
    }
    let n = !1;
    if (t === "" || t == null) {
      const a = typeof r[e];
      a === "boolean"
        ? (t = vy(t))
        : t == null && a === "string"
        ? ((t = ""), (n = !0))
        : a === "number" && ((t = 0), (n = !0));
    }
    try {
      r[e] = t;
    } catch {}
    n && r.removeAttribute(e);
  }
  function kb(r, e, t, i) {
    r.addEventListener(e, t, i);
  }
  function WE(r, e, t, i) {
    r.removeEventListener(e, t, i);
  }
  const Jm = Symbol("_vei");
  function YE(r, e, t, i, s = null) {
    const n = r[Jm] || (r[Jm] = {}),
      a = n[e];
    if (i && a) a.value = i;
    else {
      const [o, l] = jE(e);
      if (i) {
        const h = (n[e] = ZE(i, s));
        kb(r, o, h, l);
      } else a && (WE(r, o, a, l), (n[e] = void 0));
    }
  }
  const Qm = /(?:Once|Passive|Capture)$/;
  function jE(r) {
    let e;
    if (Qm.test(r)) {
      e = {};
      let i;
      for (; (i = r.match(Qm)); )
        (r = r.slice(0, r.length - i[0].length)), (e[i[0].toLowerCase()] = !0);
    }
    return [r[2] === ":" ? r.slice(3) : qs(r.slice(2)), e];
  }
  let au = 0;
  const qE = Promise.resolve(),
    KE = () => au || (qE.then(() => (au = 0)), (au = Date.now()));
  function ZE(r, e) {
    const t = (i) => {
      if (!i._vts) i._vts = Date.now();
      else if (i._vts <= t.attached) return;
      pi(JE(i, t.value), e, 5, [i]);
    };
    return (t.value = r), (t.attached = KE()), t;
  }
  function JE(r, e) {
    if (Oe(e)) {
      const t = r.stopImmediatePropagation;
      return (
        (r.stopImmediatePropagation = () => {
          t.call(r), (r._stopped = !0);
        }),
        e.map((i) => (s) => !s._stopped && i && i(s))
      );
    } else return e;
  }
  const eg = (r) =>
      r.charCodeAt(0) === 111 &&
      r.charCodeAt(1) === 110 &&
      r.charCodeAt(2) > 96 &&
      r.charCodeAt(2) < 123,
    QE = (r, e, t, i, s, n) => {
      const a = s === "svg";
      e === "class"
        ? VE(r, i, a)
        : e === "style"
        ? HE(r, t, i)
        : pc(e)
        ? zf(e) || YE(r, e, t, i, n)
        : (
            e[0] === "."
              ? ((e = e.slice(1)), !0)
              : e[0] === "^"
              ? ((e = e.slice(1)), !1)
              : eS(r, e, i, a)
          )
        ? (zE(r, e, i),
          !r.tagName.includes("-") &&
            (e === "value" || e === "checked" || e === "selected") &&
            Zm(r, e, i, a, n, e !== "value"))
        : (e === "true-value"
            ? (r._trueValue = i)
            : e === "false-value" && (r._falseValue = i),
          Zm(r, e, i, a));
    };
  function eS(r, e, t, i) {
    if (i)
      return !!(
        e === "innerHTML" ||
        e === "textContent" ||
        (e in r && eg(e) && Fe(t))
      );
    if (
      e === "spellcheck" ||
      e === "draggable" ||
      e === "translate" ||
      e === "form" ||
      (e === "list" && r.tagName === "INPUT") ||
      (e === "type" && r.tagName === "TEXTAREA")
    )
      return !1;
    if (e === "width" || e === "height") {
      const s = r.tagName;
      if (s === "IMG" || s === "VIDEO" || s === "CANVAS" || s === "SOURCE")
        return !1;
    }
    return eg(e) && Ge(t)
      ? !1
      : !!(e in r || (r._isVueCE && (/[A-Z]/.test(e) || !Ge(t))));
  }
  const Db = new WeakMap(),
    Lb = new WeakMap(),
    Oh = Symbol("_moveCb"),
    tg = Symbol("_enterCb"),
    tS = (r) => (delete r.props.mode, r),
    rS = tS({
      name: "TransitionGroup",
      props: Bt({}, Rb, { tag: String, moveClass: String }),
      setup(r, { slots: e }) {
        const t = Br(),
          i = Wy();
        let s, n;
        return (
          ol(() => {
            if (!s.length) return;
            const a = r.moveClass || `${r.name || "v"}-move`;
            if (!oS(s[0].el, t.vnode.el, a)) return;
            s.forEach(sS), s.forEach(nS);
            const o = s.filter(aS);
            Bb(),
              o.forEach((l) => {
                const h = l.el,
                  c = h.style;
                es(h, a),
                  (c.transform = c.webkitTransform = c.transitionDuration = "");
                const u = (h[Oh] = (d) => {
                  (d && d.target !== h) ||
                    ((!d || /transform$/.test(d.propertyName)) &&
                      (h.removeEventListener("transitionend", u),
                      (h[Oh] = null),
                      Cs(h, a)));
                });
                h.addEventListener("transitionend", u);
              });
          }),
          () => {
            const a = tt(r),
              o = Mb(a);
            let l = a.tag || ot;
            if (((s = []), n))
              for (let h = 0; h < n.length; h++) {
                const c = n[h];
                c.el &&
                  c.el instanceof Element &&
                  (s.push(c),
                  Rn(c, Xo(c, o, i, t)),
                  Db.set(c, c.el.getBoundingClientRect()));
              }
            n = e.default ? ap(e.default()) : [];
            for (let h = 0; h < n.length; h++) {
              const c = n[h];
              c.key != null && Rn(c, Xo(c, o, i, t));
            }
            return ne(l, null, n);
          }
        );
      },
    }),
    iS = rS;
  function sS(r) {
    const e = r.el;
    e[Oh] && e[Oh](), e[tg] && e[tg]();
  }
  function nS(r) {
    Lb.set(r, r.el.getBoundingClientRect());
  }
  function aS(r) {
    const e = Db.get(r),
      t = Lb.get(r),
      i = e.left - t.left,
      s = e.top - t.top;
    if (i || s) {
      const n = r.el.style;
      return (
        (n.transform = n.webkitTransform = `translate(${i}px,${s}px)`),
        (n.transitionDuration = "0s"),
        r
      );
    }
  }
  function oS(r, e, t) {
    const i = r.cloneNode(),
      s = r[Ma];
    s &&
      s.forEach((o) => {
        o.split(/\s+/).forEach((l) => l && i.classList.remove(l));
      }),
      t.split(/\s+/).forEach((o) => o && i.classList.add(o)),
      (i.style.display = "none");
    const n = e.nodeType === 1 ? e : e.parentNode;
    n.appendChild(i);
    const { hasTransform: a } = Fb(i);
    return n.removeChild(i), a;
  }
  const rg = (r) => {
      const e = r.props["onUpdate:modelValue"] || !1;
      return Oe(e) ? (t) => lh(e, t) : e;
    },
    ou = Symbol("_assign"),
    Nb = {
      created(r, { value: e }, t) {
        (r.checked = Ah(e, t.props.value)),
          (r[ou] = rg(t)),
          kb(r, "change", () => {
            r[ou](lS(r));
          });
      },
      beforeUpdate(r, { value: e, oldValue: t }, i) {
        (r[ou] = rg(i)), e !== t && (r.checked = Ah(e, i.props.value));
      },
    };
  function lS(r) {
    return "_value" in r ? r._value : r.value;
  }
  const hS = ["ctrl", "shift", "alt", "meta"],
    cS = {
      stop: (r) => r.stopPropagation(),
      prevent: (r) => r.preventDefault(),
      self: (r) => r.target !== r.currentTarget,
      ctrl: (r) => !r.ctrlKey,
      shift: (r) => !r.shiftKey,
      alt: (r) => !r.altKey,
      meta: (r) => !r.metaKey,
      left: (r) => "button" in r && r.button !== 0,
      middle: (r) => "button" in r && r.button !== 1,
      right: (r) => "button" in r && r.button !== 2,
      exact: (r, e) => hS.some((t) => r[`${t}Key`] && !e.includes(t)),
    },
    hi = (r, e) => {
      const t = r._withMods || (r._withMods = {}),
        i = e.join(".");
      return (
        t[i] ||
        (t[i] = (s, ...n) => {
          for (let a = 0; a < e.length; a++) {
            const o = cS[e[a]];
            if (o && o(s, e)) return;
          }
          return r(s, ...n);
        })
      );
    },
    uS = {
      esc: "escape",
      space: " ",
      up: "arrow-up",
      left: "arrow-left",
      right: "arrow-right",
      down: "arrow-down",
      delete: "backspace",
    },
    go = (r, e) => {
      const t = r._withKeys || (r._withKeys = {}),
        i = e.join(".");
      return (
        t[i] ||
        (t[i] = (s) => {
          if (!("key" in s)) return;
          const n = qs(s.key);
          if (e.some((a) => a === n || uS[a] === n)) return r(s);
        })
      );
    },
    dS = Bt({ patchProp: QE }, DE);
  let ig;
  function fS() {
    return ig || (ig = oE(dS));
  }
  const pS = (...r) => {
    const e = fS().createApp(...r),
      { mount: t } = e;
    return (
      (e.mount = (i) => {
        const s = gS(i);
        if (!s) return;
        const n = e._component;
        !Fe(n) && !n.render && !n.template && (n.template = s.innerHTML),
          s.nodeType === 1 && (s.textContent = "");
        const a = t(s, !1, mS(s));
        return (
          s instanceof Element &&
            (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")),
          a
        );
      }),
      e
    );
  };
  function mS(r) {
    if (r instanceof SVGElement) return "svg";
    if (typeof MathMLElement == "function" && r instanceof MathMLElement)
      return "mathml";
  }
  function gS(r) {
    return Ge(r) ? document.querySelector(r) : r;
  }
  const rs =
    (r, e, { checkForDefaultPrevented: t = !0 } = {}) =>
    (s) => {
      const n = r == null ? void 0 : r(s);
      if (t === !1 || !n) return e == null ? void 0 : e(s);
    };
  var sg;
  const It = typeof window < "u",
    vS = (r) => typeof r == "string",
    Fa = () => {},
    yS =
      It &&
      ((sg = window == null ? void 0 : window.navigator) == null
        ? void 0
        : sg.userAgent) &&
      /iP(ad|hone|od)/.test(window.navigator.userAgent);
  function Wo(r) {
    return typeof r == "function" ? r() : S(r);
  }
  function Ub(r, e) {
    function t(...i) {
      return new Promise((s, n) => {
        Promise.resolve(
          r(() => e.apply(this, i), { fn: e, thisArg: this, args: i })
        )
          .then(s)
          .catch(n);
      });
    }
    return t;
  }
  function bS(r, e = {}) {
    let t,
      i,
      s = Fa;
    const n = (o) => {
      clearTimeout(o), s(), (s = Fa);
    };
    return (o) => {
      const l = Wo(r),
        h = Wo(e.maxWait);
      return (
        t && n(t),
        l <= 0 || (h !== void 0 && h <= 0)
          ? (i && (n(i), (i = null)), Promise.resolve(o()))
          : new Promise((c, u) => {
              (s = e.rejectOnCancel ? u : c),
                h &&
                  !i &&
                  (i = setTimeout(() => {
                    t && n(t), (i = null), c(o());
                  }, h)),
                (t = setTimeout(() => {
                  i && n(i), (i = null), c(o());
                }, l));
            })
      );
    };
  }
  function xS(r, e = !0, t = !0, i = !1) {
    let s = 0,
      n,
      a = !0,
      o = Fa,
      l;
    const h = () => {
      n && (clearTimeout(n), (n = void 0), o(), (o = Fa));
    };
    return (u) => {
      const d = Wo(r),
        f = Date.now() - s,
        p = () => (l = u());
      return (
        h(),
        d <= 0
          ? ((s = Date.now()), p())
          : (f > d && (t || !a)
              ? ((s = Date.now()), p())
              : e &&
                (l = new Promise((m, v) => {
                  (o = i ? v : m),
                    (n = setTimeout(() => {
                      (s = Date.now()), (a = !0), m(p()), h();
                    }, Math.max(0, d - f)));
                })),
            !t && !n && (n = setTimeout(() => (a = !0), d)),
            (a = !1),
            l)
      );
    };
  }
  function _S(r) {
    return r;
  }
  function mp(r) {
    return _y() ? (Qw(r), !0) : !1;
  }
  function wS(r, e = 200, t = {}) {
    return Ub(bS(e, t), r);
  }
  function TS(r, e = 200, t = {}) {
    const i = he(r.value),
      s = wS(
        () => {
          i.value = r.value;
        },
        e,
        t
      );
    return De(r, () => s()), i;
  }
  function ES(r, e = 200, t = !1, i = !0, s = !1) {
    return Ub(xS(e, t, i, s), r);
  }
  function SS(r, e = !0) {
    Br() ? Rt(r) : e ? r() : _t(r);
  }
  function Us(r) {
    var e;
    const t = Wo(r);
    return (e = t == null ? void 0 : t.$el) != null ? e : t;
  }
  const gp = It ? window : void 0;
  function Vt(...r) {
    let e, t, i, s;
    if (
      (vS(r[0]) || Array.isArray(r[0])
        ? (([t, i, s] = r), (e = gp))
        : ([e, t, i, s] = r),
      !e)
    )
      return Fa;
    Array.isArray(t) || (t = [t]), Array.isArray(i) || (i = [i]);
    const n = [],
      a = () => {
        n.forEach((c) => c()), (n.length = 0);
      },
      o = (c, u, d, f) => (
        c.addEventListener(u, d, f), () => c.removeEventListener(u, d, f)
      ),
      l = De(
        () => [Us(e), Wo(s)],
        ([c, u]) => {
          a(), c && n.push(...t.flatMap((d) => i.map((f) => o(c, d, f, u))));
        },
        { immediate: !0, flush: "post" }
      ),
      h = () => {
        l(), a();
      };
    return mp(h), h;
  }
  let ng = !1;
  function AS(r, e, t = {}) {
    const {
      window: i = gp,
      ignore: s = [],
      capture: n = !0,
      detectIframe: a = !1,
    } = t;
    if (!i) return;
    yS &&
      !ng &&
      ((ng = !0),
      Array.from(i.document.body.children).forEach((d) =>
        d.addEventListener("click", Fa)
      ));
    let o = !0;
    const l = (d) =>
        s.some((f) => {
          if (typeof f == "string")
            return Array.from(i.document.querySelectorAll(f)).some(
              (p) => p === d.target || d.composedPath().includes(p)
            );
          {
            const p = Us(f);
            return p && (d.target === p || d.composedPath().includes(p));
          }
        }),
      c = [
        Vt(
          i,
          "click",
          (d) => {
            const f = Us(r);
            if (!(!f || f === d.target || d.composedPath().includes(f))) {
              if ((d.detail === 0 && (o = !l(d)), !o)) {
                o = !0;
                return;
              }
              e(d);
            }
          },
          { passive: !0, capture: n }
        ),
        Vt(
          i,
          "pointerdown",
          (d) => {
            const f = Us(r);
            f && (o = !d.composedPath().includes(f) && !l(d));
          },
          { passive: !0 }
        ),
        a &&
          Vt(i, "blur", (d) => {
            var f;
            const p = Us(r);
            ((f = i.document.activeElement) == null ? void 0 : f.tagName) ===
              "IFRAME" &&
              !(p != null && p.contains(i.document.activeElement)) &&
              e(d);
          }),
      ].filter(Boolean);
    return () => c.forEach((d) => d());
  }
  function CS(r, e = !1) {
    const t = he(),
      i = () => (t.value = !!r());
    return i(), SS(i, e), t;
  }
  const ag =
      typeof globalThis < "u"
        ? globalThis
        : typeof window < "u"
        ? window
        : typeof global < "u"
        ? global
        : typeof self < "u"
        ? self
        : {},
    og = "__vueuse_ssr_handlers__";
  ag[og] = ag[og] || {};
  var lg = Object.getOwnPropertySymbols,
    IS = Object.prototype.hasOwnProperty,
    PS = Object.prototype.propertyIsEnumerable,
    RS = (r, e) => {
      var t = {};
      for (var i in r) IS.call(r, i) && e.indexOf(i) < 0 && (t[i] = r[i]);
      if (r != null && lg)
        for (var i of lg(r)) e.indexOf(i) < 0 && PS.call(r, i) && (t[i] = r[i]);
      return t;
    };
  function vp(r, e, t = {}) {
    const i = t,
      { window: s = gp } = i,
      n = RS(i, ["window"]);
    let a;
    const o = CS(() => s && "ResizeObserver" in s),
      l = () => {
        a && (a.disconnect(), (a = void 0));
      },
      h = De(
        () => Us(r),
        (u) => {
          l(),
            o.value && s && u && ((a = new ResizeObserver(e)), a.observe(u, n));
        },
        { immediate: !0, flush: "post" }
      ),
      c = () => {
        l(), h();
      };
    return mp(c), { isSupported: o, stop: c };
  }
  var hg;
  (function (r) {
    (r.UP = "UP"),
      (r.RIGHT = "RIGHT"),
      (r.DOWN = "DOWN"),
      (r.LEFT = "LEFT"),
      (r.NONE = "NONE");
  })(hg || (hg = {}));
  var MS = Object.defineProperty,
    cg = Object.getOwnPropertySymbols,
    FS = Object.prototype.hasOwnProperty,
    BS = Object.prototype.propertyIsEnumerable,
    ug = (r, e, t) =>
      e in r
        ? MS(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
        : (r[e] = t),
    OS = (r, e) => {
      for (var t in e || (e = {})) FS.call(e, t) && ug(r, t, e[t]);
      if (cg) for (var t of cg(e)) BS.call(e, t) && ug(r, t, e[t]);
      return r;
    };
  const kS = {
    easeInSine: [0.12, 0, 0.39, 0],
    easeOutSine: [0.61, 1, 0.88, 1],
    easeInOutSine: [0.37, 0, 0.63, 1],
    easeInQuad: [0.11, 0, 0.5, 0],
    easeOutQuad: [0.5, 1, 0.89, 1],
    easeInOutQuad: [0.45, 0, 0.55, 1],
    easeInCubic: [0.32, 0, 0.67, 0],
    easeOutCubic: [0.33, 1, 0.68, 1],
    easeInOutCubic: [0.65, 0, 0.35, 1],
    easeInQuart: [0.5, 0, 0.75, 0],
    easeOutQuart: [0.25, 1, 0.5, 1],
    easeInOutQuart: [0.76, 0, 0.24, 1],
    easeInQuint: [0.64, 0, 0.78, 0],
    easeOutQuint: [0.22, 1, 0.36, 1],
    easeInOutQuint: [0.83, 0, 0.17, 1],
    easeInExpo: [0.7, 0, 0.84, 0],
    easeOutExpo: [0.16, 1, 0.3, 1],
    easeInOutExpo: [0.87, 0, 0.13, 1],
    easeInCirc: [0.55, 0, 1, 0.45],
    easeOutCirc: [0, 0.55, 0.45, 1],
    easeInOutCirc: [0.85, 0, 0.15, 1],
    easeInBack: [0.36, 0, 0.66, -0.56],
    easeOutBack: [0.34, 1.56, 0.64, 1],
    easeInOutBack: [0.68, -0.6, 0.32, 1.6],
  };
  OS({ linear: _S }, kS);
  const DS = () => It && /firefox/i.test(window.navigator.userAgent),
    LS = (r, e) => {
      if (!It || !r || !e) return !1;
      const t = r.getBoundingClientRect();
      let i;
      return (
        e instanceof Element
          ? (i = e.getBoundingClientRect())
          : (i = {
              top: 0,
              right: window.innerWidth,
              bottom: window.innerHeight,
              left: 0,
            }),
        t.top < i.bottom &&
          t.bottom > i.top &&
          t.right > i.left &&
          t.left < i.right
      );
    };
  var Vb =
      typeof global == "object" && global && global.Object === Object && global,
    NS = typeof self == "object" && self && self.Object === Object && self,
    yi = Vb || NS || Function("return this")(),
    zi = yi.Symbol,
    $b = Object.prototype,
    US = $b.hasOwnProperty,
    VS = $b.toString,
    oo = zi ? zi.toStringTag : void 0;
  function $S(r) {
    var e = US.call(r, oo),
      t = r[oo];
    try {
      r[oo] = void 0;
      var i = !0;
    } catch {}
    var s = VS.call(r);
    return i && (e ? (r[oo] = t) : delete r[oo]), s;
  }
  var GS = Object.prototype,
    HS = GS.toString;
  function XS(r) {
    return HS.call(r);
  }
  var zS = "[object Null]",
    WS = "[object Undefined]",
    dg = zi ? zi.toStringTag : void 0;
  function Ya(r) {
    return r == null
      ? r === void 0
        ? WS
        : zS
      : dg && dg in Object(r)
      ? $S(r)
      : XS(r);
  }
  function ja(r) {
    return r != null && typeof r == "object";
  }
  var YS = "[object Symbol]";
  function Sc(r) {
    return typeof r == "symbol" || (ja(r) && Ya(r) == YS);
  }
  function jS(r, e) {
    for (var t = -1, i = r == null ? 0 : r.length, s = Array(i); ++t < i; )
      s[t] = e(r[t], t, r);
    return s;
  }
  var xs = Array.isArray,
    qS = 1 / 0,
    fg = zi ? zi.prototype : void 0,
    pg = fg ? fg.toString : void 0;
  function Gb(r) {
    if (typeof r == "string") return r;
    if (xs(r)) return jS(r, Gb) + "";
    if (Sc(r)) return pg ? pg.call(r) : "";
    var e = r + "";
    return e == "0" && 1 / r == -qS ? "-0" : e;
  }
  var KS = /\s/;
  function ZS(r) {
    for (var e = r.length; e-- && KS.test(r.charAt(e)); );
    return e;
  }
  var JS = /^\s+/;
  function QS(r) {
    return r && r.slice(0, ZS(r) + 1).replace(JS, "");
  }
  function mi(r) {
    var e = typeof r;
    return r != null && (e == "object" || e == "function");
  }
  var mg = NaN,
    eA = /^[-+]0x[0-9a-f]+$/i,
    tA = /^0b[01]+$/i,
    rA = /^0o[0-7]+$/i,
    iA = parseInt;
  function gg(r) {
    if (typeof r == "number") return r;
    if (Sc(r)) return mg;
    if (mi(r)) {
      var e = typeof r.valueOf == "function" ? r.valueOf() : r;
      r = mi(e) ? e + "" : e;
    }
    if (typeof r != "string") return r === 0 ? r : +r;
    r = QS(r);
    var t = tA.test(r);
    return t || rA.test(r) ? iA(r.slice(2), t ? 2 : 8) : eA.test(r) ? mg : +r;
  }
  function sA(r) {
    return r;
  }
  var nA = "[object AsyncFunction]",
    aA = "[object Function]",
    oA = "[object GeneratorFunction]",
    lA = "[object Proxy]";
  function Hb(r) {
    if (!mi(r)) return !1;
    var e = Ya(r);
    return e == aA || e == oA || e == nA || e == lA;
  }
  var lu = yi["__core-js_shared__"],
    vg = (function () {
      var r = /[^.]+$/.exec((lu && lu.keys && lu.keys.IE_PROTO) || "");
      return r ? "Symbol(src)_1." + r : "";
    })();
  function hA(r) {
    return !!vg && vg in r;
  }
  var cA = Function.prototype,
    uA = cA.toString;
  function Un(r) {
    if (r != null) {
      try {
        return uA.call(r);
      } catch {}
      try {
        return r + "";
      } catch {}
    }
    return "";
  }
  var dA = /[\\^$.*+?()[\]{}|]/g,
    fA = /^\[object .+?Constructor\]$/,
    pA = Function.prototype,
    mA = Object.prototype,
    gA = pA.toString,
    vA = mA.hasOwnProperty,
    yA = RegExp(
      "^" +
        gA
          .call(vA)
          .replace(dA, "\\$&")
          .replace(
            /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
            "$1.*?"
          ) +
        "$"
    );
  function bA(r) {
    if (!mi(r) || hA(r)) return !1;
    var e = Hb(r) ? yA : fA;
    return e.test(Un(r));
  }
  function xA(r, e) {
    return r == null ? void 0 : r[e];
  }
  function Vn(r, e) {
    var t = xA(r, e);
    return bA(t) ? t : void 0;
  }
  var Td = Vn(yi, "WeakMap"),
    yg = Object.create,
    _A = (function () {
      function r() {}
      return function (e) {
        if (!mi(e)) return {};
        if (yg) return yg(e);
        r.prototype = e;
        var t = new r();
        return (r.prototype = void 0), t;
      };
    })();
  function wA(r, e, t) {
    switch (t.length) {
      case 0:
        return r.call(e);
      case 1:
        return r.call(e, t[0]);
      case 2:
        return r.call(e, t[0], t[1]);
      case 3:
        return r.call(e, t[0], t[1], t[2]);
    }
    return r.apply(e, t);
  }
  function TA(r, e) {
    var t = -1,
      i = r.length;
    for (e || (e = Array(i)); ++t < i; ) e[t] = r[t];
    return e;
  }
  var EA = 800,
    SA = 16,
    AA = Date.now;
  function CA(r) {
    var e = 0,
      t = 0;
    return function () {
      var i = AA(),
        s = SA - (i - t);
      if (((t = i), s > 0)) {
        if (++e >= EA) return arguments[0];
      } else e = 0;
      return r.apply(void 0, arguments);
    };
  }
  function IA(r) {
    return function () {
      return r;
    };
  }
  var kh = (function () {
      try {
        var r = Vn(Object, "defineProperty");
        return r({}, "", {}), r;
      } catch {}
    })(),
    PA = kh
      ? function (r, e) {
          return kh(r, "toString", {
            configurable: !0,
            enumerable: !1,
            value: IA(e),
            writable: !0,
          });
        }
      : sA,
    RA = CA(PA);
  function MA(r, e) {
    for (
      var t = -1, i = r == null ? 0 : r.length;
      ++t < i && e(r[t], t, r) !== !1;

    );
    return r;
  }
  var FA = 9007199254740991,
    BA = /^(?:0|[1-9]\d*)$/;
  function yp(r, e) {
    var t = typeof r;
    return (
      (e = e ?? FA),
      !!e &&
        (t == "number" || (t != "symbol" && BA.test(r))) &&
        r > -1 &&
        r % 1 == 0 &&
        r < e
    );
  }
  function Xb(r, e, t) {
    e == "__proto__" && kh
      ? kh(r, e, { configurable: !0, enumerable: !0, value: t, writable: !0 })
      : (r[e] = t);
  }
  function zb(r, e) {
    return r === e || (r !== r && e !== e);
  }
  var OA = Object.prototype,
    kA = OA.hasOwnProperty;
  function bp(r, e, t) {
    var i = r[e];
    (!(kA.call(r, e) && zb(i, t)) || (t === void 0 && !(e in r))) &&
      Xb(r, e, t);
  }
  function Ac(r, e, t, i) {
    var s = !t;
    t || (t = {});
    for (var n = -1, a = e.length; ++n < a; ) {
      var o = e[n],
        l = void 0;
      l === void 0 && (l = r[o]), s ? Xb(t, o, l) : bp(t, o, l);
    }
    return t;
  }
  var bg = Math.max;
  function DA(r, e, t) {
    return (
      (e = bg(e === void 0 ? r.length - 1 : e, 0)),
      function () {
        for (
          var i = arguments, s = -1, n = bg(i.length - e, 0), a = Array(n);
          ++s < n;

        )
          a[s] = i[e + s];
        s = -1;
        for (var o = Array(e + 1); ++s < e; ) o[s] = i[s];
        return (o[e] = t(a)), wA(r, this, o);
      }
    );
  }
  var LA = 9007199254740991;
  function xp(r) {
    return typeof r == "number" && r > -1 && r % 1 == 0 && r <= LA;
  }
  function Wb(r) {
    return r != null && xp(r.length) && !Hb(r);
  }
  var NA = Object.prototype;
  function _p(r) {
    var e = r && r.constructor,
      t = (typeof e == "function" && e.prototype) || NA;
    return r === t;
  }
  function UA(r, e) {
    for (var t = -1, i = Array(r); ++t < r; ) i[t] = e(t);
    return i;
  }
  var VA = "[object Arguments]";
  function xg(r) {
    return ja(r) && Ya(r) == VA;
  }
  var Yb = Object.prototype,
    $A = Yb.hasOwnProperty,
    GA = Yb.propertyIsEnumerable,
    wp = xg(
      (function () {
        return arguments;
      })()
    )
      ? xg
      : function (r) {
          return ja(r) && $A.call(r, "callee") && !GA.call(r, "callee");
        };
  function HA() {
    return !1;
  }
  var jb = typeof Rr == "object" && Rr && !Rr.nodeType && Rr,
    _g = jb && typeof Mr == "object" && Mr && !Mr.nodeType && Mr,
    XA = _g && _g.exports === jb,
    wg = XA ? yi.Buffer : void 0,
    zA = wg ? wg.isBuffer : void 0,
    qb = zA || HA,
    WA = "[object Arguments]",
    YA = "[object Array]",
    jA = "[object Boolean]",
    qA = "[object Date]",
    KA = "[object Error]",
    ZA = "[object Function]",
    JA = "[object Map]",
    QA = "[object Number]",
    eC = "[object Object]",
    tC = "[object RegExp]",
    rC = "[object Set]",
    iC = "[object String]",
    sC = "[object WeakMap]",
    nC = "[object ArrayBuffer]",
    aC = "[object DataView]",
    oC = "[object Float32Array]",
    lC = "[object Float64Array]",
    hC = "[object Int8Array]",
    cC = "[object Int16Array]",
    uC = "[object Int32Array]",
    dC = "[object Uint8Array]",
    fC = "[object Uint8ClampedArray]",
    pC = "[object Uint16Array]",
    mC = "[object Uint32Array]",
    yt = {};
  yt[oC] =
    yt[lC] =
    yt[hC] =
    yt[cC] =
    yt[uC] =
    yt[dC] =
    yt[fC] =
    yt[pC] =
    yt[mC] =
      !0;
  yt[WA] =
    yt[YA] =
    yt[nC] =
    yt[jA] =
    yt[aC] =
    yt[qA] =
    yt[KA] =
    yt[ZA] =
    yt[JA] =
    yt[QA] =
    yt[eC] =
    yt[tC] =
    yt[rC] =
    yt[iC] =
    yt[sC] =
      !1;
  function gC(r) {
    return ja(r) && xp(r.length) && !!yt[Ya(r)];
  }
  function Tp(r) {
    return function (e) {
      return r(e);
    };
  }
  var Kb = typeof Rr == "object" && Rr && !Rr.nodeType && Rr,
    Mo = Kb && typeof Mr == "object" && Mr && !Mr.nodeType && Mr,
    vC = Mo && Mo.exports === Kb,
    hu = vC && Vb.process,
    Ba = (function () {
      try {
        var r = Mo && Mo.require && Mo.require("util").types;
        return r || (hu && hu.binding && hu.binding("util"));
      } catch {}
    })(),
    Tg = Ba && Ba.isTypedArray,
    yC = Tg ? Tp(Tg) : gC,
    bC = Object.prototype,
    xC = bC.hasOwnProperty;
  function Zb(r, e) {
    var t = xs(r),
      i = !t && wp(r),
      s = !t && !i && qb(r),
      n = !t && !i && !s && yC(r),
      a = t || i || s || n,
      o = a ? UA(r.length, String) : [],
      l = o.length;
    for (var h in r)
      (e || xC.call(r, h)) &&
        !(
          a &&
          (h == "length" ||
            (s && (h == "offset" || h == "parent")) ||
            (n && (h == "buffer" || h == "byteLength" || h == "byteOffset")) ||
            yp(h, l))
        ) &&
        o.push(h);
    return o;
  }
  function Jb(r, e) {
    return function (t) {
      return r(e(t));
    };
  }
  var _C = Jb(Object.keys, Object),
    wC = Object.prototype,
    TC = wC.hasOwnProperty;
  function EC(r) {
    if (!_p(r)) return _C(r);
    var e = [];
    for (var t in Object(r)) TC.call(r, t) && t != "constructor" && e.push(t);
    return e;
  }
  function Ep(r) {
    return Wb(r) ? Zb(r) : EC(r);
  }
  function SC(r) {
    var e = [];
    if (r != null) for (var t in Object(r)) e.push(t);
    return e;
  }
  var AC = Object.prototype,
    CC = AC.hasOwnProperty;
  function IC(r) {
    if (!mi(r)) return SC(r);
    var e = _p(r),
      t = [];
    for (var i in r) (i == "constructor" && (e || !CC.call(r, i))) || t.push(i);
    return t;
  }
  function Sp(r) {
    return Wb(r) ? Zb(r, !0) : IC(r);
  }
  var PC = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    RC = /^\w*$/;
  function MC(r, e) {
    if (xs(r)) return !1;
    var t = typeof r;
    return t == "number" ||
      t == "symbol" ||
      t == "boolean" ||
      r == null ||
      Sc(r)
      ? !0
      : RC.test(r) || !PC.test(r) || (e != null && r in Object(e));
  }
  var Yo = Vn(Object, "create");
  function FC() {
    (this.__data__ = Yo ? Yo(null) : {}), (this.size = 0);
  }
  function BC(r) {
    var e = this.has(r) && delete this.__data__[r];
    return (this.size -= e ? 1 : 0), e;
  }
  var OC = "__lodash_hash_undefined__",
    kC = Object.prototype,
    DC = kC.hasOwnProperty;
  function LC(r) {
    var e = this.__data__;
    if (Yo) {
      var t = e[r];
      return t === OC ? void 0 : t;
    }
    return DC.call(e, r) ? e[r] : void 0;
  }
  var NC = Object.prototype,
    UC = NC.hasOwnProperty;
  function VC(r) {
    var e = this.__data__;
    return Yo ? e[r] !== void 0 : UC.call(e, r);
  }
  var $C = "__lodash_hash_undefined__";
  function GC(r, e) {
    var t = this.__data__;
    return (
      (this.size += this.has(r) ? 0 : 1),
      (t[r] = Yo && e === void 0 ? $C : e),
      this
    );
  }
  function Mn(r) {
    var e = -1,
      t = r == null ? 0 : r.length;
    for (this.clear(); ++e < t; ) {
      var i = r[e];
      this.set(i[0], i[1]);
    }
  }
  Mn.prototype.clear = FC;
  Mn.prototype.delete = BC;
  Mn.prototype.get = LC;
  Mn.prototype.has = VC;
  Mn.prototype.set = GC;
  function HC() {
    (this.__data__ = []), (this.size = 0);
  }
  function Cc(r, e) {
    for (var t = r.length; t--; ) if (zb(r[t][0], e)) return t;
    return -1;
  }
  var XC = Array.prototype,
    zC = XC.splice;
  function WC(r) {
    var e = this.__data__,
      t = Cc(e, r);
    if (t < 0) return !1;
    var i = e.length - 1;
    return t == i ? e.pop() : zC.call(e, t, 1), --this.size, !0;
  }
  function YC(r) {
    var e = this.__data__,
      t = Cc(e, r);
    return t < 0 ? void 0 : e[t][1];
  }
  function jC(r) {
    return Cc(this.__data__, r) > -1;
  }
  function qC(r, e) {
    var t = this.__data__,
      i = Cc(t, r);
    return i < 0 ? (++this.size, t.push([r, e])) : (t[i][1] = e), this;
  }
  function _s(r) {
    var e = -1,
      t = r == null ? 0 : r.length;
    for (this.clear(); ++e < t; ) {
      var i = r[e];
      this.set(i[0], i[1]);
    }
  }
  _s.prototype.clear = HC;
  _s.prototype.delete = WC;
  _s.prototype.get = YC;
  _s.prototype.has = jC;
  _s.prototype.set = qC;
  var jo = Vn(yi, "Map");
  function KC() {
    (this.size = 0),
      (this.__data__ = {
        hash: new Mn(),
        map: new (jo || _s)(),
        string: new Mn(),
      });
  }
  function ZC(r) {
    var e = typeof r;
    return e == "string" || e == "number" || e == "symbol" || e == "boolean"
      ? r !== "__proto__"
      : r === null;
  }
  function Ic(r, e) {
    var t = r.__data__;
    return ZC(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
  }
  function JC(r) {
    var e = Ic(this, r).delete(r);
    return (this.size -= e ? 1 : 0), e;
  }
  function QC(r) {
    return Ic(this, r).get(r);
  }
  function e2(r) {
    return Ic(this, r).has(r);
  }
  function t2(r, e) {
    var t = Ic(this, r),
      i = t.size;
    return t.set(r, e), (this.size += t.size == i ? 0 : 1), this;
  }
  function Js(r) {
    var e = -1,
      t = r == null ? 0 : r.length;
    for (this.clear(); ++e < t; ) {
      var i = r[e];
      this.set(i[0], i[1]);
    }
  }
  Js.prototype.clear = KC;
  Js.prototype.delete = JC;
  Js.prototype.get = QC;
  Js.prototype.has = e2;
  Js.prototype.set = t2;
  var r2 = "Expected a function";
  function Ap(r, e) {
    if (typeof r != "function" || (e != null && typeof e != "function"))
      throw new TypeError(r2);
    var t = function () {
      var i = arguments,
        s = e ? e.apply(this, i) : i[0],
        n = t.cache;
      if (n.has(s)) return n.get(s);
      var a = r.apply(this, i);
      return (t.cache = n.set(s, a) || n), a;
    };
    return (t.cache = new (Ap.Cache || Js)()), t;
  }
  Ap.Cache = Js;
  var i2 = 500;
  function s2(r) {
    var e = Ap(r, function (i) {
        return t.size === i2 && t.clear(), i;
      }),
      t = e.cache;
    return e;
  }
  var n2 =
      /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
    a2 = /\\(\\)?/g,
    o2 = s2(function (r) {
      var e = [];
      return (
        r.charCodeAt(0) === 46 && e.push(""),
        r.replace(n2, function (t, i, s, n) {
          e.push(s ? n.replace(a2, "$1") : i || t);
        }),
        e
      );
    });
  function l2(r) {
    return r == null ? "" : Gb(r);
  }
  function Pc(r, e) {
    return xs(r) ? r : MC(r, e) ? [r] : o2(l2(r));
  }
  var h2 = 1 / 0;
  function Cp(r) {
    if (typeof r == "string" || Sc(r)) return r;
    var e = r + "";
    return e == "0" && 1 / r == -h2 ? "-0" : e;
  }
  function Qb(r, e) {
    e = Pc(e, r);
    for (var t = 0, i = e.length; r != null && t < i; ) r = r[Cp(e[t++])];
    return t && t == i ? r : void 0;
  }
  function ex(r, e, t) {
    var i = r == null ? void 0 : Qb(r, e);
    return i === void 0 ? t : i;
  }
  function Ip(r, e) {
    for (var t = -1, i = e.length, s = r.length; ++t < i; ) r[s + t] = e[t];
    return r;
  }
  var Eg = zi ? zi.isConcatSpreadable : void 0;
  function c2(r) {
    return xs(r) || wp(r) || !!(Eg && r && r[Eg]);
  }
  function u2(r, e, t, i, s) {
    var n = -1,
      a = r.length;
    for (t || (t = c2), s || (s = []); ++n < a; ) {
      var o = r[n];
      t(o) ? Ip(s, o) : (s[s.length] = o);
    }
    return s;
  }
  function d2(r) {
    var e = r == null ? 0 : r.length;
    return e ? u2(r) : [];
  }
  function f2(r) {
    return RA(DA(r, void 0, d2), r + "");
  }
  var tx = Jb(Object.getPrototypeOf, Object);
  function Ed() {
    if (!arguments.length) return [];
    var r = arguments[0];
    return xs(r) ? r : [r];
  }
  function p2() {
    (this.__data__ = new _s()), (this.size = 0);
  }
  function m2(r) {
    var e = this.__data__,
      t = e.delete(r);
    return (this.size = e.size), t;
  }
  function g2(r) {
    return this.__data__.get(r);
  }
  function v2(r) {
    return this.__data__.has(r);
  }
  var y2 = 200;
  function b2(r, e) {
    var t = this.__data__;
    if (t instanceof _s) {
      var i = t.__data__;
      if (!jo || i.length < y2 - 1)
        return i.push([r, e]), (this.size = ++t.size), this;
      t = this.__data__ = new Js(i);
    }
    return t.set(r, e), (this.size = t.size), this;
  }
  function qa(r) {
    var e = (this.__data__ = new _s(r));
    this.size = e.size;
  }
  qa.prototype.clear = p2;
  qa.prototype.delete = m2;
  qa.prototype.get = g2;
  qa.prototype.has = v2;
  qa.prototype.set = b2;
  function x2(r, e) {
    return r && Ac(e, Ep(e), r);
  }
  function _2(r, e) {
    return r && Ac(e, Sp(e), r);
  }
  var rx = typeof Rr == "object" && Rr && !Rr.nodeType && Rr,
    Sg = rx && typeof Mr == "object" && Mr && !Mr.nodeType && Mr,
    w2 = Sg && Sg.exports === rx,
    Ag = w2 ? yi.Buffer : void 0,
    Cg = Ag ? Ag.allocUnsafe : void 0;
  function T2(r, e) {
    if (e) return r.slice();
    var t = r.length,
      i = Cg ? Cg(t) : new r.constructor(t);
    return r.copy(i), i;
  }
  function E2(r, e) {
    for (var t = -1, i = r == null ? 0 : r.length, s = 0, n = []; ++t < i; ) {
      var a = r[t];
      e(a, t, r) && (n[s++] = a);
    }
    return n;
  }
  function ix() {
    return [];
  }
  var S2 = Object.prototype,
    A2 = S2.propertyIsEnumerable,
    Ig = Object.getOwnPropertySymbols,
    Pp = Ig
      ? function (r) {
          return r == null
            ? []
            : ((r = Object(r)),
              E2(Ig(r), function (e) {
                return A2.call(r, e);
              }));
        }
      : ix;
  function C2(r, e) {
    return Ac(r, Pp(r), e);
  }
  var I2 = Object.getOwnPropertySymbols,
    sx = I2
      ? function (r) {
          for (var e = []; r; ) Ip(e, Pp(r)), (r = tx(r));
          return e;
        }
      : ix;
  function P2(r, e) {
    return Ac(r, sx(r), e);
  }
  function nx(r, e, t) {
    var i = e(r);
    return xs(r) ? i : Ip(i, t(r));
  }
  function R2(r) {
    return nx(r, Ep, Pp);
  }
  function M2(r) {
    return nx(r, Sp, sx);
  }
  var Sd = Vn(yi, "DataView"),
    Ad = Vn(yi, "Promise"),
    Cd = Vn(yi, "Set"),
    Pg = "[object Map]",
    F2 = "[object Object]",
    Rg = "[object Promise]",
    Mg = "[object Set]",
    Fg = "[object WeakMap]",
    Bg = "[object DataView]",
    B2 = Un(Sd),
    O2 = Un(jo),
    k2 = Un(Ad),
    D2 = Un(Cd),
    L2 = Un(Td),
    as = Ya;
  ((Sd && as(new Sd(new ArrayBuffer(1))) != Bg) ||
    (jo && as(new jo()) != Pg) ||
    (Ad && as(Ad.resolve()) != Rg) ||
    (Cd && as(new Cd()) != Mg) ||
    (Td && as(new Td()) != Fg)) &&
    (as = function (r) {
      var e = Ya(r),
        t = e == F2 ? r.constructor : void 0,
        i = t ? Un(t) : "";
      if (i)
        switch (i) {
          case B2:
            return Bg;
          case O2:
            return Pg;
          case k2:
            return Rg;
          case D2:
            return Mg;
          case L2:
            return Fg;
        }
      return e;
    });
  var N2 = Object.prototype,
    U2 = N2.hasOwnProperty;
  function V2(r) {
    var e = r.length,
      t = new r.constructor(e);
    return (
      e &&
        typeof r[0] == "string" &&
        U2.call(r, "index") &&
        ((t.index = r.index), (t.input = r.input)),
      t
    );
  }
  var Og = yi.Uint8Array;
  function Rp(r) {
    var e = new r.constructor(r.byteLength);
    return new Og(e).set(new Og(r)), e;
  }
  function $2(r, e) {
    var t = e ? Rp(r.buffer) : r.buffer;
    return new r.constructor(t, r.byteOffset, r.byteLength);
  }
  var G2 = /\w*$/;
  function H2(r) {
    var e = new r.constructor(r.source, G2.exec(r));
    return (e.lastIndex = r.lastIndex), e;
  }
  var kg = zi ? zi.prototype : void 0,
    Dg = kg ? kg.valueOf : void 0;
  function X2(r) {
    return Dg ? Object(Dg.call(r)) : {};
  }
  function z2(r, e) {
    var t = e ? Rp(r.buffer) : r.buffer;
    return new r.constructor(t, r.byteOffset, r.length);
  }
  var W2 = "[object Boolean]",
    Y2 = "[object Date]",
    j2 = "[object Map]",
    q2 = "[object Number]",
    K2 = "[object RegExp]",
    Z2 = "[object Set]",
    J2 = "[object String]",
    Q2 = "[object Symbol]",
    eI = "[object ArrayBuffer]",
    tI = "[object DataView]",
    rI = "[object Float32Array]",
    iI = "[object Float64Array]",
    sI = "[object Int8Array]",
    nI = "[object Int16Array]",
    aI = "[object Int32Array]",
    oI = "[object Uint8Array]",
    lI = "[object Uint8ClampedArray]",
    hI = "[object Uint16Array]",
    cI = "[object Uint32Array]";
  function uI(r, e, t) {
    var i = r.constructor;
    switch (e) {
      case eI:
        return Rp(r);
      case W2:
      case Y2:
        return new i(+r);
      case tI:
        return $2(r, t);
      case rI:
      case iI:
      case sI:
      case nI:
      case aI:
      case oI:
      case lI:
      case hI:
      case cI:
        return z2(r, t);
      case j2:
        return new i();
      case q2:
      case J2:
        return new i(r);
      case K2:
        return H2(r);
      case Z2:
        return new i();
      case Q2:
        return X2(r);
    }
  }
  function dI(r) {
    return typeof r.constructor == "function" && !_p(r) ? _A(tx(r)) : {};
  }
  var fI = "[object Map]";
  function pI(r) {
    return ja(r) && as(r) == fI;
  }
  var Lg = Ba && Ba.isMap,
    mI = Lg ? Tp(Lg) : pI,
    gI = "[object Set]";
  function vI(r) {
    return ja(r) && as(r) == gI;
  }
  var Ng = Ba && Ba.isSet,
    yI = Ng ? Tp(Ng) : vI,
    bI = 1,
    xI = 2,
    _I = 4,
    ax = "[object Arguments]",
    wI = "[object Array]",
    TI = "[object Boolean]",
    EI = "[object Date]",
    SI = "[object Error]",
    ox = "[object Function]",
    AI = "[object GeneratorFunction]",
    CI = "[object Map]",
    II = "[object Number]",
    lx = "[object Object]",
    PI = "[object RegExp]",
    RI = "[object Set]",
    MI = "[object String]",
    FI = "[object Symbol]",
    BI = "[object WeakMap]",
    OI = "[object ArrayBuffer]",
    kI = "[object DataView]",
    DI = "[object Float32Array]",
    LI = "[object Float64Array]",
    NI = "[object Int8Array]",
    UI = "[object Int16Array]",
    VI = "[object Int32Array]",
    $I = "[object Uint8Array]",
    GI = "[object Uint8ClampedArray]",
    HI = "[object Uint16Array]",
    XI = "[object Uint32Array]",
    mt = {};
  mt[ax] =
    mt[wI] =
    mt[OI] =
    mt[kI] =
    mt[TI] =
    mt[EI] =
    mt[DI] =
    mt[LI] =
    mt[NI] =
    mt[UI] =
    mt[VI] =
    mt[CI] =
    mt[II] =
    mt[lx] =
    mt[PI] =
    mt[RI] =
    mt[MI] =
    mt[FI] =
    mt[$I] =
    mt[GI] =
    mt[HI] =
    mt[XI] =
      !0;
  mt[SI] = mt[ox] = mt[BI] = !1;
  function dh(r, e, t, i, s, n) {
    var a,
      o = e & bI,
      l = e & xI,
      h = e & _I;
    if (a !== void 0) return a;
    if (!mi(r)) return r;
    var c = xs(r);
    if (c) {
      if (((a = V2(r)), !o)) return TA(r, a);
    } else {
      var u = as(r),
        d = u == ox || u == AI;
      if (qb(r)) return T2(r, o);
      if (u == lx || u == ax || (d && !s)) {
        if (((a = l || d ? {} : dI(r)), !o))
          return l ? P2(r, _2(a, r)) : C2(r, x2(a, r));
      } else {
        if (!mt[u]) return s ? r : {};
        a = uI(r, u, o);
      }
    }
    n || (n = new qa());
    var f = n.get(r);
    if (f) return f;
    n.set(r, a),
      yI(r)
        ? r.forEach(function (v) {
            a.add(dh(v, e, t, v, r, n));
          })
        : mI(r) &&
          r.forEach(function (v, g) {
            a.set(g, dh(v, e, t, g, r, n));
          });
    var p = h ? (l ? M2 : R2) : l ? Sp : Ep,
      m = c ? void 0 : p(r);
    return (
      MA(m || r, function (v, g) {
        m && ((g = v), (v = r[g])), bp(a, g, dh(v, e, t, g, r, n));
      }),
      a
    );
  }
  var zI = 4;
  function Ug(r) {
    return dh(r, zI);
  }
  function WI(r, e) {
    return r != null && e in Object(r);
  }
  function YI(r, e, t) {
    e = Pc(e, r);
    for (var i = -1, s = e.length, n = !1; ++i < s; ) {
      var a = Cp(e[i]);
      if (!(n = r != null && t(r, a))) break;
      r = r[a];
    }
    return n || ++i != s
      ? n
      : ((s = r == null ? 0 : r.length),
        !!s && xp(s) && yp(a, s) && (xs(r) || wp(r)));
  }
  function jI(r, e) {
    return r != null && YI(r, e, WI);
  }
  var cu = function () {
      return yi.Date.now();
    },
    qI = "Expected a function",
    KI = Math.max,
    ZI = Math.min;
  function Id(r, e, t) {
    var i,
      s,
      n,
      a,
      o,
      l,
      h = 0,
      c = !1,
      u = !1,
      d = !0;
    if (typeof r != "function") throw new TypeError(qI);
    (e = gg(e) || 0),
      mi(t) &&
        ((c = !!t.leading),
        (u = "maxWait" in t),
        (n = u ? KI(gg(t.maxWait) || 0, e) : n),
        (d = "trailing" in t ? !!t.trailing : d));
    function f(w) {
      var E = i,
        A = s;
      return (i = s = void 0), (h = w), (a = r.apply(A, E)), a;
    }
    function p(w) {
      return (h = w), (o = setTimeout(g, e)), c ? f(w) : a;
    }
    function m(w) {
      var E = w - l,
        A = w - h,
        C = e - E;
      return u ? ZI(C, n - A) : C;
    }
    function v(w) {
      var E = w - l,
        A = w - h;
      return l === void 0 || E >= e || E < 0 || (u && A >= n);
    }
    function g() {
      var w = cu();
      if (v(w)) return x(w);
      o = setTimeout(g, m(w));
    }
    function x(w) {
      return (o = void 0), d && i ? f(w) : ((i = s = void 0), a);
    }
    function b() {
      o !== void 0 && clearTimeout(o), (h = 0), (i = l = s = o = void 0);
    }
    function y() {
      return o === void 0 ? a : x(cu());
    }
    function _() {
      var w = cu(),
        E = v(w);
      if (((i = arguments), (s = this), (l = w), E)) {
        if (o === void 0) return p(l);
        if (u) return clearTimeout(o), (o = setTimeout(g, e)), f(l);
      }
      return o === void 0 && (o = setTimeout(g, e)), a;
    }
    return (_.cancel = b), (_.flush = y), _;
  }
  function qo(r) {
    for (var e = -1, t = r == null ? 0 : r.length, i = {}; ++e < t; ) {
      var s = r[e];
      i[s[0]] = s[1];
    }
    return i;
  }
  function Ni(r) {
    return r == null;
  }
  function JI(r) {
    return r === void 0;
  }
  function hx(r, e, t, i) {
    if (!mi(r)) return r;
    e = Pc(e, r);
    for (var s = -1, n = e.length, a = n - 1, o = r; o != null && ++s < n; ) {
      var l = Cp(e[s]),
        h = t;
      if (l === "__proto__" || l === "constructor" || l === "prototype")
        return r;
      if (s != a) {
        var c = o[l];
        (h = void 0), h === void 0 && (h = mi(c) ? c : yp(e[s + 1]) ? [] : {});
      }
      bp(o, l, h), (o = o[l]);
    }
    return r;
  }
  function QI(r, e, t) {
    for (var i = -1, s = e.length, n = {}; ++i < s; ) {
      var a = e[i],
        o = Qb(r, a);
      t(o, a) && hx(n, Pc(a, r), o);
    }
    return n;
  }
  function eP(r, e) {
    return QI(r, e, function (t, i) {
      return jI(r, i);
    });
  }
  var tP = f2(function (r, e) {
    return r == null ? {} : eP(r, e);
  });
  function rP(r, e, t) {
    return r == null ? r : hx(r, e, t);
  }
  var iP = "Expected a function";
  function uu(r, e, t) {
    var i = !0,
      s = !0;
    if (typeof r != "function") throw new TypeError(iP);
    return (
      mi(t) &&
        ((i = "leading" in t ? !!t.leading : i),
        (s = "trailing" in t ? !!t.trailing : s)),
      Id(r, e, { leading: i, maxWait: e, trailing: s })
    );
  }
  const la = (r) => r === void 0,
    Ui = (r) => typeof r == "boolean",
    at = (r) => typeof r == "number",
    _a = (r) => (typeof Element > "u" ? !1 : r instanceof Element),
    Vg = (r) => Ni(r),
    sP = (r) => (Ge(r) ? !Number.isNaN(Number(r)) : !1),
    nP = (r) => Object.keys(r),
    du = (r, e, t) => ({
      get value() {
        return ex(r, e, t);
      },
      set value(i) {
        rP(r, e, i);
      },
    });
  class aP extends Error {
    constructor(e) {
      super(e), (this.name = "ElementPlusError");
    }
  }
  function hl(r, e) {
    throw new aP(`[${r}] ${e}`);
  }
  const oP = (r, e) => {
    var t;
    if (!It || !r || !e) return "";
    let i = Xr(e);
    i === "float" && (i = "cssFloat");
    try {
      const s = r.style[i];
      if (s) return s;
      const n =
        (t = document.defaultView) == null ? void 0 : t.getComputedStyle(r, "");
      return n ? n[i] : "";
    } catch {
      return r.style[i];
    }
  };
  function Fn(r, e = "px") {
    if (!r) return "";
    if (at(r) || sP(r)) return `${r}${e}`;
    if (Ge(r)) return r;
  }
  const lP = (r, e) => {
      if (!It) return !1;
      const t = {
          undefined: "overflow",
          true: "overflow-y",
          false: "overflow-x",
        }[String(e)],
        i = oP(r, t);
      return ["scroll", "auto", "overlay"].some((s) => i.includes(s));
    },
    hP = (r, e) => {
      if (!It) return;
      let t = r;
      for (; t; ) {
        if ([window, document, document.documentElement].includes(t))
          return window;
        if (lP(t, e)) return t;
        t = t.parentNode;
      }
      return t;
    };
  /*! Element Plus Icons Vue v2.3.1 */ var cP = ge({
      name: "ArrowDown",
      __name: "arrow-down",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z",
              }),
            ]
          )
        );
      },
    }),
    uP = cP,
    dP = ge({
      name: "ArrowLeft",
      __name: "arrow-left",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z",
              }),
            ]
          )
        );
      },
    }),
    fP = dP,
    pP = ge({
      name: "ArrowRight",
      __name: "arrow-right",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z",
              }),
            ]
          )
        );
      },
    }),
    mP = pP,
    gP = ge({
      name: "ArrowUp",
      __name: "arrow-up",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0",
              }),
            ]
          )
        );
      },
    }),
    vP = gP,
    yP = ge({
      name: "CircleCheck",
      __name: "circle-check",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896",
              }),
              Se("path", {
                fill: "currentColor",
                d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z",
              }),
            ]
          )
        );
      },
    }),
    bP = yP,
    xP = ge({
      name: "CircleClose",
      __name: "circle-close",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z",
              }),
              Se("path", {
                fill: "currentColor",
                d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896",
              }),
            ]
          )
        );
      },
    }),
    cx = xP,
    _P = ge({
      name: "Close",
      __name: "close",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z",
              }),
            ]
          )
        );
      },
    }),
    wP = _P,
    TP = ge({
      name: "FullScreen",
      __name: "full-screen",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64z",
              }),
            ]
          )
        );
      },
    }),
    EP = TP,
    SP = ge({
      name: "Hide",
      __name: "hide",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z",
              }),
              Se("path", {
                fill: "currentColor",
                d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z",
              }),
            ]
          )
        );
      },
    }),
    AP = SP,
    CP = ge({
      name: "Loading",
      __name: "loading",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z",
              }),
            ]
          )
        );
      },
    }),
    Mp = CP,
    IP = ge({
      name: "Minus",
      __name: "minus",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64",
              }),
            ]
          )
        );
      },
    }),
    PP = IP,
    RP = ge({
      name: "Plus",
      __name: "plus",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z",
              }),
            ]
          )
        );
      },
    }),
    MP = RP,
    FP = ge({
      name: "QuestionFilled",
      __name: "question-filled",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z",
              }),
            ]
          )
        );
      },
    }),
    BP = FP,
    OP = ge({
      name: "RefreshLeft",
      __name: "refresh-left",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z",
              }),
            ]
          )
        );
      },
    }),
    kP = OP,
    DP = ge({
      name: "RefreshRight",
      __name: "refresh-right",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z",
              }),
            ]
          )
        );
      },
    }),
    LP = DP,
    NP = ge({
      name: "ScaleToOriginal",
      __name: "scale-to-original",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118M512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412M512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512",
              }),
            ]
          )
        );
      },
    }),
    UP = NP,
    VP = ge({
      name: "View",
      __name: "view",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160",
              }),
            ]
          )
        );
      },
    }),
    $P = VP,
    GP = ge({
      name: "ZoomIn",
      __name: "zoom-in",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704m-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64z",
              }),
            ]
          )
        );
      },
    }),
    HP = GP,
    XP = ge({
      name: "ZoomOut",
      __name: "zoom-out",
      setup(r) {
        return (e, t) => (
          j(),
          xe(
            "svg",
            { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024" },
            [
              Se("path", {
                fill: "currentColor",
                d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704M352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64",
              }),
            ]
          )
        );
      },
    }),
    zP = XP;
  const ux = "__epPropKey",
    Ne = (r) => r,
    WP = (r) => Qe(r) && !!r[ux],
    Rc = (r, e) => {
      if (!Qe(r) || WP(r)) return r;
      const { values: t, required: i, default: s, type: n, validator: a } = r,
        l = {
          type: n,
          required: !!i,
          validator:
            t || a
              ? (h) => {
                  let c = !1,
                    u = [];
                  if (
                    (t &&
                      ((u = Array.from(t)),
                      nt(r, "default") && u.push(s),
                      c || (c = u.includes(h))),
                    a && (c || (c = a(h))),
                    !c && u.length > 0)
                  ) {
                    const d = [...new Set(u)]
                      .map((f) => JSON.stringify(f))
                      .join(", ");
                    BE(
                      `Invalid prop: validation failed${
                        e ? ` for prop "${e}"` : ""
                      }. Expected one of [${d}], got value ${JSON.stringify(
                        h
                      )}.`
                    );
                  }
                  return c;
                }
              : void 0,
          [ux]: !0,
        };
      return nt(r, "default") && (l.default = s), l;
    },
    et = (r) => qo(Object.entries(r).map(([e, t]) => [e, Rc(t, e)])),
    hs = Ne([String, Object, Function]),
    YP = { validating: Mp, success: bP, error: cx },
    Qt = (r, e) => {
      if (
        ((r.install = (t) => {
          for (const i of [r, ...Object.values(e ?? {})])
            t.component(i.name, i);
        }),
        e)
      )
        for (const [t, i] of Object.entries(e)) r[t] = i;
      return r;
    },
    Mc = (r) => ((r.install = ar), r),
    ii = {
      tab: "Tab",
      enter: "Enter",
      space: "Space",
      left: "ArrowLeft",
      up: "ArrowUp",
      right: "ArrowRight",
      down: "ArrowDown",
      esc: "Escape",
      delete: "Delete",
      backspace: "Backspace",
      numpadEnter: "NumpadEnter",
      pageUp: "PageUp",
      pageDown: "PageDown",
      home: "Home",
      end: "End",
    },
    $t = "update:modelValue",
    Ys = "change",
    Vi = "input",
    cl = ["", "default", "small", "large"],
    jP = (r) => ["", ...cl].includes(r),
    qP = (r) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(r),
    Fp = (r) => r,
    KP = ["class", "style"],
    ZP = /^on[A-Z]/,
    dx = (r = {}) => {
      const { excludeListeners: e = !1, excludeKeys: t } = r,
        i = X(() => ((t == null ? void 0 : t.value) || []).concat(KP)),
        s = Br();
      return X(
        s
          ? () => {
              var n;
              return qo(
                Object.entries(
                  (n = s.proxy) == null ? void 0 : n.$attrs
                ).filter(([a]) => !i.value.includes(a) && !(e && ZP.test(a)))
              );
            }
          : () => ({})
      );
    },
    fx = (
      {
        from: r,
        replacement: e,
        scope: t,
        version: i,
        ref: s,
        type: n = "API",
      },
      a
    ) => {
      De(
        () => S(a),
        (o) => {},
        { immediate: !0 }
      );
    };
  var JP = {
    name: "en",
    el: {
      breadcrumb: { label: "Breadcrumb" },
      colorpicker: {
        confirm: "OK",
        clear: "Clear",
        defaultLabel: "color picker",
        description:
          "current color is {color}. press enter to select a new color.",
        alphaLabel: "pick alpha value",
      },
      datepicker: {
        now: "Now",
        today: "Today",
        cancel: "Cancel",
        clear: "Clear",
        confirm: "OK",
        dateTablePrompt:
          "Use the arrow keys and enter to select the day of the month",
        monthTablePrompt: "Use the arrow keys and enter to select the month",
        yearTablePrompt: "Use the arrow keys and enter to select the year",
        selectedDate: "Selected date",
        selectDate: "Select date",
        selectTime: "Select time",
        startDate: "Start Date",
        startTime: "Start Time",
        endDate: "End Date",
        endTime: "End Time",
        prevYear: "Previous Year",
        nextYear: "Next Year",
        prevMonth: "Previous Month",
        nextMonth: "Next Month",
        year: "",
        month1: "January",
        month2: "February",
        month3: "March",
        month4: "April",
        month5: "May",
        month6: "June",
        month7: "July",
        month8: "August",
        month9: "September",
        month10: "October",
        month11: "November",
        month12: "December",
        week: "week",
        weeks: {
          sun: "Sun",
          mon: "Mon",
          tue: "Tue",
          wed: "Wed",
          thu: "Thu",
          fri: "Fri",
          sat: "Sat",
        },
        weeksFull: {
          sun: "Sunday",
          mon: "Monday",
          tue: "Tuesday",
          wed: "Wednesday",
          thu: "Thursday",
          fri: "Friday",
          sat: "Saturday",
        },
        months: {
          jan: "Jan",
          feb: "Feb",
          mar: "Mar",
          apr: "Apr",
          may: "May",
          jun: "Jun",
          jul: "Jul",
          aug: "Aug",
          sep: "Sep",
          oct: "Oct",
          nov: "Nov",
          dec: "Dec",
        },
      },
      inputNumber: { decrease: "decrease number", increase: "increase number" },
      select: {
        loading: "Loading",
        noMatch: "No matching data",
        noData: "No data",
        placeholder: "Select",
      },
      mention: { loading: "Loading" },
      dropdown: { toggleDropdown: "Toggle Dropdown" },
      cascader: {
        noMatch: "No matching data",
        loading: "Loading",
        placeholder: "Select",
        noData: "No data",
      },
      pagination: {
        goto: "Go to",
        pagesize: "/page",
        total: "Total {total}",
        pageClassifier: "",
        page: "Page",
        prev: "Go to previous page",
        next: "Go to next page",
        currentPage: "page {pager}",
        prevPages: "Previous {pager} pages",
        nextPages: "Next {pager} pages",
        deprecationWarning:
          "Deprecated usages detected, please refer to the el-pagination documentation for more details",
      },
      dialog: { close: "Close this dialog" },
      drawer: { close: "Close this dialog" },
      messagebox: {
        title: "Message",
        confirm: "OK",
        cancel: "Cancel",
        error: "Illegal input",
        close: "Close this dialog",
      },
      upload: {
        deleteTip: "press delete to remove",
        delete: "Delete",
        preview: "Preview",
        continue: "Continue",
      },
      slider: {
        defaultLabel: "slider between {min} and {max}",
        defaultRangeStartLabel: "pick start value",
        defaultRangeEndLabel: "pick end value",
      },
      table: {
        emptyText: "No Data",
        confirmFilter: "Confirm",
        resetFilter: "Reset",
        clearFilter: "All",
        sumText: "Sum",
      },
      tour: { next: "Next", previous: "Previous", finish: "Finish" },
      tree: { emptyText: "No Data" },
      transfer: {
        noMatch: "No matching data",
        noData: "No data",
        titles: ["List 1", "List 2"],
        filterPlaceholder: "Enter keyword",
        noCheckedFormat: "{total} items",
        hasCheckedFormat: "{checked}/{total} checked",
      },
      image: { error: "FAILED" },
      pageHeader: { title: "Back" },
      popconfirm: { confirmButtonText: "Yes", cancelButtonText: "No" },
      carousel: {
        leftArrow: "Carousel arrow left",
        rightArrow: "Carousel arrow right",
        indicator: "Carousel switch to index {index}",
      },
    },
  };
  const QP = (r) => (e, t) => eR(e, t, S(r)),
    eR = (r, e, t) =>
      ex(t, r, r).replace(/\{(\w+)\}/g, (i, s) => {
        var n;
        return `${(n = e == null ? void 0 : e[s]) != null ? n : `{${s}}`}`;
      }),
    tR = (r) => {
      const e = X(() => S(r).name),
        t = Mt(r) ? r : he(r);
      return { lang: e, locale: t, t: QP(r) };
    },
    rR = Symbol("localeContextKey"),
    ul = (r) => {
      const e = rt(rR, he());
      return tR(X(() => e.value || JP));
    },
    fu = "el",
    iR = "is-",
    an = (r, e, t, i, s) => {
      let n = `${r}-${e}`;
      return t && (n += `-${t}`), i && (n += `__${i}`), s && (n += `--${s}`), n;
    },
    sR = Symbol("namespaceContextKey"),
    Bp = (r) => {
      const e = Br() ? rt(sR, he(fu)) : he(fu);
      return X(() => S(e) || fu);
    },
    ut = (r, e) => {
      const t = Bp();
      return {
        namespace: t,
        b: (m = "") => an(t.value, r, m, "", ""),
        e: (m) => (m ? an(t.value, r, "", m, "") : ""),
        m: (m) => (m ? an(t.value, r, "", "", m) : ""),
        be: (m, v) => (m && v ? an(t.value, r, m, v, "") : ""),
        em: (m, v) => (m && v ? an(t.value, r, "", m, v) : ""),
        bm: (m, v) => (m && v ? an(t.value, r, m, "", v) : ""),
        bem: (m, v, g) => (m && v && g ? an(t.value, r, m, v, g) : ""),
        is: (m, ...v) => {
          const g = v.length >= 1 ? v[0] : !0;
          return m && g ? `${iR}${m}` : "";
        },
        cssVar: (m) => {
          const v = {};
          for (const g in m) m[g] && (v[`--${t.value}-${g}`] = m[g]);
          return v;
        },
        cssVarName: (m) => `--${t.value}-${m}`,
        cssVarBlock: (m) => {
          const v = {};
          for (const g in m) m[g] && (v[`--${t.value}-${r}-${g}`] = m[g]);
          return v;
        },
        cssVarBlockName: (m) => `--${t.value}-${r}-${m}`,
      };
    },
    nR = Rc({ type: Ne(Boolean), default: null }),
    aR = Rc({ type: Ne(Function) }),
    px = (r) => {
      const e = `update:${r}`,
        t = `onUpdate:${r}`,
        i = [e],
        s = { [r]: nR, [t]: aR };
      return {
        useModelToggle: ({
          indicator: a,
          toggleReason: o,
          shouldHideWhenRouteChanges: l,
          shouldProceed: h,
          onShow: c,
          onHide: u,
        }) => {
          const d = Br(),
            { emit: f } = d,
            p = d.props,
            m = X(() => Fe(p[t])),
            v = X(() => p[r] === null),
            g = (E) => {
              a.value !== !0 &&
                ((a.value = !0), o && (o.value = E), Fe(c) && c(E));
            },
            x = (E) => {
              a.value !== !1 &&
                ((a.value = !1), o && (o.value = E), Fe(u) && u(E));
            },
            b = (E) => {
              if (p.disabled === !0 || (Fe(h) && !h())) return;
              const A = m.value && It;
              A && f(e, !0), (v.value || !A) && g(E);
            },
            y = (E) => {
              if (p.disabled === !0 || !It) return;
              const A = m.value && It;
              A && f(e, !1), (v.value || !A) && x(E);
            },
            _ = (E) => {
              Ui(E) &&
                (p.disabled && E
                  ? m.value && f(e, !1)
                  : a.value !== E && (E ? g() : x()));
            },
            w = () => {
              a.value ? y() : b();
            };
          return (
            De(() => p[r], _),
            l &&
              d.appContext.config.globalProperties.$route !== void 0 &&
              De(
                () => ({ ...d.proxy.$route }),
                () => {
                  l.value && a.value && y();
                }
              ),
            Rt(() => {
              _(p[r]);
            }),
            { hide: y, show: b, toggle: w, hasUpdateHandler: m }
          );
        },
        useModelToggleProps: s,
        useModelToggleEmits: i,
      };
    };
  px("modelValue");
  const mx = (r) => {
    const e = Br();
    return X(() => {
      var t, i;
      return (i =
        (t = e == null ? void 0 : e.proxy) == null ? void 0 : t.$props) == null
        ? void 0
        : i[r];
    });
  };
  var yr = "top",
    zr = "bottom",
    Wr = "right",
    br = "left",
    Op = "auto",
    dl = [yr, zr, Wr, br],
    Oa = "start",
    Ko = "end",
    oR = "clippingParents",
    gx = "viewport",
    lo = "popper",
    lR = "reference",
    $g = dl.reduce(function (r, e) {
      return r.concat([e + "-" + Oa, e + "-" + Ko]);
    }, []),
    fl = [].concat(dl, [Op]).reduce(function (r, e) {
      return r.concat([e, e + "-" + Oa, e + "-" + Ko]);
    }, []),
    hR = "beforeRead",
    cR = "read",
    uR = "afterRead",
    dR = "beforeMain",
    fR = "main",
    pR = "afterMain",
    mR = "beforeWrite",
    gR = "write",
    vR = "afterWrite",
    yR = [hR, cR, uR, dR, fR, pR, mR, gR, vR];
  function Wi(r) {
    return r ? (r.nodeName || "").toLowerCase() : null;
  }
  function bi(r) {
    if (r == null) return window;
    if (r.toString() !== "[object Window]") {
      var e = r.ownerDocument;
      return (e && e.defaultView) || window;
    }
    return r;
  }
  function ka(r) {
    var e = bi(r).Element;
    return r instanceof e || r instanceof Element;
  }
  function Hr(r) {
    var e = bi(r).HTMLElement;
    return r instanceof e || r instanceof HTMLElement;
  }
  function kp(r) {
    if (typeof ShadowRoot > "u") return !1;
    var e = bi(r).ShadowRoot;
    return r instanceof e || r instanceof ShadowRoot;
  }
  function bR(r) {
    var e = r.state;
    Object.keys(e.elements).forEach(function (t) {
      var i = e.styles[t] || {},
        s = e.attributes[t] || {},
        n = e.elements[t];
      !Hr(n) ||
        !Wi(n) ||
        (Object.assign(n.style, i),
        Object.keys(s).forEach(function (a) {
          var o = s[a];
          o === !1
            ? n.removeAttribute(a)
            : n.setAttribute(a, o === !0 ? "" : o);
        }));
    });
  }
  function xR(r) {
    var e = r.state,
      t = {
        popper: {
          position: e.options.strategy,
          left: "0",
          top: "0",
          margin: "0",
        },
        arrow: { position: "absolute" },
        reference: {},
      };
    return (
      Object.assign(e.elements.popper.style, t.popper),
      (e.styles = t),
      e.elements.arrow && Object.assign(e.elements.arrow.style, t.arrow),
      function () {
        Object.keys(e.elements).forEach(function (i) {
          var s = e.elements[i],
            n = e.attributes[i] || {},
            a = Object.keys(e.styles.hasOwnProperty(i) ? e.styles[i] : t[i]),
            o = a.reduce(function (l, h) {
              return (l[h] = ""), l;
            }, {});
          !Hr(s) ||
            !Wi(s) ||
            (Object.assign(s.style, o),
            Object.keys(n).forEach(function (l) {
              s.removeAttribute(l);
            }));
        });
      }
    );
  }
  var vx = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: bR,
    effect: xR,
    requires: ["computeStyles"],
  };
  function $i(r) {
    return r.split("-")[0];
  }
  var wn = Math.max,
    Dh = Math.min,
    Da = Math.round;
  function La(r, e) {
    e === void 0 && (e = !1);
    var t = r.getBoundingClientRect(),
      i = 1,
      s = 1;
    if (Hr(r) && e) {
      var n = r.offsetHeight,
        a = r.offsetWidth;
      a > 0 && (i = Da(t.width) / a || 1), n > 0 && (s = Da(t.height) / n || 1);
    }
    return {
      width: t.width / i,
      height: t.height / s,
      top: t.top / s,
      right: t.right / i,
      bottom: t.bottom / s,
      left: t.left / i,
      x: t.left / i,
      y: t.top / s,
    };
  }
  function Dp(r) {
    var e = La(r),
      t = r.offsetWidth,
      i = r.offsetHeight;
    return (
      Math.abs(e.width - t) <= 1 && (t = e.width),
      Math.abs(e.height - i) <= 1 && (i = e.height),
      { x: r.offsetLeft, y: r.offsetTop, width: t, height: i }
    );
  }
  function yx(r, e) {
    var t = e.getRootNode && e.getRootNode();
    if (r.contains(e)) return !0;
    if (t && kp(t)) {
      var i = e;
      do {
        if (i && r.isSameNode(i)) return !0;
        i = i.parentNode || i.host;
      } while (i);
    }
    return !1;
  }
  function gs(r) {
    return bi(r).getComputedStyle(r);
  }
  function _R(r) {
    return ["table", "td", "th"].indexOf(Wi(r)) >= 0;
  }
  function Qs(r) {
    return ((ka(r) ? r.ownerDocument : r.document) || window.document)
      .documentElement;
  }
  function Fc(r) {
    return Wi(r) === "html"
      ? r
      : r.assignedSlot || r.parentNode || (kp(r) ? r.host : null) || Qs(r);
  }
  function Gg(r) {
    return !Hr(r) || gs(r).position === "fixed" ? null : r.offsetParent;
  }
  function wR(r) {
    var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1,
      t = navigator.userAgent.indexOf("Trident") !== -1;
    if (t && Hr(r)) {
      var i = gs(r);
      if (i.position === "fixed") return null;
    }
    var s = Fc(r);
    for (
      kp(s) && (s = s.host);
      Hr(s) && ["html", "body"].indexOf(Wi(s)) < 0;

    ) {
      var n = gs(s);
      if (
        n.transform !== "none" ||
        n.perspective !== "none" ||
        n.contain === "paint" ||
        ["transform", "perspective"].indexOf(n.willChange) !== -1 ||
        (e && n.willChange === "filter") ||
        (e && n.filter && n.filter !== "none")
      )
        return s;
      s = s.parentNode;
    }
    return null;
  }
  function pl(r) {
    for (var e = bi(r), t = Gg(r); t && _R(t) && gs(t).position === "static"; )
      t = Gg(t);
    return t &&
      (Wi(t) === "html" || (Wi(t) === "body" && gs(t).position === "static"))
      ? e
      : t || wR(r) || e;
  }
  function Lp(r) {
    return ["top", "bottom"].indexOf(r) >= 0 ? "x" : "y";
  }
  function Fo(r, e, t) {
    return wn(r, Dh(e, t));
  }
  function TR(r, e, t) {
    var i = Fo(r, e, t);
    return i > t ? t : i;
  }
  function bx() {
    return { top: 0, right: 0, bottom: 0, left: 0 };
  }
  function xx(r) {
    return Object.assign({}, bx(), r);
  }
  function _x(r, e) {
    return e.reduce(function (t, i) {
      return (t[i] = r), t;
    }, {});
  }
  var ER = function (r, e) {
    return (
      (r =
        typeof r == "function"
          ? r(Object.assign({}, e.rects, { placement: e.placement }))
          : r),
      xx(typeof r != "number" ? r : _x(r, dl))
    );
  };
  function SR(r) {
    var e,
      t = r.state,
      i = r.name,
      s = r.options,
      n = t.elements.arrow,
      a = t.modifiersData.popperOffsets,
      o = $i(t.placement),
      l = Lp(o),
      h = [br, Wr].indexOf(o) >= 0,
      c = h ? "height" : "width";
    if (!(!n || !a)) {
      var u = ER(s.padding, t),
        d = Dp(n),
        f = l === "y" ? yr : br,
        p = l === "y" ? zr : Wr,
        m =
          t.rects.reference[c] +
          t.rects.reference[l] -
          a[l] -
          t.rects.popper[c],
        v = a[l] - t.rects.reference[l],
        g = pl(n),
        x = g ? (l === "y" ? g.clientHeight || 0 : g.clientWidth || 0) : 0,
        b = m / 2 - v / 2,
        y = u[f],
        _ = x - d[c] - u[p],
        w = x / 2 - d[c] / 2 + b,
        E = Fo(y, w, _),
        A = l;
      t.modifiersData[i] = ((e = {}), (e[A] = E), (e.centerOffset = E - w), e);
    }
  }
  function AR(r) {
    var e = r.state,
      t = r.options,
      i = t.element,
      s = i === void 0 ? "[data-popper-arrow]" : i;
    s != null &&
      ((typeof s == "string" &&
        ((s = e.elements.popper.querySelector(s)), !s)) ||
        !yx(e.elements.popper, s) ||
        (e.elements.arrow = s));
  }
  var CR = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: SR,
    effect: AR,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"],
  };
  function Na(r) {
    return r.split("-")[1];
  }
  var IR = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
  function PR(r) {
    var e = r.x,
      t = r.y,
      i = window,
      s = i.devicePixelRatio || 1;
    return { x: Da(e * s) / s || 0, y: Da(t * s) / s || 0 };
  }
  function Hg(r) {
    var e,
      t = r.popper,
      i = r.popperRect,
      s = r.placement,
      n = r.variation,
      a = r.offsets,
      o = r.position,
      l = r.gpuAcceleration,
      h = r.adaptive,
      c = r.roundOffsets,
      u = r.isFixed,
      d = a.x,
      f = d === void 0 ? 0 : d,
      p = a.y,
      m = p === void 0 ? 0 : p,
      v = typeof c == "function" ? c({ x: f, y: m }) : { x: f, y: m };
    (f = v.x), (m = v.y);
    var g = a.hasOwnProperty("x"),
      x = a.hasOwnProperty("y"),
      b = br,
      y = yr,
      _ = window;
    if (h) {
      var w = pl(t),
        E = "clientHeight",
        A = "clientWidth";
      if (
        (w === bi(t) &&
          ((w = Qs(t)),
          gs(w).position !== "static" &&
            o === "absolute" &&
            ((E = "scrollHeight"), (A = "scrollWidth"))),
        (w = w),
        s === yr || ((s === br || s === Wr) && n === Ko))
      ) {
        y = zr;
        var C =
          u && w === _ && _.visualViewport ? _.visualViewport.height : w[E];
        (m -= C - i.height), (m *= l ? 1 : -1);
      }
      if (s === br || ((s === yr || s === zr) && n === Ko)) {
        b = Wr;
        var F =
          u && w === _ && _.visualViewport ? _.visualViewport.width : w[A];
        (f -= F - i.width), (f *= l ? 1 : -1);
      }
    }
    var B = Object.assign({ position: o }, h && IR),
      R = c === !0 ? PR({ x: f, y: m }) : { x: f, y: m };
    if (((f = R.x), (m = R.y), l)) {
      var I;
      return Object.assign(
        {},
        B,
        ((I = {}),
        (I[y] = x ? "0" : ""),
        (I[b] = g ? "0" : ""),
        (I.transform =
          (_.devicePixelRatio || 1) <= 1
            ? "translate(" + f + "px, " + m + "px)"
            : "translate3d(" + f + "px, " + m + "px, 0)"),
        I)
      );
    }
    return Object.assign(
      {},
      B,
      ((e = {}),
      (e[y] = x ? m + "px" : ""),
      (e[b] = g ? f + "px" : ""),
      (e.transform = ""),
      e)
    );
  }
  function RR(r) {
    var e = r.state,
      t = r.options,
      i = t.gpuAcceleration,
      s = i === void 0 ? !0 : i,
      n = t.adaptive,
      a = n === void 0 ? !0 : n,
      o = t.roundOffsets,
      l = o === void 0 ? !0 : o,
      h = {
        placement: $i(e.placement),
        variation: Na(e.placement),
        popper: e.elements.popper,
        popperRect: e.rects.popper,
        gpuAcceleration: s,
        isFixed: e.options.strategy === "fixed",
      };
    e.modifiersData.popperOffsets != null &&
      (e.styles.popper = Object.assign(
        {},
        e.styles.popper,
        Hg(
          Object.assign({}, h, {
            offsets: e.modifiersData.popperOffsets,
            position: e.options.strategy,
            adaptive: a,
            roundOffsets: l,
          })
        )
      )),
      e.modifiersData.arrow != null &&
        (e.styles.arrow = Object.assign(
          {},
          e.styles.arrow,
          Hg(
            Object.assign({}, h, {
              offsets: e.modifiersData.arrow,
              position: "absolute",
              adaptive: !1,
              roundOffsets: l,
            })
          )
        )),
      (e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-placement": e.placement,
      }));
  }
  var wx = {
      name: "computeStyles",
      enabled: !0,
      phase: "beforeWrite",
      fn: RR,
      data: {},
    },
    Rl = { passive: !0 };
  function MR(r) {
    var e = r.state,
      t = r.instance,
      i = r.options,
      s = i.scroll,
      n = s === void 0 ? !0 : s,
      a = i.resize,
      o = a === void 0 ? !0 : a,
      l = bi(e.elements.popper),
      h = [].concat(e.scrollParents.reference, e.scrollParents.popper);
    return (
      n &&
        h.forEach(function (c) {
          c.addEventListener("scroll", t.update, Rl);
        }),
      o && l.addEventListener("resize", t.update, Rl),
      function () {
        n &&
          h.forEach(function (c) {
            c.removeEventListener("scroll", t.update, Rl);
          }),
          o && l.removeEventListener("resize", t.update, Rl);
      }
    );
  }
  var Tx = {
      name: "eventListeners",
      enabled: !0,
      phase: "write",
      fn: function () {},
      effect: MR,
      data: {},
    },
    FR = { left: "right", right: "left", bottom: "top", top: "bottom" };
  function fh(r) {
    return r.replace(/left|right|bottom|top/g, function (e) {
      return FR[e];
    });
  }
  var BR = { start: "end", end: "start" };
  function Xg(r) {
    return r.replace(/start|end/g, function (e) {
      return BR[e];
    });
  }
  function Np(r) {
    var e = bi(r),
      t = e.pageXOffset,
      i = e.pageYOffset;
    return { scrollLeft: t, scrollTop: i };
  }
  function Up(r) {
    return La(Qs(r)).left + Np(r).scrollLeft;
  }
  function OR(r) {
    var e = bi(r),
      t = Qs(r),
      i = e.visualViewport,
      s = t.clientWidth,
      n = t.clientHeight,
      a = 0,
      o = 0;
    return (
      i &&
        ((s = i.width),
        (n = i.height),
        /^((?!chrome|android).)*safari/i.test(navigator.userAgent) ||
          ((a = i.offsetLeft), (o = i.offsetTop))),
      { width: s, height: n, x: a + Up(r), y: o }
    );
  }
  function kR(r) {
    var e,
      t = Qs(r),
      i = Np(r),
      s = (e = r.ownerDocument) == null ? void 0 : e.body,
      n = wn(
        t.scrollWidth,
        t.clientWidth,
        s ? s.scrollWidth : 0,
        s ? s.clientWidth : 0
      ),
      a = wn(
        t.scrollHeight,
        t.clientHeight,
        s ? s.scrollHeight : 0,
        s ? s.clientHeight : 0
      ),
      o = -i.scrollLeft + Up(r),
      l = -i.scrollTop;
    return (
      gs(s || t).direction === "rtl" &&
        (o += wn(t.clientWidth, s ? s.clientWidth : 0) - n),
      { width: n, height: a, x: o, y: l }
    );
  }
  function Vp(r) {
    var e = gs(r),
      t = e.overflow,
      i = e.overflowX,
      s = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(t + s + i);
  }
  function Ex(r) {
    return ["html", "body", "#document"].indexOf(Wi(r)) >= 0
      ? r.ownerDocument.body
      : Hr(r) && Vp(r)
      ? r
      : Ex(Fc(r));
  }
  function Bo(r, e) {
    var t;
    e === void 0 && (e = []);
    var i = Ex(r),
      s = i === ((t = r.ownerDocument) == null ? void 0 : t.body),
      n = bi(i),
      a = s ? [n].concat(n.visualViewport || [], Vp(i) ? i : []) : i,
      o = e.concat(a);
    return s ? o : o.concat(Bo(Fc(a)));
  }
  function Pd(r) {
    return Object.assign({}, r, {
      left: r.x,
      top: r.y,
      right: r.x + r.width,
      bottom: r.y + r.height,
    });
  }
  function DR(r) {
    var e = La(r);
    return (
      (e.top = e.top + r.clientTop),
      (e.left = e.left + r.clientLeft),
      (e.bottom = e.top + r.clientHeight),
      (e.right = e.left + r.clientWidth),
      (e.width = r.clientWidth),
      (e.height = r.clientHeight),
      (e.x = e.left),
      (e.y = e.top),
      e
    );
  }
  function zg(r, e) {
    return e === gx ? Pd(OR(r)) : ka(e) ? DR(e) : Pd(kR(Qs(r)));
  }
  function LR(r) {
    var e = Bo(Fc(r)),
      t = ["absolute", "fixed"].indexOf(gs(r).position) >= 0,
      i = t && Hr(r) ? pl(r) : r;
    return ka(i)
      ? e.filter(function (s) {
          return ka(s) && yx(s, i) && Wi(s) !== "body";
        })
      : [];
  }
  function NR(r, e, t) {
    var i = e === "clippingParents" ? LR(r) : [].concat(e),
      s = [].concat(i, [t]),
      n = s[0],
      a = s.reduce(function (o, l) {
        var h = zg(r, l);
        return (
          (o.top = wn(h.top, o.top)),
          (o.right = Dh(h.right, o.right)),
          (o.bottom = Dh(h.bottom, o.bottom)),
          (o.left = wn(h.left, o.left)),
          o
        );
      }, zg(r, n));
    return (
      (a.width = a.right - a.left),
      (a.height = a.bottom - a.top),
      (a.x = a.left),
      (a.y = a.top),
      a
    );
  }
  function Sx(r) {
    var e = r.reference,
      t = r.element,
      i = r.placement,
      s = i ? $i(i) : null,
      n = i ? Na(i) : null,
      a = e.x + e.width / 2 - t.width / 2,
      o = e.y + e.height / 2 - t.height / 2,
      l;
    switch (s) {
      case yr:
        l = { x: a, y: e.y - t.height };
        break;
      case zr:
        l = { x: a, y: e.y + e.height };
        break;
      case Wr:
        l = { x: e.x + e.width, y: o };
        break;
      case br:
        l = { x: e.x - t.width, y: o };
        break;
      default:
        l = { x: e.x, y: e.y };
    }
    var h = s ? Lp(s) : null;
    if (h != null) {
      var c = h === "y" ? "height" : "width";
      switch (n) {
        case Oa:
          l[h] = l[h] - (e[c] / 2 - t[c] / 2);
          break;
        case Ko:
          l[h] = l[h] + (e[c] / 2 - t[c] / 2);
          break;
      }
    }
    return l;
  }
  function Zo(r, e) {
    e === void 0 && (e = {});
    var t = e,
      i = t.placement,
      s = i === void 0 ? r.placement : i,
      n = t.boundary,
      a = n === void 0 ? oR : n,
      o = t.rootBoundary,
      l = o === void 0 ? gx : o,
      h = t.elementContext,
      c = h === void 0 ? lo : h,
      u = t.altBoundary,
      d = u === void 0 ? !1 : u,
      f = t.padding,
      p = f === void 0 ? 0 : f,
      m = xx(typeof p != "number" ? p : _x(p, dl)),
      v = c === lo ? lR : lo,
      g = r.rects.popper,
      x = r.elements[d ? v : c],
      b = NR(ka(x) ? x : x.contextElement || Qs(r.elements.popper), a, l),
      y = La(r.elements.reference),
      _ = Sx({ reference: y, element: g, strategy: "absolute", placement: s }),
      w = Pd(Object.assign({}, g, _)),
      E = c === lo ? w : y,
      A = {
        top: b.top - E.top + m.top,
        bottom: E.bottom - b.bottom + m.bottom,
        left: b.left - E.left + m.left,
        right: E.right - b.right + m.right,
      },
      C = r.modifiersData.offset;
    if (c === lo && C) {
      var F = C[s];
      Object.keys(A).forEach(function (B) {
        var R = [Wr, zr].indexOf(B) >= 0 ? 1 : -1,
          I = [yr, zr].indexOf(B) >= 0 ? "y" : "x";
        A[B] += F[I] * R;
      });
    }
    return A;
  }
  function UR(r, e) {
    e === void 0 && (e = {});
    var t = e,
      i = t.placement,
      s = t.boundary,
      n = t.rootBoundary,
      a = t.padding,
      o = t.flipVariations,
      l = t.allowedAutoPlacements,
      h = l === void 0 ? fl : l,
      c = Na(i),
      u = c
        ? o
          ? $g
          : $g.filter(function (p) {
              return Na(p) === c;
            })
        : dl,
      d = u.filter(function (p) {
        return h.indexOf(p) >= 0;
      });
    d.length === 0 && (d = u);
    var f = d.reduce(function (p, m) {
      return (
        (p[m] = Zo(r, {
          placement: m,
          boundary: s,
          rootBoundary: n,
          padding: a,
        })[$i(m)]),
        p
      );
    }, {});
    return Object.keys(f).sort(function (p, m) {
      return f[p] - f[m];
    });
  }
  function VR(r) {
    if ($i(r) === Op) return [];
    var e = fh(r);
    return [Xg(r), e, Xg(e)];
  }
  function $R(r) {
    var e = r.state,
      t = r.options,
      i = r.name;
    if (!e.modifiersData[i]._skip) {
      for (
        var s = t.mainAxis,
          n = s === void 0 ? !0 : s,
          a = t.altAxis,
          o = a === void 0 ? !0 : a,
          l = t.fallbackPlacements,
          h = t.padding,
          c = t.boundary,
          u = t.rootBoundary,
          d = t.altBoundary,
          f = t.flipVariations,
          p = f === void 0 ? !0 : f,
          m = t.allowedAutoPlacements,
          v = e.options.placement,
          g = $i(v),
          x = g === v,
          b = l || (x || !p ? [fh(v)] : VR(v)),
          y = [v].concat(b).reduce(function (q, K) {
            return q.concat(
              $i(K) === Op
                ? UR(e, {
                    placement: K,
                    boundary: c,
                    rootBoundary: u,
                    padding: h,
                    flipVariations: p,
                    allowedAutoPlacements: m,
                  })
                : K
            );
          }, []),
          _ = e.rects.reference,
          w = e.rects.popper,
          E = new Map(),
          A = !0,
          C = y[0],
          F = 0;
        F < y.length;
        F++
      ) {
        var B = y[F],
          R = $i(B),
          I = Na(B) === Oa,
          P = [yr, zr].indexOf(R) >= 0,
          M = P ? "width" : "height",
          L = Zo(e, {
            placement: B,
            boundary: c,
            rootBoundary: u,
            altBoundary: d,
            padding: h,
          }),
          U = P ? (I ? Wr : br) : I ? zr : yr;
        _[M] > w[M] && (U = fh(U));
        var V = fh(U),
          z = [];
        if (
          (n && z.push(L[R] <= 0),
          o && z.push(L[U] <= 0, L[V] <= 0),
          z.every(function (q) {
            return q;
          }))
        ) {
          (C = B), (A = !1);
          break;
        }
        E.set(B, z);
      }
      if (A)
        for (
          var N = p ? 3 : 1,
            O = function (q) {
              var K = y.find(function (ue) {
                var ie = E.get(ue);
                if (ie)
                  return ie.slice(0, q).every(function (ee) {
                    return ee;
                  });
              });
              if (K) return (C = K), "break";
            },
            H = N;
          H > 0;
          H--
        ) {
          var G = O(H);
          if (G === "break") break;
        }
      e.placement !== C &&
        ((e.modifiersData[i]._skip = !0), (e.placement = C), (e.reset = !0));
    }
  }
  var GR = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: $R,
    requiresIfExists: ["offset"],
    data: { _skip: !1 },
  };
  function Wg(r, e, t) {
    return (
      t === void 0 && (t = { x: 0, y: 0 }),
      {
        top: r.top - e.height - t.y,
        right: r.right - e.width + t.x,
        bottom: r.bottom - e.height + t.y,
        left: r.left - e.width - t.x,
      }
    );
  }
  function Yg(r) {
    return [yr, Wr, zr, br].some(function (e) {
      return r[e] >= 0;
    });
  }
  function HR(r) {
    var e = r.state,
      t = r.name,
      i = e.rects.reference,
      s = e.rects.popper,
      n = e.modifiersData.preventOverflow,
      a = Zo(e, { elementContext: "reference" }),
      o = Zo(e, { altBoundary: !0 }),
      l = Wg(a, i),
      h = Wg(o, s, n),
      c = Yg(l),
      u = Yg(h);
    (e.modifiersData[t] = {
      referenceClippingOffsets: l,
      popperEscapeOffsets: h,
      isReferenceHidden: c,
      hasPopperEscaped: u,
    }),
      (e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-reference-hidden": c,
        "data-popper-escaped": u,
      }));
  }
  var XR = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: HR,
  };
  function zR(r, e, t) {
    var i = $i(r),
      s = [br, yr].indexOf(i) >= 0 ? -1 : 1,
      n =
        typeof t == "function" ? t(Object.assign({}, e, { placement: r })) : t,
      a = n[0],
      o = n[1];
    return (
      (a = a || 0),
      (o = (o || 0) * s),
      [br, Wr].indexOf(i) >= 0 ? { x: o, y: a } : { x: a, y: o }
    );
  }
  function WR(r) {
    var e = r.state,
      t = r.options,
      i = r.name,
      s = t.offset,
      n = s === void 0 ? [0, 0] : s,
      a = fl.reduce(function (c, u) {
        return (c[u] = zR(u, e.rects, n)), c;
      }, {}),
      o = a[e.placement],
      l = o.x,
      h = o.y;
    e.modifiersData.popperOffsets != null &&
      ((e.modifiersData.popperOffsets.x += l),
      (e.modifiersData.popperOffsets.y += h)),
      (e.modifiersData[i] = a);
  }
  var YR = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: WR,
  };
  function jR(r) {
    var e = r.state,
      t = r.name;
    e.modifiersData[t] = Sx({
      reference: e.rects.reference,
      element: e.rects.popper,
      strategy: "absolute",
      placement: e.placement,
    });
  }
  var Ax = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: jR,
    data: {},
  };
  function qR(r) {
    return r === "x" ? "y" : "x";
  }
  function KR(r) {
    var e = r.state,
      t = r.options,
      i = r.name,
      s = t.mainAxis,
      n = s === void 0 ? !0 : s,
      a = t.altAxis,
      o = a === void 0 ? !1 : a,
      l = t.boundary,
      h = t.rootBoundary,
      c = t.altBoundary,
      u = t.padding,
      d = t.tether,
      f = d === void 0 ? !0 : d,
      p = t.tetherOffset,
      m = p === void 0 ? 0 : p,
      v = Zo(e, { boundary: l, rootBoundary: h, padding: u, altBoundary: c }),
      g = $i(e.placement),
      x = Na(e.placement),
      b = !x,
      y = Lp(g),
      _ = qR(y),
      w = e.modifiersData.popperOffsets,
      E = e.rects.reference,
      A = e.rects.popper,
      C =
        typeof m == "function"
          ? m(Object.assign({}, e.rects, { placement: e.placement }))
          : m,
      F =
        typeof C == "number"
          ? { mainAxis: C, altAxis: C }
          : Object.assign({ mainAxis: 0, altAxis: 0 }, C),
      B = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
      R = { x: 0, y: 0 };
    if (w) {
      if (n) {
        var I,
          P = y === "y" ? yr : br,
          M = y === "y" ? zr : Wr,
          L = y === "y" ? "height" : "width",
          U = w[y],
          V = U + v[P],
          z = U - v[M],
          N = f ? -A[L] / 2 : 0,
          O = x === Oa ? E[L] : A[L],
          H = x === Oa ? -A[L] : -E[L],
          G = e.elements.arrow,
          q = f && G ? Dp(G) : { width: 0, height: 0 },
          K = e.modifiersData["arrow#persistent"]
            ? e.modifiersData["arrow#persistent"].padding
            : bx(),
          ue = K[P],
          ie = K[M],
          ee = Fo(0, E[L], q[L]),
          ve = b
            ? E[L] / 2 - N - ee - ue - F.mainAxis
            : O - ee - ue - F.mainAxis,
          ye = b
            ? -E[L] / 2 + N + ee + ie + F.mainAxis
            : H + ee + ie + F.mainAxis,
          _e = e.elements.arrow && pl(e.elements.arrow),
          ke = _e ? (y === "y" ? _e.clientTop || 0 : _e.clientLeft || 0) : 0,
          k = (I = B == null ? void 0 : B[y]) != null ? I : 0,
          D = U + ve - k - ke,
          W = U + ye - k,
          te = Fo(f ? Dh(V, D) : V, U, f ? wn(z, W) : z);
        (w[y] = te), (R[y] = te - U);
      }
      if (o) {
        var J,
          Q = y === "x" ? yr : br,
          de = y === "x" ? zr : Wr,
          oe = w[_],
          se = _ === "y" ? "height" : "width",
          re = oe + v[Q],
          Pe = oe - v[de],
          fe = [yr, br].indexOf(g) !== -1,
          Y = (J = B == null ? void 0 : B[_]) != null ? J : 0,
          Te = fe ? re : oe - E[se] - A[se] - Y + F.altAxis,
          Ue = fe ? oe + E[se] + A[se] - Y - F.altAxis : Pe,
          it = f && fe ? TR(Te, oe, Ue) : Fo(f ? Te : re, oe, f ? Ue : Pe);
        (w[_] = it), (R[_] = it - oe);
      }
      e.modifiersData[i] = R;
    }
  }
  var ZR = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: KR,
    requiresIfExists: ["offset"],
  };
  function JR(r) {
    return { scrollLeft: r.scrollLeft, scrollTop: r.scrollTop };
  }
  function QR(r) {
    return r === bi(r) || !Hr(r) ? Np(r) : JR(r);
  }
  function eM(r) {
    var e = r.getBoundingClientRect(),
      t = Da(e.width) / r.offsetWidth || 1,
      i = Da(e.height) / r.offsetHeight || 1;
    return t !== 1 || i !== 1;
  }
  function tM(r, e, t) {
    t === void 0 && (t = !1);
    var i = Hr(e),
      s = Hr(e) && eM(e),
      n = Qs(e),
      a = La(r, s),
      o = { scrollLeft: 0, scrollTop: 0 },
      l = { x: 0, y: 0 };
    return (
      (i || (!i && !t)) &&
        ((Wi(e) !== "body" || Vp(n)) && (o = QR(e)),
        Hr(e)
          ? ((l = La(e, !0)), (l.x += e.clientLeft), (l.y += e.clientTop))
          : n && (l.x = Up(n))),
      {
        x: a.left + o.scrollLeft - l.x,
        y: a.top + o.scrollTop - l.y,
        width: a.width,
        height: a.height,
      }
    );
  }
  function rM(r) {
    var e = new Map(),
      t = new Set(),
      i = [];
    r.forEach(function (n) {
      e.set(n.name, n);
    });
    function s(n) {
      t.add(n.name);
      var a = [].concat(n.requires || [], n.requiresIfExists || []);
      a.forEach(function (o) {
        if (!t.has(o)) {
          var l = e.get(o);
          l && s(l);
        }
      }),
        i.push(n);
    }
    return (
      r.forEach(function (n) {
        t.has(n.name) || s(n);
      }),
      i
    );
  }
  function iM(r) {
    var e = rM(r);
    return yR.reduce(function (t, i) {
      return t.concat(
        e.filter(function (s) {
          return s.phase === i;
        })
      );
    }, []);
  }
  function sM(r) {
    var e;
    return function () {
      return (
        e ||
          (e = new Promise(function (t) {
            Promise.resolve().then(function () {
              (e = void 0), t(r());
            });
          })),
        e
      );
    };
  }
  function nM(r) {
    var e = r.reduce(function (t, i) {
      var s = t[i.name];
      return (
        (t[i.name] = s
          ? Object.assign({}, s, i, {
              options: Object.assign({}, s.options, i.options),
              data: Object.assign({}, s.data, i.data),
            })
          : i),
        t
      );
    }, {});
    return Object.keys(e).map(function (t) {
      return e[t];
    });
  }
  var jg = { placement: "bottom", modifiers: [], strategy: "absolute" };
  function qg() {
    for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++)
      e[t] = arguments[t];
    return !e.some(function (i) {
      return !(i && typeof i.getBoundingClientRect == "function");
    });
  }
  function $p(r) {
    r === void 0 && (r = {});
    var e = r,
      t = e.defaultModifiers,
      i = t === void 0 ? [] : t,
      s = e.defaultOptions,
      n = s === void 0 ? jg : s;
    return function (a, o, l) {
      l === void 0 && (l = n);
      var h = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, jg, n),
          modifiersData: {},
          elements: { reference: a, popper: o },
          attributes: {},
          styles: {},
        },
        c = [],
        u = !1,
        d = {
          state: h,
          setOptions: function (m) {
            var v = typeof m == "function" ? m(h.options) : m;
            p(),
              (h.options = Object.assign({}, n, h.options, v)),
              (h.scrollParents = {
                reference: ka(a)
                  ? Bo(a)
                  : a.contextElement
                  ? Bo(a.contextElement)
                  : [],
                popper: Bo(o),
              });
            var g = iM(nM([].concat(i, h.options.modifiers)));
            return (
              (h.orderedModifiers = g.filter(function (x) {
                return x.enabled;
              })),
              f(),
              d.update()
            );
          },
          forceUpdate: function () {
            if (!u) {
              var m = h.elements,
                v = m.reference,
                g = m.popper;
              if (qg(v, g)) {
                (h.rects = {
                  reference: tM(v, pl(g), h.options.strategy === "fixed"),
                  popper: Dp(g),
                }),
                  (h.reset = !1),
                  (h.placement = h.options.placement),
                  h.orderedModifiers.forEach(function (A) {
                    return (h.modifiersData[A.name] = Object.assign(
                      {},
                      A.data
                    ));
                  });
                for (var x = 0; x < h.orderedModifiers.length; x++) {
                  if (h.reset === !0) {
                    (h.reset = !1), (x = -1);
                    continue;
                  }
                  var b = h.orderedModifiers[x],
                    y = b.fn,
                    _ = b.options,
                    w = _ === void 0 ? {} : _,
                    E = b.name;
                  typeof y == "function" &&
                    (h =
                      y({ state: h, options: w, name: E, instance: d }) || h);
                }
              }
            }
          },
          update: sM(function () {
            return new Promise(function (m) {
              d.forceUpdate(), m(h);
            });
          }),
          destroy: function () {
            p(), (u = !0);
          },
        };
      if (!qg(a, o)) return d;
      d.setOptions(l).then(function (m) {
        !u && l.onFirstUpdate && l.onFirstUpdate(m);
      });
      function f() {
        h.orderedModifiers.forEach(function (m) {
          var v = m.name,
            g = m.options,
            x = g === void 0 ? {} : g,
            b = m.effect;
          if (typeof b == "function") {
            var y = b({ state: h, name: v, instance: d, options: x }),
              _ = function () {};
            c.push(y || _);
          }
        });
      }
      function p() {
        c.forEach(function (m) {
          return m();
        }),
          (c = []);
      }
      return d;
    };
  }
  $p();
  var aM = [Tx, Ax, wx, vx];
  $p({ defaultModifiers: aM });
  var oM = [Tx, Ax, wx, vx, YR, GR, ZR, CR, XR],
    lM = $p({ defaultModifiers: oM });
  const hM = (r, e, t = {}) => {
    const i = {
        name: "updateState",
        enabled: !0,
        phase: "write",
        fn: ({ state: l }) => {
          const h = cM(l);
          Object.assign(a.value, h);
        },
        requires: ["computeStyles"],
      },
      s = X(() => {
        const {
          onFirstUpdate: l,
          placement: h,
          strategy: c,
          modifiers: u,
        } = S(t);
        return {
          onFirstUpdate: l,
          placement: h || "bottom",
          strategy: c || "absolute",
          modifiers: [...(u || []), i, { name: "applyStyles", enabled: !1 }],
        };
      }),
      n = _n(),
      a = he({
        styles: {
          popper: { position: S(s).strategy, left: "0", top: "0" },
          arrow: { position: "absolute" },
        },
        attributes: {},
      }),
      o = () => {
        n.value && (n.value.destroy(), (n.value = void 0));
      };
    return (
      De(
        s,
        (l) => {
          const h = S(n);
          h && h.setOptions(l);
        },
        { deep: !0 }
      ),
      De([r, e], ([l, h]) => {
        o(), !(!l || !h) && (n.value = lM(l, h, S(s)));
      }),
      Or(() => {
        o();
      }),
      {
        state: X(() => {
          var l;
          return { ...(((l = S(n)) == null ? void 0 : l.state) || {}) };
        }),
        styles: X(() => S(a).styles),
        attributes: X(() => S(a).attributes),
        update: () => {
          var l;
          return (l = S(n)) == null ? void 0 : l.update();
        },
        forceUpdate: () => {
          var l;
          return (l = S(n)) == null ? void 0 : l.forceUpdate();
        },
        instanceRef: X(() => S(n)),
      }
    );
  };
  function cM(r) {
    const e = Object.keys(r.elements),
      t = qo(e.map((s) => [s, r.styles[s] || {}])),
      i = qo(e.map((s) => [s, r.attributes[s]]));
    return { styles: t, attributes: i };
  }
  function Kg() {
    let r;
    const e = (i, s) => {
        t(), (r = window.setTimeout(i, s));
      },
      t = () => window.clearTimeout(r);
    return mp(() => t()), { registerTimeout: e, cancelTimeout: t };
  }
  const Zg = { prefix: Math.floor(Math.random() * 1e4), current: 0 },
    uM = Symbol("elIdInjection"),
    Cx = () => (Br() ? rt(uM, Zg) : Zg),
    Bc = (r) => {
      const e = Cx(),
        t = Bp();
      return X(() => S(r) || `${t.value}-id-${e.prefix}-${e.current++}`);
    };
  let ea = [];
  const Jg = (r) => {
      const e = r;
      e.key === ii.esc && ea.forEach((t) => t(e));
    },
    dM = (r) => {
      Rt(() => {
        ea.length === 0 && document.addEventListener("keydown", Jg),
          It && ea.push(r);
      }),
        Or(() => {
          (ea = ea.filter((e) => e !== r)),
            ea.length === 0 &&
              It &&
              document.removeEventListener("keydown", Jg);
        });
    };
  let Qg;
  const Ix = () => {
      const r = Bp(),
        e = Cx(),
        t = X(() => `${r.value}-popper-container-${e.prefix}`),
        i = X(() => `#${t.value}`);
      return { id: t, selector: i };
    },
    fM = (r) => {
      const e = document.createElement("div");
      return (e.id = r), document.body.appendChild(e), e;
    },
    pM = () => {
      const { id: r, selector: e } = Ix();
      return (
        tb(() => {
          It &&
            (!Qg || !document.body.querySelector(e.value)) &&
            (Qg = fM(r.value));
        }),
        { id: r, selector: e }
      );
    },
    mM = et({
      showAfter: { type: Number, default: 0 },
      hideAfter: { type: Number, default: 200 },
      autoClose: { type: Number, default: 0 },
    }),
    gM = ({ showAfter: r, hideAfter: e, autoClose: t, open: i, close: s }) => {
      const { registerTimeout: n } = Kg(),
        { registerTimeout: a, cancelTimeout: o } = Kg();
      return {
        onOpen: (c) => {
          n(() => {
            i(c);
            const u = S(t);
            at(u) &&
              u > 0 &&
              a(() => {
                s(c);
              }, u);
          }, S(r));
        },
        onClose: (c) => {
          o(),
            n(() => {
              s(c);
            }, S(e));
        },
      };
    },
    Px = Symbol("elForwardRef"),
    vM = (r) => {
      Fr(Px, {
        setForwardRef: (t) => {
          r.value = t;
        },
      });
    },
    yM = (r) => ({
      mounted(e) {
        r(e);
      },
      updated(e) {
        r(e);
      },
      unmounted() {
        r(null);
      },
    }),
    e0 = { current: 0 },
    t0 = he(0),
    bM = 2e3,
    r0 = Symbol("elZIndexContextKey"),
    xM = Symbol("zIndexContextKey"),
    Rx = (r) => {
      const e = Br() ? rt(r0, e0) : e0,
        t = Br() ? rt(xM, void 0) : void 0,
        i = X(() => {
          const a = S(t);
          return at(a) ? a : bM;
        }),
        s = X(() => i.value + t0.value),
        n = () => (e.current++, (t0.value = e.current), s.value);
      return (
        !It && rt(r0), { initialZIndex: i, currentZIndex: s, nextZIndex: n }
      );
    };
  function _M(r) {
    let e;
    function t() {
      if (r.value == null) return;
      const { selectionStart: s, selectionEnd: n, value: a } = r.value;
      if (s == null || n == null) return;
      const o = a.slice(0, Math.max(0, s)),
        l = a.slice(Math.max(0, n));
      e = {
        selectionStart: s,
        selectionEnd: n,
        value: a,
        beforeTxt: o,
        afterTxt: l,
      };
    }
    function i() {
      if (r.value == null || e == null) return;
      const { value: s } = r.value,
        { beforeTxt: n, afterTxt: a, selectionStart: o } = e;
      if (n == null || a == null || o == null) return;
      let l = s.length;
      if (s.endsWith(a)) l = s.length - a.length;
      else if (s.startsWith(n)) l = n.length;
      else {
        const h = n[o - 1],
          c = s.indexOf(h, o - 1);
        c !== -1 && (l = c + 1);
      }
      r.value.setSelectionRange(l, l);
    }
    return [t, i];
  }
  const Bn = Rc({ type: String, values: cl, required: !1 }),
    wM = Symbol("size"),
    TM = () => {
      const r = rt(wM, {});
      return X(() => S(r.size) || "");
    };
  function EM(
    r,
    { beforeFocus: e, afterFocus: t, beforeBlur: i, afterBlur: s } = {}
  ) {
    const n = Br(),
      { emit: a } = n,
      o = _n(),
      l = he(!1),
      h = (d) => {
        (Fe(e) && e(d)) ||
          l.value ||
          ((l.value = !0), a("focus", d), t == null || t());
      },
      c = (d) => {
        var f;
        (Fe(i) && i(d)) ||
          (d.relatedTarget &&
            (f = o.value) != null &&
            f.contains(d.relatedTarget)) ||
          ((l.value = !1), a("blur", d), s == null || s());
      },
      u = () => {
        var d, f;
        ((d = o.value) != null &&
          d.contains(document.activeElement) &&
          o.value !== document.activeElement) ||
          (f = r.value) == null ||
          f.focus();
      };
    return (
      De(o, (d) => {
        d && d.setAttribute("tabindex", "-1");
      }),
      Vt(o, "focus", h, !0),
      Vt(o, "blur", c, !0),
      Vt(o, "click", u, !0),
      { isFocused: l, wrapperRef: o, handleFocus: h, handleBlur: c }
    );
  }
  function SM({ afterComposition: r, emit: e }) {
    const t = he(!1),
      i = (o) => {
        e == null || e("compositionstart", o), (t.value = !0);
      },
      s = (o) => {
        var l;
        e == null || e("compositionupdate", o);
        const h = (l = o.target) == null ? void 0 : l.value,
          c = h[h.length - 1] || "";
        t.value = !qP(c);
      },
      n = (o) => {
        e == null || e("compositionend", o),
          t.value && ((t.value = !1), _t(() => r(o)));
      };
    return {
      isComposing: t,
      handleComposition: (o) => {
        o.type === "compositionend" ? n(o) : s(o);
      },
      handleCompositionStart: i,
      handleCompositionUpdate: s,
      handleCompositionEnd: n,
    };
  }
  const AM = et({
      ariaLabel: String,
      ariaOrientation: {
        type: String,
        values: ["horizontal", "vertical", "undefined"],
      },
      ariaControls: String,
    }),
    en = (r) => tP(AM, r),
    CM = Symbol(),
    i0 = he();
  function IM(r, e = void 0) {
    const t = Br() ? rt(CM, i0) : i0;
    return X(() => {
      var i, s;
      return (s = (i = t.value) == null ? void 0 : i[r]) != null ? s : e;
    });
  }
  var ct = (r, e) => {
    const t = r.__vccOpts || r;
    for (const [i, s] of e) t[i] = s;
    return t;
  };
  const PM = et({
      size: { type: Ne([Number, String]) },
      color: { type: String },
    }),
    RM = ge({ name: "ElIcon", inheritAttrs: !1 }),
    MM = ge({
      ...RM,
      props: PM,
      setup(r) {
        const e = r,
          t = ut("icon"),
          i = X(() => {
            const { size: s, color: n } = e;
            return !s && !n
              ? {}
              : { fontSize: la(s) ? void 0 : Fn(s), "--color": n };
          });
        return (s, n) => (
          j(),
          xe(
            "i",
            Gr({ class: S(t).b(), style: S(i) }, s.$attrs),
            [Xe(s.$slots, "default")],
            16
          )
        );
      },
    });
  var FM = ct(MM, [["__file", "icon.vue"]]);
  const xt = Qt(FM),
    Ka = Symbol("formContextKey"),
    On = Symbol("formItemContextKey"),
    ws = (r, e = {}) => {
      const t = he(void 0),
        i = e.prop ? t : mx("size"),
        s = e.global ? t : TM(),
        n = e.form ? { size: void 0 } : rt(Ka, void 0),
        a = e.formItem ? { size: void 0 } : rt(On, void 0);
      return X(
        () =>
          i.value ||
          S(r) ||
          (a == null ? void 0 : a.size) ||
          (n == null ? void 0 : n.size) ||
          s.value ||
          ""
      );
    },
    Za = (r) => {
      const e = mx("disabled"),
        t = rt(Ka, void 0);
      return X(
        () => e.value || S(r) || (t == null ? void 0 : t.disabled) || !1
      );
    },
    Ja = () => {
      const r = rt(Ka, void 0),
        e = rt(On, void 0);
      return { form: r, formItem: e };
    },
    Oc = (
      r,
      { formItemContext: e, disableIdGeneration: t, disableIdManagement: i }
    ) => {
      t || (t = he(!1)), i || (i = he(!1));
      const s = he();
      let n;
      const a = X(() => {
        var o;
        return !!(
          !(r.label || r.ariaLabel) &&
          e &&
          e.inputIds &&
          ((o = e.inputIds) == null ? void 0 : o.length) <= 1
        );
      });
      return (
        Rt(() => {
          n = De(
            [ni(r, "id"), t],
            ([o, l]) => {
              const h = o ?? (l ? void 0 : Bc().value);
              h !== s.value &&
                (e != null &&
                  e.removeInputId &&
                  (s.value && e.removeInputId(s.value),
                  !(i != null && i.value) && !l && h && e.addInputId(h)),
                (s.value = h));
            },
            { immediate: !0 }
          );
        }),
        op(() => {
          n && n(),
            e != null && e.removeInputId && s.value && e.removeInputId(s.value);
        }),
        { isLabeledByFormItem: a, inputId: s }
      );
    },
    BM = et({ size: { type: String, values: cl }, disabled: Boolean }),
    OM = et({
      ...BM,
      model: Object,
      rules: { type: Ne(Object) },
      labelPosition: {
        type: String,
        values: ["left", "right", "top"],
        default: "right",
      },
      requireAsteriskPosition: {
        type: String,
        values: ["left", "right"],
        default: "left",
      },
      labelWidth: { type: [String, Number], default: "" },
      labelSuffix: { type: String, default: "" },
      inline: Boolean,
      inlineMessage: Boolean,
      statusIcon: Boolean,
      showMessage: { type: Boolean, default: !0 },
      validateOnRuleChange: { type: Boolean, default: !0 },
      hideRequiredAsterisk: Boolean,
      scrollToError: Boolean,
      scrollIntoViewOptions: { type: [Object, Boolean] },
    }),
    kM = { validate: (r, e, t) => (Oe(r) || Ge(r)) && Ui(e) && Ge(t) };
  function DM() {
    const r = he([]),
      e = X(() => {
        if (!r.value.length) return "0";
        const n = Math.max(...r.value);
        return n ? `${n}px` : "";
      });
    function t(n) {
      const a = r.value.indexOf(n);
      return a === -1 && e.value, a;
    }
    function i(n, a) {
      if (n && a) {
        const o = t(a);
        r.value.splice(o, 1, n);
      } else n && r.value.push(n);
    }
    function s(n) {
      const a = t(n);
      a > -1 && r.value.splice(a, 1);
    }
    return {
      autoLabelWidth: e,
      registerLabelWidth: i,
      deregisterLabelWidth: s,
    };
  }
  const Ml = (r, e) => {
      const t = Ed(e);
      return t.length > 0 ? r.filter((i) => i.prop && t.includes(i.prop)) : r;
    },
    LM = "ElForm",
    NM = ge({ name: LM }),
    UM = ge({
      ...NM,
      props: OM,
      emits: kM,
      setup(r, { expose: e, emit: t }) {
        const i = r,
          s = [],
          n = ws(),
          a = ut("form"),
          o = X(() => {
            const { labelPosition: b, inline: y } = i;
            return [
              a.b(),
              a.m(n.value || "default"),
              { [a.m(`label-${b}`)]: b, [a.m("inline")]: y },
            ];
          }),
          l = (b) => s.find((y) => y.prop === b),
          h = (b) => {
            s.push(b);
          },
          c = (b) => {
            b.prop && s.splice(s.indexOf(b), 1);
          },
          u = (b = []) => {
            i.model && Ml(s, b).forEach((y) => y.resetField());
          },
          d = (b = []) => {
            Ml(s, b).forEach((y) => y.clearValidate());
          },
          f = X(() => !!i.model),
          p = (b) => {
            if (s.length === 0) return [];
            const y = Ml(s, b);
            return y.length ? y : [];
          },
          m = async (b) => g(void 0, b),
          v = async (b = []) => {
            if (!f.value) return !1;
            const y = p(b);
            if (y.length === 0) return !0;
            let _ = {};
            for (const w of y)
              try {
                await w.validate("");
              } catch (E) {
                _ = { ..._, ...E };
              }
            return Object.keys(_).length === 0 ? !0 : Promise.reject(_);
          },
          g = async (b = [], y) => {
            const _ = !Fe(y);
            try {
              const w = await v(b);
              return w === !0 && (await (y == null ? void 0 : y(w))), w;
            } catch (w) {
              if (w instanceof Error) throw w;
              const E = w;
              return (
                i.scrollToError && x(Object.keys(E)[0]),
                await (y == null ? void 0 : y(!1, E)),
                _ && Promise.reject(E)
              );
            }
          },
          x = (b) => {
            var y;
            const _ = Ml(s, b)[0];
            _ &&
              ((y = _.$el) == null ||
                y.scrollIntoView(i.scrollIntoViewOptions));
          };
        return (
          De(
            () => i.rules,
            () => {
              i.validateOnRuleChange && m().catch((b) => void 0);
            },
            { deep: !0 }
          ),
          Fr(
            Ka,
            vi({
              ...Ra(i),
              emit: t,
              resetFields: u,
              clearValidate: d,
              validateField: g,
              getField: l,
              addField: h,
              removeField: c,
              ...DM(),
            })
          ),
          e({
            validate: m,
            validateField: g,
            resetFields: u,
            clearValidate: d,
            scrollToField: x,
            fields: s,
          }),
          (b, y) => (
            j(), xe("form", { class: ce(S(o)) }, [Xe(b.$slots, "default")], 2)
          )
        );
      },
    });
  var VM = ct(UM, [["__file", "form.vue"]]);
  function yn() {
    return (
      (yn = Object.assign
        ? Object.assign.bind()
        : function (r) {
            for (var e = 1; e < arguments.length; e++) {
              var t = arguments[e];
              for (var i in t)
                Object.prototype.hasOwnProperty.call(t, i) && (r[i] = t[i]);
            }
            return r;
          }),
      yn.apply(this, arguments)
    );
  }
  function $M(r, e) {
    (r.prototype = Object.create(e.prototype)),
      (r.prototype.constructor = r),
      Jo(r, e);
  }
  function Rd(r) {
    return (
      (Rd = Object.setPrototypeOf
        ? Object.getPrototypeOf.bind()
        : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t);
          }),
      Rd(r)
    );
  }
  function Jo(r, e) {
    return (
      (Jo = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (i, s) {
            return (i.__proto__ = s), i;
          }),
      Jo(r, e)
    );
  }
  function GM() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return (
        Boolean.prototype.valueOf.call(
          Reflect.construct(Boolean, [], function () {})
        ),
        !0
      );
    } catch {
      return !1;
    }
  }
  function ph(r, e, t) {
    return (
      GM()
        ? (ph = Reflect.construct.bind())
        : (ph = function (s, n, a) {
            var o = [null];
            o.push.apply(o, n);
            var l = Function.bind.apply(s, o),
              h = new l();
            return a && Jo(h, a.prototype), h;
          }),
      ph.apply(null, arguments)
    );
  }
  function HM(r) {
    return Function.toString.call(r).indexOf("[native code]") !== -1;
  }
  function Md(r) {
    var e = typeof Map == "function" ? new Map() : void 0;
    return (
      (Md = function (i) {
        if (i === null || !HM(i)) return i;
        if (typeof i != "function")
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        if (typeof e < "u") {
          if (e.has(i)) return e.get(i);
          e.set(i, s);
        }
        function s() {
          return ph(i, arguments, Rd(this).constructor);
        }
        return (
          (s.prototype = Object.create(i.prototype, {
            constructor: {
              value: s,
              enumerable: !1,
              writable: !0,
              configurable: !0,
            },
          })),
          Jo(s, i)
        );
      }),
      Md(r)
    );
  }
  var XM = /%[sdj%]/g,
    zM = function () {};
  function Fd(r) {
    if (!r || !r.length) return null;
    var e = {};
    return (
      r.forEach(function (t) {
        var i = t.field;
        (e[i] = e[i] || []), e[i].push(t);
      }),
      e
    );
  }
  function Pr(r) {
    for (
      var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), i = 1;
      i < e;
      i++
    )
      t[i - 1] = arguments[i];
    var s = 0,
      n = t.length;
    if (typeof r == "function") return r.apply(null, t);
    if (typeof r == "string") {
      var a = r.replace(XM, function (o) {
        if (o === "%%") return "%";
        if (s >= n) return o;
        switch (o) {
          case "%s":
            return String(t[s++]);
          case "%d":
            return Number(t[s++]);
          case "%j":
            try {
              return JSON.stringify(t[s++]);
            } catch {
              return "[Circular]";
            }
            break;
          default:
            return o;
        }
      });
      return a;
    }
    return r;
  }
  function WM(r) {
    return (
      r === "string" ||
      r === "url" ||
      r === "hex" ||
      r === "email" ||
      r === "date" ||
      r === "pattern"
    );
  }
  function Gt(r, e) {
    return !!(
      r == null ||
      (e === "array" && Array.isArray(r) && !r.length) ||
      (WM(e) && typeof r == "string" && !r)
    );
  }
  function YM(r, e, t) {
    var i = [],
      s = 0,
      n = r.length;
    function a(o) {
      i.push.apply(i, o || []), s++, s === n && t(i);
    }
    r.forEach(function (o) {
      e(o, a);
    });
  }
  function s0(r, e, t) {
    var i = 0,
      s = r.length;
    function n(a) {
      if (a && a.length) {
        t(a);
        return;
      }
      var o = i;
      (i = i + 1), o < s ? e(r[o], n) : t([]);
    }
    n([]);
  }
  function jM(r) {
    var e = [];
    return (
      Object.keys(r).forEach(function (t) {
        e.push.apply(e, r[t] || []);
      }),
      e
    );
  }
  var n0 = (function (r) {
    $M(e, r);
    function e(t, i) {
      var s;
      return (
        (s = r.call(this, "Async Validation Error") || this),
        (s.errors = t),
        (s.fields = i),
        s
      );
    }
    return e;
  })(Md(Error));
  function qM(r, e, t, i, s) {
    if (e.first) {
      var n = new Promise(function (d, f) {
        var p = function (g) {
            return i(g), g.length ? f(new n0(g, Fd(g))) : d(s);
          },
          m = jM(r);
        s0(m, t, p);
      });
      return (
        n.catch(function (d) {
          return d;
        }),
        n
      );
    }
    var a = e.firstFields === !0 ? Object.keys(r) : e.firstFields || [],
      o = Object.keys(r),
      l = o.length,
      h = 0,
      c = [],
      u = new Promise(function (d, f) {
        var p = function (v) {
          if ((c.push.apply(c, v), h++, h === l))
            return i(c), c.length ? f(new n0(c, Fd(c))) : d(s);
        };
        o.length || (i(c), d(s)),
          o.forEach(function (m) {
            var v = r[m];
            a.indexOf(m) !== -1 ? s0(v, t, p) : YM(v, t, p);
          });
      });
    return (
      u.catch(function (d) {
        return d;
      }),
      u
    );
  }
  function KM(r) {
    return !!(r && r.message !== void 0);
  }
  function ZM(r, e) {
    for (var t = r, i = 0; i < e.length; i++) {
      if (t == null) return t;
      t = t[e[i]];
    }
    return t;
  }
  function a0(r, e) {
    return function (t) {
      var i;
      return (
        r.fullFields
          ? (i = ZM(e, r.fullFields))
          : (i = e[t.field || r.fullField]),
        KM(t)
          ? ((t.field = t.field || r.fullField), (t.fieldValue = i), t)
          : {
              message: typeof t == "function" ? t() : t,
              fieldValue: i,
              field: t.field || r.fullField,
            }
      );
    };
  }
  function o0(r, e) {
    if (e) {
      for (var t in e)
        if (e.hasOwnProperty(t)) {
          var i = e[t];
          typeof i == "object" && typeof r[t] == "object"
            ? (r[t] = yn({}, r[t], i))
            : (r[t] = i);
        }
    }
    return r;
  }
  var Mx = function (e, t, i, s, n, a) {
      e.required &&
        (!i.hasOwnProperty(e.field) || Gt(t, a || e.type)) &&
        s.push(Pr(n.messages.required, e.fullField));
    },
    JM = function (e, t, i, s, n) {
      (/^\s+$/.test(t) || t === "") &&
        s.push(Pr(n.messages.whitespace, e.fullField));
    },
    Fl,
    QM = function () {
      if (Fl) return Fl;
      var r = "[a-fA-F\\d:]",
        e = function (y) {
          return y && y.includeBoundaries
            ? "(?:(?<=\\s|^)(?=" + r + ")|(?<=" + r + ")(?=\\s|$))"
            : "";
        },
        t =
          "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",
        i = "[a-fA-F\\d]{1,4}",
        s = (
          `
(?:
(?:` +
          i +
          ":){7}(?:" +
          i +
          `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` +
          i +
          ":){6}(?:" +
          t +
          "|:" +
          i +
          `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` +
          i +
          ":){5}(?::" +
          t +
          "|(?::" +
          i +
          `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` +
          i +
          ":){4}(?:(?::" +
          i +
          "){0,1}:" +
          t +
          "|(?::" +
          i +
          `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` +
          i +
          ":){3}(?:(?::" +
          i +
          "){0,2}:" +
          t +
          "|(?::" +
          i +
          `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` +
          i +
          ":){2}(?:(?::" +
          i +
          "){0,3}:" +
          t +
          "|(?::" +
          i +
          `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` +
          i +
          ":){1}(?:(?::" +
          i +
          "){0,4}:" +
          t +
          "|(?::" +
          i +
          `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` +
          i +
          "){0,5}:" +
          t +
          "|(?::" +
          i +
          `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`
        )
          .replace(/\s*\/\/.*$/gm, "")
          .replace(/\n/g, "")
          .trim(),
        n = new RegExp("(?:^" + t + "$)|(?:^" + s + "$)"),
        a = new RegExp("^" + t + "$"),
        o = new RegExp("^" + s + "$"),
        l = function (y) {
          return y && y.exact
            ? n
            : new RegExp(
                "(?:" + e(y) + t + e(y) + ")|(?:" + e(y) + s + e(y) + ")",
                "g"
              );
        };
      (l.v4 = function (b) {
        return b && b.exact ? a : new RegExp("" + e(b) + t + e(b), "g");
      }),
        (l.v6 = function (b) {
          return b && b.exact ? o : new RegExp("" + e(b) + s + e(b), "g");
        });
      var h = "(?:(?:[a-z]+:)?//)",
        c = "(?:\\S+(?::\\S*)?@)?",
        u = l.v4().source,
        d = l.v6().source,
        f = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)",
        p = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*",
        m = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))",
        v = "(?::\\d{2,5})?",
        g = '(?:[/?#][^\\s"]*)?',
        x =
          "(?:" +
          h +
          "|www\\.)" +
          c +
          "(?:localhost|" +
          u +
          "|" +
          d +
          "|" +
          f +
          p +
          m +
          ")" +
          v +
          g;
      return (Fl = new RegExp("(?:^" + x + "$)", "i")), Fl;
    },
    l0 = {
      email:
        /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
      hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i,
    },
    vo = {
      integer: function (e) {
        return vo.number(e) && parseInt(e, 10) === e;
      },
      float: function (e) {
        return vo.number(e) && !vo.integer(e);
      },
      array: function (e) {
        return Array.isArray(e);
      },
      regexp: function (e) {
        if (e instanceof RegExp) return !0;
        try {
          return !!new RegExp(e);
        } catch {
          return !1;
        }
      },
      date: function (e) {
        return (
          typeof e.getTime == "function" &&
          typeof e.getMonth == "function" &&
          typeof e.getYear == "function" &&
          !isNaN(e.getTime())
        );
      },
      number: function (e) {
        return isNaN(e) ? !1 : typeof e == "number";
      },
      object: function (e) {
        return typeof e == "object" && !vo.array(e);
      },
      method: function (e) {
        return typeof e == "function";
      },
      email: function (e) {
        return typeof e == "string" && e.length <= 320 && !!e.match(l0.email);
      },
      url: function (e) {
        return typeof e == "string" && e.length <= 2048 && !!e.match(QM());
      },
      hex: function (e) {
        return typeof e == "string" && !!e.match(l0.hex);
      },
    },
    eF = function (e, t, i, s, n) {
      if (e.required && t === void 0) {
        Mx(e, t, i, s, n);
        return;
      }
      var a = [
          "integer",
          "float",
          "array",
          "regexp",
          "object",
          "method",
          "email",
          "number",
          "date",
          "url",
          "hex",
        ],
        o = e.type;
      a.indexOf(o) > -1
        ? vo[o](t) || s.push(Pr(n.messages.types[o], e.fullField, e.type))
        : o &&
          typeof t !== e.type &&
          s.push(Pr(n.messages.types[o], e.fullField, e.type));
    },
    tF = function (e, t, i, s, n) {
      var a = typeof e.len == "number",
        o = typeof e.min == "number",
        l = typeof e.max == "number",
        h = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
        c = t,
        u = null,
        d = typeof t == "number",
        f = typeof t == "string",
        p = Array.isArray(t);
      if ((d ? (u = "number") : f ? (u = "string") : p && (u = "array"), !u))
        return !1;
      p && (c = t.length),
        f && (c = t.replace(h, "_").length),
        a
          ? c !== e.len && s.push(Pr(n.messages[u].len, e.fullField, e.len))
          : o && !l && c < e.min
          ? s.push(Pr(n.messages[u].min, e.fullField, e.min))
          : l && !o && c > e.max
          ? s.push(Pr(n.messages[u].max, e.fullField, e.max))
          : o &&
            l &&
            (c < e.min || c > e.max) &&
            s.push(Pr(n.messages[u].range, e.fullField, e.min, e.max));
    },
    zn = "enum",
    rF = function (e, t, i, s, n) {
      (e[zn] = Array.isArray(e[zn]) ? e[zn] : []),
        e[zn].indexOf(t) === -1 &&
          s.push(Pr(n.messages[zn], e.fullField, e[zn].join(", ")));
    },
    iF = function (e, t, i, s, n) {
      if (e.pattern) {
        if (e.pattern instanceof RegExp)
          (e.pattern.lastIndex = 0),
            e.pattern.test(t) ||
              s.push(
                Pr(n.messages.pattern.mismatch, e.fullField, t, e.pattern)
              );
        else if (typeof e.pattern == "string") {
          var a = new RegExp(e.pattern);
          a.test(t) ||
            s.push(Pr(n.messages.pattern.mismatch, e.fullField, t, e.pattern));
        }
      }
    },
    qe = {
      required: Mx,
      whitespace: JM,
      type: eF,
      range: tF,
      enum: rF,
      pattern: iF,
    },
    sF = function (e, t, i, s, n) {
      var a = [],
        o = e.required || (!e.required && s.hasOwnProperty(e.field));
      if (o) {
        if (Gt(t, "string") && !e.required) return i();
        qe.required(e, t, s, a, n, "string"),
          Gt(t, "string") ||
            (qe.type(e, t, s, a, n),
            qe.range(e, t, s, a, n),
            qe.pattern(e, t, s, a, n),
            e.whitespace === !0 && qe.whitespace(e, t, s, a, n));
      }
      i(a);
    },
    nF = function (e, t, i, s, n) {
      var a = [],
        o = e.required || (!e.required && s.hasOwnProperty(e.field));
      if (o) {
        if (Gt(t) && !e.required) return i();
        qe.required(e, t, s, a, n), t !== void 0 && qe.type(e, t, s, a, n);
      }
      i(a);
    },
    aF = function (e, t, i, s, n) {
      var a = [],
        o = e.required || (!e.required && s.hasOwnProperty(e.field));
      if (o) {
        if ((t === "" && (t = void 0), Gt(t) && !e.required)) return i();
        qe.required(e, t, s, a, n),
          t !== void 0 && (qe.type(e, t, s, a, n), qe.range(e, t, s, a, n));
      }
      i(a);
    },
    oF = function (e, t, i, s, n) {
      var a = [],
        o = e.required || (!e.required && s.hasOwnProperty(e.field));
      if (o) {
        if (Gt(t) && !e.required) return i();
        qe.required(e, t, s, a, n), t !== void 0 && qe.type(e, t, s, a, n);
      }
      i(a);
    },
    lF = function (e, t, i, s, n) {
      var a = [],
        o = e.required || (!e.required && s.hasOwnProperty(e.field));
      if (o) {
        if (Gt(t) && !e.required) return i();
        qe.required(e, t, s, a, n), Gt(t) || qe.type(e, t, s, a, n);
      }
      i(a);
    },
    hF = function (e, t, i, s, n) {
      var a = [],
        o = e.required || (!e.required && s.hasOwnProperty(e.field));
      if (o) {
        if (Gt(t) && !e.required) return i();
        qe.required(e, t, s, a, n),
          t !== void 0 && (qe.type(e, t, s, a, n), qe.range(e, t, s, a, n));
      }
      i(a);
    },
    cF = function (e, t, i, s, n) {
      var a = [],
        o = e.required || (!e.required && s.hasOwnProperty(e.field));
      if (o) {
        if (Gt(t) && !e.required) return i();
        qe.required(e, t, s, a, n),
          t !== void 0 && (qe.type(e, t, s, a, n), qe.range(e, t, s, a, n));
      }
      i(a);
    },
    uF = function (e, t, i, s, n) {
      var a = [],
        o = e.required || (!e.required && s.hasOwnProperty(e.field));
      if (o) {
        if (t == null && !e.required) return i();
        qe.required(e, t, s, a, n, "array"),
          t != null && (qe.type(e, t, s, a, n), qe.range(e, t, s, a, n));
      }
      i(a);
    },
    dF = function (e, t, i, s, n) {
      var a = [],
        o = e.required || (!e.required && s.hasOwnProperty(e.field));
      if (o) {
        if (Gt(t) && !e.required) return i();
        qe.required(e, t, s, a, n), t !== void 0 && qe.type(e, t, s, a, n);
      }
      i(a);
    },
    fF = "enum",
    pF = function (e, t, i, s, n) {
      var a = [],
        o = e.required || (!e.required && s.hasOwnProperty(e.field));
      if (o) {
        if (Gt(t) && !e.required) return i();
        qe.required(e, t, s, a, n), t !== void 0 && qe[fF](e, t, s, a, n);
      }
      i(a);
    },
    mF = function (e, t, i, s, n) {
      var a = [],
        o = e.required || (!e.required && s.hasOwnProperty(e.field));
      if (o) {
        if (Gt(t, "string") && !e.required) return i();
        qe.required(e, t, s, a, n),
          Gt(t, "string") || qe.pattern(e, t, s, a, n);
      }
      i(a);
    },
    gF = function (e, t, i, s, n) {
      var a = [],
        o = e.required || (!e.required && s.hasOwnProperty(e.field));
      if (o) {
        if (Gt(t, "date") && !e.required) return i();
        if ((qe.required(e, t, s, a, n), !Gt(t, "date"))) {
          var l;
          t instanceof Date ? (l = t) : (l = new Date(t)),
            qe.type(e, l, s, a, n),
            l && qe.range(e, l.getTime(), s, a, n);
        }
      }
      i(a);
    },
    vF = function (e, t, i, s, n) {
      var a = [],
        o = Array.isArray(t) ? "array" : typeof t;
      qe.required(e, t, s, a, n, o), i(a);
    },
    pu = function (e, t, i, s, n) {
      var a = e.type,
        o = [],
        l = e.required || (!e.required && s.hasOwnProperty(e.field));
      if (l) {
        if (Gt(t, a) && !e.required) return i();
        qe.required(e, t, s, o, n, a), Gt(t, a) || qe.type(e, t, s, o, n);
      }
      i(o);
    },
    yF = function (e, t, i, s, n) {
      var a = [],
        o = e.required || (!e.required && s.hasOwnProperty(e.field));
      if (o) {
        if (Gt(t) && !e.required) return i();
        qe.required(e, t, s, a, n);
      }
      i(a);
    },
    Oo = {
      string: sF,
      method: nF,
      number: aF,
      boolean: oF,
      regexp: lF,
      integer: hF,
      float: cF,
      array: uF,
      object: dF,
      enum: pF,
      pattern: mF,
      date: gF,
      url: pu,
      hex: pu,
      email: pu,
      required: vF,
      any: yF,
    };
  function Bd() {
    return {
      default: "Validation error on field %s",
      required: "%s is required",
      enum: "%s must be one of %s",
      whitespace: "%s cannot be empty",
      date: {
        format: "%s date %s is invalid for format %s",
        parse: "%s date could not be parsed, %s is invalid ",
        invalid: "%s date %s is invalid",
      },
      types: {
        string: "%s is not a %s",
        method: "%s is not a %s (function)",
        array: "%s is not an %s",
        object: "%s is not an %s",
        number: "%s is not a %s",
        date: "%s is not a %s",
        boolean: "%s is not a %s",
        integer: "%s is not an %s",
        float: "%s is not a %s",
        regexp: "%s is not a valid %s",
        email: "%s is not a valid %s",
        url: "%s is not a valid %s",
        hex: "%s is not a valid %s",
      },
      string: {
        len: "%s must be exactly %s characters",
        min: "%s must be at least %s characters",
        max: "%s cannot be longer than %s characters",
        range: "%s must be between %s and %s characters",
      },
      number: {
        len: "%s must equal %s",
        min: "%s cannot be less than %s",
        max: "%s cannot be greater than %s",
        range: "%s must be between %s and %s",
      },
      array: {
        len: "%s must be exactly %s in length",
        min: "%s cannot be less than %s in length",
        max: "%s cannot be greater than %s in length",
        range: "%s must be between %s and %s in length",
      },
      pattern: { mismatch: "%s value %s does not match pattern %s" },
      clone: function () {
        var e = JSON.parse(JSON.stringify(this));
        return (e.clone = this.clone), e;
      },
    };
  }
  var Od = Bd(),
    ml = (function () {
      function r(t) {
        (this.rules = null), (this._messages = Od), this.define(t);
      }
      var e = r.prototype;
      return (
        (e.define = function (i) {
          var s = this;
          if (!i) throw new Error("Cannot configure a schema with no rules");
          if (typeof i != "object" || Array.isArray(i))
            throw new Error("Rules must be an object");
          (this.rules = {}),
            Object.keys(i).forEach(function (n) {
              var a = i[n];
              s.rules[n] = Array.isArray(a) ? a : [a];
            });
        }),
        (e.messages = function (i) {
          return i && (this._messages = o0(Bd(), i)), this._messages;
        }),
        (e.validate = function (i, s, n) {
          var a = this;
          s === void 0 && (s = {}), n === void 0 && (n = function () {});
          var o = i,
            l = s,
            h = n;
          if (
            (typeof l == "function" && ((h = l), (l = {})),
            !this.rules || Object.keys(this.rules).length === 0)
          )
            return h && h(null, o), Promise.resolve(o);
          function c(m) {
            var v = [],
              g = {};
            function x(y) {
              if (Array.isArray(y)) {
                var _;
                v = (_ = v).concat.apply(_, y);
              } else v.push(y);
            }
            for (var b = 0; b < m.length; b++) x(m[b]);
            v.length ? ((g = Fd(v)), h(v, g)) : h(null, o);
          }
          if (l.messages) {
            var u = this.messages();
            u === Od && (u = Bd()), o0(u, l.messages), (l.messages = u);
          } else l.messages = this.messages();
          var d = {},
            f = l.keys || Object.keys(this.rules);
          f.forEach(function (m) {
            var v = a.rules[m],
              g = o[m];
            v.forEach(function (x) {
              var b = x;
              typeof b.transform == "function" &&
                (o === i && (o = yn({}, o)), (g = o[m] = b.transform(g))),
                typeof b == "function"
                  ? (b = { validator: b })
                  : (b = yn({}, b)),
                (b.validator = a.getValidationMethod(b)),
                b.validator &&
                  ((b.field = m),
                  (b.fullField = b.fullField || m),
                  (b.type = a.getType(b)),
                  (d[m] = d[m] || []),
                  d[m].push({ rule: b, value: g, source: o, field: m }));
            });
          });
          var p = {};
          return qM(
            d,
            l,
            function (m, v) {
              var g = m.rule,
                x =
                  (g.type === "object" || g.type === "array") &&
                  (typeof g.fields == "object" ||
                    typeof g.defaultField == "object");
              (x = x && (g.required || (!g.required && m.value))),
                (g.field = m.field);
              function b(w, E) {
                return yn({}, E, {
                  fullField: g.fullField + "." + w,
                  fullFields: g.fullFields ? [].concat(g.fullFields, [w]) : [w],
                });
              }
              function y(w) {
                w === void 0 && (w = []);
                var E = Array.isArray(w) ? w : [w];
                !l.suppressWarning &&
                  E.length &&
                  r.warning("async-validator:", E),
                  E.length &&
                    g.message !== void 0 &&
                    (E = [].concat(g.message));
                var A = E.map(a0(g, o));
                if (l.first && A.length) return (p[g.field] = 1), v(A);
                if (!x) v(A);
                else {
                  if (g.required && !m.value)
                    return (
                      g.message !== void 0
                        ? (A = [].concat(g.message).map(a0(g, o)))
                        : l.error &&
                          (A = [l.error(g, Pr(l.messages.required, g.field))]),
                      v(A)
                    );
                  var C = {};
                  g.defaultField &&
                    Object.keys(m.value).map(function (R) {
                      C[R] = g.defaultField;
                    }),
                    (C = yn({}, C, m.rule.fields));
                  var F = {};
                  Object.keys(C).forEach(function (R) {
                    var I = C[R],
                      P = Array.isArray(I) ? I : [I];
                    F[R] = P.map(b.bind(null, R));
                  });
                  var B = new r(F);
                  B.messages(l.messages),
                    m.rule.options &&
                      ((m.rule.options.messages = l.messages),
                      (m.rule.options.error = l.error)),
                    B.validate(m.value, m.rule.options || l, function (R) {
                      var I = [];
                      A && A.length && I.push.apply(I, A),
                        R && R.length && I.push.apply(I, R),
                        v(I.length ? I : null);
                    });
                }
              }
              var _;
              if (g.asyncValidator)
                _ = g.asyncValidator(g, m.value, y, m.source, l);
              else if (g.validator) {
                try {
                  _ = g.validator(g, m.value, y, m.source, l);
                } catch (w) {
                  console.error == null || console.error(w),
                    l.suppressValidatorError ||
                      setTimeout(function () {
                        throw w;
                      }, 0),
                    y(w.message);
                }
                _ === !0
                  ? y()
                  : _ === !1
                  ? y(
                      typeof g.message == "function"
                        ? g.message(g.fullField || g.field)
                        : g.message || (g.fullField || g.field) + " fails"
                    )
                  : _ instanceof Array
                  ? y(_)
                  : _ instanceof Error && y(_.message);
              }
              _ &&
                _.then &&
                _.then(
                  function () {
                    return y();
                  },
                  function (w) {
                    return y(w);
                  }
                );
            },
            function (m) {
              c(m);
            },
            o
          );
        }),
        (e.getType = function (i) {
          if (
            (i.type === void 0 &&
              i.pattern instanceof RegExp &&
              (i.type = "pattern"),
            typeof i.validator != "function" &&
              i.type &&
              !Oo.hasOwnProperty(i.type))
          )
            throw new Error(Pr("Unknown rule type %s", i.type));
          return i.type || "string";
        }),
        (e.getValidationMethod = function (i) {
          if (typeof i.validator == "function") return i.validator;
          var s = Object.keys(i),
            n = s.indexOf("message");
          return (
            n !== -1 && s.splice(n, 1),
            s.length === 1 && s[0] === "required"
              ? Oo.required
              : Oo[this.getType(i)] || void 0
          );
        }),
        r
      );
    })();
  ml.register = function (e, t) {
    if (typeof t != "function")
      throw new Error(
        "Cannot register a validator by type, validator is not a function"
      );
    Oo[e] = t;
  };
  ml.warning = zM;
  ml.messages = Od;
  ml.validators = Oo;
  const bF = ["", "error", "validating", "success"],
    xF = et({
      label: String,
      labelWidth: { type: [String, Number], default: "" },
      labelPosition: {
        type: String,
        values: ["left", "right", "top", ""],
        default: "",
      },
      prop: { type: Ne([String, Array]) },
      required: { type: Boolean, default: void 0 },
      rules: { type: Ne([Object, Array]) },
      error: String,
      validateStatus: { type: String, values: bF },
      for: String,
      inlineMessage: { type: [String, Boolean], default: "" },
      showMessage: { type: Boolean, default: !0 },
      size: { type: String, values: cl },
    }),
    h0 = "ElLabelWrap";
  var _F = ge({
    name: h0,
    props: { isAutoWidth: Boolean, updateAll: Boolean },
    setup(r, { slots: e }) {
      const t = rt(Ka, void 0),
        i = rt(On);
      i || hl(h0, "usage: <el-form-item><label-wrap /></el-form-item>");
      const s = ut("form"),
        n = he(),
        a = he(0),
        o = () => {
          var c;
          if ((c = n.value) != null && c.firstElementChild) {
            const u = window.getComputedStyle(n.value.firstElementChild).width;
            return Math.ceil(Number.parseFloat(u));
          } else return 0;
        },
        l = (c = "update") => {
          _t(() => {
            e.default &&
              r.isAutoWidth &&
              (c === "update"
                ? (a.value = o())
                : c === "remove" &&
                  (t == null || t.deregisterLabelWidth(a.value)));
          });
        },
        h = () => l("update");
      return (
        Rt(() => {
          h();
        }),
        Or(() => {
          l("remove");
        }),
        ol(() => h()),
        De(a, (c, u) => {
          r.updateAll && (t == null || t.registerLabelWidth(c, u));
        }),
        vp(
          X(() => {
            var c, u;
            return (u = (c = n.value) == null ? void 0 : c.firstElementChild) !=
              null
              ? u
              : null;
          }),
          h
        ),
        () => {
          var c, u;
          if (!e) return null;
          const { isAutoWidth: d } = r;
          if (d) {
            const f = t == null ? void 0 : t.autoLabelWidth,
              p = i == null ? void 0 : i.hasLabel,
              m = {};
            if (p && f && f !== "auto") {
              const v = Math.max(0, Number.parseInt(f, 10) - a.value),
                x =
                  (i.labelPosition || t.labelPosition) === "left"
                    ? "marginRight"
                    : "marginLeft";
              v && (m[x] = `${v}px`);
            }
            return ne(
              "div",
              { ref: n, class: [s.be("item", "label-wrap")], style: m },
              [(c = e.default) == null ? void 0 : c.call(e)]
            );
          } else
            return ne(ot, { ref: n }, [
              (u = e.default) == null ? void 0 : u.call(e),
            ]);
        }
      );
    },
  });
  const wF = ge({ name: "ElFormItem" }),
    TF = ge({
      ...wF,
      props: xF,
      setup(r, { expose: e }) {
        const t = r,
          i = lp(),
          s = rt(Ka, void 0),
          n = rt(On, void 0),
          a = ws(void 0, { formItem: !1 }),
          o = ut("form-item"),
          l = Bc().value,
          h = he([]),
          c = he(""),
          u = TS(c, 100),
          d = he(""),
          f = he();
        let p,
          m = !1;
        const v = X(
            () => t.labelPosition || (s == null ? void 0 : s.labelPosition)
          ),
          g = X(() => {
            if (v.value === "top") return {};
            const ee = Fn(
              t.labelWidth || (s == null ? void 0 : s.labelWidth) || ""
            );
            return ee ? { width: ee } : {};
          }),
          x = X(() => {
            if (v.value === "top" || (s != null && s.inline)) return {};
            if (!t.label && !t.labelWidth && F) return {};
            const ee = Fn(
              t.labelWidth || (s == null ? void 0 : s.labelWidth) || ""
            );
            return !t.label && !i.label ? { marginLeft: ee } : {};
          }),
          b = X(() => [
            o.b(),
            o.m(a.value),
            o.is("error", c.value === "error"),
            o.is("validating", c.value === "validating"),
            o.is("success", c.value === "success"),
            o.is("required", M.value || t.required),
            o.is("no-asterisk", s == null ? void 0 : s.hideRequiredAsterisk),
            (s == null ? void 0 : s.requireAsteriskPosition) === "right"
              ? "asterisk-right"
              : "asterisk-left",
            {
              [o.m("feedback")]: s == null ? void 0 : s.statusIcon,
              [o.m(`label-${v.value}`)]: v.value,
            },
          ]),
          y = X(() =>
            Ui(t.inlineMessage)
              ? t.inlineMessage
              : (s == null ? void 0 : s.inlineMessage) || !1
          ),
          _ = X(() => [o.e("error"), { [o.em("error", "inline")]: y.value }]),
          w = X(() => (t.prop ? (Ge(t.prop) ? t.prop : t.prop.join(".")) : "")),
          E = X(() => !!(t.label || i.label)),
          A = X(() => t.for || (h.value.length === 1 ? h.value[0] : void 0)),
          C = X(() => !A.value && E.value),
          F = !!n,
          B = X(() => {
            const ee = s == null ? void 0 : s.model;
            if (!(!ee || !t.prop)) return du(ee, t.prop).value;
          }),
          R = X(() => {
            const { required: ee } = t,
              ve = [];
            t.rules && ve.push(...Ed(t.rules));
            const ye = s == null ? void 0 : s.rules;
            if (ye && t.prop) {
              const _e = du(ye, t.prop).value;
              _e && ve.push(...Ed(_e));
            }
            if (ee !== void 0) {
              const _e = ve
                .map((ke, k) => [ke, k])
                .filter(([ke]) => Object.keys(ke).includes("required"));
              if (_e.length > 0)
                for (const [ke, k] of _e)
                  ke.required !== ee && (ve[k] = { ...ke, required: ee });
              else ve.push({ required: ee });
            }
            return ve;
          }),
          I = X(() => R.value.length > 0),
          P = (ee) =>
            R.value
              .filter((ye) =>
                !ye.trigger || !ee
                  ? !0
                  : Array.isArray(ye.trigger)
                  ? ye.trigger.includes(ee)
                  : ye.trigger === ee
              )
              .map(({ trigger: ye, ..._e }) => _e),
          M = X(() => R.value.some((ee) => ee.required)),
          L = X(() => {
            var ee;
            return (
              u.value === "error" &&
              t.showMessage &&
              ((ee = s == null ? void 0 : s.showMessage) != null ? ee : !0)
            );
          }),
          U = X(
            () =>
              `${t.label || ""}${(s == null ? void 0 : s.labelSuffix) || ""}`
          ),
          V = (ee) => {
            c.value = ee;
          },
          z = (ee) => {
            var ve, ye;
            const { errors: _e, fields: ke } = ee;
            (!_e || !ke) && console.error(ee),
              V("error"),
              (d.value = _e
                ? (ye =
                    (ve = _e == null ? void 0 : _e[0]) == null
                      ? void 0
                      : ve.message) != null
                  ? ye
                  : `${t.prop} is required`
                : ""),
              s == null || s.emit("validate", t.prop, !1, d.value);
          },
          N = () => {
            V("success"), s == null || s.emit("validate", t.prop, !0, "");
          },
          O = async (ee) => {
            const ve = w.value;
            return new ml({ [ve]: ee })
              .validate({ [ve]: B.value }, { firstFields: !0 })
              .then(() => (N(), !0))
              .catch((_e) => (z(_e), Promise.reject(_e)));
          },
          H = async (ee, ve) => {
            if (m || !t.prop) return !1;
            const ye = Fe(ve);
            if (!I.value) return ve == null || ve(!1), !1;
            const _e = P(ee);
            return _e.length === 0
              ? (ve == null || ve(!0), !0)
              : (V("validating"),
                O(_e)
                  .then(() => (ve == null || ve(!0), !0))
                  .catch((ke) => {
                    const { fields: k } = ke;
                    return ve == null || ve(!1, k), ye ? !1 : Promise.reject(k);
                  }));
          },
          G = () => {
            V(""), (d.value = ""), (m = !1);
          },
          q = async () => {
            const ee = s == null ? void 0 : s.model;
            if (!ee || !t.prop) return;
            const ve = du(ee, t.prop);
            (m = !0), (ve.value = Ug(p)), await _t(), G(), (m = !1);
          },
          K = (ee) => {
            h.value.includes(ee) || h.value.push(ee);
          },
          ue = (ee) => {
            h.value = h.value.filter((ve) => ve !== ee);
          };
        De(
          () => t.error,
          (ee) => {
            (d.value = ee || ""), V(ee ? "error" : "");
          },
          { immediate: !0 }
        ),
          De(
            () => t.validateStatus,
            (ee) => V(ee || "")
          );
        const ie = vi({
          ...Ra(t),
          $el: f,
          size: a,
          validateState: c,
          labelId: l,
          inputIds: h,
          isGroup: C,
          hasLabel: E,
          fieldValue: B,
          addInputId: K,
          removeInputId: ue,
          resetField: q,
          clearValidate: G,
          validate: H,
        });
        return (
          Fr(On, ie),
          Rt(() => {
            t.prop && (s == null || s.addField(ie), (p = Ug(B.value)));
          }),
          Or(() => {
            s == null || s.removeField(ie);
          }),
          e({
            size: a,
            validateMessage: d,
            validateState: c,
            validate: H,
            clearValidate: G,
            resetField: q,
          }),
          (ee, ve) => {
            var ye;
            return (
              j(),
              xe(
                "div",
                {
                  ref_key: "formItemRef",
                  ref: f,
                  class: ce(S(b)),
                  role: S(C) ? "group" : void 0,
                  "aria-labelledby": S(C) ? S(l) : void 0,
                },
                [
                  ne(
                    S(_F),
                    {
                      "is-auto-width": S(g).width === "auto",
                      "update-all":
                        ((ye = S(s)) == null ? void 0 : ye.labelWidth) ===
                        "auto",
                    },
                    {
                      default: be(() => [
                        S(E)
                          ? (j(),
                            Me(
                              qt(S(A) ? "label" : "div"),
                              {
                                key: 0,
                                id: S(l),
                                for: S(A),
                                class: ce(S(o).e("label")),
                                style: Et(S(g)),
                              },
                              {
                                default: be(() => [
                                  Xe(
                                    ee.$slots,
                                    "label",
                                    { label: S(U) },
                                    () => [vr(Ut(S(U)), 1)]
                                  ),
                                ]),
                                _: 3,
                              },
                              8,
                              ["id", "for", "class", "style"]
                            ))
                          : Re("v-if", !0),
                      ]),
                      _: 3,
                    },
                    8,
                    ["is-auto-width", "update-all"]
                  ),
                  Se(
                    "div",
                    { class: ce(S(o).e("content")), style: Et(S(x)) },
                    [
                      Xe(ee.$slots, "default"),
                      ne(
                        iS,
                        { name: `${S(o).namespace.value}-zoom-in-top` },
                        {
                          default: be(() => [
                            S(L)
                              ? Xe(
                                  ee.$slots,
                                  "error",
                                  { key: 0, error: d.value },
                                  () => [
                                    Se(
                                      "div",
                                      { class: ce(S(_)) },
                                      Ut(d.value),
                                      3
                                    ),
                                  ]
                                )
                              : Re("v-if", !0),
                          ]),
                          _: 3,
                        },
                        8,
                        ["name"]
                      ),
                    ],
                    6
                  ),
                ],
                10,
                ["role", "aria-labelledby"]
              )
            );
          }
        );
      },
    });
  var Fx = ct(TF, [["__file", "form-item.vue"]]);
  const EF = Qt(VM, { FormItem: Fx }),
    SF = Mc(Fx);
  let Kr;
  const AF = `
  height:0 !important;
  visibility:hidden !important;
  ${DS() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`,
    CF = [
      "letter-spacing",
      "line-height",
      "padding-top",
      "padding-bottom",
      "font-family",
      "font-weight",
      "font-size",
      "text-rendering",
      "text-transform",
      "width",
      "text-indent",
      "padding-left",
      "padding-right",
      "border-width",
      "box-sizing",
    ];
  function IF(r) {
    const e = window.getComputedStyle(r),
      t = e.getPropertyValue("box-sizing"),
      i =
        Number.parseFloat(e.getPropertyValue("padding-bottom")) +
        Number.parseFloat(e.getPropertyValue("padding-top")),
      s =
        Number.parseFloat(e.getPropertyValue("border-bottom-width")) +
        Number.parseFloat(e.getPropertyValue("border-top-width"));
    return {
      contextStyle: CF.map((a) => `${a}:${e.getPropertyValue(a)}`).join(";"),
      paddingSize: i,
      borderSize: s,
      boxSizing: t,
    };
  }
  function c0(r, e = 1, t) {
    var i;
    Kr ||
      ((Kr = document.createElement("textarea")),
      document.body.appendChild(Kr));
    const {
      paddingSize: s,
      borderSize: n,
      boxSizing: a,
      contextStyle: o,
    } = IF(r);
    Kr.setAttribute("style", `${o};${AF}`),
      (Kr.value = r.value || r.placeholder || "");
    let l = Kr.scrollHeight;
    const h = {};
    a === "border-box" ? (l = l + n) : a === "content-box" && (l = l - s),
      (Kr.value = "");
    const c = Kr.scrollHeight - s;
    if (at(e)) {
      let u = c * e;
      a === "border-box" && (u = u + s + n),
        (l = Math.max(u, l)),
        (h.minHeight = `${u}px`);
    }
    if (at(t)) {
      let u = c * t;
      a === "border-box" && (u = u + s + n), (l = Math.min(u, l));
    }
    return (
      (h.height = `${l}px`),
      (i = Kr.parentNode) == null || i.removeChild(Kr),
      (Kr = void 0),
      h
    );
  }
  const PF = et({
      id: { type: String, default: void 0 },
      size: Bn,
      disabled: Boolean,
      modelValue: { type: Ne([String, Number, Object]), default: "" },
      maxlength: { type: [String, Number] },
      minlength: { type: [String, Number] },
      type: { type: String, default: "text" },
      resize: {
        type: String,
        values: ["none", "both", "horizontal", "vertical"],
      },
      autosize: { type: Ne([Boolean, Object]), default: !1 },
      autocomplete: { type: String, default: "off" },
      formatter: { type: Function },
      parser: { type: Function },
      placeholder: { type: String },
      form: { type: String },
      readonly: Boolean,
      clearable: Boolean,
      showPassword: Boolean,
      showWordLimit: Boolean,
      suffixIcon: { type: hs },
      prefixIcon: { type: hs },
      containerRole: { type: String, default: void 0 },
      tabindex: { type: [String, Number], default: 0 },
      validateEvent: { type: Boolean, default: !0 },
      inputStyle: { type: Ne([Object, Array, String]), default: () => Fp({}) },
      autofocus: Boolean,
      rows: { type: Number, default: 2 },
      ...en(["ariaLabel"]),
    }),
    RF = {
      [$t]: (r) => Ge(r),
      input: (r) => Ge(r),
      change: (r) => Ge(r),
      focus: (r) => r instanceof FocusEvent,
      blur: (r) => r instanceof FocusEvent,
      clear: () => !0,
      mouseleave: (r) => r instanceof MouseEvent,
      mouseenter: (r) => r instanceof MouseEvent,
      keydown: (r) => r instanceof Event,
      compositionstart: (r) => r instanceof CompositionEvent,
      compositionupdate: (r) => r instanceof CompositionEvent,
      compositionend: (r) => r instanceof CompositionEvent,
    },
    MF = ge({ name: "ElInput", inheritAttrs: !1 }),
    FF = ge({
      ...MF,
      props: PF,
      emits: RF,
      setup(r, { expose: e, emit: t }) {
        const i = r,
          s = sb(),
          n = lp(),
          a = X(() => {
            const Y = {};
            return (
              i.containerRole === "combobox" &&
                ((Y["aria-haspopup"] = s["aria-haspopup"]),
                (Y["aria-owns"] = s["aria-owns"]),
                (Y["aria-expanded"] = s["aria-expanded"])),
              Y
            );
          }),
          o = X(() => [
            i.type === "textarea" ? v.b() : m.b(),
            m.m(f.value),
            m.is("disabled", p.value),
            m.is("exceed", G.value),
            {
              [m.b("group")]: n.prepend || n.append,
              [m.m("prefix")]: n.prefix || i.prefixIcon,
              [m.m("suffix")]:
                n.suffix || i.suffixIcon || i.clearable || i.showPassword,
              [m.bm("suffix", "password-clear")]: z.value && N.value,
              [m.b("hidden")]: i.type === "hidden",
            },
            s.class,
          ]),
          l = X(() => [m.e("wrapper"), m.is("focus", C.value)]),
          h = dx({ excludeKeys: X(() => Object.keys(a.value)) }),
          { form: c, formItem: u } = Ja(),
          { inputId: d } = Oc(i, { formItemContext: u }),
          f = ws(),
          p = Za(),
          m = ut("input"),
          v = ut("textarea"),
          g = _n(),
          x = _n(),
          b = he(!1),
          y = he(!1),
          _ = he(),
          w = _n(i.inputStyle),
          E = X(() => g.value || x.value),
          {
            wrapperRef: A,
            isFocused: C,
            handleFocus: F,
            handleBlur: B,
          } = EM(E, {
            beforeFocus() {
              return p.value;
            },
            afterBlur() {
              var Y;
              i.validateEvent &&
                ((Y = u == null ? void 0 : u.validate) == null ||
                  Y.call(u, "blur").catch((Te) => void 0));
            },
          }),
          R = X(() => {
            var Y;
            return (Y = c == null ? void 0 : c.statusIcon) != null ? Y : !1;
          }),
          I = X(() => (u == null ? void 0 : u.validateState) || ""),
          P = X(() => I.value && YP[I.value]),
          M = X(() => (y.value ? $P : AP)),
          L = X(() => [s.style]),
          U = X(() => [i.inputStyle, w.value, { resize: i.resize }]),
          V = X(() => (Ni(i.modelValue) ? "" : String(i.modelValue))),
          z = X(
            () =>
              i.clearable &&
              !p.value &&
              !i.readonly &&
              !!V.value &&
              (C.value || b.value)
          ),
          N = X(
            () =>
              i.showPassword &&
              !p.value &&
              !i.readonly &&
              !!V.value &&
              (!!V.value || C.value)
          ),
          O = X(
            () =>
              i.showWordLimit &&
              !!i.maxlength &&
              (i.type === "text" || i.type === "textarea") &&
              !p.value &&
              !i.readonly &&
              !i.showPassword
          ),
          H = X(() => V.value.length),
          G = X(() => !!O.value && H.value > Number(i.maxlength)),
          q = X(
            () =>
              !!n.suffix ||
              !!i.suffixIcon ||
              z.value ||
              i.showPassword ||
              O.value ||
              (!!I.value && R.value)
          ),
          [K, ue] = _M(g);
        vp(x, (Y) => {
          if ((ve(), !O.value || i.resize !== "both")) return;
          const Te = Y[0],
            { width: Ue } = Te.contentRect;
          _.value = { right: `calc(100% - ${Ue + 15 + 6}px)` };
        });
        const ie = () => {
            const { type: Y, autosize: Te } = i;
            if (!(!It || Y !== "textarea" || !x.value))
              if (Te) {
                const Ue = Qe(Te) ? Te.minRows : void 0,
                  it = Qe(Te) ? Te.maxRows : void 0,
                  st = c0(x.value, Ue, it);
                (w.value = { overflowY: "hidden", ...st }),
                  _t(() => {
                    x.value.offsetHeight, (w.value = st);
                  });
              } else w.value = { minHeight: c0(x.value).minHeight };
          },
          ve = ((Y) => {
            let Te = !1;
            return () => {
              var Ue;
              if (Te || !i.autosize) return;
              ((Ue = x.value) == null ? void 0 : Ue.offsetParent) === null ||
                (Y(), (Te = !0));
            };
          })(ie),
          ye = () => {
            const Y = E.value,
              Te = i.formatter ? i.formatter(V.value) : V.value;
            !Y || Y.value === Te || (Y.value = Te);
          },
          _e = async (Y) => {
            K();
            let { value: Te } = Y.target;
            if (
              (i.formatter && (Te = i.parser ? i.parser(Te) : Te), !k.value)
            ) {
              if (Te === V.value) {
                ye();
                return;
              }
              t($t, Te), t("input", Te), await _t(), ye(), ue();
            }
          },
          ke = (Y) => {
            t("change", Y.target.value);
          },
          {
            isComposing: k,
            handleCompositionStart: D,
            handleCompositionUpdate: W,
            handleCompositionEnd: te,
          } = SM({ emit: t, afterComposition: _e }),
          J = () => {
            (y.value = !y.value), Q();
          },
          Q = async () => {
            var Y;
            await _t(), (Y = E.value) == null || Y.focus();
          },
          de = () => {
            var Y;
            return (Y = E.value) == null ? void 0 : Y.blur();
          },
          oe = (Y) => {
            (b.value = !1), t("mouseleave", Y);
          },
          se = (Y) => {
            (b.value = !0), t("mouseenter", Y);
          },
          re = (Y) => {
            t("keydown", Y);
          },
          Pe = () => {
            var Y;
            (Y = E.value) == null || Y.select();
          },
          fe = () => {
            t($t, ""), t("change", ""), t("clear"), t("input", "");
          };
        return (
          De(
            () => i.modelValue,
            () => {
              var Y;
              _t(() => ie()),
                i.validateEvent &&
                  ((Y = u == null ? void 0 : u.validate) == null ||
                    Y.call(u, "change").catch((Te) => void 0));
            }
          ),
          De(V, () => ye()),
          De(
            () => i.type,
            async () => {
              await _t(), ye(), ie();
            }
          ),
          Rt(() => {
            !i.formatter && i.parser, ye(), _t(ie);
          }),
          e({
            input: g,
            textarea: x,
            ref: E,
            textareaStyle: U,
            autosize: ni(i, "autosize"),
            isComposing: k,
            focus: Q,
            blur: de,
            select: Pe,
            clear: fe,
            resizeTextarea: ie,
          }),
          (Y, Te) => (
            j(),
            xe(
              "div",
              Gr(S(a), {
                class: [
                  S(o),
                  {
                    [S(m).bm("group", "append")]: Y.$slots.append,
                    [S(m).bm("group", "prepend")]: Y.$slots.prepend,
                  },
                ],
                style: S(L),
                role: Y.containerRole,
                onMouseenter: se,
                onMouseleave: oe,
              }),
              [
                Re(" input "),
                Y.type !== "textarea"
                  ? (j(),
                    xe(
                      ot,
                      { key: 0 },
                      [
                        Re(" prepend slot "),
                        Y.$slots.prepend
                          ? (j(),
                            xe(
                              "div",
                              {
                                key: 0,
                                class: ce(S(m).be("group", "prepend")),
                              },
                              [Xe(Y.$slots, "prepend")],
                              2
                            ))
                          : Re("v-if", !0),
                        Se(
                          "div",
                          { ref_key: "wrapperRef", ref: A, class: ce(S(l)) },
                          [
                            Re(" prefix slot "),
                            Y.$slots.prefix || Y.prefixIcon
                              ? (j(),
                                xe(
                                  "span",
                                  { key: 0, class: ce(S(m).e("prefix")) },
                                  [
                                    Se(
                                      "span",
                                      { class: ce(S(m).e("prefix-inner")) },
                                      [
                                        Xe(Y.$slots, "prefix"),
                                        Y.prefixIcon
                                          ? (j(),
                                            Me(
                                              S(xt),
                                              {
                                                key: 0,
                                                class: ce(S(m).e("icon")),
                                              },
                                              {
                                                default: be(() => [
                                                  (j(), Me(qt(Y.prefixIcon))),
                                                ]),
                                                _: 1,
                                              },
                                              8,
                                              ["class"]
                                            ))
                                          : Re("v-if", !0),
                                      ],
                                      2
                                    ),
                                  ],
                                  2
                                ))
                              : Re("v-if", !0),
                            Se(
                              "input",
                              Gr(
                                {
                                  id: S(d),
                                  ref_key: "input",
                                  ref: g,
                                  class: S(m).e("inner"),
                                },
                                S(h),
                                {
                                  minlength: Y.minlength,
                                  maxlength: Y.maxlength,
                                  type: Y.showPassword
                                    ? y.value
                                      ? "text"
                                      : "password"
                                    : Y.type,
                                  disabled: S(p),
                                  readonly: Y.readonly,
                                  autocomplete: Y.autocomplete,
                                  tabindex: Y.tabindex,
                                  "aria-label": Y.ariaLabel,
                                  placeholder: Y.placeholder,
                                  style: Y.inputStyle,
                                  form: Y.form,
                                  autofocus: Y.autofocus,
                                  onCompositionstart: S(D),
                                  onCompositionupdate: S(W),
                                  onCompositionend: S(te),
                                  onInput: _e,
                                  onChange: ke,
                                  onKeydown: re,
                                }
                              ),
                              null,
                              16,
                              [
                                "id",
                                "minlength",
                                "maxlength",
                                "type",
                                "disabled",
                                "readonly",
                                "autocomplete",
                                "tabindex",
                                "aria-label",
                                "placeholder",
                                "form",
                                "autofocus",
                                "onCompositionstart",
                                "onCompositionupdate",
                                "onCompositionend",
                              ]
                            ),
                            Re(" suffix slot "),
                            S(q)
                              ? (j(),
                                xe(
                                  "span",
                                  { key: 1, class: ce(S(m).e("suffix")) },
                                  [
                                    Se(
                                      "span",
                                      { class: ce(S(m).e("suffix-inner")) },
                                      [
                                        !S(z) || !S(N) || !S(O)
                                          ? (j(),
                                            xe(
                                              ot,
                                              { key: 0 },
                                              [
                                                Xe(Y.$slots, "suffix"),
                                                Y.suffixIcon
                                                  ? (j(),
                                                    Me(
                                                      S(xt),
                                                      {
                                                        key: 0,
                                                        class: ce(
                                                          S(m).e("icon")
                                                        ),
                                                      },
                                                      {
                                                        default: be(() => [
                                                          (j(),
                                                          Me(qt(Y.suffixIcon))),
                                                        ]),
                                                        _: 1,
                                                      },
                                                      8,
                                                      ["class"]
                                                    ))
                                                  : Re("v-if", !0),
                                              ],
                                              64
                                            ))
                                          : Re("v-if", !0),
                                        S(z)
                                          ? (j(),
                                            Me(
                                              S(xt),
                                              {
                                                key: 1,
                                                class: ce([
                                                  S(m).e("icon"),
                                                  S(m).e("clear"),
                                                ]),
                                                onMousedown: hi(S(ar), [
                                                  "prevent",
                                                ]),
                                                onClick: fe,
                                              },
                                              {
                                                default: be(() => [ne(S(cx))]),
                                                _: 1,
                                              },
                                              8,
                                              ["class", "onMousedown"]
                                            ))
                                          : Re("v-if", !0),
                                        S(N)
                                          ? (j(),
                                            Me(
                                              S(xt),
                                              {
                                                key: 2,
                                                class: ce([
                                                  S(m).e("icon"),
                                                  S(m).e("password"),
                                                ]),
                                                onClick: J,
                                              },
                                              {
                                                default: be(() => [
                                                  (j(), Me(qt(S(M)))),
                                                ]),
                                                _: 1,
                                              },
                                              8,
                                              ["class"]
                                            ))
                                          : Re("v-if", !0),
                                        S(O)
                                          ? (j(),
                                            xe(
                                              "span",
                                              {
                                                key: 3,
                                                class: ce(S(m).e("count")),
                                              },
                                              [
                                                Se(
                                                  "span",
                                                  {
                                                    class: ce(
                                                      S(m).e("count-inner")
                                                    ),
                                                  },
                                                  Ut(S(H)) +
                                                    " / " +
                                                    Ut(Y.maxlength),
                                                  3
                                                ),
                                              ],
                                              2
                                            ))
                                          : Re("v-if", !0),
                                        S(I) && S(P) && S(R)
                                          ? (j(),
                                            Me(
                                              S(xt),
                                              {
                                                key: 4,
                                                class: ce([
                                                  S(m).e("icon"),
                                                  S(m).e("validateIcon"),
                                                  S(m).is(
                                                    "loading",
                                                    S(I) === "validating"
                                                  ),
                                                ]),
                                              },
                                              {
                                                default: be(() => [
                                                  (j(), Me(qt(S(P)))),
                                                ]),
                                                _: 1,
                                              },
                                              8,
                                              ["class"]
                                            ))
                                          : Re("v-if", !0),
                                      ],
                                      2
                                    ),
                                  ],
                                  2
                                ))
                              : Re("v-if", !0),
                          ],
                          2
                        ),
                        Re(" append slot "),
                        Y.$slots.append
                          ? (j(),
                            xe(
                              "div",
                              { key: 1, class: ce(S(m).be("group", "append")) },
                              [Xe(Y.$slots, "append")],
                              2
                            ))
                          : Re("v-if", !0),
                      ],
                      64
                    ))
                  : (j(),
                    xe(
                      ot,
                      { key: 1 },
                      [
                        Re(" textarea "),
                        Se(
                          "textarea",
                          Gr(
                            {
                              id: S(d),
                              ref_key: "textarea",
                              ref: x,
                              class: [S(v).e("inner"), S(m).is("focus", S(C))],
                            },
                            S(h),
                            {
                              minlength: Y.minlength,
                              maxlength: Y.maxlength,
                              tabindex: Y.tabindex,
                              disabled: S(p),
                              readonly: Y.readonly,
                              autocomplete: Y.autocomplete,
                              style: S(U),
                              "aria-label": Y.ariaLabel,
                              placeholder: Y.placeholder,
                              form: Y.form,
                              autofocus: Y.autofocus,
                              rows: Y.rows,
                              onCompositionstart: S(D),
                              onCompositionupdate: S(W),
                              onCompositionend: S(te),
                              onInput: _e,
                              onFocus: S(F),
                              onBlur: S(B),
                              onChange: ke,
                              onKeydown: re,
                            }
                          ),
                          null,
                          16,
                          [
                            "id",
                            "minlength",
                            "maxlength",
                            "tabindex",
                            "disabled",
                            "readonly",
                            "autocomplete",
                            "aria-label",
                            "placeholder",
                            "form",
                            "autofocus",
                            "rows",
                            "onCompositionstart",
                            "onCompositionupdate",
                            "onCompositionend",
                            "onFocus",
                            "onBlur",
                          ]
                        ),
                        S(O)
                          ? (j(),
                            xe(
                              "span",
                              {
                                key: 0,
                                style: Et(_.value),
                                class: ce(S(m).e("count")),
                              },
                              Ut(S(H)) + " / " + Ut(Y.maxlength),
                              7
                            ))
                          : Re("v-if", !0),
                      ],
                      64
                    )),
              ],
              16,
              ["role"]
            )
          )
        );
      },
    });
  var BF = ct(FF, [["__file", "input.vue"]]);
  const OF = Qt(BF),
    Wn = 4,
    kF = {
      vertical: {
        offset: "offsetHeight",
        scroll: "scrollTop",
        scrollSize: "scrollHeight",
        size: "height",
        key: "vertical",
        axis: "Y",
        client: "clientY",
        direction: "top",
      },
      horizontal: {
        offset: "offsetWidth",
        scroll: "scrollLeft",
        scrollSize: "scrollWidth",
        size: "width",
        key: "horizontal",
        axis: "X",
        client: "clientX",
        direction: "left",
      },
    },
    DF = ({ move: r, size: e, bar: t }) => ({
      [t.size]: e,
      transform: `translate${t.axis}(${r}%)`,
    }),
    Gp = Symbol("scrollbarContextKey"),
    LF = et({
      vertical: Boolean,
      size: String,
      move: Number,
      ratio: { type: Number, required: !0 },
      always: Boolean,
    }),
    NF = "Thumb",
    UF = ge({
      __name: "thumb",
      props: LF,
      setup(r) {
        const e = r,
          t = rt(Gp),
          i = ut("scrollbar");
        t || hl(NF, "can not inject scrollbar context");
        const s = he(),
          n = he(),
          a = he({}),
          o = he(!1);
        let l = !1,
          h = !1,
          c = It ? document.onselectstart : null;
        const u = X(() => kF[e.vertical ? "vertical" : "horizontal"]),
          d = X(() => DF({ size: e.size, move: e.move, bar: u.value })),
          f = X(
            () =>
              s.value[u.value.offset] ** 2 /
              t.wrapElement[u.value.scrollSize] /
              e.ratio /
              n.value[u.value.offset]
          ),
          p = (w) => {
            var E;
            if ((w.stopPropagation(), w.ctrlKey || [1, 2].includes(w.button)))
              return;
            (E = window.getSelection()) == null || E.removeAllRanges(), v(w);
            const A = w.currentTarget;
            A &&
              (a.value[u.value.axis] =
                A[u.value.offset] -
                (w[u.value.client] -
                  A.getBoundingClientRect()[u.value.direction]));
          },
          m = (w) => {
            if (!n.value || !s.value || !t.wrapElement) return;
            const E = Math.abs(
                w.target.getBoundingClientRect()[u.value.direction] -
                  w[u.value.client]
              ),
              A = n.value[u.value.offset] / 2,
              C = ((E - A) * 100 * f.value) / s.value[u.value.offset];
            t.wrapElement[u.value.scroll] =
              (C * t.wrapElement[u.value.scrollSize]) / 100;
          },
          v = (w) => {
            w.stopImmediatePropagation(),
              (l = !0),
              document.addEventListener("mousemove", g),
              document.addEventListener("mouseup", x),
              (c = document.onselectstart),
              (document.onselectstart = () => !1);
          },
          g = (w) => {
            if (!s.value || !n.value || l === !1) return;
            const E = a.value[u.value.axis];
            if (!E) return;
            const A =
                (s.value.getBoundingClientRect()[u.value.direction] -
                  w[u.value.client]) *
                -1,
              C = n.value[u.value.offset] - E,
              F = ((A - C) * 100 * f.value) / s.value[u.value.offset];
            t.wrapElement[u.value.scroll] =
              (F * t.wrapElement[u.value.scrollSize]) / 100;
          },
          x = () => {
            (l = !1),
              (a.value[u.value.axis] = 0),
              document.removeEventListener("mousemove", g),
              document.removeEventListener("mouseup", x),
              _(),
              h && (o.value = !1);
          },
          b = () => {
            (h = !1), (o.value = !!e.size);
          },
          y = () => {
            (h = !0), (o.value = l);
          };
        Or(() => {
          _(), document.removeEventListener("mouseup", x);
        });
        const _ = () => {
          document.onselectstart !== c && (document.onselectstart = c);
        };
        return (
          Vt(ni(t, "scrollbarElement"), "mousemove", b),
          Vt(ni(t, "scrollbarElement"), "mouseleave", y),
          (w, E) => (
            j(),
            Me(
              fp,
              { name: S(i).b("fade"), persisted: "" },
              {
                default: be(() => [
                  Ws(
                    Se(
                      "div",
                      {
                        ref_key: "instance",
                        ref: s,
                        class: ce([S(i).e("bar"), S(i).is(S(u).key)]),
                        onMousedown: m,
                      },
                      [
                        Se(
                          "div",
                          {
                            ref_key: "thumb",
                            ref: n,
                            class: ce(S(i).e("thumb")),
                            style: Et(S(d)),
                            onMousedown: p,
                          },
                          null,
                          38
                        ),
                      ],
                      34
                    ),
                    [[pp, w.always || o.value]]
                  ),
                ]),
                _: 1,
              },
              8,
              ["name"]
            )
          )
        );
      },
    });
  var u0 = ct(UF, [["__file", "thumb.vue"]]);
  const VF = et({
      always: { type: Boolean, default: !0 },
      minSize: { type: Number, required: !0 },
    }),
    $F = ge({
      __name: "bar",
      props: VF,
      setup(r, { expose: e }) {
        const t = r,
          i = rt(Gp),
          s = he(0),
          n = he(0),
          a = he(""),
          o = he(""),
          l = he(1),
          h = he(1);
        return (
          e({
            handleScroll: (d) => {
              if (d) {
                const f = d.offsetHeight - Wn,
                  p = d.offsetWidth - Wn;
                (n.value = ((d.scrollTop * 100) / f) * l.value),
                  (s.value = ((d.scrollLeft * 100) / p) * h.value);
              }
            },
            update: () => {
              const d = i == null ? void 0 : i.wrapElement;
              if (!d) return;
              const f = d.offsetHeight - Wn,
                p = d.offsetWidth - Wn,
                m = f ** 2 / d.scrollHeight,
                v = p ** 2 / d.scrollWidth,
                g = Math.max(m, t.minSize),
                x = Math.max(v, t.minSize);
              (l.value = m / (f - m) / (g / (f - g))),
                (h.value = v / (p - v) / (x / (p - x))),
                (o.value = g + Wn < f ? `${g}px` : ""),
                (a.value = x + Wn < p ? `${x}px` : "");
            },
          }),
          (d, f) => (
            j(),
            xe(
              ot,
              null,
              [
                ne(
                  u0,
                  {
                    move: s.value,
                    ratio: h.value,
                    size: a.value,
                    always: d.always,
                  },
                  null,
                  8,
                  ["move", "ratio", "size", "always"]
                ),
                ne(
                  u0,
                  {
                    move: n.value,
                    ratio: l.value,
                    size: o.value,
                    vertical: "",
                    always: d.always,
                  },
                  null,
                  8,
                  ["move", "ratio", "size", "always"]
                ),
              ],
              64
            )
          )
        );
      },
    });
  var GF = ct($F, [["__file", "bar.vue"]]);
  const HF = et({
      height: { type: [String, Number], default: "" },
      maxHeight: { type: [String, Number], default: "" },
      native: { type: Boolean, default: !1 },
      wrapStyle: { type: Ne([String, Object, Array]), default: "" },
      wrapClass: { type: [String, Array], default: "" },
      viewClass: { type: [String, Array], default: "" },
      viewStyle: { type: [String, Array, Object], default: "" },
      noresize: Boolean,
      tag: { type: String, default: "div" },
      always: Boolean,
      minSize: { type: Number, default: 20 },
      tabindex: { type: [String, Number], default: void 0 },
      id: String,
      role: String,
      ...en(["ariaLabel", "ariaOrientation"]),
    }),
    XF = { scroll: ({ scrollTop: r, scrollLeft: e }) => [r, e].every(at) },
    zF = "ElScrollbar",
    WF = ge({ name: zF }),
    YF = ge({
      ...WF,
      props: HF,
      emits: XF,
      setup(r, { expose: e, emit: t }) {
        const i = r,
          s = ut("scrollbar");
        let n,
          a,
          o = 0,
          l = 0;
        const h = he(),
          c = he(),
          u = he(),
          d = he(),
          f = X(() => {
            const _ = {};
            return (
              i.height && (_.height = Fn(i.height)),
              i.maxHeight && (_.maxHeight = Fn(i.maxHeight)),
              [i.wrapStyle, _]
            );
          }),
          p = X(() => [
            i.wrapClass,
            s.e("wrap"),
            { [s.em("wrap", "hidden-default")]: !i.native },
          ]),
          m = X(() => [s.e("view"), i.viewClass]),
          v = () => {
            var _;
            c.value &&
              ((_ = d.value) == null || _.handleScroll(c.value),
              (o = c.value.scrollTop),
              (l = c.value.scrollLeft),
              t("scroll", {
                scrollTop: c.value.scrollTop,
                scrollLeft: c.value.scrollLeft,
              }));
          };
        function g(_, w) {
          Qe(_)
            ? c.value.scrollTo(_)
            : at(_) && at(w) && c.value.scrollTo(_, w);
        }
        const x = (_) => {
            at(_) && (c.value.scrollTop = _);
          },
          b = (_) => {
            at(_) && (c.value.scrollLeft = _);
          },
          y = () => {
            var _;
            (_ = d.value) == null || _.update();
          };
        return (
          De(
            () => i.noresize,
            (_) => {
              _
                ? (n == null || n(), a == null || a())
                : (({ stop: n } = vp(u, y)), (a = Vt("resize", y)));
            },
            { immediate: !0 }
          ),
          De(
            () => [i.maxHeight, i.height],
            () => {
              i.native ||
                _t(() => {
                  var _;
                  y(),
                    c.value &&
                      ((_ = d.value) == null || _.handleScroll(c.value));
                });
            }
          ),
          Fr(Gp, vi({ scrollbarElement: h, wrapElement: c })),
          Jy(() => {
            (c.value.scrollTop = o), (c.value.scrollLeft = l);
          }),
          Rt(() => {
            i.native ||
              _t(() => {
                y();
              });
          }),
          ol(() => y()),
          e({
            wrapRef: c,
            update: y,
            scrollTo: g,
            setScrollTop: x,
            setScrollLeft: b,
            handleScroll: v,
          }),
          (_, w) => (
            j(),
            xe(
              "div",
              { ref_key: "scrollbarRef", ref: h, class: ce(S(s).b()) },
              [
                Se(
                  "div",
                  {
                    ref_key: "wrapRef",
                    ref: c,
                    class: ce(S(p)),
                    style: Et(S(f)),
                    tabindex: _.tabindex,
                    onScroll: v,
                  },
                  [
                    (j(),
                    Me(
                      qt(_.tag),
                      {
                        id: _.id,
                        ref_key: "resizeRef",
                        ref: u,
                        class: ce(S(m)),
                        style: Et(_.viewStyle),
                        role: _.role,
                        "aria-label": _.ariaLabel,
                        "aria-orientation": _.ariaOrientation,
                      },
                      { default: be(() => [Xe(_.$slots, "default")]), _: 3 },
                      8,
                      [
                        "id",
                        "class",
                        "style",
                        "role",
                        "aria-label",
                        "aria-orientation",
                      ]
                    )),
                  ],
                  46,
                  ["tabindex"]
                ),
                _.native
                  ? Re("v-if", !0)
                  : (j(),
                    Me(
                      GF,
                      {
                        key: 0,
                        ref_key: "barRef",
                        ref: d,
                        always: _.always,
                        "min-size": _.minSize,
                      },
                      null,
                      8,
                      ["always", "min-size"]
                    )),
              ],
              2
            )
          )
        );
      },
    });
  var jF = ct(YF, [["__file", "scrollbar.vue"]]);
  const qF = Qt(jF),
    Hp = Symbol("popper"),
    Bx = Symbol("popperContent"),
    KF = [
      "dialog",
      "grid",
      "group",
      "listbox",
      "menu",
      "navigation",
      "tooltip",
      "tree",
    ],
    Ox = et({ role: { type: String, values: KF, default: "tooltip" } }),
    ZF = ge({ name: "ElPopper", inheritAttrs: !1 }),
    JF = ge({
      ...ZF,
      props: Ox,
      setup(r, { expose: e }) {
        const t = r,
          i = he(),
          s = he(),
          n = he(),
          a = he(),
          o = X(() => t.role),
          l = {
            triggerRef: i,
            popperInstanceRef: s,
            contentRef: n,
            referenceRef: a,
            role: o,
          };
        return e(l), Fr(Hp, l), (h, c) => Xe(h.$slots, "default");
      },
    });
  var QF = ct(JF, [["__file", "popper.vue"]]);
  const kx = et({ arrowOffset: { type: Number, default: 5 } }),
    e3 = ge({ name: "ElPopperArrow", inheritAttrs: !1 }),
    t3 = ge({
      ...e3,
      props: kx,
      setup(r, { expose: e }) {
        const t = r,
          i = ut("popper"),
          { arrowOffset: s, arrowRef: n, arrowStyle: a } = rt(Bx, void 0);
        return (
          De(
            () => t.arrowOffset,
            (o) => {
              s.value = o;
            }
          ),
          Or(() => {
            n.value = void 0;
          }),
          e({ arrowRef: n }),
          (o, l) => (
            j(),
            xe(
              "span",
              {
                ref_key: "arrowRef",
                ref: n,
                class: ce(S(i).e("arrow")),
                style: Et(S(a)),
                "data-popper-arrow": "",
              },
              null,
              6
            )
          )
        );
      },
    });
  var r3 = ct(t3, [["__file", "arrow.vue"]]);
  const i3 = "ElOnlyChild",
    s3 = ge({
      name: i3,
      setup(r, { slots: e, attrs: t }) {
        var i;
        const s = rt(Px),
          n = yM((i = s == null ? void 0 : s.setForwardRef) != null ? i : ar);
        return () => {
          var a;
          const o = (a = e.default) == null ? void 0 : a.call(e, t);
          if (!o || o.length > 1) return null;
          const l = Dx(o);
          return l ? Ws(ms(l, t), [[n]]) : null;
        };
      },
    });
  function Dx(r) {
    if (!r) return null;
    const e = r;
    for (const t of e) {
      if (Qe(t))
        switch (t.type) {
          case ir:
            continue;
          case Wa:
          case "svg":
            return d0(t);
          case ot:
            return Dx(t.children);
          default:
            return t;
        }
      return d0(t);
    }
    return null;
  }
  function d0(r) {
    const e = ut("only-child");
    return ne("span", { class: e.e("content") }, [r]);
  }
  const Lx = et({
      virtualRef: { type: Ne(Object) },
      virtualTriggering: Boolean,
      onMouseenter: { type: Ne(Function) },
      onMouseleave: { type: Ne(Function) },
      onClick: { type: Ne(Function) },
      onKeydown: { type: Ne(Function) },
      onFocus: { type: Ne(Function) },
      onBlur: { type: Ne(Function) },
      onContextmenu: { type: Ne(Function) },
      id: String,
      open: Boolean,
    }),
    n3 = ge({ name: "ElPopperTrigger", inheritAttrs: !1 }),
    a3 = ge({
      ...n3,
      props: Lx,
      setup(r, { expose: e }) {
        const t = r,
          { role: i, triggerRef: s } = rt(Hp, void 0);
        vM(s);
        const n = X(() => (o.value ? t.id : void 0)),
          a = X(() => {
            if (i && i.value === "tooltip")
              return t.open && t.id ? t.id : void 0;
          }),
          o = X(() => {
            if (i && i.value !== "tooltip") return i.value;
          }),
          l = X(() => (o.value ? `${t.open}` : void 0));
        let h;
        const c = [
          "onMouseenter",
          "onMouseleave",
          "onClick",
          "onKeydown",
          "onFocus",
          "onBlur",
          "onContextmenu",
        ];
        return (
          Rt(() => {
            De(
              () => t.virtualRef,
              (u) => {
                u && (s.value = Us(u));
              },
              { immediate: !0 }
            ),
              De(
                s,
                (u, d) => {
                  h == null || h(),
                    (h = void 0),
                    _a(u) &&
                      (c.forEach((f) => {
                        var p;
                        const m = t[f];
                        m &&
                          (u.addEventListener(f.slice(2).toLowerCase(), m),
                          (p = d == null ? void 0 : d.removeEventListener) ==
                            null || p.call(d, f.slice(2).toLowerCase(), m));
                      }),
                      (h = De(
                        [n, a, o, l],
                        (f) => {
                          [
                            "aria-controls",
                            "aria-describedby",
                            "aria-haspopup",
                            "aria-expanded",
                          ].forEach((p, m) => {
                            Ni(f[m])
                              ? u.removeAttribute(p)
                              : u.setAttribute(p, f[m]);
                          });
                        },
                        { immediate: !0 }
                      ))),
                    _a(d) &&
                      [
                        "aria-controls",
                        "aria-describedby",
                        "aria-haspopup",
                        "aria-expanded",
                      ].forEach((f) => d.removeAttribute(f));
                },
                { immediate: !0 }
              );
          }),
          Or(() => {
            if ((h == null || h(), (h = void 0), s.value && _a(s.value))) {
              const u = s.value;
              c.forEach((d) => {
                const f = t[d];
                f && u.removeEventListener(d.slice(2).toLowerCase(), f);
              }),
                (s.value = void 0);
            }
          }),
          e({ triggerRef: s }),
          (u, d) =>
            u.virtualTriggering
              ? Re("v-if", !0)
              : (j(),
                Me(
                  S(s3),
                  Gr({ key: 0 }, u.$attrs, {
                    "aria-controls": S(n),
                    "aria-describedby": S(a),
                    "aria-expanded": S(l),
                    "aria-haspopup": S(o),
                  }),
                  { default: be(() => [Xe(u.$slots, "default")]), _: 3 },
                  16,
                  [
                    "aria-controls",
                    "aria-describedby",
                    "aria-expanded",
                    "aria-haspopup",
                  ]
                ))
        );
      },
    });
  var o3 = ct(a3, [["__file", "trigger.vue"]]);
  const mu = "focus-trap.focus-after-trapped",
    gu = "focus-trap.focus-after-released",
    l3 = "focus-trap.focusout-prevented",
    f0 = { cancelable: !0, bubbles: !1 },
    h3 = { cancelable: !0, bubbles: !1 },
    p0 = "focusAfterTrapped",
    m0 = "focusAfterReleased",
    c3 = Symbol("elFocusTrap"),
    Xp = he(),
    kc = he(0),
    zp = he(0);
  let Bl = 0;
  const Nx = (r) => {
      const e = [],
        t = document.createTreeWalker(r, NodeFilter.SHOW_ELEMENT, {
          acceptNode: (i) => {
            const s = i.tagName === "INPUT" && i.type === "hidden";
            return i.disabled || i.hidden || s
              ? NodeFilter.FILTER_SKIP
              : i.tabIndex >= 0 || i === document.activeElement
              ? NodeFilter.FILTER_ACCEPT
              : NodeFilter.FILTER_SKIP;
          },
        });
      for (; t.nextNode(); ) e.push(t.currentNode);
      return e;
    },
    g0 = (r, e) => {
      for (const t of r) if (!u3(t, e)) return t;
    },
    u3 = (r, e) => {
      if (getComputedStyle(r).visibility === "hidden") return !0;
      for (; r; ) {
        if (e && r === e) return !1;
        if (getComputedStyle(r).display === "none") return !0;
        r = r.parentElement;
      }
      return !1;
    },
    d3 = (r) => {
      const e = Nx(r),
        t = g0(e, r),
        i = g0(e.reverse(), r);
      return [t, i];
    },
    f3 = (r) => r instanceof HTMLInputElement && "select" in r,
    Is = (r, e) => {
      if (r && r.focus) {
        const t = document.activeElement;
        r.focus({ preventScroll: !0 }),
          (zp.value = window.performance.now()),
          r !== t && f3(r) && e && r.select();
      }
    };
  function v0(r, e) {
    const t = [...r],
      i = r.indexOf(e);
    return i !== -1 && t.splice(i, 1), t;
  }
  const p3 = () => {
      let r = [];
      return {
        push: (i) => {
          const s = r[0];
          s && i !== s && s.pause(), (r = v0(r, i)), r.unshift(i);
        },
        remove: (i) => {
          var s, n;
          (r = v0(r, i)),
            (n = (s = r[0]) == null ? void 0 : s.resume) == null || n.call(s);
        },
      };
    },
    m3 = (r, e = !1) => {
      const t = document.activeElement;
      for (const i of r) if ((Is(i, e), document.activeElement !== t)) return;
    },
    y0 = p3(),
    g3 = () => kc.value > zp.value,
    Ol = () => {
      (Xp.value = "pointer"), (kc.value = window.performance.now());
    },
    b0 = () => {
      (Xp.value = "keyboard"), (kc.value = window.performance.now());
    },
    v3 = () => (
      Rt(() => {
        Bl === 0 &&
          (document.addEventListener("mousedown", Ol),
          document.addEventListener("touchstart", Ol),
          document.addEventListener("keydown", b0)),
          Bl++;
      }),
      Or(() => {
        Bl--,
          Bl <= 0 &&
            (document.removeEventListener("mousedown", Ol),
            document.removeEventListener("touchstart", Ol),
            document.removeEventListener("keydown", b0));
      }),
      {
        focusReason: Xp,
        lastUserFocusTimestamp: kc,
        lastAutomatedFocusTimestamp: zp,
      }
    ),
    kl = (r) => new CustomEvent(l3, { ...h3, detail: r }),
    y3 = ge({
      name: "ElFocusTrap",
      inheritAttrs: !1,
      props: {
        loop: Boolean,
        trapped: Boolean,
        focusTrapEl: Object,
        focusStartEl: { type: [Object, String], default: "first" },
      },
      emits: [
        p0,
        m0,
        "focusin",
        "focusout",
        "focusout-prevented",
        "release-requested",
      ],
      setup(r, { emit: e }) {
        const t = he();
        let i, s;
        const { focusReason: n } = v3();
        dM((p) => {
          r.trapped && !a.paused && e("release-requested", p);
        });
        const a = {
            paused: !1,
            pause() {
              this.paused = !0;
            },
            resume() {
              this.paused = !1;
            },
          },
          o = (p) => {
            if ((!r.loop && !r.trapped) || a.paused) return;
            const {
                key: m,
                altKey: v,
                ctrlKey: g,
                metaKey: x,
                currentTarget: b,
                shiftKey: y,
              } = p,
              { loop: _ } = r,
              w = m === ii.tab && !v && !g && !x,
              E = document.activeElement;
            if (w && E) {
              const A = b,
                [C, F] = d3(A);
              if (C && F) {
                if (!y && E === F) {
                  const R = kl({ focusReason: n.value });
                  e("focusout-prevented", R),
                    R.defaultPrevented || (p.preventDefault(), _ && Is(C, !0));
                } else if (y && [C, A].includes(E)) {
                  const R = kl({ focusReason: n.value });
                  e("focusout-prevented", R),
                    R.defaultPrevented || (p.preventDefault(), _ && Is(F, !0));
                }
              } else if (E === A) {
                const R = kl({ focusReason: n.value });
                e("focusout-prevented", R),
                  R.defaultPrevented || p.preventDefault();
              }
            }
          };
        Fr(c3, { focusTrapRef: t, onKeydown: o }),
          De(
            () => r.focusTrapEl,
            (p) => {
              p && (t.value = p);
            },
            { immediate: !0 }
          ),
          De([t], ([p], [m]) => {
            p &&
              (p.addEventListener("keydown", o),
              p.addEventListener("focusin", c),
              p.addEventListener("focusout", u)),
              m &&
                (m.removeEventListener("keydown", o),
                m.removeEventListener("focusin", c),
                m.removeEventListener("focusout", u));
          });
        const l = (p) => {
            e(p0, p);
          },
          h = (p) => e(m0, p),
          c = (p) => {
            const m = S(t);
            if (!m) return;
            const v = p.target,
              g = p.relatedTarget,
              x = v && m.contains(v);
            r.trapped || (g && m.contains(g)) || (i = g),
              x && e("focusin", p),
              !a.paused && r.trapped && (x ? (s = v) : Is(s, !0));
          },
          u = (p) => {
            const m = S(t);
            if (!(a.paused || !m))
              if (r.trapped) {
                const v = p.relatedTarget;
                !Ni(v) &&
                  !m.contains(v) &&
                  setTimeout(() => {
                    if (!a.paused && r.trapped) {
                      const g = kl({ focusReason: n.value });
                      e("focusout-prevented", g),
                        g.defaultPrevented || Is(s, !0);
                    }
                  }, 0);
              } else {
                const v = p.target;
                (v && m.contains(v)) || e("focusout", p);
              }
          };
        async function d() {
          await _t();
          const p = S(t);
          if (p) {
            y0.push(a);
            const m = p.contains(document.activeElement)
              ? i
              : document.activeElement;
            if (((i = m), !p.contains(m))) {
              const g = new Event(mu, f0);
              p.addEventListener(mu, l),
                p.dispatchEvent(g),
                g.defaultPrevented ||
                  _t(() => {
                    let x = r.focusStartEl;
                    Ge(x) ||
                      (Is(x), document.activeElement !== x && (x = "first")),
                      x === "first" && m3(Nx(p), !0),
                      (document.activeElement === m || x === "container") &&
                        Is(p);
                  });
            }
          }
        }
        function f() {
          const p = S(t);
          if (p) {
            p.removeEventListener(mu, l);
            const m = new CustomEvent(gu, {
              ...f0,
              detail: { focusReason: n.value },
            });
            p.addEventListener(gu, h),
              p.dispatchEvent(m),
              !m.defaultPrevented &&
                (n.value == "keyboard" ||
                  !g3() ||
                  p.contains(document.activeElement)) &&
                Is(i ?? document.body),
              p.removeEventListener(gu, h),
              y0.remove(a);
          }
        }
        return (
          Rt(() => {
            r.trapped && d(),
              De(
                () => r.trapped,
                (p) => {
                  p ? d() : f();
                }
              );
          }),
          Or(() => {
            r.trapped && f(),
              t.value &&
                (t.value.removeEventListener("keydown", o),
                t.value.removeEventListener("focusin", c),
                t.value.removeEventListener("focusout", u),
                (t.value = void 0));
          }),
          { onKeydown: o }
        );
      },
    });
  function b3(r, e, t, i, s, n) {
    return Xe(r.$slots, "default", { handleKeydown: r.onKeydown });
  }
  var x3 = ct(y3, [
    ["render", b3],
    ["__file", "focus-trap.vue"],
  ]);
  const _3 = ["fixed", "absolute"],
    w3 = et({
      boundariesPadding: { type: Number, default: 0 },
      fallbackPlacements: { type: Ne(Array), default: void 0 },
      gpuAcceleration: { type: Boolean, default: !0 },
      offset: { type: Number, default: 12 },
      placement: { type: String, values: fl, default: "bottom" },
      popperOptions: { type: Ne(Object), default: () => ({}) },
      strategy: { type: String, values: _3, default: "absolute" },
    }),
    Ux = et({
      ...w3,
      id: String,
      style: { type: Ne([String, Array, Object]) },
      className: { type: Ne([String, Array, Object]) },
      effect: { type: Ne(String), default: "dark" },
      visible: Boolean,
      enterable: { type: Boolean, default: !0 },
      pure: Boolean,
      focusOnShow: { type: Boolean, default: !1 },
      trapping: { type: Boolean, default: !1 },
      popperClass: { type: Ne([String, Array, Object]) },
      popperStyle: { type: Ne([String, Array, Object]) },
      referenceEl: { type: Ne(Object) },
      triggerTargetEl: { type: Ne(Object) },
      stopPopperMouseEvent: { type: Boolean, default: !0 },
      virtualTriggering: Boolean,
      zIndex: Number,
      ...en(["ariaLabel"]),
    }),
    T3 = {
      mouseenter: (r) => r instanceof MouseEvent,
      mouseleave: (r) => r instanceof MouseEvent,
      focus: () => !0,
      blur: () => !0,
      close: () => !0,
    },
    E3 = (r, e = []) => {
      const { placement: t, strategy: i, popperOptions: s } = r,
        n = { placement: t, strategy: i, ...s, modifiers: [...A3(r), ...e] };
      return C3(n, s == null ? void 0 : s.modifiers), n;
    },
    S3 = (r) => {
      if (It) return Us(r);
    };
  function A3(r) {
    const { offset: e, gpuAcceleration: t, fallbackPlacements: i } = r;
    return [
      { name: "offset", options: { offset: [0, e ?? 12] } },
      {
        name: "preventOverflow",
        options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } },
      },
      { name: "flip", options: { padding: 5, fallbackPlacements: i } },
      { name: "computeStyles", options: { gpuAcceleration: t } },
    ];
  }
  function C3(r, e) {
    e && (r.modifiers = [...r.modifiers, ...(e ?? [])]);
  }
  const I3 = 0,
    P3 = (r) => {
      const {
          popperInstanceRef: e,
          contentRef: t,
          triggerRef: i,
          role: s,
        } = rt(Hp, void 0),
        n = he(),
        a = he(),
        o = X(() => ({ name: "eventListeners", enabled: !!r.visible })),
        l = X(() => {
          var g;
          const x = S(n),
            b = (g = S(a)) != null ? g : I3;
          return {
            name: "arrow",
            enabled: !JI(x),
            options: { element: x, padding: b },
          };
        }),
        h = X(() => ({
          onFirstUpdate: () => {
            p();
          },
          ...E3(r, [S(l), S(o)]),
        })),
        c = X(() => S3(r.referenceEl) || S(i)),
        {
          attributes: u,
          state: d,
          styles: f,
          update: p,
          forceUpdate: m,
          instanceRef: v,
        } = hM(c, t, h);
      return (
        De(v, (g) => (e.value = g)),
        Rt(() => {
          De(
            () => {
              var g;
              return (g = S(c)) == null ? void 0 : g.getBoundingClientRect();
            },
            () => {
              p();
            }
          );
        }),
        {
          attributes: u,
          arrowRef: n,
          contentRef: t,
          instanceRef: v,
          state: d,
          styles: f,
          role: s,
          forceUpdate: m,
          update: p,
        }
      );
    },
    R3 = (r, { attributes: e, styles: t, role: i }) => {
      const { nextZIndex: s } = Rx(),
        n = ut("popper"),
        a = X(() => S(e).popper),
        o = he(at(r.zIndex) ? r.zIndex : s()),
        l = X(() => [
          n.b(),
          n.is("pure", r.pure),
          n.is(r.effect),
          r.popperClass,
        ]),
        h = X(() => [{ zIndex: S(o) }, S(t).popper, r.popperStyle || {}]),
        c = X(() => (i.value === "dialog" ? "false" : void 0)),
        u = X(() => S(t).arrow || {});
      return {
        ariaModal: c,
        arrowStyle: u,
        contentAttrs: a,
        contentClass: l,
        contentStyle: h,
        contentZIndex: o,
        updateZIndex: () => {
          o.value = at(r.zIndex) ? r.zIndex : s();
        },
      };
    },
    M3 = (r, e) => {
      const t = he(!1),
        i = he();
      return {
        focusStartRef: i,
        trapped: t,
        onFocusAfterReleased: (h) => {
          var c;
          ((c = h.detail) == null ? void 0 : c.focusReason) !== "pointer" &&
            ((i.value = "first"), e("blur"));
        },
        onFocusAfterTrapped: () => {
          e("focus");
        },
        onFocusInTrap: (h) => {
          r.visible &&
            !t.value &&
            (h.target && (i.value = h.target), (t.value = !0));
        },
        onFocusoutPrevented: (h) => {
          r.trapping ||
            (h.detail.focusReason === "pointer" && h.preventDefault(),
            (t.value = !1));
        },
        onReleaseRequested: () => {
          (t.value = !1), e("close");
        },
      };
    },
    F3 = ge({ name: "ElPopperContent" }),
    B3 = ge({
      ...F3,
      props: Ux,
      emits: T3,
      setup(r, { expose: e, emit: t }) {
        const i = r,
          {
            focusStartRef: s,
            trapped: n,
            onFocusAfterReleased: a,
            onFocusAfterTrapped: o,
            onFocusInTrap: l,
            onFocusoutPrevented: h,
            onReleaseRequested: c,
          } = M3(i, t),
          {
            attributes: u,
            arrowRef: d,
            contentRef: f,
            styles: p,
            instanceRef: m,
            role: v,
            update: g,
          } = P3(i),
          {
            ariaModal: x,
            arrowStyle: b,
            contentAttrs: y,
            contentClass: _,
            contentStyle: w,
            updateZIndex: E,
          } = R3(i, { styles: p, attributes: u, role: v }),
          A = rt(On, void 0),
          C = he();
        Fr(Bx, { arrowStyle: b, arrowRef: d, arrowOffset: C }),
          A && Fr(On, { ...A, addInputId: ar, removeInputId: ar });
        let F;
        const B = (I = !0) => {
            g(), I && E();
          },
          R = () => {
            B(!1),
              i.visible && i.focusOnShow
                ? (n.value = !0)
                : i.visible === !1 && (n.value = !1);
          };
        return (
          Rt(() => {
            De(
              () => i.triggerTargetEl,
              (I, P) => {
                F == null || F(), (F = void 0);
                const M = S(I || f.value),
                  L = S(P || f.value);
                _a(M) &&
                  (F = De(
                    [v, () => i.ariaLabel, x, () => i.id],
                    (U) => {
                      ["role", "aria-label", "aria-modal", "id"].forEach(
                        (V, z) => {
                          Ni(U[z])
                            ? M.removeAttribute(V)
                            : M.setAttribute(V, U[z]);
                        }
                      );
                    },
                    { immediate: !0 }
                  )),
                  L !== M &&
                    _a(L) &&
                    ["role", "aria-label", "aria-modal", "id"].forEach((U) => {
                      L.removeAttribute(U);
                    });
              },
              { immediate: !0 }
            ),
              De(() => i.visible, R, { immediate: !0 });
          }),
          Or(() => {
            F == null || F(), (F = void 0);
          }),
          e({
            popperContentRef: f,
            popperInstanceRef: m,
            updatePopper: B,
            contentStyle: w,
          }),
          (I, P) => (
            j(),
            xe(
              "div",
              Gr({ ref_key: "contentRef", ref: f }, S(y), {
                style: S(w),
                class: S(_),
                tabindex: "-1",
                onMouseenter: (M) => I.$emit("mouseenter", M),
                onMouseleave: (M) => I.$emit("mouseleave", M),
              }),
              [
                ne(
                  S(x3),
                  {
                    trapped: S(n),
                    "trap-on-focus-in": !0,
                    "focus-trap-el": S(f),
                    "focus-start-el": S(s),
                    onFocusAfterTrapped: S(o),
                    onFocusAfterReleased: S(a),
                    onFocusin: S(l),
                    onFocusoutPrevented: S(h),
                    onReleaseRequested: S(c),
                  },
                  { default: be(() => [Xe(I.$slots, "default")]), _: 3 },
                  8,
                  [
                    "trapped",
                    "focus-trap-el",
                    "focus-start-el",
                    "onFocusAfterTrapped",
                    "onFocusAfterReleased",
                    "onFocusin",
                    "onFocusoutPrevented",
                    "onReleaseRequested",
                  ]
                ),
              ],
              16,
              ["onMouseenter", "onMouseleave"]
            )
          )
        );
      },
    });
  var O3 = ct(B3, [["__file", "content.vue"]]);
  const k3 = Qt(QF),
    Wp = Symbol("elTooltip"),
    Lh = et({
      ...mM,
      ...Ux,
      appendTo: { type: Ne([String, Object]) },
      content: { type: String, default: "" },
      rawContent: Boolean,
      persistent: Boolean,
      visible: { type: Ne(Boolean), default: null },
      transition: String,
      teleported: { type: Boolean, default: !0 },
      disabled: Boolean,
      ...en(["ariaLabel"]),
    }),
    Vx = et({
      ...Lx,
      disabled: Boolean,
      trigger: { type: Ne([String, Array]), default: "hover" },
      triggerKeys: { type: Ne(Array), default: () => [ii.enter, ii.space] },
    }),
    {
      useModelToggleProps: D3,
      useModelToggleEmits: L3,
      useModelToggle: N3,
    } = px("visible"),
    U3 = et({
      ...Ox,
      ...D3,
      ...Lh,
      ...Vx,
      ...kx,
      showArrow: { type: Boolean, default: !0 },
    }),
    V3 = [...L3, "before-show", "before-hide", "show", "hide", "open", "close"],
    $3 = (r, e) => (Oe(r) ? r.includes(e) : r === e),
    Yn = (r, e, t) => (i) => {
      $3(S(r), e) && t(i);
    },
    G3 = ge({ name: "ElTooltipTrigger" }),
    H3 = ge({
      ...G3,
      props: Vx,
      setup(r, { expose: e }) {
        const t = r,
          i = ut("tooltip"),
          {
            controlled: s,
            id: n,
            open: a,
            onOpen: o,
            onClose: l,
            onToggle: h,
          } = rt(Wp, void 0),
          c = he(null),
          u = () => {
            if (S(s) || t.disabled) return !0;
          },
          d = ni(t, "trigger"),
          f = rs(u, Yn(d, "hover", o)),
          p = rs(u, Yn(d, "hover", l)),
          m = rs(
            u,
            Yn(d, "click", (y) => {
              y.button === 0 && h(y);
            })
          ),
          v = rs(u, Yn(d, "focus", o)),
          g = rs(u, Yn(d, "focus", l)),
          x = rs(
            u,
            Yn(d, "contextmenu", (y) => {
              y.preventDefault(), h(y);
            })
          ),
          b = rs(u, (y) => {
            const { code: _ } = y;
            t.triggerKeys.includes(_) && (y.preventDefault(), h(y));
          });
        return (
          e({ triggerRef: c }),
          (y, _) => (
            j(),
            Me(
              S(o3),
              {
                id: S(n),
                "virtual-ref": y.virtualRef,
                open: S(a),
                "virtual-triggering": y.virtualTriggering,
                class: ce(S(i).e("trigger")),
                onBlur: S(g),
                onClick: S(m),
                onContextmenu: S(x),
                onFocus: S(v),
                onMouseenter: S(f),
                onMouseleave: S(p),
                onKeydown: S(b),
              },
              { default: be(() => [Xe(y.$slots, "default")]), _: 3 },
              8,
              [
                "id",
                "virtual-ref",
                "open",
                "virtual-triggering",
                "class",
                "onBlur",
                "onClick",
                "onContextmenu",
                "onFocus",
                "onMouseenter",
                "onMouseleave",
                "onKeydown",
              ]
            )
          )
        );
      },
    });
  var X3 = ct(H3, [["__file", "trigger.vue"]]);
  const z3 = et({
      to: { type: Ne([String, Object]), required: !0 },
      disabled: Boolean,
    }),
    W3 = ge({
      __name: "teleport",
      props: z3,
      setup(r) {
        return (e, t) =>
          e.disabled
            ? Xe(e.$slots, "default", { key: 0 })
            : (j(),
              Me(DT, { key: 1, to: e.to }, [Xe(e.$slots, "default")], 8, [
                "to",
              ]));
      },
    });
  var Y3 = ct(W3, [["__file", "teleport.vue"]]);
  const $x = Qt(Y3),
    j3 = ge({ name: "ElTooltipContent", inheritAttrs: !1 }),
    q3 = ge({
      ...j3,
      props: Lh,
      setup(r, { expose: e }) {
        const t = r,
          { selector: i } = Ix(),
          s = ut("tooltip"),
          n = he(null);
        let a;
        const {
            controlled: o,
            id: l,
            open: h,
            trigger: c,
            onClose: u,
            onOpen: d,
            onShow: f,
            onHide: p,
            onBeforeShow: m,
            onBeforeHide: v,
          } = rt(Wp, void 0),
          g = X(() => t.transition || `${s.namespace.value}-fade-in-linear`),
          x = X(() => t.persistent);
        Or(() => {
          a == null || a();
        });
        const b = X(() => (S(x) ? !0 : S(h))),
          y = X(() => (t.disabled ? !1 : S(h))),
          _ = X(() => t.appendTo || i.value),
          w = X(() => {
            var L;
            return (L = t.style) != null ? L : {};
          }),
          E = he(!0),
          A = () => {
            p(), (E.value = !0);
          },
          C = () => {
            if (S(o)) return !0;
          },
          F = rs(C, () => {
            t.enterable && S(c) === "hover" && d();
          }),
          B = rs(C, () => {
            S(c) === "hover" && u();
          }),
          R = () => {
            var L, U;
            (U = (L = n.value) == null ? void 0 : L.updatePopper) == null ||
              U.call(L),
              m == null || m();
          },
          I = () => {
            v == null || v();
          },
          P = () => {
            f(),
              (a = AS(
                X(() => {
                  var L;
                  return (L = n.value) == null ? void 0 : L.popperContentRef;
                }),
                () => {
                  if (S(o)) return;
                  S(c) !== "hover" && u();
                }
              ));
          },
          M = () => {
            t.virtualTriggering || u();
          };
        return (
          De(
            () => S(h),
            (L) => {
              L ? (E.value = !1) : a == null || a();
            },
            { flush: "post" }
          ),
          De(
            () => t.content,
            () => {
              var L, U;
              (U = (L = n.value) == null ? void 0 : L.updatePopper) == null ||
                U.call(L);
            }
          ),
          e({ contentRef: n }),
          (L, U) => (
            j(),
            Me(
              S($x),
              { disabled: !L.teleported, to: S(_) },
              {
                default: be(() => [
                  ne(
                    fp,
                    {
                      name: S(g),
                      onAfterLeave: A,
                      onBeforeEnter: R,
                      onAfterEnter: P,
                      onBeforeLeave: I,
                    },
                    {
                      default: be(() => [
                        S(b)
                          ? Ws(
                              (j(),
                              Me(
                                S(O3),
                                Gr(
                                  {
                                    key: 0,
                                    id: S(l),
                                    ref_key: "contentRef",
                                    ref: n,
                                  },
                                  L.$attrs,
                                  {
                                    "aria-label": L.ariaLabel,
                                    "aria-hidden": E.value,
                                    "boundaries-padding": L.boundariesPadding,
                                    "fallback-placements": L.fallbackPlacements,
                                    "gpu-acceleration": L.gpuAcceleration,
                                    offset: L.offset,
                                    placement: L.placement,
                                    "popper-options": L.popperOptions,
                                    strategy: L.strategy,
                                    effect: L.effect,
                                    enterable: L.enterable,
                                    pure: L.pure,
                                    "popper-class": L.popperClass,
                                    "popper-style": [L.popperStyle, S(w)],
                                    "reference-el": L.referenceEl,
                                    "trigger-target-el": L.triggerTargetEl,
                                    visible: S(y),
                                    "z-index": L.zIndex,
                                    onMouseenter: S(F),
                                    onMouseleave: S(B),
                                    onBlur: M,
                                    onClose: S(u),
                                  }
                                ),
                                {
                                  default: be(() => [Xe(L.$slots, "default")]),
                                  _: 3,
                                },
                                16,
                                [
                                  "id",
                                  "aria-label",
                                  "aria-hidden",
                                  "boundaries-padding",
                                  "fallback-placements",
                                  "gpu-acceleration",
                                  "offset",
                                  "placement",
                                  "popper-options",
                                  "strategy",
                                  "effect",
                                  "enterable",
                                  "pure",
                                  "popper-class",
                                  "popper-style",
                                  "reference-el",
                                  "trigger-target-el",
                                  "visible",
                                  "z-index",
                                  "onMouseenter",
                                  "onMouseleave",
                                  "onClose",
                                ]
                              )),
                              [[pp, S(y)]]
                            )
                          : Re("v-if", !0),
                      ]),
                      _: 3,
                    },
                    8,
                    ["name"]
                  ),
                ]),
                _: 3,
              },
              8,
              ["disabled", "to"]
            )
          )
        );
      },
    });
  var K3 = ct(q3, [["__file", "content.vue"]]);
  const Z3 = ge({ name: "ElTooltip" }),
    J3 = ge({
      ...Z3,
      props: U3,
      emits: V3,
      setup(r, { expose: e, emit: t }) {
        const i = r;
        pM();
        const s = Bc(),
          n = he(),
          a = he(),
          o = () => {
            var g;
            const x = S(n);
            x && ((g = x.popperInstanceRef) == null || g.update());
          },
          l = he(!1),
          h = he(),
          {
            show: c,
            hide: u,
            hasUpdateHandler: d,
          } = N3({ indicator: l, toggleReason: h }),
          { onOpen: f, onClose: p } = gM({
            showAfter: ni(i, "showAfter"),
            hideAfter: ni(i, "hideAfter"),
            autoClose: ni(i, "autoClose"),
            open: c,
            close: u,
          }),
          m = X(() => Ui(i.visible) && !d.value);
        Fr(Wp, {
          controlled: m,
          id: s,
          open: ep(l),
          trigger: ni(i, "trigger"),
          onOpen: (g) => {
            f(g);
          },
          onClose: (g) => {
            p(g);
          },
          onToggle: (g) => {
            S(l) ? p(g) : f(g);
          },
          onShow: () => {
            t("show", h.value);
          },
          onHide: () => {
            t("hide", h.value);
          },
          onBeforeShow: () => {
            t("before-show", h.value);
          },
          onBeforeHide: () => {
            t("before-hide", h.value);
          },
          updatePopper: o,
        }),
          De(
            () => i.disabled,
            (g) => {
              g && l.value && (l.value = !1);
            }
          );
        const v = (g) => {
          var x, b;
          const y =
              (b = (x = a.value) == null ? void 0 : x.contentRef) == null
                ? void 0
                : b.popperContentRef,
            _ =
              (g == null ? void 0 : g.relatedTarget) || document.activeElement;
          return y && y.contains(_);
        };
        return (
          Qy(() => l.value && u()),
          e({
            popperRef: n,
            contentRef: a,
            isFocusInsideContent: v,
            updatePopper: o,
            onOpen: f,
            onClose: p,
            hide: u,
          }),
          (g, x) => (
            j(),
            Me(
              S(k3),
              { ref_key: "popperRef", ref: n, role: g.role },
              {
                default: be(() => [
                  ne(
                    X3,
                    {
                      disabled: g.disabled,
                      trigger: g.trigger,
                      "trigger-keys": g.triggerKeys,
                      "virtual-ref": g.virtualRef,
                      "virtual-triggering": g.virtualTriggering,
                    },
                    {
                      default: be(() => [
                        g.$slots.default
                          ? Xe(g.$slots, "default", { key: 0 })
                          : Re("v-if", !0),
                      ]),
                      _: 3,
                    },
                    8,
                    [
                      "disabled",
                      "trigger",
                      "trigger-keys",
                      "virtual-ref",
                      "virtual-triggering",
                    ]
                  ),
                  ne(
                    K3,
                    {
                      ref_key: "contentRef",
                      ref: a,
                      "aria-label": g.ariaLabel,
                      "boundaries-padding": g.boundariesPadding,
                      content: g.content,
                      disabled: g.disabled,
                      effect: g.effect,
                      enterable: g.enterable,
                      "fallback-placements": g.fallbackPlacements,
                      "hide-after": g.hideAfter,
                      "gpu-acceleration": g.gpuAcceleration,
                      offset: g.offset,
                      persistent: g.persistent,
                      "popper-class": g.popperClass,
                      "popper-style": g.popperStyle,
                      placement: g.placement,
                      "popper-options": g.popperOptions,
                      pure: g.pure,
                      "raw-content": g.rawContent,
                      "reference-el": g.referenceEl,
                      "trigger-target-el": g.triggerTargetEl,
                      "show-after": g.showAfter,
                      strategy: g.strategy,
                      teleported: g.teleported,
                      transition: g.transition,
                      "virtual-triggering": g.virtualTriggering,
                      "z-index": g.zIndex,
                      "append-to": g.appendTo,
                    },
                    {
                      default: be(() => [
                        Xe(g.$slots, "content", {}, () => [
                          g.rawContent
                            ? (j(),
                              xe(
                                "span",
                                { key: 0, innerHTML: g.content },
                                null,
                                8,
                                ["innerHTML"]
                              ))
                            : (j(), xe("span", { key: 1 }, Ut(g.content), 1)),
                        ]),
                        g.showArrow
                          ? (j(),
                            Me(
                              S(r3),
                              { key: 0, "arrow-offset": g.arrowOffset },
                              null,
                              8,
                              ["arrow-offset"]
                            ))
                          : Re("v-if", !0),
                      ]),
                      _: 3,
                    },
                    8,
                    [
                      "aria-label",
                      "boundaries-padding",
                      "content",
                      "disabled",
                      "effect",
                      "enterable",
                      "fallback-placements",
                      "hide-after",
                      "gpu-acceleration",
                      "offset",
                      "persistent",
                      "popper-class",
                      "popper-style",
                      "placement",
                      "popper-options",
                      "pure",
                      "raw-content",
                      "reference-el",
                      "trigger-target-el",
                      "show-after",
                      "strategy",
                      "teleported",
                      "transition",
                      "virtual-triggering",
                      "z-index",
                      "append-to",
                    ]
                  ),
                ]),
                _: 3,
              },
              8,
              ["role"]
            )
          )
        );
      },
    });
  var Q3 = ct(J3, [["__file", "tooltip.vue"]]);
  const Gx = Qt(Q3),
    Hx = Symbol("buttonGroupContextKey"),
    eB = (r, e) => {
      fx(
        {
          from: "type.text",
          replacement: "link",
          version: "3.0.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/button.html#button-attributes",
        },
        X(() => r.type === "text")
      );
      const t = rt(Hx, void 0),
        i = IM("button"),
        { form: s } = Ja(),
        n = ws(X(() => (t == null ? void 0 : t.size))),
        a = Za(),
        o = he(),
        l = lp(),
        h = X(() => r.type || (t == null ? void 0 : t.type) || ""),
        c = X(() => {
          var p, m, v;
          return (v =
            (m = r.autoInsertSpace) != null
              ? m
              : (p = i.value) == null
              ? void 0
              : p.autoInsertSpace) != null
            ? v
            : !1;
        }),
        u = X(() =>
          r.tag === "button"
            ? {
                ariaDisabled: a.value || r.loading,
                disabled: a.value || r.loading,
                autofocus: r.autofocus,
                type: r.nativeType,
              }
            : {}
        ),
        d = X(() => {
          var p;
          const m = (p = l.default) == null ? void 0 : p.call(l);
          if (c.value && (m == null ? void 0 : m.length) === 1) {
            const v = m[0];
            if ((v == null ? void 0 : v.type) === Wa) {
              const g = v.children;
              return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(
                g.trim()
              );
            }
          }
          return !1;
        });
      return {
        _disabled: a,
        _size: n,
        _type: h,
        _ref: o,
        _props: u,
        shouldAddSpace: d,
        handleClick: (p) => {
          if (a.value || r.loading) {
            p.stopPropagation();
            return;
          }
          r.nativeType === "reset" && (s == null || s.resetFields()),
            e("click", p);
        },
      };
    },
    kd = [
      "default",
      "primary",
      "success",
      "warning",
      "info",
      "danger",
      "text",
      "",
    ],
    tB = ["button", "submit", "reset"],
    Dd = et({
      size: Bn,
      disabled: Boolean,
      type: { type: String, values: kd, default: "" },
      icon: { type: hs },
      nativeType: { type: String, values: tB, default: "button" },
      loading: Boolean,
      loadingIcon: { type: hs, default: () => Mp },
      plain: Boolean,
      text: Boolean,
      link: Boolean,
      bg: Boolean,
      autofocus: Boolean,
      round: Boolean,
      circle: Boolean,
      color: String,
      dark: Boolean,
      autoInsertSpace: { type: Boolean, default: void 0 },
      tag: { type: Ne([String, Object]), default: "button" },
    }),
    rB = { click: (r) => r instanceof MouseEvent };
  function Jt(r, e) {
    iB(r) && (r = "100%");
    var t = sB(r);
    return (
      (r = e === 360 ? r : Math.min(e, Math.max(0, parseFloat(r)))),
      t && (r = parseInt(String(r * e), 10) / 100),
      Math.abs(r - e) < 1e-6
        ? 1
        : (e === 360
            ? (r = (r < 0 ? (r % e) + e : r % e) / parseFloat(String(e)))
            : (r = (r % e) / parseFloat(String(e))),
          r)
    );
  }
  function Dl(r) {
    return Math.min(1, Math.max(0, r));
  }
  function iB(r) {
    return typeof r == "string" && r.indexOf(".") !== -1 && parseFloat(r) === 1;
  }
  function sB(r) {
    return typeof r == "string" && r.indexOf("%") !== -1;
  }
  function Xx(r) {
    return (r = parseFloat(r)), (isNaN(r) || r < 0 || r > 1) && (r = 1), r;
  }
  function Ll(r) {
    return r <= 1 ? "".concat(Number(r) * 100, "%") : r;
  }
  function bn(r) {
    return r.length === 1 ? "0" + r : String(r);
  }
  function nB(r, e, t) {
    return { r: Jt(r, 255) * 255, g: Jt(e, 255) * 255, b: Jt(t, 255) * 255 };
  }
  function x0(r, e, t) {
    (r = Jt(r, 255)), (e = Jt(e, 255)), (t = Jt(t, 255));
    var i = Math.max(r, e, t),
      s = Math.min(r, e, t),
      n = 0,
      a = 0,
      o = (i + s) / 2;
    if (i === s) (a = 0), (n = 0);
    else {
      var l = i - s;
      switch (((a = o > 0.5 ? l / (2 - i - s) : l / (i + s)), i)) {
        case r:
          n = (e - t) / l + (e < t ? 6 : 0);
          break;
        case e:
          n = (t - r) / l + 2;
          break;
        case t:
          n = (r - e) / l + 4;
          break;
      }
      n /= 6;
    }
    return { h: n, s: a, l: o };
  }
  function vu(r, e, t) {
    return (
      t < 0 && (t += 1),
      t > 1 && (t -= 1),
      t < 1 / 6
        ? r + (e - r) * (6 * t)
        : t < 1 / 2
        ? e
        : t < 2 / 3
        ? r + (e - r) * (2 / 3 - t) * 6
        : r
    );
  }
  function aB(r, e, t) {
    var i, s, n;
    if (((r = Jt(r, 360)), (e = Jt(e, 100)), (t = Jt(t, 100)), e === 0))
      (s = t), (n = t), (i = t);
    else {
      var a = t < 0.5 ? t * (1 + e) : t + e - t * e,
        o = 2 * t - a;
      (i = vu(o, a, r + 1 / 3)), (s = vu(o, a, r)), (n = vu(o, a, r - 1 / 3));
    }
    return { r: i * 255, g: s * 255, b: n * 255 };
  }
  function _0(r, e, t) {
    (r = Jt(r, 255)), (e = Jt(e, 255)), (t = Jt(t, 255));
    var i = Math.max(r, e, t),
      s = Math.min(r, e, t),
      n = 0,
      a = i,
      o = i - s,
      l = i === 0 ? 0 : o / i;
    if (i === s) n = 0;
    else {
      switch (i) {
        case r:
          n = (e - t) / o + (e < t ? 6 : 0);
          break;
        case e:
          n = (t - r) / o + 2;
          break;
        case t:
          n = (r - e) / o + 4;
          break;
      }
      n /= 6;
    }
    return { h: n, s: l, v: a };
  }
  function oB(r, e, t) {
    (r = Jt(r, 360) * 6), (e = Jt(e, 100)), (t = Jt(t, 100));
    var i = Math.floor(r),
      s = r - i,
      n = t * (1 - e),
      a = t * (1 - s * e),
      o = t * (1 - (1 - s) * e),
      l = i % 6,
      h = [t, a, n, n, o, t][l],
      c = [o, t, t, a, n, n][l],
      u = [n, n, o, t, t, a][l];
    return { r: h * 255, g: c * 255, b: u * 255 };
  }
  function w0(r, e, t, i) {
    var s = [
      bn(Math.round(r).toString(16)),
      bn(Math.round(e).toString(16)),
      bn(Math.round(t).toString(16)),
    ];
    return i &&
      s[0].startsWith(s[0].charAt(1)) &&
      s[1].startsWith(s[1].charAt(1)) &&
      s[2].startsWith(s[2].charAt(1))
      ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0)
      : s.join("");
  }
  function lB(r, e, t, i, s) {
    var n = [
      bn(Math.round(r).toString(16)),
      bn(Math.round(e).toString(16)),
      bn(Math.round(t).toString(16)),
      bn(hB(i)),
    ];
    return s &&
      n[0].startsWith(n[0].charAt(1)) &&
      n[1].startsWith(n[1].charAt(1)) &&
      n[2].startsWith(n[2].charAt(1)) &&
      n[3].startsWith(n[3].charAt(1))
      ? n[0].charAt(0) + n[1].charAt(0) + n[2].charAt(0) + n[3].charAt(0)
      : n.join("");
  }
  function hB(r) {
    return Math.round(parseFloat(r) * 255).toString(16);
  }
  function T0(r) {
    return Er(r) / 255;
  }
  function Er(r) {
    return parseInt(r, 16);
  }
  function cB(r) {
    return { r: r >> 16, g: (r & 65280) >> 8, b: r & 255 };
  }
  var Ld = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    goldenrod: "#daa520",
    gold: "#ffd700",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavenderblush: "#fff0f5",
    lavender: "#e6e6fa",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32",
  };
  function uB(r) {
    var e = { r: 0, g: 0, b: 0 },
      t = 1,
      i = null,
      s = null,
      n = null,
      a = !1,
      o = !1;
    return (
      typeof r == "string" && (r = pB(r)),
      typeof r == "object" &&
        (Zi(r.r) && Zi(r.g) && Zi(r.b)
          ? ((e = nB(r.r, r.g, r.b)),
            (a = !0),
            (o = String(r.r).substr(-1) === "%" ? "prgb" : "rgb"))
          : Zi(r.h) && Zi(r.s) && Zi(r.v)
          ? ((i = Ll(r.s)),
            (s = Ll(r.v)),
            (e = oB(r.h, i, s)),
            (a = !0),
            (o = "hsv"))
          : Zi(r.h) &&
            Zi(r.s) &&
            Zi(r.l) &&
            ((i = Ll(r.s)),
            (n = Ll(r.l)),
            (e = aB(r.h, i, n)),
            (a = !0),
            (o = "hsl")),
        Object.prototype.hasOwnProperty.call(r, "a") && (t = r.a)),
      (t = Xx(t)),
      {
        ok: a,
        format: r.format || o,
        r: Math.min(255, Math.max(e.r, 0)),
        g: Math.min(255, Math.max(e.g, 0)),
        b: Math.min(255, Math.max(e.b, 0)),
        a: t,
      }
    );
  }
  var dB = "[-\\+]?\\d+%?",
    fB = "[-\\+]?\\d*\\.\\d+%?",
    Vs = "(?:".concat(fB, ")|(?:").concat(dB, ")"),
    yu = "[\\s|\\(]+("
      .concat(Vs, ")[,|\\s]+(")
      .concat(Vs, ")[,|\\s]+(")
      .concat(Vs, ")\\s*\\)?"),
    bu = "[\\s|\\(]+("
      .concat(Vs, ")[,|\\s]+(")
      .concat(Vs, ")[,|\\s]+(")
      .concat(Vs, ")[,|\\s]+(")
      .concat(Vs, ")\\s*\\)?"),
    ei = {
      CSS_UNIT: new RegExp(Vs),
      rgb: new RegExp("rgb" + yu),
      rgba: new RegExp("rgba" + bu),
      hsl: new RegExp("hsl" + yu),
      hsla: new RegExp("hsla" + bu),
      hsv: new RegExp("hsv" + yu),
      hsva: new RegExp("hsva" + bu),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    };
  function pB(r) {
    if (((r = r.trim().toLowerCase()), r.length === 0)) return !1;
    var e = !1;
    if (Ld[r]) (r = Ld[r]), (e = !0);
    else if (r === "transparent")
      return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    var t = ei.rgb.exec(r);
    return t
      ? { r: t[1], g: t[2], b: t[3] }
      : ((t = ei.rgba.exec(r)),
        t
          ? { r: t[1], g: t[2], b: t[3], a: t[4] }
          : ((t = ei.hsl.exec(r)),
            t
              ? { h: t[1], s: t[2], l: t[3] }
              : ((t = ei.hsla.exec(r)),
                t
                  ? { h: t[1], s: t[2], l: t[3], a: t[4] }
                  : ((t = ei.hsv.exec(r)),
                    t
                      ? { h: t[1], s: t[2], v: t[3] }
                      : ((t = ei.hsva.exec(r)),
                        t
                          ? { h: t[1], s: t[2], v: t[3], a: t[4] }
                          : ((t = ei.hex8.exec(r)),
                            t
                              ? {
                                  r: Er(t[1]),
                                  g: Er(t[2]),
                                  b: Er(t[3]),
                                  a: T0(t[4]),
                                  format: e ? "name" : "hex8",
                                }
                              : ((t = ei.hex6.exec(r)),
                                t
                                  ? {
                                      r: Er(t[1]),
                                      g: Er(t[2]),
                                      b: Er(t[3]),
                                      format: e ? "name" : "hex",
                                    }
                                  : ((t = ei.hex4.exec(r)),
                                    t
                                      ? {
                                          r: Er(t[1] + t[1]),
                                          g: Er(t[2] + t[2]),
                                          b: Er(t[3] + t[3]),
                                          a: T0(t[4] + t[4]),
                                          format: e ? "name" : "hex8",
                                        }
                                      : ((t = ei.hex3.exec(r)),
                                        t
                                          ? {
                                              r: Er(t[1] + t[1]),
                                              g: Er(t[2] + t[2]),
                                              b: Er(t[3] + t[3]),
                                              format: e ? "name" : "hex",
                                            }
                                          : !1)))))))));
  }
  function Zi(r) {
    return !!ei.CSS_UNIT.exec(String(r));
  }
  var mB = (function () {
    function r(e, t) {
      e === void 0 && (e = ""), t === void 0 && (t = {});
      var i;
      if (e instanceof r) return e;
      typeof e == "number" && (e = cB(e)), (this.originalInput = e);
      var s = uB(e);
      (this.originalInput = e),
        (this.r = s.r),
        (this.g = s.g),
        (this.b = s.b),
        (this.a = s.a),
        (this.roundA = Math.round(100 * this.a) / 100),
        (this.format = (i = t.format) !== null && i !== void 0 ? i : s.format),
        (this.gradientType = t.gradientType),
        this.r < 1 && (this.r = Math.round(this.r)),
        this.g < 1 && (this.g = Math.round(this.g)),
        this.b < 1 && (this.b = Math.round(this.b)),
        (this.isValid = s.ok);
    }
    return (
      (r.prototype.isDark = function () {
        return this.getBrightness() < 128;
      }),
      (r.prototype.isLight = function () {
        return !this.isDark();
      }),
      (r.prototype.getBrightness = function () {
        var e = this.toRgb();
        return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3;
      }),
      (r.prototype.getLuminance = function () {
        var e = this.toRgb(),
          t,
          i,
          s,
          n = e.r / 255,
          a = e.g / 255,
          o = e.b / 255;
        return (
          n <= 0.03928
            ? (t = n / 12.92)
            : (t = Math.pow((n + 0.055) / 1.055, 2.4)),
          a <= 0.03928
            ? (i = a / 12.92)
            : (i = Math.pow((a + 0.055) / 1.055, 2.4)),
          o <= 0.03928
            ? (s = o / 12.92)
            : (s = Math.pow((o + 0.055) / 1.055, 2.4)),
          0.2126 * t + 0.7152 * i + 0.0722 * s
        );
      }),
      (r.prototype.getAlpha = function () {
        return this.a;
      }),
      (r.prototype.setAlpha = function (e) {
        return (
          (this.a = Xx(e)), (this.roundA = Math.round(100 * this.a) / 100), this
        );
      }),
      (r.prototype.isMonochrome = function () {
        var e = this.toHsl().s;
        return e === 0;
      }),
      (r.prototype.toHsv = function () {
        var e = _0(this.r, this.g, this.b);
        return { h: e.h * 360, s: e.s, v: e.v, a: this.a };
      }),
      (r.prototype.toHsvString = function () {
        var e = _0(this.r, this.g, this.b),
          t = Math.round(e.h * 360),
          i = Math.round(e.s * 100),
          s = Math.round(e.v * 100);
        return this.a === 1
          ? "hsv(".concat(t, ", ").concat(i, "%, ").concat(s, "%)")
          : "hsva("
              .concat(t, ", ")
              .concat(i, "%, ")
              .concat(s, "%, ")
              .concat(this.roundA, ")");
      }),
      (r.prototype.toHsl = function () {
        var e = x0(this.r, this.g, this.b);
        return { h: e.h * 360, s: e.s, l: e.l, a: this.a };
      }),
      (r.prototype.toHslString = function () {
        var e = x0(this.r, this.g, this.b),
          t = Math.round(e.h * 360),
          i = Math.round(e.s * 100),
          s = Math.round(e.l * 100);
        return this.a === 1
          ? "hsl(".concat(t, ", ").concat(i, "%, ").concat(s, "%)")
          : "hsla("
              .concat(t, ", ")
              .concat(i, "%, ")
              .concat(s, "%, ")
              .concat(this.roundA, ")");
      }),
      (r.prototype.toHex = function (e) {
        return e === void 0 && (e = !1), w0(this.r, this.g, this.b, e);
      }),
      (r.prototype.toHexString = function (e) {
        return e === void 0 && (e = !1), "#" + this.toHex(e);
      }),
      (r.prototype.toHex8 = function (e) {
        return e === void 0 && (e = !1), lB(this.r, this.g, this.b, this.a, e);
      }),
      (r.prototype.toHex8String = function (e) {
        return e === void 0 && (e = !1), "#" + this.toHex8(e);
      }),
      (r.prototype.toHexShortString = function (e) {
        return (
          e === void 0 && (e = !1),
          this.a === 1 ? this.toHexString(e) : this.toHex8String(e)
        );
      }),
      (r.prototype.toRgb = function () {
        return {
          r: Math.round(this.r),
          g: Math.round(this.g),
          b: Math.round(this.b),
          a: this.a,
        };
      }),
      (r.prototype.toRgbString = function () {
        var e = Math.round(this.r),
          t = Math.round(this.g),
          i = Math.round(this.b);
        return this.a === 1
          ? "rgb(".concat(e, ", ").concat(t, ", ").concat(i, ")")
          : "rgba("
              .concat(e, ", ")
              .concat(t, ", ")
              .concat(i, ", ")
              .concat(this.roundA, ")");
      }),
      (r.prototype.toPercentageRgb = function () {
        var e = function (t) {
          return "".concat(Math.round(Jt(t, 255) * 100), "%");
        };
        return { r: e(this.r), g: e(this.g), b: e(this.b), a: this.a };
      }),
      (r.prototype.toPercentageRgbString = function () {
        var e = function (t) {
          return Math.round(Jt(t, 255) * 100);
        };
        return this.a === 1
          ? "rgb("
              .concat(e(this.r), "%, ")
              .concat(e(this.g), "%, ")
              .concat(e(this.b), "%)")
          : "rgba("
              .concat(e(this.r), "%, ")
              .concat(e(this.g), "%, ")
              .concat(e(this.b), "%, ")
              .concat(this.roundA, ")");
      }),
      (r.prototype.toName = function () {
        if (this.a === 0) return "transparent";
        if (this.a < 1) return !1;
        for (
          var e = "#" + w0(this.r, this.g, this.b, !1),
            t = 0,
            i = Object.entries(Ld);
          t < i.length;
          t++
        ) {
          var s = i[t],
            n = s[0],
            a = s[1];
          if (e === a) return n;
        }
        return !1;
      }),
      (r.prototype.toString = function (e) {
        var t = !!e;
        e = e ?? this.format;
        var i = !1,
          s = this.a < 1 && this.a >= 0,
          n = !t && s && (e.startsWith("hex") || e === "name");
        return n
          ? e === "name" && this.a === 0
            ? this.toName()
            : this.toRgbString()
          : (e === "rgb" && (i = this.toRgbString()),
            e === "prgb" && (i = this.toPercentageRgbString()),
            (e === "hex" || e === "hex6") && (i = this.toHexString()),
            e === "hex3" && (i = this.toHexString(!0)),
            e === "hex4" && (i = this.toHex8String(!0)),
            e === "hex8" && (i = this.toHex8String()),
            e === "name" && (i = this.toName()),
            e === "hsl" && (i = this.toHslString()),
            e === "hsv" && (i = this.toHsvString()),
            i || this.toHexString());
      }),
      (r.prototype.toNumber = function () {
        return (
          (Math.round(this.r) << 16) +
          (Math.round(this.g) << 8) +
          Math.round(this.b)
        );
      }),
      (r.prototype.clone = function () {
        return new r(this.toString());
      }),
      (r.prototype.lighten = function (e) {
        e === void 0 && (e = 10);
        var t = this.toHsl();
        return (t.l += e / 100), (t.l = Dl(t.l)), new r(t);
      }),
      (r.prototype.brighten = function (e) {
        e === void 0 && (e = 10);
        var t = this.toRgb();
        return (
          (t.r = Math.max(
            0,
            Math.min(255, t.r - Math.round(255 * -(e / 100)))
          )),
          (t.g = Math.max(
            0,
            Math.min(255, t.g - Math.round(255 * -(e / 100)))
          )),
          (t.b = Math.max(
            0,
            Math.min(255, t.b - Math.round(255 * -(e / 100)))
          )),
          new r(t)
        );
      }),
      (r.prototype.darken = function (e) {
        e === void 0 && (e = 10);
        var t = this.toHsl();
        return (t.l -= e / 100), (t.l = Dl(t.l)), new r(t);
      }),
      (r.prototype.tint = function (e) {
        return e === void 0 && (e = 10), this.mix("white", e);
      }),
      (r.prototype.shade = function (e) {
        return e === void 0 && (e = 10), this.mix("black", e);
      }),
      (r.prototype.desaturate = function (e) {
        e === void 0 && (e = 10);
        var t = this.toHsl();
        return (t.s -= e / 100), (t.s = Dl(t.s)), new r(t);
      }),
      (r.prototype.saturate = function (e) {
        e === void 0 && (e = 10);
        var t = this.toHsl();
        return (t.s += e / 100), (t.s = Dl(t.s)), new r(t);
      }),
      (r.prototype.greyscale = function () {
        return this.desaturate(100);
      }),
      (r.prototype.spin = function (e) {
        var t = this.toHsl(),
          i = (t.h + e) % 360;
        return (t.h = i < 0 ? 360 + i : i), new r(t);
      }),
      (r.prototype.mix = function (e, t) {
        t === void 0 && (t = 50);
        var i = this.toRgb(),
          s = new r(e).toRgb(),
          n = t / 100,
          a = {
            r: (s.r - i.r) * n + i.r,
            g: (s.g - i.g) * n + i.g,
            b: (s.b - i.b) * n + i.b,
            a: (s.a - i.a) * n + i.a,
          };
        return new r(a);
      }),
      (r.prototype.analogous = function (e, t) {
        e === void 0 && (e = 6), t === void 0 && (t = 30);
        var i = this.toHsl(),
          s = 360 / t,
          n = [this];
        for (i.h = (i.h - ((s * e) >> 1) + 720) % 360; --e; )
          (i.h = (i.h + s) % 360), n.push(new r(i));
        return n;
      }),
      (r.prototype.complement = function () {
        var e = this.toHsl();
        return (e.h = (e.h + 180) % 360), new r(e);
      }),
      (r.prototype.monochromatic = function (e) {
        e === void 0 && (e = 6);
        for (
          var t = this.toHsv(), i = t.h, s = t.s, n = t.v, a = [], o = 1 / e;
          e--;

        )
          a.push(new r({ h: i, s, v: n })), (n = (n + o) % 1);
        return a;
      }),
      (r.prototype.splitcomplement = function () {
        var e = this.toHsl(),
          t = e.h;
        return [
          this,
          new r({ h: (t + 72) % 360, s: e.s, l: e.l }),
          new r({ h: (t + 216) % 360, s: e.s, l: e.l }),
        ];
      }),
      (r.prototype.onBackground = function (e) {
        var t = this.toRgb(),
          i = new r(e).toRgb(),
          s = t.a + i.a * (1 - t.a);
        return new r({
          r: (t.r * t.a + i.r * i.a * (1 - t.a)) / s,
          g: (t.g * t.a + i.g * i.a * (1 - t.a)) / s,
          b: (t.b * t.a + i.b * i.a * (1 - t.a)) / s,
          a: s,
        });
      }),
      (r.prototype.triad = function () {
        return this.polyad(3);
      }),
      (r.prototype.tetrad = function () {
        return this.polyad(4);
      }),
      (r.prototype.polyad = function (e) {
        for (
          var t = this.toHsl(), i = t.h, s = [this], n = 360 / e, a = 1;
          a < e;
          a++
        )
          s.push(new r({ h: (i + a * n) % 360, s: t.s, l: t.l }));
        return s;
      }),
      (r.prototype.equals = function (e) {
        return this.toRgbString() === new r(e).toRgbString();
      }),
      r
    );
  })();
  function Ss(r, e = 20) {
    return r.mix("#141414", e).toString();
  }
  function gB(r) {
    const e = Za(),
      t = ut("button");
    return X(() => {
      let i = {},
        s = r.color;
      if (s) {
        const n = s.match(/var\((.*?)\)/);
        n &&
          (s = window
            .getComputedStyle(window.document.documentElement)
            .getPropertyValue(n[1]));
        const a = new mB(s),
          o = r.dark ? a.tint(20).toString() : Ss(a, 20);
        if (r.plain)
          (i = t.cssVarBlock({
            "bg-color": r.dark ? Ss(a, 90) : a.tint(90).toString(),
            "text-color": s,
            "border-color": r.dark ? Ss(a, 50) : a.tint(50).toString(),
            "hover-text-color": `var(${t.cssVarName("color-white")})`,
            "hover-bg-color": s,
            "hover-border-color": s,
            "active-bg-color": o,
            "active-text-color": `var(${t.cssVarName("color-white")})`,
            "active-border-color": o,
          })),
            e.value &&
              ((i[t.cssVarBlockName("disabled-bg-color")] = r.dark
                ? Ss(a, 90)
                : a.tint(90).toString()),
              (i[t.cssVarBlockName("disabled-text-color")] = r.dark
                ? Ss(a, 50)
                : a.tint(50).toString()),
              (i[t.cssVarBlockName("disabled-border-color")] = r.dark
                ? Ss(a, 80)
                : a.tint(80).toString()));
        else {
          const l = r.dark ? Ss(a, 30) : a.tint(30).toString(),
            h = a.isDark()
              ? `var(${t.cssVarName("color-white")})`
              : `var(${t.cssVarName("color-black")})`;
          if (
            ((i = t.cssVarBlock({
              "bg-color": s,
              "text-color": h,
              "border-color": s,
              "hover-bg-color": l,
              "hover-text-color": h,
              "hover-border-color": l,
              "active-bg-color": o,
              "active-border-color": o,
            })),
            e.value)
          ) {
            const c = r.dark ? Ss(a, 50) : a.tint(50).toString();
            (i[t.cssVarBlockName("disabled-bg-color")] = c),
              (i[t.cssVarBlockName("disabled-text-color")] = r.dark
                ? "rgba(255, 255, 255, 0.5)"
                : `var(${t.cssVarName("color-white")})`),
              (i[t.cssVarBlockName("disabled-border-color")] = c);
          }
        }
      }
      return i;
    });
  }
  const vB = ge({ name: "ElButton" }),
    yB = ge({
      ...vB,
      props: Dd,
      emits: rB,
      setup(r, { expose: e, emit: t }) {
        const i = r,
          s = gB(i),
          n = ut("button"),
          {
            _ref: a,
            _size: o,
            _type: l,
            _disabled: h,
            _props: c,
            shouldAddSpace: u,
            handleClick: d,
          } = eB(i, t),
          f = X(() => [
            n.b(),
            n.m(l.value),
            n.m(o.value),
            n.is("disabled", h.value),
            n.is("loading", i.loading),
            n.is("plain", i.plain),
            n.is("round", i.round),
            n.is("circle", i.circle),
            n.is("text", i.text),
            n.is("link", i.link),
            n.is("has-bg", i.bg),
          ]);
        return (
          e({ ref: a, size: o, type: l, disabled: h, shouldAddSpace: u }),
          (p, m) => (
            j(),
            Me(
              qt(p.tag),
              Gr({ ref_key: "_ref", ref: a }, S(c), {
                class: S(f),
                style: S(s),
                onClick: S(d),
              }),
              {
                default: be(() => [
                  p.loading
                    ? (j(),
                      xe(
                        ot,
                        { key: 0 },
                        [
                          p.$slots.loading
                            ? Xe(p.$slots, "loading", { key: 0 })
                            : (j(),
                              Me(
                                S(xt),
                                { key: 1, class: ce(S(n).is("loading")) },
                                {
                                  default: be(() => [
                                    (j(), Me(qt(p.loadingIcon))),
                                  ]),
                                  _: 1,
                                },
                                8,
                                ["class"]
                              )),
                        ],
                        64
                      ))
                    : p.icon || p.$slots.icon
                    ? (j(),
                      Me(
                        S(xt),
                        { key: 1 },
                        {
                          default: be(() => [
                            p.icon
                              ? (j(), Me(qt(p.icon), { key: 0 }))
                              : Xe(p.$slots, "icon", { key: 1 }),
                          ]),
                          _: 3,
                        }
                      ))
                    : Re("v-if", !0),
                  p.$slots.default
                    ? (j(),
                      xe(
                        "span",
                        {
                          key: 2,
                          class: ce({ [S(n).em("text", "expand")]: S(u) }),
                        },
                        [Xe(p.$slots, "default")],
                        2
                      ))
                    : Re("v-if", !0),
                ]),
                _: 3,
              },
              16,
              ["class", "style", "onClick"]
            )
          )
        );
      },
    });
  var bB = ct(yB, [["__file", "button.vue"]]);
  const xB = { size: Dd.size, type: Dd.type },
    _B = ge({ name: "ElButtonGroup" }),
    wB = ge({
      ..._B,
      props: xB,
      setup(r) {
        const e = r;
        Fr(Hx, vi({ size: ni(e, "size"), type: ni(e, "type") }));
        const t = ut("button");
        return (i, s) => (
          j(),
          xe(
            "div",
            { class: ce(S(t).b("group")) },
            [Xe(i.$slots, "default")],
            2
          )
        );
      },
    });
  var zx = ct(wB, [["__file", "button-group.vue"]]);
  const Nd = Qt(bB, { ButtonGroup: zx });
  Mc(zx);
  var ko =
    typeof globalThis < "u"
      ? globalThis
      : typeof window < "u"
      ? window
      : typeof global < "u"
      ? global
      : typeof self < "u"
      ? self
      : {};
  function Wx(r) {
    return r &&
      r.__esModule &&
      Object.prototype.hasOwnProperty.call(r, "default")
      ? r.default
      : r;
  }
  function TB(r) {
    if (r.__esModule) return r;
    var e = r.default;
    if (typeof e == "function") {
      var t = function i() {
        return this instanceof i
          ? Reflect.construct(e, arguments, this.constructor)
          : e.apply(this, arguments);
      };
      t.prototype = e.prototype;
    } else t = {};
    return (
      Object.defineProperty(t, "__esModule", { value: !0 }),
      Object.keys(r).forEach(function (i) {
        var s = Object.getOwnPropertyDescriptor(r, i);
        Object.defineProperty(
          t,
          i,
          s.get
            ? s
            : {
                enumerable: !0,
                get: function () {
                  return r[i];
                },
              }
        );
      }),
      t
    );
  }
  const EB = 100,
    SB = 600,
    E0 = {
      beforeMount(r, e) {
        const t = e.value,
          { interval: i = EB, delay: s = SB } = Fe(t) ? {} : t;
        let n, a;
        const o = () => (Fe(t) ? t() : t.handler()),
          l = () => {
            a && (clearTimeout(a), (a = void 0)),
              n && (clearInterval(n), (n = void 0));
          };
        r.addEventListener("mousedown", (h) => {
          h.button === 0 &&
            (l(),
            o(),
            document.addEventListener("mouseup", () => l(), { once: !0 }),
            (a = setTimeout(() => {
              n = setInterval(() => {
                o();
              }, i);
            }, s)));
        });
      },
    },
    Yx = et({
      modelValue: { type: [String, Number, Boolean], default: void 0 },
      size: Bn,
      disabled: Boolean,
      label: { type: [String, Number, Boolean], default: void 0 },
      value: { type: [String, Number, Boolean], default: void 0 },
      name: { type: String, default: void 0 },
    }),
    AB = et({ ...Yx, border: Boolean }),
    jx = {
      [$t]: (r) => Ge(r) || at(r) || Ui(r),
      [Ys]: (r) => Ge(r) || at(r) || Ui(r),
    },
    qx = Symbol("radioGroupKey"),
    Kx = (r, e) => {
      const t = he(),
        i = rt(qx, void 0),
        s = X(() => !!i),
        n = X(() => (Vg(r.value) ? r.label : r.value)),
        a = X({
          get() {
            return s.value ? i.modelValue : r.modelValue;
          },
          set(u) {
            s.value ? i.changeEvent(u) : e && e($t, u),
              (t.value.checked = r.modelValue === n.value);
          },
        }),
        o = ws(X(() => (i == null ? void 0 : i.size))),
        l = Za(X(() => (i == null ? void 0 : i.disabled))),
        h = he(!1),
        c = X(() => (l.value || (s.value && a.value !== n.value) ? -1 : 0));
      return (
        fx(
          {
            from: "label act as value",
            replacement: "value",
            version: "3.0.0",
            scope: "el-radio",
            ref: "https://element-plus.org/en-US/component/radio.html",
          },
          X(() => s.value && Vg(r.value))
        ),
        {
          radioRef: t,
          isGroup: s,
          radioGroup: i,
          focus: h,
          size: o,
          disabled: l,
          tabIndex: c,
          modelValue: a,
          actualValue: n,
        }
      );
    },
    CB = ge({ name: "ElRadio" }),
    IB = ge({
      ...CB,
      props: AB,
      emits: jx,
      setup(r, { emit: e }) {
        const t = r,
          i = ut("radio"),
          {
            radioRef: s,
            radioGroup: n,
            focus: a,
            size: o,
            disabled: l,
            modelValue: h,
            actualValue: c,
          } = Kx(t, e);
        function u() {
          _t(() => e("change", h.value));
        }
        return (d, f) => {
          var p;
          return (
            j(),
            xe(
              "label",
              {
                class: ce([
                  S(i).b(),
                  S(i).is("disabled", S(l)),
                  S(i).is("focus", S(a)),
                  S(i).is("bordered", d.border),
                  S(i).is("checked", S(h) === S(c)),
                  S(i).m(S(o)),
                ]),
              },
              [
                Se(
                  "span",
                  {
                    class: ce([
                      S(i).e("input"),
                      S(i).is("disabled", S(l)),
                      S(i).is("checked", S(h) === S(c)),
                    ]),
                  },
                  [
                    Ws(
                      Se(
                        "input",
                        {
                          ref_key: "radioRef",
                          ref: s,
                          "onUpdate:modelValue": (m) =>
                            Mt(h) ? (h.value = m) : null,
                          class: ce(S(i).e("original")),
                          value: S(c),
                          name:
                            d.name || ((p = S(n)) == null ? void 0 : p.name),
                          disabled: S(l),
                          checked: S(h) === S(c),
                          type: "radio",
                          onFocus: (m) => (a.value = !0),
                          onBlur: (m) => (a.value = !1),
                          onChange: u,
                          onClick: hi(() => {}, ["stop"]),
                        },
                        null,
                        42,
                        [
                          "onUpdate:modelValue",
                          "value",
                          "name",
                          "disabled",
                          "checked",
                          "onFocus",
                          "onBlur",
                          "onClick",
                        ]
                      ),
                      [[Nb, S(h)]]
                    ),
                    Se("span", { class: ce(S(i).e("inner")) }, null, 2),
                  ],
                  2
                ),
                Se(
                  "span",
                  {
                    class: ce(S(i).e("label")),
                    onKeydown: hi(() => {}, ["stop"]),
                  },
                  [Xe(d.$slots, "default", {}, () => [vr(Ut(d.label), 1)])],
                  42,
                  ["onKeydown"]
                ),
              ],
              2
            )
          );
        };
      },
    });
  var PB = ct(IB, [["__file", "radio.vue"]]);
  const RB = et({ ...Yx }),
    MB = ge({ name: "ElRadioButton" }),
    FB = ge({
      ...MB,
      props: RB,
      setup(r) {
        const e = r,
          t = ut("radio"),
          {
            radioRef: i,
            focus: s,
            size: n,
            disabled: a,
            modelValue: o,
            radioGroup: l,
            actualValue: h,
          } = Kx(e),
          c = X(() => ({
            backgroundColor: (l == null ? void 0 : l.fill) || "",
            borderColor: (l == null ? void 0 : l.fill) || "",
            boxShadow: l != null && l.fill ? `-1px 0 0 0 ${l.fill}` : "",
            color: (l == null ? void 0 : l.textColor) || "",
          }));
        return (u, d) => {
          var f;
          return (
            j(),
            xe(
              "label",
              {
                class: ce([
                  S(t).b("button"),
                  S(t).is("active", S(o) === S(h)),
                  S(t).is("disabled", S(a)),
                  S(t).is("focus", S(s)),
                  S(t).bm("button", S(n)),
                ]),
              },
              [
                Ws(
                  Se(
                    "input",
                    {
                      ref_key: "radioRef",
                      ref: i,
                      "onUpdate:modelValue": (p) =>
                        Mt(o) ? (o.value = p) : null,
                      class: ce(S(t).be("button", "original-radio")),
                      value: S(h),
                      type: "radio",
                      name: u.name || ((f = S(l)) == null ? void 0 : f.name),
                      disabled: S(a),
                      onFocus: (p) => (s.value = !0),
                      onBlur: (p) => (s.value = !1),
                      onClick: hi(() => {}, ["stop"]),
                    },
                    null,
                    42,
                    [
                      "onUpdate:modelValue",
                      "value",
                      "name",
                      "disabled",
                      "onFocus",
                      "onBlur",
                      "onClick",
                    ]
                  ),
                  [[Nb, S(o)]]
                ),
                Se(
                  "span",
                  {
                    class: ce(S(t).be("button", "inner")),
                    style: Et(S(o) === S(h) ? S(c) : {}),
                    onKeydown: hi(() => {}, ["stop"]),
                  },
                  [Xe(u.$slots, "default", {}, () => [vr(Ut(u.label), 1)])],
                  46,
                  ["onKeydown"]
                ),
              ],
              2
            )
          );
        };
      },
    });
  var Zx = ct(FB, [["__file", "radio-button.vue"]]);
  const BB = et({
      id: { type: String, default: void 0 },
      size: Bn,
      disabled: Boolean,
      modelValue: { type: [String, Number, Boolean], default: void 0 },
      fill: { type: String, default: "" },
      textColor: { type: String, default: "" },
      name: { type: String, default: void 0 },
      validateEvent: { type: Boolean, default: !0 },
      ...en(["ariaLabel"]),
    }),
    OB = jx,
    kB = ge({ name: "ElRadioGroup" }),
    DB = ge({
      ...kB,
      props: BB,
      emits: OB,
      setup(r, { emit: e }) {
        const t = r,
          i = ut("radio"),
          s = Bc(),
          n = he(),
          { formItem: a } = Ja(),
          { inputId: o, isLabeledByFormItem: l } = Oc(t, {
            formItemContext: a,
          }),
          h = (u) => {
            e($t, u), _t(() => e("change", u));
          };
        Rt(() => {
          const u = n.value.querySelectorAll("[type=radio]"),
            d = u[0];
          !Array.from(u).some((f) => f.checked) && d && (d.tabIndex = 0);
        });
        const c = X(() => t.name || s.value);
        return (
          Fr(qx, vi({ ...Ra(t), changeEvent: h, name: c })),
          De(
            () => t.modelValue,
            () => {
              t.validateEvent &&
                (a == null || a.validate("change").catch((u) => void 0));
            }
          ),
          (u, d) => (
            j(),
            xe(
              "div",
              {
                id: S(o),
                ref_key: "radioGroupRef",
                ref: n,
                class: ce(S(i).b("group")),
                role: "radiogroup",
                "aria-label": S(l) ? void 0 : u.ariaLabel || "radio-group",
                "aria-labelledby": S(l) ? S(a).labelId : void 0,
              },
              [Xe(u.$slots, "default")],
              10,
              ["id", "aria-label", "aria-labelledby"]
            )
          )
        );
      },
    });
  var Jx = ct(DB, [["__file", "radio-group.vue"]]);
  const LB = Qt(PB, { RadioButton: Zx, RadioGroup: Jx }),
    NB = Mc(Jx);
  Mc(Zx);
  const UB = et({
      direction: {
        type: String,
        values: ["horizontal", "vertical"],
        default: "horizontal",
      },
      contentPosition: {
        type: String,
        values: ["left", "center", "right"],
        default: "center",
      },
      borderStyle: { type: Ne(String), default: "solid" },
    }),
    VB = ge({ name: "ElDivider" }),
    $B = ge({
      ...VB,
      props: UB,
      setup(r) {
        const e = r,
          t = ut("divider"),
          i = X(() => t.cssVar({ "border-style": e.borderStyle }));
        return (s, n) => (
          j(),
          xe(
            "div",
            {
              class: ce([S(t).b(), S(t).m(s.direction)]),
              style: Et(S(i)),
              role: "separator",
            },
            [
              s.$slots.default && s.direction !== "vertical"
                ? (j(),
                  xe(
                    "div",
                    {
                      key: 0,
                      class: ce([S(t).e("text"), S(t).is(s.contentPosition)]),
                    },
                    [Xe(s.$slots, "default")],
                    2
                  ))
                : Re("v-if", !0),
            ],
            6
          )
        );
      },
    });
  var GB = ct($B, [["__file", "divider.vue"]]);
  const HB = Qt(GB),
    XB = et({
      urlList: { type: Ne(Array), default: () => Fp([]) },
      zIndex: { type: Number },
      initialIndex: { type: Number, default: 0 },
      infinite: { type: Boolean, default: !0 },
      hideOnClickModal: Boolean,
      teleported: Boolean,
      closeOnPressEscape: { type: Boolean, default: !0 },
      zoomRate: { type: Number, default: 1.2 },
      minScale: { type: Number, default: 0.2 },
      maxScale: { type: Number, default: 7 },
      crossorigin: { type: Ne(String) },
    }),
    zB = { close: () => !0, switch: (r) => at(r), rotate: (r) => at(r) },
    WB = ge({ name: "ElImageViewer" }),
    YB = ge({
      ...WB,
      props: XB,
      emits: zB,
      setup(r, { expose: e, emit: t }) {
        var i;
        const s = r,
          n = {
            CONTAIN: { name: "contain", icon: fd(EP) },
            ORIGINAL: { name: "original", icon: fd(UP) },
          },
          { t: a } = ul(),
          o = ut("image-viewer"),
          { nextZIndex: l } = Rx(),
          h = he(),
          c = he([]),
          u = Jw(),
          d = he(!0),
          f = he(s.initialIndex),
          p = _n(n.CONTAIN),
          m = he({
            scale: 1,
            deg: 0,
            offsetX: 0,
            offsetY: 0,
            enableTransition: !1,
          }),
          v = he((i = s.zIndex) != null ? i : l()),
          g = X(() => {
            const { urlList: N } = s;
            return N.length <= 1;
          }),
          x = X(() => f.value === 0),
          b = X(() => f.value === s.urlList.length - 1),
          y = X(() => s.urlList[f.value]),
          _ = X(() => [
            o.e("btn"),
            o.e("prev"),
            o.is("disabled", !s.infinite && x.value),
          ]),
          w = X(() => [
            o.e("btn"),
            o.e("next"),
            o.is("disabled", !s.infinite && b.value),
          ]),
          E = X(() => {
            const {
              scale: N,
              deg: O,
              offsetX: H,
              offsetY: G,
              enableTransition: q,
            } = m.value;
            let K = H / N,
              ue = G / N;
            const ie = (O * Math.PI) / 180,
              ee = Math.cos(ie),
              ve = Math.sin(ie);
            (K = K * ee + ue * ve), (ue = ue * ee - (H / N) * ve);
            const ye = {
              transform: `scale(${N}) rotate(${O}deg) translate(${K}px, ${ue}px)`,
              transition: q ? "transform .3s" : "",
            };
            return (
              p.value.name === n.CONTAIN.name &&
                (ye.maxWidth = ye.maxHeight = "100%"),
              ye
            );
          });
        function A() {
          F(), t("close");
        }
        function C() {
          const N = uu((H) => {
              switch (H.code) {
                case ii.esc:
                  s.closeOnPressEscape && A();
                  break;
                case ii.space:
                  M();
                  break;
                case ii.left:
                  U();
                  break;
                case ii.up:
                  z("zoomIn");
                  break;
                case ii.right:
                  V();
                  break;
                case ii.down:
                  z("zoomOut");
                  break;
              }
            }),
            O = uu((H) => {
              const G = H.deltaY || H.deltaX;
              z(G < 0 ? "zoomIn" : "zoomOut", {
                zoomRate: s.zoomRate,
                enableTransition: !1,
              });
            });
          u.run(() => {
            Vt(document, "keydown", N), Vt(document, "wheel", O);
          });
        }
        function F() {
          u.stop();
        }
        function B() {
          d.value = !1;
        }
        function R(N) {
          (d.value = !1), (N.target.alt = a("el.image.error"));
        }
        function I(N) {
          if (d.value || N.button !== 0 || !h.value) return;
          m.value.enableTransition = !1;
          const { offsetX: O, offsetY: H } = m.value,
            G = N.pageX,
            q = N.pageY,
            K = uu((ie) => {
              m.value = {
                ...m.value,
                offsetX: O + ie.pageX - G,
                offsetY: H + ie.pageY - q,
              };
            }),
            ue = Vt(document, "mousemove", K);
          Vt(document, "mouseup", () => {
            ue();
          }),
            N.preventDefault();
        }
        function P() {
          m.value = {
            scale: 1,
            deg: 0,
            offsetX: 0,
            offsetY: 0,
            enableTransition: !1,
          };
        }
        function M() {
          if (d.value) return;
          const N = nP(n),
            O = Object.values(n),
            H = p.value.name,
            q = (O.findIndex((K) => K.name === H) + 1) % N.length;
          (p.value = n[N[q]]), P();
        }
        function L(N) {
          const O = s.urlList.length;
          f.value = (N + O) % O;
        }
        function U() {
          (x.value && !s.infinite) || L(f.value - 1);
        }
        function V() {
          (b.value && !s.infinite) || L(f.value + 1);
        }
        function z(N, O = {}) {
          if (d.value) return;
          const { minScale: H, maxScale: G } = s,
            {
              zoomRate: q,
              rotateDeg: K,
              enableTransition: ue,
            } = {
              zoomRate: s.zoomRate,
              rotateDeg: 90,
              enableTransition: !0,
              ...O,
            };
          switch (N) {
            case "zoomOut":
              m.value.scale > H &&
                (m.value.scale = Number.parseFloat(
                  (m.value.scale / q).toFixed(3)
                ));
              break;
            case "zoomIn":
              m.value.scale < G &&
                (m.value.scale = Number.parseFloat(
                  (m.value.scale * q).toFixed(3)
                ));
              break;
            case "clockwise":
              (m.value.deg += K), t("rotate", m.value.deg);
              break;
            case "anticlockwise":
              (m.value.deg -= K), t("rotate", m.value.deg);
              break;
          }
          m.value.enableTransition = ue;
        }
        return (
          De(y, () => {
            _t(() => {
              const N = c.value[0];
              (N != null && N.complete) || (d.value = !0);
            });
          }),
          De(f, (N) => {
            P(), t("switch", N);
          }),
          Rt(() => {
            var N, O;
            C(),
              (O = (N = h.value) == null ? void 0 : N.focus) == null ||
                O.call(N);
          }),
          e({ setActiveItem: L }),
          (N, O) => (
            j(),
            Me(
              S($x),
              { to: "body", disabled: !N.teleported },
              {
                default: be(() => [
                  ne(
                    fp,
                    { name: "viewer-fade", appear: "" },
                    {
                      default: be(() => [
                        Se(
                          "div",
                          {
                            ref_key: "wrapper",
                            ref: h,
                            tabindex: -1,
                            class: ce(S(o).e("wrapper")),
                            style: Et({ zIndex: v.value }),
                          },
                          [
                            Se(
                              "div",
                              {
                                class: ce(S(o).e("mask")),
                                onClick: hi(
                                  (H) => N.hideOnClickModal && A(),
                                  ["self"]
                                ),
                              },
                              null,
                              10,
                              ["onClick"]
                            ),
                            Re(" CLOSE "),
                            Se(
                              "span",
                              {
                                class: ce([S(o).e("btn"), S(o).e("close")]),
                                onClick: A,
                              },
                              [
                                ne(S(xt), null, {
                                  default: be(() => [ne(S(wP))]),
                                  _: 1,
                                }),
                              ],
                              2
                            ),
                            Re(" ARROW "),
                            S(g)
                              ? Re("v-if", !0)
                              : (j(),
                                xe(
                                  ot,
                                  { key: 0 },
                                  [
                                    Se(
                                      "span",
                                      { class: ce(S(_)), onClick: U },
                                      [
                                        ne(S(xt), null, {
                                          default: be(() => [ne(S(fP))]),
                                          _: 1,
                                        }),
                                      ],
                                      2
                                    ),
                                    Se(
                                      "span",
                                      { class: ce(S(w)), onClick: V },
                                      [
                                        ne(S(xt), null, {
                                          default: be(() => [ne(S(mP))]),
                                          _: 1,
                                        }),
                                      ],
                                      2
                                    ),
                                  ],
                                  64
                                )),
                            Re(" ACTIONS "),
                            Se(
                              "div",
                              { class: ce([S(o).e("btn"), S(o).e("actions")]) },
                              [
                                Se(
                                  "div",
                                  { class: ce(S(o).e("actions__inner")) },
                                  [
                                    ne(
                                      S(xt),
                                      { onClick: (H) => z("zoomOut") },
                                      { default: be(() => [ne(S(zP))]), _: 1 },
                                      8,
                                      ["onClick"]
                                    ),
                                    ne(
                                      S(xt),
                                      { onClick: (H) => z("zoomIn") },
                                      { default: be(() => [ne(S(HP))]), _: 1 },
                                      8,
                                      ["onClick"]
                                    ),
                                    Se(
                                      "i",
                                      { class: ce(S(o).e("actions__divider")) },
                                      null,
                                      2
                                    ),
                                    ne(
                                      S(xt),
                                      { onClick: M },
                                      {
                                        default: be(() => [
                                          (j(), Me(qt(S(p).icon))),
                                        ]),
                                        _: 1,
                                      }
                                    ),
                                    Se(
                                      "i",
                                      { class: ce(S(o).e("actions__divider")) },
                                      null,
                                      2
                                    ),
                                    ne(
                                      S(xt),
                                      { onClick: (H) => z("anticlockwise") },
                                      { default: be(() => [ne(S(kP))]), _: 1 },
                                      8,
                                      ["onClick"]
                                    ),
                                    ne(
                                      S(xt),
                                      { onClick: (H) => z("clockwise") },
                                      { default: be(() => [ne(S(LP))]), _: 1 },
                                      8,
                                      ["onClick"]
                                    ),
                                  ],
                                  2
                                ),
                              ],
                              2
                            ),
                            Re(" CANVAS "),
                            Se(
                              "div",
                              { class: ce(S(o).e("canvas")) },
                              [
                                (j(!0),
                                xe(
                                  ot,
                                  null,
                                  Io(N.urlList, (H, G) =>
                                    Ws(
                                      (j(),
                                      xe(
                                        "img",
                                        {
                                          ref_for: !0,
                                          ref: (q) => (c.value[G] = q),
                                          key: H,
                                          src: H,
                                          style: Et(S(E)),
                                          class: ce(S(o).e("img")),
                                          crossorigin: N.crossorigin,
                                          onLoad: B,
                                          onError: R,
                                          onMousedown: I,
                                        },
                                        null,
                                        46,
                                        ["src", "crossorigin"]
                                      )),
                                      [[pp, G === f.value]]
                                    )
                                  ),
                                  128
                                )),
                              ],
                              2
                            ),
                            Xe(N.$slots, "default"),
                          ],
                          6
                        ),
                      ]),
                      _: 3,
                    }
                  ),
                ]),
                _: 3,
              },
              8,
              ["disabled"]
            )
          )
        );
      },
    });
  var jB = ct(YB, [["__file", "image-viewer.vue"]]);
  const qB = Qt(jB),
    KB = et({
      hideOnClickModal: Boolean,
      src: { type: String, default: "" },
      fit: {
        type: String,
        values: ["", "contain", "cover", "fill", "none", "scale-down"],
        default: "",
      },
      loading: { type: String, values: ["eager", "lazy"] },
      lazy: Boolean,
      scrollContainer: { type: Ne([String, Object]) },
      previewSrcList: { type: Ne(Array), default: () => Fp([]) },
      previewTeleported: Boolean,
      zIndex: { type: Number },
      initialIndex: { type: Number, default: 0 },
      infinite: { type: Boolean, default: !0 },
      closeOnPressEscape: { type: Boolean, default: !0 },
      zoomRate: { type: Number, default: 1.2 },
      minScale: { type: Number, default: 0.2 },
      maxScale: { type: Number, default: 7 },
      crossorigin: { type: Ne(String) },
    }),
    ZB = {
      load: (r) => r instanceof Event,
      error: (r) => r instanceof Event,
      switch: (r) => at(r),
      close: () => !0,
      show: () => !0,
    },
    JB = ge({ name: "ElImage", inheritAttrs: !1 }),
    QB = ge({
      ...JB,
      props: KB,
      emits: ZB,
      setup(r, { emit: e }) {
        const t = r;
        let i = "";
        const { t: s } = ul(),
          n = ut("image"),
          a = sb(),
          o = X(() =>
            qo(
              Object.entries(a).filter(
                ([V]) =>
                  /^(data-|on[A-Z])/i.test(V) || ["id", "style"].includes(V)
              )
            )
          ),
          l = dx({
            excludeListeners: !0,
            excludeKeys: X(() => Object.keys(o.value)),
          }),
          h = he(),
          c = he(!1),
          u = he(!0),
          d = he(!1),
          f = he(),
          p = he(),
          m = It && "loading" in HTMLImageElement.prototype;
        let v, g;
        const x = X(() => [
            n.e("inner"),
            y.value && n.e("preview"),
            u.value && n.is("loading"),
          ]),
          b = X(() => {
            const { fit: V } = t;
            return It && V ? { objectFit: V } : {};
          }),
          y = X(() => {
            const { previewSrcList: V } = t;
            return Array.isArray(V) && V.length > 0;
          }),
          _ = X(() => {
            const { previewSrcList: V, initialIndex: z } = t;
            let N = z;
            return z > V.length - 1 && (N = 0), N;
          }),
          w = X(() =>
            t.loading === "eager" ? !1 : (!m && t.loading === "lazy") || t.lazy
          ),
          E = () => {
            It && ((u.value = !0), (c.value = !1), (h.value = t.src));
          };
        function A(V) {
          (u.value = !1), (c.value = !1), e("load", V);
        }
        function C(V) {
          (u.value = !1), (c.value = !0), e("error", V);
        }
        function F() {
          LS(f.value, p.value) && (E(), I());
        }
        const B = ES(F, 200, !0);
        async function R() {
          var V;
          if (!It) return;
          await _t();
          const { scrollContainer: z } = t;
          _a(z)
            ? (p.value = z)
            : Ge(z) && z !== ""
            ? (p.value = (V = document.querySelector(z)) != null ? V : void 0)
            : f.value && (p.value = hP(f.value)),
            p.value && ((v = Vt(p, "scroll", B)), setTimeout(() => F(), 100));
        }
        function I() {
          !It || !p.value || !B || (v == null || v(), (p.value = void 0));
        }
        function P(V) {
          if (V.ctrlKey) {
            if (V.deltaY < 0) return V.preventDefault(), !1;
            if (V.deltaY > 0) return V.preventDefault(), !1;
          }
        }
        function M() {
          y.value &&
            ((g = Vt("wheel", P, { passive: !1 })),
            (i = document.body.style.overflow),
            (document.body.style.overflow = "hidden"),
            (d.value = !0),
            e("show"));
        }
        function L() {
          g == null || g(),
            (document.body.style.overflow = i),
            (d.value = !1),
            e("close");
        }
        function U(V) {
          e("switch", V);
        }
        return (
          De(
            () => t.src,
            () => {
              w.value ? ((u.value = !0), (c.value = !1), I(), R()) : E();
            }
          ),
          Rt(() => {
            w.value ? R() : E();
          }),
          (V, z) => (
            j(),
            xe(
              "div",
              Gr({ ref_key: "container", ref: f }, S(o), {
                class: [S(n).b(), V.$attrs.class],
              }),
              [
                c.value
                  ? Xe(V.$slots, "error", { key: 0 }, () => [
                      Se(
                        "div",
                        { class: ce(S(n).e("error")) },
                        Ut(S(s)("el.image.error")),
                        3
                      ),
                    ])
                  : (j(),
                    xe(
                      ot,
                      { key: 1 },
                      [
                        h.value !== void 0
                          ? (j(),
                            xe(
                              "img",
                              Gr({ key: 0 }, S(l), {
                                src: h.value,
                                loading: V.loading,
                                style: S(b),
                                class: S(x),
                                crossorigin: V.crossorigin,
                                onClick: M,
                                onLoad: A,
                                onError: C,
                              }),
                              null,
                              16,
                              ["src", "loading", "crossorigin"]
                            ))
                          : Re("v-if", !0),
                        u.value
                          ? (j(),
                            xe(
                              "div",
                              { key: 1, class: ce(S(n).e("wrapper")) },
                              [
                                Xe(V.$slots, "placeholder", {}, () => [
                                  Se(
                                    "div",
                                    { class: ce(S(n).e("placeholder")) },
                                    null,
                                    2
                                  ),
                                ]),
                              ],
                              2
                            ))
                          : Re("v-if", !0),
                      ],
                      64
                    )),
                S(y)
                  ? (j(),
                    xe(
                      ot,
                      { key: 2 },
                      [
                        d.value
                          ? (j(),
                            Me(
                              S(qB),
                              {
                                key: 0,
                                "z-index": V.zIndex,
                                "initial-index": S(_),
                                infinite: V.infinite,
                                "zoom-rate": V.zoomRate,
                                "min-scale": V.minScale,
                                "max-scale": V.maxScale,
                                "url-list": V.previewSrcList,
                                crossorigin: V.crossorigin,
                                "hide-on-click-modal": V.hideOnClickModal,
                                teleported: V.previewTeleported,
                                "close-on-press-escape": V.closeOnPressEscape,
                                onClose: L,
                                onSwitch: U,
                              },
                              {
                                default: be(() => [
                                  V.$slots.viewer
                                    ? (j(),
                                      xe("div", { key: 0 }, [
                                        Xe(V.$slots, "viewer"),
                                      ]))
                                    : Re("v-if", !0),
                                ]),
                                _: 3,
                              },
                              8,
                              [
                                "z-index",
                                "initial-index",
                                "infinite",
                                "zoom-rate",
                                "min-scale",
                                "max-scale",
                                "url-list",
                                "crossorigin",
                                "hide-on-click-modal",
                                "teleported",
                                "close-on-press-escape",
                              ]
                            ))
                          : Re("v-if", !0),
                      ],
                      64
                    ))
                  : Re("v-if", !0),
              ],
              16
            )
          )
        );
      },
    });
  var eO = ct(QB, [["__file", "image.vue"]]);
  const tO = Qt(eO),
    rO = et({
      id: { type: String, default: void 0 },
      step: { type: Number, default: 1 },
      stepStrictly: Boolean,
      max: { type: Number, default: Number.POSITIVE_INFINITY },
      min: { type: Number, default: Number.NEGATIVE_INFINITY },
      modelValue: Number,
      readonly: Boolean,
      disabled: Boolean,
      size: Bn,
      controls: { type: Boolean, default: !0 },
      controlsPosition: { type: String, default: "", values: ["", "right"] },
      valueOnClear: {
        type: [String, Number, null],
        validator: (r) => r === null || at(r) || ["min", "max"].includes(r),
        default: null,
      },
      name: String,
      placeholder: String,
      precision: {
        type: Number,
        validator: (r) => r >= 0 && r === Number.parseInt(`${r}`, 10),
      },
      validateEvent: { type: Boolean, default: !0 },
      ...en(["ariaLabel"]),
    }),
    iO = {
      [Ys]: (r, e) => e !== r,
      blur: (r) => r instanceof FocusEvent,
      focus: (r) => r instanceof FocusEvent,
      [Vi]: (r) => at(r) || Ni(r),
      [$t]: (r) => at(r) || Ni(r),
    },
    sO = ge({ name: "ElInputNumber" }),
    nO = ge({
      ...sO,
      props: rO,
      emits: iO,
      setup(r, { expose: e, emit: t }) {
        const i = r,
          { t: s } = ul(),
          n = ut("input-number"),
          a = he(),
          o = vi({ currentValue: i.modelValue, userInput: null }),
          { formItem: l } = Ja(),
          h = X(() => at(i.modelValue) && i.modelValue <= i.min),
          c = X(() => at(i.modelValue) && i.modelValue >= i.max),
          u = X(() => {
            const M = g(i.step);
            return la(i.precision)
              ? Math.max(g(i.modelValue), M)
              : (M > i.precision, i.precision);
          }),
          d = X(() => i.controls && i.controlsPosition === "right"),
          f = ws(),
          p = Za(),
          m = X(() => {
            if (o.userInput !== null) return o.userInput;
            let M = o.currentValue;
            if (Ni(M)) return "";
            if (at(M)) {
              if (Number.isNaN(M)) return "";
              la(i.precision) || (M = M.toFixed(i.precision));
            }
            return M;
          }),
          v = (M, L) => {
            if ((la(L) && (L = u.value), L === 0)) return Math.round(M);
            let U = String(M);
            const V = U.indexOf(".");
            if (V === -1 || !U.replace(".", "").split("")[V + L]) return M;
            const O = U.length;
            return (
              U.charAt(O - 1) === "5" &&
                (U = `${U.slice(0, Math.max(0, O - 1))}6`),
              Number.parseFloat(Number(U).toFixed(L))
            );
          },
          g = (M) => {
            if (Ni(M)) return 0;
            const L = M.toString(),
              U = L.indexOf(".");
            let V = 0;
            return U !== -1 && (V = L.length - U - 1), V;
          },
          x = (M, L = 1) => (at(M) ? v(M + i.step * L) : o.currentValue),
          b = () => {
            if (i.readonly || p.value || c.value) return;
            const M = Number(m.value) || 0,
              L = x(M);
            w(L), t(Vi, o.currentValue), I();
          },
          y = () => {
            if (i.readonly || p.value || h.value) return;
            const M = Number(m.value) || 0,
              L = x(M, -1);
            w(L), t(Vi, o.currentValue), I();
          },
          _ = (M, L) => {
            const {
              max: U,
              min: V,
              step: z,
              precision: N,
              stepStrictly: O,
              valueOnClear: H,
            } = i;
            U < V && hl("InputNumber", "min should not be greater than max.");
            let G = Number(M);
            if (Ni(M) || Number.isNaN(G)) return null;
            if (M === "") {
              if (H === null) return null;
              G = Ge(H) ? { min: V, max: U }[H] : H;
            }
            return (
              O && (G = v(Math.round(G / z) * z, N)),
              la(N) || (G = v(G, N)),
              (G > U || G < V) && ((G = G > U ? U : V), L && t($t, G)),
              G
            );
          },
          w = (M, L = !0) => {
            var U;
            const V = o.currentValue,
              z = _(M);
            if (!L) {
              t($t, z);
              return;
            }
            (V === z && M) ||
              ((o.userInput = null),
              t($t, z),
              V !== z && t(Ys, z, V),
              i.validateEvent &&
                ((U = l == null ? void 0 : l.validate) == null ||
                  U.call(l, "change").catch((N) => void 0)),
              (o.currentValue = z));
          },
          E = (M) => {
            o.userInput = M;
            const L = M === "" ? null : Number(M);
            t(Vi, L), w(L, !1);
          },
          A = (M) => {
            const L = M !== "" ? Number(M) : "";
            ((at(L) && !Number.isNaN(L)) || M === "") && w(L),
              I(),
              (o.userInput = null);
          },
          C = () => {
            var M, L;
            (L = (M = a.value) == null ? void 0 : M.focus) == null || L.call(M);
          },
          F = () => {
            var M, L;
            (L = (M = a.value) == null ? void 0 : M.blur) == null || L.call(M);
          },
          B = (M) => {
            t("focus", M);
          },
          R = (M) => {
            var L;
            (o.userInput = null),
              t("blur", M),
              i.validateEvent &&
                ((L = l == null ? void 0 : l.validate) == null ||
                  L.call(l, "blur").catch((U) => void 0));
          },
          I = () => {
            o.currentValue !== i.modelValue && (o.currentValue = i.modelValue);
          },
          P = (M) => {
            document.activeElement === M.target && M.preventDefault();
          };
        return (
          De(
            () => i.modelValue,
            (M, L) => {
              const U = _(M, !0);
              o.userInput === null && U !== L && (o.currentValue = U);
            },
            { immediate: !0 }
          ),
          Rt(() => {
            var M;
            const { min: L, max: U, modelValue: V } = i,
              z = (M = a.value) == null ? void 0 : M.input;
            if (
              (z.setAttribute("role", "spinbutton"),
              Number.isFinite(U)
                ? z.setAttribute("aria-valuemax", String(U))
                : z.removeAttribute("aria-valuemax"),
              Number.isFinite(L)
                ? z.setAttribute("aria-valuemin", String(L))
                : z.removeAttribute("aria-valuemin"),
              z.setAttribute(
                "aria-valuenow",
                o.currentValue || o.currentValue === 0
                  ? String(o.currentValue)
                  : ""
              ),
              z.setAttribute("aria-disabled", String(p.value)),
              !at(V) && V != null)
            ) {
              let N = Number(V);
              Number.isNaN(N) && (N = null), t($t, N);
            }
            z.addEventListener("wheel", P, { passive: !1 });
          }),
          ol(() => {
            var M, L;
            const U = (M = a.value) == null ? void 0 : M.input;
            U == null ||
              U.setAttribute(
                "aria-valuenow",
                `${(L = o.currentValue) != null ? L : ""}`
              );
          }),
          e({ focus: C, blur: F }),
          (M, L) => (
            j(),
            xe(
              "div",
              {
                class: ce([
                  S(n).b(),
                  S(n).m(S(f)),
                  S(n).is("disabled", S(p)),
                  S(n).is("without-controls", !M.controls),
                  S(n).is("controls-right", S(d)),
                ]),
                onDragstart: hi(() => {}, ["prevent"]),
              },
              [
                M.controls
                  ? Ws(
                      (j(),
                      xe(
                        "span",
                        {
                          key: 0,
                          role: "button",
                          "aria-label": S(s)("el.inputNumber.decrease"),
                          class: ce([
                            S(n).e("decrease"),
                            S(n).is("disabled", S(h)),
                          ]),
                          onKeydown: go(y, ["enter"]),
                        },
                        [
                          Xe(M.$slots, "decrease-icon", {}, () => [
                            ne(S(xt), null, {
                              default: be(() => [
                                S(d)
                                  ? (j(), Me(S(uP), { key: 0 }))
                                  : (j(), Me(S(PP), { key: 1 })),
                              ]),
                              _: 1,
                            }),
                          ]),
                        ],
                        42,
                        ["aria-label", "onKeydown"]
                      )),
                      [[S(E0), y]]
                    )
                  : Re("v-if", !0),
                M.controls
                  ? Ws(
                      (j(),
                      xe(
                        "span",
                        {
                          key: 1,
                          role: "button",
                          "aria-label": S(s)("el.inputNumber.increase"),
                          class: ce([
                            S(n).e("increase"),
                            S(n).is("disabled", S(c)),
                          ]),
                          onKeydown: go(b, ["enter"]),
                        },
                        [
                          Xe(M.$slots, "increase-icon", {}, () => [
                            ne(S(xt), null, {
                              default: be(() => [
                                S(d)
                                  ? (j(), Me(S(vP), { key: 0 }))
                                  : (j(), Me(S(MP), { key: 1 })),
                              ]),
                              _: 1,
                            }),
                          ]),
                        ],
                        42,
                        ["aria-label", "onKeydown"]
                      )),
                      [[S(E0), b]]
                    )
                  : Re("v-if", !0),
                ne(
                  S(OF),
                  {
                    id: M.id,
                    ref_key: "input",
                    ref: a,
                    type: "number",
                    step: M.step,
                    "model-value": S(m),
                    placeholder: M.placeholder,
                    readonly: M.readonly,
                    disabled: S(p),
                    size: S(f),
                    max: M.max,
                    min: M.min,
                    name: M.name,
                    "aria-label": M.ariaLabel,
                    "validate-event": !1,
                    onKeydown: [
                      go(hi(b, ["prevent"]), ["up"]),
                      go(hi(y, ["prevent"]), ["down"]),
                    ],
                    onBlur: R,
                    onFocus: B,
                    onInput: E,
                    onChange: A,
                  },
                  null,
                  8,
                  [
                    "id",
                    "step",
                    "model-value",
                    "placeholder",
                    "readonly",
                    "disabled",
                    "size",
                    "max",
                    "min",
                    "name",
                    "aria-label",
                    "onKeydown",
                  ]
                ),
              ],
              42,
              ["onDragstart"]
            )
          )
        );
      },
    });
  var aO = ct(nO, [["__file", "input-number.vue"]]);
  const oO = Qt(aO),
    lO = et({
      title: String,
      confirmButtonText: String,
      cancelButtonText: String,
      confirmButtonType: { type: String, values: kd, default: "primary" },
      cancelButtonType: { type: String, values: kd, default: "text" },
      icon: { type: hs, default: () => BP },
      iconColor: { type: String, default: "#f90" },
      hideIcon: { type: Boolean, default: !1 },
      hideAfter: { type: Number, default: 200 },
      teleported: Lh.teleported,
      persistent: Lh.persistent,
      width: { type: [String, Number], default: 150 },
    }),
    hO = {
      confirm: (r) => r instanceof MouseEvent,
      cancel: (r) => r instanceof MouseEvent,
    },
    cO = ge({ name: "ElPopconfirm" }),
    uO = ge({
      ...cO,
      props: lO,
      emits: hO,
      setup(r, { emit: e }) {
        const t = r,
          { t: i } = ul(),
          s = ut("popconfirm"),
          n = he(),
          a = () => {
            var d, f;
            (f = (d = n.value) == null ? void 0 : d.onClose) == null ||
              f.call(d);
          },
          o = X(() => ({ width: Fn(t.width) })),
          l = (d) => {
            e("confirm", d), a();
          },
          h = (d) => {
            e("cancel", d), a();
          },
          c = X(
            () => t.confirmButtonText || i("el.popconfirm.confirmButtonText")
          ),
          u = X(
            () => t.cancelButtonText || i("el.popconfirm.cancelButtonText")
          );
        return (d, f) => (
          j(),
          Me(
            S(Gx),
            Gr(
              {
                ref_key: "tooltipRef",
                ref: n,
                trigger: "click",
                effect: "light",
              },
              d.$attrs,
              {
                "popper-class": `${S(s).namespace.value}-popover`,
                "popper-style": S(o),
                teleported: d.teleported,
                "fallback-placements": ["bottom", "top", "right", "left"],
                "hide-after": d.hideAfter,
                persistent: d.persistent,
              }
            ),
            {
              content: be(() => [
                Se(
                  "div",
                  { class: ce(S(s).b()) },
                  [
                    Se(
                      "div",
                      { class: ce(S(s).e("main")) },
                      [
                        !d.hideIcon && d.icon
                          ? (j(),
                            Me(
                              S(xt),
                              {
                                key: 0,
                                class: ce(S(s).e("icon")),
                                style: Et({ color: d.iconColor }),
                              },
                              {
                                default: be(() => [(j(), Me(qt(d.icon)))]),
                                _: 1,
                              },
                              8,
                              ["class", "style"]
                            ))
                          : Re("v-if", !0),
                        vr(" " + Ut(d.title), 1),
                      ],
                      2
                    ),
                    Se(
                      "div",
                      { class: ce(S(s).e("action")) },
                      [
                        Xe(
                          d.$slots,
                          "actions",
                          { confirm: l, cancel: h },
                          () => [
                            ne(
                              S(Nd),
                              {
                                size: "small",
                                type:
                                  d.cancelButtonType === "text"
                                    ? ""
                                    : d.cancelButtonType,
                                text: d.cancelButtonType === "text",
                                onClick: h,
                              },
                              { default: be(() => [vr(Ut(S(u)), 1)]), _: 1 },
                              8,
                              ["type", "text"]
                            ),
                            ne(
                              S(Nd),
                              {
                                size: "small",
                                type:
                                  d.confirmButtonType === "text"
                                    ? ""
                                    : d.confirmButtonType,
                                text: d.confirmButtonType === "text",
                                onClick: l,
                              },
                              { default: be(() => [vr(Ut(S(c)), 1)]), _: 1 },
                              8,
                              ["type", "text"]
                            ),
                          ]
                        ),
                      ],
                      2
                    ),
                  ],
                  2
                ),
              ]),
              default: be(() => [
                d.$slots.reference
                  ? Xe(d.$slots, "reference", { key: 0 })
                  : Re("v-if", !0),
              ]),
              _: 3,
            },
            16,
            [
              "popper-class",
              "popper-style",
              "teleported",
              "hide-after",
              "persistent",
            ]
          )
        );
      },
    });
  var dO = ct(uO, [["__file", "popconfirm.vue"]]);
  const fO = Qt(dO),
    Qx = Symbol("sliderContextKey"),
    pO = et({
      modelValue: { type: Ne([Number, Array]), default: 0 },
      id: { type: String, default: void 0 },
      min: { type: Number, default: 0 },
      max: { type: Number, default: 100 },
      step: { type: Number, default: 1 },
      showInput: Boolean,
      showInputControls: { type: Boolean, default: !0 },
      size: Bn,
      inputSize: Bn,
      showStops: Boolean,
      showTooltip: { type: Boolean, default: !0 },
      formatTooltip: { type: Ne(Function), default: void 0 },
      disabled: Boolean,
      range: Boolean,
      vertical: Boolean,
      height: String,
      debounce: { type: Number, default: 300 },
      rangeStartLabel: { type: String, default: void 0 },
      rangeEndLabel: { type: String, default: void 0 },
      formatValueText: { type: Ne(Function), default: void 0 },
      tooltipClass: { type: String, default: void 0 },
      placement: { type: String, values: fl, default: "top" },
      marks: { type: Ne(Object) },
      validateEvent: { type: Boolean, default: !0 },
      ...en(["ariaLabel"]),
    }),
    xu = (r) => at(r) || (Oe(r) && r.every(at)),
    mO = { [$t]: xu, [Vi]: xu, [Ys]: xu },
    gO = (r, e, t) => {
      const i = he();
      return (
        Rt(async () => {
          r.range
            ? (Array.isArray(r.modelValue)
                ? ((e.firstValue = Math.max(r.min, r.modelValue[0])),
                  (e.secondValue = Math.min(r.max, r.modelValue[1])))
                : ((e.firstValue = r.min), (e.secondValue = r.max)),
              (e.oldValue = [e.firstValue, e.secondValue]))
            : (typeof r.modelValue != "number" || Number.isNaN(r.modelValue)
                ? (e.firstValue = r.min)
                : (e.firstValue = Math.min(
                    r.max,
                    Math.max(r.min, r.modelValue)
                  )),
              (e.oldValue = e.firstValue)),
            Vt(window, "resize", t),
            await _t(),
            t();
        }),
        { sliderWrapper: i }
      );
    },
    vO = (r) =>
      X(() =>
        r.marks
          ? Object.keys(r.marks)
              .map(Number.parseFloat)
              .sort((t, i) => t - i)
              .filter((t) => t <= r.max && t >= r.min)
              .map((t) => ({
                point: t,
                position: ((t - r.min) * 100) / (r.max - r.min),
                mark: r.marks[t],
              }))
          : []
      ),
    yO = (r, e, t) => {
      const { form: i, formItem: s } = Ja(),
        n = _n(),
        a = he(),
        o = he(),
        l = { firstButton: a, secondButton: o },
        h = X(() => r.disabled || (i == null ? void 0 : i.disabled) || !1),
        c = X(() => Math.min(e.firstValue, e.secondValue)),
        u = X(() => Math.max(e.firstValue, e.secondValue)),
        d = X(() =>
          r.range
            ? `${(100 * (u.value - c.value)) / (r.max - r.min)}%`
            : `${(100 * (e.firstValue - r.min)) / (r.max - r.min)}%`
        ),
        f = X(() =>
          r.range ? `${(100 * (c.value - r.min)) / (r.max - r.min)}%` : "0%"
        ),
        p = X(() => (r.vertical ? { height: r.height } : {})),
        m = X(() =>
          r.vertical
            ? { height: d.value, bottom: f.value }
            : { width: d.value, left: f.value }
        ),
        v = () => {
          n.value &&
            (e.sliderSize =
              n.value[`client${r.vertical ? "Height" : "Width"}`]);
        },
        g = (R) => {
          const I = r.min + (R * (r.max - r.min)) / 100;
          if (!r.range) return a;
          let P;
          return (
            Math.abs(c.value - I) < Math.abs(u.value - I)
              ? (P =
                  e.firstValue < e.secondValue ? "firstButton" : "secondButton")
              : (P =
                  e.firstValue > e.secondValue
                    ? "firstButton"
                    : "secondButton"),
            l[P]
          );
        },
        x = (R) => {
          const I = g(R);
          return I.value.setPosition(R), I;
        },
        b = (R) => {
          (e.firstValue = R ?? r.min),
            _(r.range ? [c.value, u.value] : R ?? r.min);
        },
        y = (R) => {
          (e.secondValue = R), r.range && _([c.value, u.value]);
        },
        _ = (R) => {
          t($t, R), t(Vi, R);
        },
        w = async () => {
          await _t(), t(Ys, r.range ? [c.value, u.value] : r.modelValue);
        },
        E = (R) => {
          var I, P, M, L, U, V;
          if (h.value || e.dragging) return;
          v();
          let z = 0;
          if (r.vertical) {
            const N =
              (M =
                (P = (I = R.touches) == null ? void 0 : I.item(0)) == null
                  ? void 0
                  : P.clientY) != null
                ? M
                : R.clientY;
            z =
              ((n.value.getBoundingClientRect().bottom - N) / e.sliderSize) *
              100;
          } else {
            const N =
                (V =
                  (U = (L = R.touches) == null ? void 0 : L.item(0)) == null
                    ? void 0
                    : U.clientX) != null
                  ? V
                  : R.clientX,
              O = n.value.getBoundingClientRect().left;
            z = ((N - O) / e.sliderSize) * 100;
          }
          if (!(z < 0 || z > 100)) return x(z);
        };
      return {
        elFormItem: s,
        slider: n,
        firstButton: a,
        secondButton: o,
        sliderDisabled: h,
        minValue: c,
        maxValue: u,
        runwayStyle: p,
        barStyle: m,
        resetSize: v,
        setPosition: x,
        emitChange: w,
        onSliderWrapperPrevent: (R) => {
          var I, P;
          (((I = l.firstButton.value) != null && I.dragging) ||
            ((P = l.secondButton.value) != null && P.dragging)) &&
            R.preventDefault();
        },
        onSliderClick: (R) => {
          E(R) && w();
        },
        onSliderDown: async (R) => {
          const I = E(R);
          I && (await _t(), I.value.onButtonDown(R));
        },
        onSliderMarkerDown: (R) => {
          h.value || e.dragging || x(R);
        },
        setFirstValue: b,
        setSecondValue: y,
      };
    },
    {
      left: bO,
      down: xO,
      right: _O,
      up: wO,
      home: TO,
      end: EO,
      pageUp: SO,
      pageDown: AO,
    } = ii,
    CO = (r, e, t) => {
      const i = he(),
        s = he(!1),
        n = X(() => e.value instanceof Function),
        a = X(() => (n.value && e.value(r.modelValue)) || r.modelValue),
        o = Id(() => {
          t.value && (s.value = !0);
        }, 50),
        l = Id(() => {
          t.value && (s.value = !1);
        }, 50);
      return {
        tooltip: i,
        tooltipVisible: s,
        formatValue: a,
        displayTooltip: o,
        hideTooltip: l,
      };
    },
    IO = (r, e, t) => {
      const {
          disabled: i,
          min: s,
          max: n,
          step: a,
          showTooltip: o,
          precision: l,
          sliderSize: h,
          formatTooltip: c,
          emitChange: u,
          resetSize: d,
          updateDragging: f,
        } = rt(Qx),
        {
          tooltip: p,
          tooltipVisible: m,
          formatValue: v,
          displayTooltip: g,
          hideTooltip: x,
        } = CO(r, c, o),
        b = he(),
        y = X(
          () => `${((r.modelValue - s.value) / (n.value - s.value)) * 100}%`
        ),
        _ = X(() => (r.vertical ? { bottom: y.value } : { left: y.value })),
        w = () => {
          (e.hovering = !0), g();
        },
        E = () => {
          (e.hovering = !1), e.dragging || x();
        },
        A = (H) => {
          i.value ||
            (H.preventDefault(),
            V(H),
            window.addEventListener("mousemove", z),
            window.addEventListener("touchmove", z),
            window.addEventListener("mouseup", N),
            window.addEventListener("touchend", N),
            window.addEventListener("contextmenu", N),
            b.value.focus());
        },
        C = (H) => {
          i.value ||
            ((e.newPosition =
              Number.parseFloat(y.value) + (H / (n.value - s.value)) * 100),
            O(e.newPosition),
            u());
        },
        F = () => {
          C(-a.value);
        },
        B = () => {
          C(a.value);
        },
        R = () => {
          C(-a.value * 4);
        },
        I = () => {
          C(a.value * 4);
        },
        P = () => {
          i.value || (O(0), u());
        },
        M = () => {
          i.value || (O(100), u());
        },
        L = (H) => {
          let G = !0;
          [bO, xO].includes(H.key)
            ? F()
            : [_O, wO].includes(H.key)
            ? B()
            : H.key === TO
            ? P()
            : H.key === EO
            ? M()
            : H.key === AO
            ? R()
            : H.key === SO
            ? I()
            : (G = !1),
            G && H.preventDefault();
        },
        U = (H) => {
          let G, q;
          return (
            H.type.startsWith("touch")
              ? ((q = H.touches[0].clientY), (G = H.touches[0].clientX))
              : ((q = H.clientY), (G = H.clientX)),
            { clientX: G, clientY: q }
          );
        },
        V = (H) => {
          (e.dragging = !0), (e.isClick = !0);
          const { clientX: G, clientY: q } = U(H);
          r.vertical ? (e.startY = q) : (e.startX = G),
            (e.startPosition = Number.parseFloat(y.value)),
            (e.newPosition = e.startPosition);
        },
        z = (H) => {
          if (e.dragging) {
            (e.isClick = !1), g(), d();
            let G;
            const { clientX: q, clientY: K } = U(H);
            r.vertical
              ? ((e.currentY = K),
                (G = ((e.startY - e.currentY) / h.value) * 100))
              : ((e.currentX = q),
                (G = ((e.currentX - e.startX) / h.value) * 100)),
              (e.newPosition = e.startPosition + G),
              O(e.newPosition);
          }
        },
        N = () => {
          e.dragging &&
            (setTimeout(() => {
              (e.dragging = !1),
                e.hovering || x(),
                e.isClick || O(e.newPosition),
                u();
            }, 0),
            window.removeEventListener("mousemove", z),
            window.removeEventListener("touchmove", z),
            window.removeEventListener("mouseup", N),
            window.removeEventListener("touchend", N),
            window.removeEventListener("contextmenu", N));
        },
        O = async (H) => {
          if (H === null || Number.isNaN(+H)) return;
          H < 0 ? (H = 0) : H > 100 && (H = 100);
          const G = 100 / ((n.value - s.value) / a.value);
          let K = Math.round(H / G) * G * (n.value - s.value) * 0.01 + s.value;
          (K = Number.parseFloat(K.toFixed(l.value))),
            K !== r.modelValue && t($t, K),
            !e.dragging &&
              r.modelValue !== e.oldValue &&
              (e.oldValue = r.modelValue),
            await _t(),
            e.dragging && g(),
            p.value.updatePopper();
        };
      return (
        De(
          () => e.dragging,
          (H) => {
            f(H);
          }
        ),
        Vt(b, "touchstart", A, { passive: !1 }),
        {
          disabled: i,
          button: b,
          tooltip: p,
          tooltipVisible: m,
          showTooltip: o,
          wrapperStyle: _,
          formatValue: v,
          handleMouseEnter: w,
          handleMouseLeave: E,
          onButtonDown: A,
          onKeyDown: L,
          setPosition: O,
        }
      );
    },
    PO = (r, e, t, i) => ({
      stops: X(() => {
        if (!r.showStops || r.min > r.max) return [];
        if (r.step === 0) return [];
        const a = (r.max - r.min) / r.step,
          o = (100 * r.step) / (r.max - r.min),
          l = Array.from({ length: a - 1 }).map((h, c) => (c + 1) * o);
        return r.range
          ? l.filter(
              (h) =>
                h < (100 * (t.value - r.min)) / (r.max - r.min) ||
                h > (100 * (i.value - r.min)) / (r.max - r.min)
            )
          : l.filter(
              (h) => h > (100 * (e.firstValue - r.min)) / (r.max - r.min)
            );
      }),
      getStopStyle: (a) =>
        r.vertical ? { bottom: `${a}%` } : { left: `${a}%` },
    }),
    RO = (r, e, t, i, s, n) => {
      const a = (h) => {
          s($t, h), s(Vi, h);
        },
        o = () =>
          r.range
            ? ![t.value, i.value].every((h, c) => h === e.oldValue[c])
            : r.modelValue !== e.oldValue,
        l = () => {
          var h, c;
          r.min > r.max && hl("Slider", "min should not be greater than max.");
          const u = r.modelValue;
          r.range && Array.isArray(u)
            ? u[1] < r.min
              ? a([r.min, r.min])
              : u[0] > r.max
              ? a([r.max, r.max])
              : u[0] < r.min
              ? a([r.min, u[1]])
              : u[1] > r.max
              ? a([u[0], r.max])
              : ((e.firstValue = u[0]),
                (e.secondValue = u[1]),
                o() &&
                  (r.validateEvent &&
                    ((h = n == null ? void 0 : n.validate) == null ||
                      h.call(n, "change").catch((d) => void 0)),
                  (e.oldValue = u.slice())))
            : !r.range &&
              typeof u == "number" &&
              !Number.isNaN(u) &&
              (u < r.min
                ? a(r.min)
                : u > r.max
                ? a(r.max)
                : ((e.firstValue = u),
                  o() &&
                    (r.validateEvent &&
                      ((c = n == null ? void 0 : n.validate) == null ||
                        c.call(n, "change").catch((d) => void 0)),
                    (e.oldValue = u))));
        };
      l(),
        De(
          () => e.dragging,
          (h) => {
            h || l();
          }
        ),
        De(
          () => r.modelValue,
          (h, c) => {
            e.dragging ||
              (Array.isArray(h) &&
                Array.isArray(c) &&
                h.every((u, d) => u === c[d]) &&
                e.firstValue === h[0] &&
                e.secondValue === h[1]) ||
              l();
          },
          { deep: !0 }
        ),
        De(
          () => [r.min, r.max],
          () => {
            l();
          }
        );
    },
    MO = et({
      modelValue: { type: Number, default: 0 },
      vertical: Boolean,
      tooltipClass: String,
      placement: { type: String, values: fl, default: "top" },
    }),
    FO = { [$t]: (r) => at(r) },
    BO = ge({ name: "ElSliderButton" }),
    OO = ge({
      ...BO,
      props: MO,
      emits: FO,
      setup(r, { expose: e, emit: t }) {
        const i = r,
          s = ut("slider"),
          n = vi({
            hovering: !1,
            dragging: !1,
            isClick: !1,
            startX: 0,
            currentX: 0,
            startY: 0,
            currentY: 0,
            startPosition: 0,
            newPosition: 0,
            oldValue: i.modelValue,
          }),
          {
            disabled: a,
            button: o,
            tooltip: l,
            showTooltip: h,
            tooltipVisible: c,
            wrapperStyle: u,
            formatValue: d,
            handleMouseEnter: f,
            handleMouseLeave: p,
            onButtonDown: m,
            onKeyDown: v,
            setPosition: g,
          } = IO(i, n, t),
          { hovering: x, dragging: b } = Ra(n);
        return (
          e({
            onButtonDown: m,
            onKeyDown: v,
            setPosition: g,
            hovering: x,
            dragging: b,
          }),
          (y, _) => (
            j(),
            xe(
              "div",
              {
                ref_key: "button",
                ref: o,
                class: ce([
                  S(s).e("button-wrapper"),
                  { hover: S(x), dragging: S(b) },
                ]),
                style: Et(S(u)),
                tabindex: S(a) ? -1 : 0,
                onMouseenter: S(f),
                onMouseleave: S(p),
                onMousedown: S(m),
                onFocus: S(f),
                onBlur: S(p),
                onKeydown: S(v),
              },
              [
                ne(
                  S(Gx),
                  {
                    ref_key: "tooltip",
                    ref: l,
                    visible: S(c),
                    placement: y.placement,
                    "fallback-placements": ["top", "bottom", "right", "left"],
                    "stop-popper-mouse-event": !1,
                    "popper-class": y.tooltipClass,
                    disabled: !S(h),
                    persistent: "",
                  },
                  {
                    content: be(() => [Se("span", null, Ut(S(d)), 1)]),
                    default: be(() => [
                      Se(
                        "div",
                        {
                          class: ce([
                            S(s).e("button"),
                            { hover: S(x), dragging: S(b) },
                          ]),
                        },
                        null,
                        2
                      ),
                    ]),
                    _: 1,
                  },
                  8,
                  ["visible", "placement", "popper-class", "disabled"]
                ),
              ],
              46,
              [
                "tabindex",
                "onMouseenter",
                "onMouseleave",
                "onMousedown",
                "onFocus",
                "onBlur",
                "onKeydown",
              ]
            )
          )
        );
      },
    });
  var S0 = ct(OO, [["__file", "button.vue"]]);
  const kO = et({ mark: { type: Ne([String, Object]), default: void 0 } });
  var DO = ge({
    name: "ElSliderMarker",
    props: kO,
    setup(r) {
      const e = ut("slider"),
        t = X(() => (Ge(r.mark) ? r.mark : r.mark.label)),
        i = X(() => (Ge(r.mark) ? void 0 : r.mark.style));
      return () =>
        Cb("div", { class: e.e("marks-text"), style: i.value }, t.value);
    },
  });
  const LO = ge({ name: "ElSlider" }),
    NO = ge({
      ...LO,
      props: pO,
      emits: mO,
      setup(r, { expose: e, emit: t }) {
        const i = r,
          s = ut("slider"),
          { t: n } = ul(),
          a = vi({
            firstValue: 0,
            secondValue: 0,
            oldValue: 0,
            dragging: !1,
            sliderSize: 1,
          }),
          {
            elFormItem: o,
            slider: l,
            firstButton: h,
            secondButton: c,
            sliderDisabled: u,
            minValue: d,
            maxValue: f,
            runwayStyle: p,
            barStyle: m,
            resetSize: v,
            emitChange: g,
            onSliderWrapperPrevent: x,
            onSliderClick: b,
            onSliderDown: y,
            onSliderMarkerDown: _,
            setFirstValue: w,
            setSecondValue: E,
          } = yO(i, a, t),
          { stops: A, getStopStyle: C } = PO(i, a, d, f),
          { inputId: F, isLabeledByFormItem: B } = Oc(i, {
            formItemContext: o,
          }),
          R = ws(),
          I = X(() => i.inputSize || R.value),
          P = X(
            () =>
              i.ariaLabel ||
              n("el.slider.defaultLabel", { min: i.min, max: i.max })
          ),
          M = X(() =>
            i.range
              ? i.rangeStartLabel || n("el.slider.defaultRangeStartLabel")
              : P.value
          ),
          L = X(() =>
            i.formatValueText ? i.formatValueText(G.value) : `${G.value}`
          ),
          U = X(() => i.rangeEndLabel || n("el.slider.defaultRangeEndLabel")),
          V = X(() =>
            i.formatValueText ? i.formatValueText(q.value) : `${q.value}`
          ),
          z = X(() => [
            s.b(),
            s.m(R.value),
            s.is("vertical", i.vertical),
            { [s.m("with-input")]: i.showInput },
          ]),
          N = vO(i);
        RO(i, a, d, f, t, o);
        const O = X(() => {
            const ie = [i.min, i.max, i.step].map((ee) => {
              const ve = `${ee}`.split(".")[1];
              return ve ? ve.length : 0;
            });
            return Math.max.apply(null, ie);
          }),
          { sliderWrapper: H } = gO(i, a, v),
          { firstValue: G, secondValue: q, sliderSize: K } = Ra(a),
          ue = (ie) => {
            a.dragging = ie;
          };
        return (
          Vt(H, "touchstart", x, { passive: !1 }),
          Vt(H, "touchmove", x, { passive: !1 }),
          Fr(Qx, {
            ...Ra(i),
            sliderSize: K,
            disabled: u,
            precision: O,
            emitChange: g,
            resetSize: v,
            updateDragging: ue,
          }),
          e({ onSliderClick: b }),
          (ie, ee) => {
            var ve, ye;
            return (
              j(),
              xe(
                "div",
                {
                  id: ie.range ? S(F) : void 0,
                  ref_key: "sliderWrapper",
                  ref: H,
                  class: ce(S(z)),
                  role: ie.range ? "group" : void 0,
                  "aria-label": ie.range && !S(B) ? S(P) : void 0,
                  "aria-labelledby":
                    ie.range && S(B)
                      ? (ve = S(o)) == null
                        ? void 0
                        : ve.labelId
                      : void 0,
                },
                [
                  Se(
                    "div",
                    {
                      ref_key: "slider",
                      ref: l,
                      class: ce([
                        S(s).e("runway"),
                        { "show-input": ie.showInput && !ie.range },
                        S(s).is("disabled", S(u)),
                      ]),
                      style: Et(S(p)),
                      onMousedown: S(y),
                      onTouchstartPassive: S(y),
                    },
                    [
                      Se(
                        "div",
                        { class: ce(S(s).e("bar")), style: Et(S(m)) },
                        null,
                        6
                      ),
                      ne(
                        S0,
                        {
                          id: ie.range ? void 0 : S(F),
                          ref_key: "firstButton",
                          ref: h,
                          "model-value": S(G),
                          vertical: ie.vertical,
                          "tooltip-class": ie.tooltipClass,
                          placement: ie.placement,
                          role: "slider",
                          "aria-label": ie.range || !S(B) ? S(M) : void 0,
                          "aria-labelledby":
                            !ie.range && S(B)
                              ? (ye = S(o)) == null
                                ? void 0
                                : ye.labelId
                              : void 0,
                          "aria-valuemin": ie.min,
                          "aria-valuemax": ie.range ? S(q) : ie.max,
                          "aria-valuenow": S(G),
                          "aria-valuetext": S(L),
                          "aria-orientation": ie.vertical
                            ? "vertical"
                            : "horizontal",
                          "aria-disabled": S(u),
                          "onUpdate:modelValue": S(w),
                        },
                        null,
                        8,
                        [
                          "id",
                          "model-value",
                          "vertical",
                          "tooltip-class",
                          "placement",
                          "aria-label",
                          "aria-labelledby",
                          "aria-valuemin",
                          "aria-valuemax",
                          "aria-valuenow",
                          "aria-valuetext",
                          "aria-orientation",
                          "aria-disabled",
                          "onUpdate:modelValue",
                        ]
                      ),
                      ie.range
                        ? (j(),
                          Me(
                            S0,
                            {
                              key: 0,
                              ref_key: "secondButton",
                              ref: c,
                              "model-value": S(q),
                              vertical: ie.vertical,
                              "tooltip-class": ie.tooltipClass,
                              placement: ie.placement,
                              role: "slider",
                              "aria-label": S(U),
                              "aria-valuemin": S(G),
                              "aria-valuemax": ie.max,
                              "aria-valuenow": S(q),
                              "aria-valuetext": S(V),
                              "aria-orientation": ie.vertical
                                ? "vertical"
                                : "horizontal",
                              "aria-disabled": S(u),
                              "onUpdate:modelValue": S(E),
                            },
                            null,
                            8,
                            [
                              "model-value",
                              "vertical",
                              "tooltip-class",
                              "placement",
                              "aria-label",
                              "aria-valuemin",
                              "aria-valuemax",
                              "aria-valuenow",
                              "aria-valuetext",
                              "aria-orientation",
                              "aria-disabled",
                              "onUpdate:modelValue",
                            ]
                          ))
                        : Re("v-if", !0),
                      ie.showStops
                        ? (j(),
                          xe("div", { key: 1 }, [
                            (j(!0),
                            xe(
                              ot,
                              null,
                              Io(
                                S(A),
                                (_e, ke) => (
                                  j(),
                                  xe(
                                    "div",
                                    {
                                      key: ke,
                                      class: ce(S(s).e("stop")),
                                      style: Et(S(C)(_e)),
                                    },
                                    null,
                                    6
                                  )
                                )
                              ),
                              128
                            )),
                          ]))
                        : Re("v-if", !0),
                      S(N).length > 0
                        ? (j(),
                          xe(
                            ot,
                            { key: 2 },
                            [
                              Se("div", null, [
                                (j(!0),
                                xe(
                                  ot,
                                  null,
                                  Io(
                                    S(N),
                                    (_e, ke) => (
                                      j(),
                                      xe(
                                        "div",
                                        {
                                          key: ke,
                                          style: Et(S(C)(_e.position)),
                                          class: ce([
                                            S(s).e("stop"),
                                            S(s).e("marks-stop"),
                                          ]),
                                        },
                                        null,
                                        6
                                      )
                                    )
                                  ),
                                  128
                                )),
                              ]),
                              Se(
                                "div",
                                { class: ce(S(s).e("marks")) },
                                [
                                  (j(!0),
                                  xe(
                                    ot,
                                    null,
                                    Io(
                                      S(N),
                                      (_e, ke) => (
                                        j(),
                                        Me(
                                          S(DO),
                                          {
                                            key: ke,
                                            mark: _e.mark,
                                            style: Et(S(C)(_e.position)),
                                            onMousedown: hi(
                                              (k) => S(_)(_e.position),
                                              ["stop"]
                                            ),
                                          },
                                          null,
                                          8,
                                          ["mark", "style", "onMousedown"]
                                        )
                                      )
                                    ),
                                    128
                                  )),
                                ],
                                2
                              ),
                            ],
                            64
                          ))
                        : Re("v-if", !0),
                    ],
                    46,
                    ["onMousedown", "onTouchstartPassive"]
                  ),
                  ie.showInput && !ie.range
                    ? (j(),
                      Me(
                        S(oO),
                        {
                          key: 0,
                          ref: "input",
                          "model-value": S(G),
                          class: ce(S(s).e("input")),
                          step: ie.step,
                          disabled: S(u),
                          controls: ie.showInputControls,
                          min: ie.min,
                          max: ie.max,
                          precision: S(O),
                          debounce: ie.debounce,
                          size: S(I),
                          "onUpdate:modelValue": S(w),
                          onChange: S(g),
                        },
                        null,
                        8,
                        [
                          "model-value",
                          "class",
                          "step",
                          "disabled",
                          "controls",
                          "min",
                          "max",
                          "precision",
                          "debounce",
                          "size",
                          "onUpdate:modelValue",
                          "onChange",
                        ]
                      ))
                    : Re("v-if", !0),
                ],
                10,
                ["id", "role", "aria-label", "aria-labelledby"]
              )
            );
          }
        );
      },
    });
  var UO = ct(NO, [["__file", "slider.vue"]]);
  const VO = Qt(UO),
    $O = et({
      modelValue: { type: [Boolean, String, Number], default: !1 },
      disabled: Boolean,
      loading: Boolean,
      size: { type: String, validator: jP },
      width: { type: [String, Number], default: "" },
      inlinePrompt: Boolean,
      inactiveActionIcon: { type: hs },
      activeActionIcon: { type: hs },
      activeIcon: { type: hs },
      inactiveIcon: { type: hs },
      activeText: { type: String, default: "" },
      inactiveText: { type: String, default: "" },
      activeValue: { type: [Boolean, String, Number], default: !0 },
      inactiveValue: { type: [Boolean, String, Number], default: !1 },
      name: { type: String, default: "" },
      validateEvent: { type: Boolean, default: !0 },
      beforeChange: { type: Ne(Function) },
      id: String,
      tabindex: { type: [String, Number] },
      ...en(["ariaLabel"]),
    }),
    GO = {
      [$t]: (r) => Ui(r) || Ge(r) || at(r),
      [Ys]: (r) => Ui(r) || Ge(r) || at(r),
      [Vi]: (r) => Ui(r) || Ge(r) || at(r),
    },
    e1 = "ElSwitch",
    HO = ge({ name: e1 }),
    XO = ge({
      ...HO,
      props: $O,
      emits: GO,
      setup(r, { expose: e, emit: t }) {
        const i = r,
          { formItem: s } = Ja(),
          n = ws(),
          a = ut("switch"),
          { inputId: o } = Oc(i, { formItemContext: s }),
          l = Za(X(() => i.loading)),
          h = he(i.modelValue !== !1),
          c = he(),
          u = he(),
          d = X(() => [
            a.b(),
            a.m(n.value),
            a.is("disabled", l.value),
            a.is("checked", g.value),
          ]),
          f = X(() => [
            a.e("label"),
            a.em("label", "left"),
            a.is("active", !g.value),
          ]),
          p = X(() => [
            a.e("label"),
            a.em("label", "right"),
            a.is("active", g.value),
          ]),
          m = X(() => ({ width: Fn(i.width) }));
        De(
          () => i.modelValue,
          () => {
            h.value = !0;
          }
        );
        const v = X(() => (h.value ? i.modelValue : !1)),
          g = X(() => v.value === i.activeValue);
        [i.activeValue, i.inactiveValue].includes(v.value) ||
          (t($t, i.inactiveValue),
          t(Ys, i.inactiveValue),
          t(Vi, i.inactiveValue)),
          De(g, (_) => {
            var w;
            (c.value.checked = _),
              i.validateEvent &&
                ((w = s == null ? void 0 : s.validate) == null ||
                  w.call(s, "change").catch((E) => void 0));
          });
        const x = () => {
            const _ = g.value ? i.inactiveValue : i.activeValue;
            t($t, _),
              t(Ys, _),
              t(Vi, _),
              _t(() => {
                c.value.checked = g.value;
              });
          },
          b = () => {
            if (l.value) return;
            const { beforeChange: _ } = i;
            if (!_) {
              x();
              return;
            }
            const w = _();
            [Sh(w), Ui(w)].includes(!0) ||
              hl(
                e1,
                "beforeChange must return type `Promise<boolean>` or `boolean`"
              ),
              Sh(w)
                ? w
                    .then((A) => {
                      A && x();
                    })
                    .catch((A) => {})
                : w && x();
          },
          y = () => {
            var _, w;
            (w = (_ = c.value) == null ? void 0 : _.focus) == null || w.call(_);
          };
        return (
          Rt(() => {
            c.value.checked = g.value;
          }),
          e({ focus: y, checked: g }),
          (_, w) => (
            j(),
            xe(
              "div",
              { class: ce(S(d)), onClick: hi(b, ["prevent"]) },
              [
                Se(
                  "input",
                  {
                    id: S(o),
                    ref_key: "input",
                    ref: c,
                    class: ce(S(a).e("input")),
                    type: "checkbox",
                    role: "switch",
                    "aria-checked": S(g),
                    "aria-disabled": S(l),
                    "aria-label": _.ariaLabel,
                    name: _.name,
                    "true-value": _.activeValue,
                    "false-value": _.inactiveValue,
                    disabled: S(l),
                    tabindex: _.tabindex,
                    onChange: x,
                    onKeydown: go(b, ["enter"]),
                  },
                  null,
                  42,
                  [
                    "id",
                    "aria-checked",
                    "aria-disabled",
                    "aria-label",
                    "name",
                    "true-value",
                    "false-value",
                    "disabled",
                    "tabindex",
                    "onKeydown",
                  ]
                ),
                !_.inlinePrompt && (_.inactiveIcon || _.inactiveText)
                  ? (j(),
                    xe(
                      "span",
                      { key: 0, class: ce(S(f)) },
                      [
                        _.inactiveIcon
                          ? (j(),
                            Me(
                              S(xt),
                              { key: 0 },
                              {
                                default: be(() => [
                                  (j(), Me(qt(_.inactiveIcon))),
                                ]),
                                _: 1,
                              }
                            ))
                          : Re("v-if", !0),
                        !_.inactiveIcon && _.inactiveText
                          ? (j(),
                            xe(
                              "span",
                              { key: 1, "aria-hidden": S(g) },
                              Ut(_.inactiveText),
                              9,
                              ["aria-hidden"]
                            ))
                          : Re("v-if", !0),
                      ],
                      2
                    ))
                  : Re("v-if", !0),
                Se(
                  "span",
                  {
                    ref_key: "core",
                    ref: u,
                    class: ce(S(a).e("core")),
                    style: Et(S(m)),
                  },
                  [
                    _.inlinePrompt
                      ? (j(),
                        xe(
                          "div",
                          { key: 0, class: ce(S(a).e("inner")) },
                          [
                            _.activeIcon || _.inactiveIcon
                              ? (j(),
                                Me(
                                  S(xt),
                                  { key: 0, class: ce(S(a).is("icon")) },
                                  {
                                    default: be(() => [
                                      (j(),
                                      Me(
                                        qt(S(g) ? _.activeIcon : _.inactiveIcon)
                                      )),
                                    ]),
                                    _: 1,
                                  },
                                  8,
                                  ["class"]
                                ))
                              : _.activeText || _.inactiveText
                              ? (j(),
                                xe(
                                  "span",
                                  {
                                    key: 1,
                                    class: ce(S(a).is("text")),
                                    "aria-hidden": !S(g),
                                  },
                                  Ut(S(g) ? _.activeText : _.inactiveText),
                                  11,
                                  ["aria-hidden"]
                                ))
                              : Re("v-if", !0),
                          ],
                          2
                        ))
                      : Re("v-if", !0),
                    Se(
                      "div",
                      { class: ce(S(a).e("action")) },
                      [
                        _.loading
                          ? (j(),
                            Me(
                              S(xt),
                              { key: 0, class: ce(S(a).is("loading")) },
                              { default: be(() => [ne(S(Mp))]), _: 1 },
                              8,
                              ["class"]
                            ))
                          : S(g)
                          ? Xe(_.$slots, "active-action", { key: 1 }, () => [
                              _.activeActionIcon
                                ? (j(),
                                  Me(
                                    S(xt),
                                    { key: 0 },
                                    {
                                      default: be(() => [
                                        (j(), Me(qt(_.activeActionIcon))),
                                      ]),
                                      _: 1,
                                    }
                                  ))
                                : Re("v-if", !0),
                            ])
                          : S(g)
                          ? Re("v-if", !0)
                          : Xe(_.$slots, "inactive-action", { key: 2 }, () => [
                              _.inactiveActionIcon
                                ? (j(),
                                  Me(
                                    S(xt),
                                    { key: 0 },
                                    {
                                      default: be(() => [
                                        (j(), Me(qt(_.inactiveActionIcon))),
                                      ]),
                                      _: 1,
                                    }
                                  ))
                                : Re("v-if", !0),
                            ]),
                      ],
                      2
                    ),
                  ],
                  6
                ),
                !_.inlinePrompt && (_.activeIcon || _.activeText)
                  ? (j(),
                    xe(
                      "span",
                      { key: 1, class: ce(S(p)) },
                      [
                        _.activeIcon
                          ? (j(),
                            Me(
                              S(xt),
                              { key: 0 },
                              {
                                default: be(() => [
                                  (j(), Me(qt(_.activeIcon))),
                                ]),
                                _: 1,
                              }
                            ))
                          : Re("v-if", !0),
                        !_.activeIcon && _.activeText
                          ? (j(),
                            xe(
                              "span",
                              { key: 1, "aria-hidden": !S(g) },
                              Ut(_.activeText),
                              9,
                              ["aria-hidden"]
                            ))
                          : Re("v-if", !0),
                      ],
                      2
                    ))
                  : Re("v-if", !0),
              ],
              10,
              ["onClick"]
            )
          )
        );
      },
    });
  var zO = ct(XO, [["__file", "switch.vue"]]);
  const WO = Qt(zO),
    YO = et({
      type: {
        type: String,
        values: ["primary", "success", "info", "warning", "danger", ""],
        default: "",
      },
      size: { type: String, values: cl, default: "" },
      truncated: Boolean,
      lineClamp: { type: [String, Number] },
      tag: { type: String, default: "span" },
    }),
    jO = ge({ name: "ElText" }),
    qO = ge({
      ...jO,
      props: YO,
      setup(r) {
        const e = r,
          t = ws(),
          i = ut("text"),
          s = X(() => [
            i.b(),
            i.m(e.type),
            i.m(t.value),
            i.is("truncated", e.truncated),
            i.is("line-clamp", !la(e.lineClamp)),
          ]);
        return (n, a) => (
          j(),
          Me(
            qt(n.tag),
            {
              class: ce(S(s)),
              style: Et({ "-webkit-line-clamp": n.lineClamp }),
            },
            { default: be(() => [Xe(n.$slots, "default")]), _: 3 },
            8,
            ["class", "style"]
          )
        );
      },
    });
  var KO = ct(qO, [["__file", "text.vue"]]);
  const ZO = Qt(KO);
  var $n = ((r) => (
      (r[(r.WEBGL_LEGACY = 0)] = "WEBGL_LEGACY"),
      (r[(r.WEBGL = 1)] = "WEBGL"),
      (r[(r.WEBGL2 = 2)] = "WEBGL2"),
      r
    ))($n || {}),
    t1 = ((r) => (
      (r[(r.UNKNOWN = 0)] = "UNKNOWN"),
      (r[(r.WEBGL = 1)] = "WEBGL"),
      (r[(r.CANVAS = 2)] = "CANVAS"),
      r
    ))(t1 || {}),
    Ud = ((r) => (
      (r[(r.COLOR = 16384)] = "COLOR"),
      (r[(r.DEPTH = 256)] = "DEPTH"),
      (r[(r.STENCIL = 1024)] = "STENCIL"),
      r
    ))(Ud || {}),
    Be = ((r) => (
      (r[(r.NORMAL = 0)] = "NORMAL"),
      (r[(r.ADD = 1)] = "ADD"),
      (r[(r.MULTIPLY = 2)] = "MULTIPLY"),
      (r[(r.SCREEN = 3)] = "SCREEN"),
      (r[(r.OVERLAY = 4)] = "OVERLAY"),
      (r[(r.DARKEN = 5)] = "DARKEN"),
      (r[(r.LIGHTEN = 6)] = "LIGHTEN"),
      (r[(r.COLOR_DODGE = 7)] = "COLOR_DODGE"),
      (r[(r.COLOR_BURN = 8)] = "COLOR_BURN"),
      (r[(r.HARD_LIGHT = 9)] = "HARD_LIGHT"),
      (r[(r.SOFT_LIGHT = 10)] = "SOFT_LIGHT"),
      (r[(r.DIFFERENCE = 11)] = "DIFFERENCE"),
      (r[(r.EXCLUSION = 12)] = "EXCLUSION"),
      (r[(r.HUE = 13)] = "HUE"),
      (r[(r.SATURATION = 14)] = "SATURATION"),
      (r[(r.COLOR = 15)] = "COLOR"),
      (r[(r.LUMINOSITY = 16)] = "LUMINOSITY"),
      (r[(r.NORMAL_NPM = 17)] = "NORMAL_NPM"),
      (r[(r.ADD_NPM = 18)] = "ADD_NPM"),
      (r[(r.SCREEN_NPM = 19)] = "SCREEN_NPM"),
      (r[(r.NONE = 20)] = "NONE"),
      (r[(r.SRC_OVER = 0)] = "SRC_OVER"),
      (r[(r.SRC_IN = 21)] = "SRC_IN"),
      (r[(r.SRC_OUT = 22)] = "SRC_OUT"),
      (r[(r.SRC_ATOP = 23)] = "SRC_ATOP"),
      (r[(r.DST_OVER = 24)] = "DST_OVER"),
      (r[(r.DST_IN = 25)] = "DST_IN"),
      (r[(r.DST_OUT = 26)] = "DST_OUT"),
      (r[(r.DST_ATOP = 27)] = "DST_ATOP"),
      (r[(r.ERASE = 26)] = "ERASE"),
      (r[(r.SUBTRACT = 28)] = "SUBTRACT"),
      (r[(r.XOR = 29)] = "XOR"),
      r
    ))(Be || {}),
    Di = ((r) => (
      (r[(r.POINTS = 0)] = "POINTS"),
      (r[(r.LINES = 1)] = "LINES"),
      (r[(r.LINE_LOOP = 2)] = "LINE_LOOP"),
      (r[(r.LINE_STRIP = 3)] = "LINE_STRIP"),
      (r[(r.TRIANGLES = 4)] = "TRIANGLES"),
      (r[(r.TRIANGLE_STRIP = 5)] = "TRIANGLE_STRIP"),
      (r[(r.TRIANGLE_FAN = 6)] = "TRIANGLE_FAN"),
      r
    ))(Di || {}),
    le = ((r) => (
      (r[(r.RGBA = 6408)] = "RGBA"),
      (r[(r.RGB = 6407)] = "RGB"),
      (r[(r.RG = 33319)] = "RG"),
      (r[(r.RED = 6403)] = "RED"),
      (r[(r.RGBA_INTEGER = 36249)] = "RGBA_INTEGER"),
      (r[(r.RGB_INTEGER = 36248)] = "RGB_INTEGER"),
      (r[(r.RG_INTEGER = 33320)] = "RG_INTEGER"),
      (r[(r.RED_INTEGER = 36244)] = "RED_INTEGER"),
      (r[(r.ALPHA = 6406)] = "ALPHA"),
      (r[(r.LUMINANCE = 6409)] = "LUMINANCE"),
      (r[(r.LUMINANCE_ALPHA = 6410)] = "LUMINANCE_ALPHA"),
      (r[(r.DEPTH_COMPONENT = 6402)] = "DEPTH_COMPONENT"),
      (r[(r.DEPTH_STENCIL = 34041)] = "DEPTH_STENCIL"),
      r
    ))(le || {}),
    wa = ((r) => (
      (r[(r.TEXTURE_2D = 3553)] = "TEXTURE_2D"),
      (r[(r.TEXTURE_CUBE_MAP = 34067)] = "TEXTURE_CUBE_MAP"),
      (r[(r.TEXTURE_2D_ARRAY = 35866)] = "TEXTURE_2D_ARRAY"),
      (r[(r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
        "TEXTURE_CUBE_MAP_POSITIVE_X"),
      (r[(r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
        "TEXTURE_CUBE_MAP_NEGATIVE_X"),
      (r[(r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
        "TEXTURE_CUBE_MAP_POSITIVE_Y"),
      (r[(r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
        "TEXTURE_CUBE_MAP_NEGATIVE_Y"),
      (r[(r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
        "TEXTURE_CUBE_MAP_POSITIVE_Z"),
      (r[(r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
        "TEXTURE_CUBE_MAP_NEGATIVE_Z"),
      r
    ))(wa || {}),
    Ae = ((r) => (
      (r[(r.UNSIGNED_BYTE = 5121)] = "UNSIGNED_BYTE"),
      (r[(r.UNSIGNED_SHORT = 5123)] = "UNSIGNED_SHORT"),
      (r[(r.UNSIGNED_SHORT_5_6_5 = 33635)] = "UNSIGNED_SHORT_5_6_5"),
      (r[(r.UNSIGNED_SHORT_4_4_4_4 = 32819)] = "UNSIGNED_SHORT_4_4_4_4"),
      (r[(r.UNSIGNED_SHORT_5_5_5_1 = 32820)] = "UNSIGNED_SHORT_5_5_5_1"),
      (r[(r.UNSIGNED_INT = 5125)] = "UNSIGNED_INT"),
      (r[(r.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
        "UNSIGNED_INT_10F_11F_11F_REV"),
      (r[(r.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
        "UNSIGNED_INT_2_10_10_10_REV"),
      (r[(r.UNSIGNED_INT_24_8 = 34042)] = "UNSIGNED_INT_24_8"),
      (r[(r.UNSIGNED_INT_5_9_9_9_REV = 35902)] = "UNSIGNED_INT_5_9_9_9_REV"),
      (r[(r.BYTE = 5120)] = "BYTE"),
      (r[(r.SHORT = 5122)] = "SHORT"),
      (r[(r.INT = 5124)] = "INT"),
      (r[(r.FLOAT = 5126)] = "FLOAT"),
      (r[(r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
        "FLOAT_32_UNSIGNED_INT_24_8_REV"),
      (r[(r.HALF_FLOAT = 36193)] = "HALF_FLOAT"),
      r
    ))(Ae || {}),
    Ee = ((r) => (
      (r[(r.FLOAT = 0)] = "FLOAT"),
      (r[(r.INT = 1)] = "INT"),
      (r[(r.UINT = 2)] = "UINT"),
      r
    ))(Ee || {}),
    ai = ((r) => (
      (r[(r.NEAREST = 0)] = "NEAREST"), (r[(r.LINEAR = 1)] = "LINEAR"), r
    ))(ai || {}),
    ci = ((r) => (
      (r[(r.CLAMP = 33071)] = "CLAMP"),
      (r[(r.REPEAT = 10497)] = "REPEAT"),
      (r[(r.MIRRORED_REPEAT = 33648)] = "MIRRORED_REPEAT"),
      r
    ))(ci || {}),
    Yr = ((r) => (
      (r[(r.OFF = 0)] = "OFF"),
      (r[(r.POW2 = 1)] = "POW2"),
      (r[(r.ON = 2)] = "ON"),
      (r[(r.ON_MANUAL = 3)] = "ON_MANUAL"),
      r
    ))(Yr || {}),
    sr = ((r) => (
      (r[(r.NPM = 0)] = "NPM"),
      (r[(r.UNPACK = 1)] = "UNPACK"),
      (r[(r.PMA = 2)] = "PMA"),
      (r[(r.NO_PREMULTIPLIED_ALPHA = 0)] = "NO_PREMULTIPLIED_ALPHA"),
      (r[(r.PREMULTIPLY_ON_UPLOAD = 1)] = "PREMULTIPLY_ON_UPLOAD"),
      (r[(r.PREMULTIPLIED_ALPHA = 2)] = "PREMULTIPLIED_ALPHA"),
      r
    ))(sr || {}),
    Oi = ((r) => (
      (r[(r.NO = 0)] = "NO"),
      (r[(r.YES = 1)] = "YES"),
      (r[(r.AUTO = 2)] = "AUTO"),
      (r[(r.BLEND = 0)] = "BLEND"),
      (r[(r.CLEAR = 1)] = "CLEAR"),
      (r[(r.BLIT = 2)] = "BLIT"),
      r
    ))(Oi || {}),
    Yp = ((r) => (
      (r[(r.AUTO = 0)] = "AUTO"), (r[(r.MANUAL = 1)] = "MANUAL"), r
    ))(Yp || {}),
    Ur = ((r) => (
      (r.LOW = "lowp"), (r.MEDIUM = "mediump"), (r.HIGH = "highp"), r
    ))(Ur || {}),
    Lt = ((r) => (
      (r[(r.NONE = 0)] = "NONE"),
      (r[(r.SCISSOR = 1)] = "SCISSOR"),
      (r[(r.STENCIL = 2)] = "STENCIL"),
      (r[(r.SPRITE = 3)] = "SPRITE"),
      (r[(r.COLOR = 4)] = "COLOR"),
      r
    ))(Lt || {}),
    Ft = ((r) => (
      (r[(r.NONE = 0)] = "NONE"),
      (r[(r.LOW = 2)] = "LOW"),
      (r[(r.MEDIUM = 4)] = "MEDIUM"),
      (r[(r.HIGH = 8)] = "HIGH"),
      r
    ))(Ft || {}),
    Gi = ((r) => (
      (r[(r.ELEMENT_ARRAY_BUFFER = 34963)] = "ELEMENT_ARRAY_BUFFER"),
      (r[(r.ARRAY_BUFFER = 34962)] = "ARRAY_BUFFER"),
      (r[(r.UNIFORM_BUFFER = 35345)] = "UNIFORM_BUFFER"),
      r
    ))(Gi || {});
  const JO = {
      createCanvas: (r, e) => {
        const t = document.createElement("canvas");
        return (t.width = r), (t.height = e), t;
      },
      getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
      getWebGLRenderingContext: () => WebGLRenderingContext,
      getNavigator: () => navigator,
      getBaseUrl: () => document.baseURI ?? window.location.href,
      getFontFaceSet: () => document.fonts,
      fetch: (r, e) => fetch(r, e),
      parseXML: (r) => new DOMParser().parseFromString(r, "text/xml"),
    },
    we = {
      ADAPTER: JO,
      RESOLUTION: 1,
      CREATE_IMAGE_BITMAP: !1,
      ROUND_PIXELS: !1,
    };
  var _u = /iPhone/i,
    A0 = /iPod/i,
    C0 = /iPad/i,
    I0 = /\biOS-universal(?:.+)Mac\b/i,
    wu = /\bAndroid(?:.+)Mobile\b/i,
    P0 = /Android/i,
    jn = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
    Nl = /Silk/i,
    Ji = /Windows Phone/i,
    R0 = /\bWindows(?:.+)ARM\b/i,
    M0 = /BlackBerry/i,
    F0 = /BB10/i,
    B0 = /Opera Mini/i,
    O0 = /\b(CriOS|Chrome)(?:.+)Mobile/i,
    k0 = /Mobile(?:.+)Firefox\b/i,
    D0 = function (r) {
      return (
        typeof r < "u" &&
        r.platform === "MacIntel" &&
        typeof r.maxTouchPoints == "number" &&
        r.maxTouchPoints > 1 &&
        typeof MSStream > "u"
      );
    };
  function QO(r) {
    return function (e) {
      return e.test(r);
    };
  }
  function L0(r) {
    var e = { userAgent: "", platform: "", maxTouchPoints: 0 };
    !r && typeof navigator < "u"
      ? (e = {
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          maxTouchPoints: navigator.maxTouchPoints || 0,
        })
      : typeof r == "string"
      ? (e.userAgent = r)
      : r &&
        r.userAgent &&
        (e = {
          userAgent: r.userAgent,
          platform: r.platform,
          maxTouchPoints: r.maxTouchPoints || 0,
        });
    var t = e.userAgent,
      i = t.split("[FBAN");
    typeof i[1] < "u" && (t = i[0]),
      (i = t.split("Twitter")),
      typeof i[1] < "u" && (t = i[0]);
    var s = QO(t),
      n = {
        apple: {
          phone: s(_u) && !s(Ji),
          ipod: s(A0),
          tablet: !s(_u) && (s(C0) || D0(e)) && !s(Ji),
          universal: s(I0),
          device: (s(_u) || s(A0) || s(C0) || s(I0) || D0(e)) && !s(Ji),
        },
        amazon: {
          phone: s(jn),
          tablet: !s(jn) && s(Nl),
          device: s(jn) || s(Nl),
        },
        android: {
          phone: (!s(Ji) && s(jn)) || (!s(Ji) && s(wu)),
          tablet: !s(Ji) && !s(jn) && !s(wu) && (s(Nl) || s(P0)),
          device:
            (!s(Ji) && (s(jn) || s(Nl) || s(wu) || s(P0))) || s(/\bokhttp\b/i),
        },
        windows: { phone: s(Ji), tablet: s(R0), device: s(Ji) || s(R0) },
        other: {
          blackberry: s(M0),
          blackberry10: s(F0),
          opera: s(B0),
          firefox: s(k0),
          chrome: s(O0),
          device: s(M0) || s(F0) || s(B0) || s(k0) || s(O0),
        },
        any: !1,
        phone: !1,
        tablet: !1,
      };
    return (
      (n.any =
        n.apple.device ||
        n.android.device ||
        n.windows.device ||
        n.other.device),
      (n.phone = n.apple.phone || n.android.phone || n.windows.phone),
      (n.tablet = n.apple.tablet || n.android.tablet || n.windows.tablet),
      n
    );
  }
  const ek = L0.default ?? L0,
    cs = ek(globalThis.navigator);
  we.RETINA_PREFIX = /@([0-9\.]+)x/;
  we.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
  var r1 = { exports: {} };
  (function (r) {
    var e = Object.prototype.hasOwnProperty,
      t = "~";
    function i() {}
    Object.create &&
      ((i.prototype = Object.create(null)), new i().__proto__ || (t = !1));
    function s(l, h, c) {
      (this.fn = l), (this.context = h), (this.once = c || !1);
    }
    function n(l, h, c, u, d) {
      if (typeof c != "function")
        throw new TypeError("The listener must be a function");
      var f = new s(c, u || l, d),
        p = t ? t + h : h;
      return (
        l._events[p]
          ? l._events[p].fn
            ? (l._events[p] = [l._events[p], f])
            : l._events[p].push(f)
          : ((l._events[p] = f), l._eventsCount++),
        l
      );
    }
    function a(l, h) {
      --l._eventsCount === 0 ? (l._events = new i()) : delete l._events[h];
    }
    function o() {
      (this._events = new i()), (this._eventsCount = 0);
    }
    (o.prototype.eventNames = function () {
      var h = [],
        c,
        u;
      if (this._eventsCount === 0) return h;
      for (u in (c = this._events)) e.call(c, u) && h.push(t ? u.slice(1) : u);
      return Object.getOwnPropertySymbols
        ? h.concat(Object.getOwnPropertySymbols(c))
        : h;
    }),
      (o.prototype.listeners = function (h) {
        var c = t ? t + h : h,
          u = this._events[c];
        if (!u) return [];
        if (u.fn) return [u.fn];
        for (var d = 0, f = u.length, p = new Array(f); d < f; d++)
          p[d] = u[d].fn;
        return p;
      }),
      (o.prototype.listenerCount = function (h) {
        var c = t ? t + h : h,
          u = this._events[c];
        return u ? (u.fn ? 1 : u.length) : 0;
      }),
      (o.prototype.emit = function (h, c, u, d, f, p) {
        var m = t ? t + h : h;
        if (!this._events[m]) return !1;
        var v = this._events[m],
          g = arguments.length,
          x,
          b;
        if (v.fn) {
          switch ((v.once && this.removeListener(h, v.fn, void 0, !0), g)) {
            case 1:
              return v.fn.call(v.context), !0;
            case 2:
              return v.fn.call(v.context, c), !0;
            case 3:
              return v.fn.call(v.context, c, u), !0;
            case 4:
              return v.fn.call(v.context, c, u, d), !0;
            case 5:
              return v.fn.call(v.context, c, u, d, f), !0;
            case 6:
              return v.fn.call(v.context, c, u, d, f, p), !0;
          }
          for (b = 1, x = new Array(g - 1); b < g; b++) x[b - 1] = arguments[b];
          v.fn.apply(v.context, x);
        } else {
          var y = v.length,
            _;
          for (b = 0; b < y; b++)
            switch (
              (v[b].once && this.removeListener(h, v[b].fn, void 0, !0), g)
            ) {
              case 1:
                v[b].fn.call(v[b].context);
                break;
              case 2:
                v[b].fn.call(v[b].context, c);
                break;
              case 3:
                v[b].fn.call(v[b].context, c, u);
                break;
              case 4:
                v[b].fn.call(v[b].context, c, u, d);
                break;
              default:
                if (!x)
                  for (_ = 1, x = new Array(g - 1); _ < g; _++)
                    x[_ - 1] = arguments[_];
                v[b].fn.apply(v[b].context, x);
            }
        }
        return !0;
      }),
      (o.prototype.on = function (h, c, u) {
        return n(this, h, c, u, !1);
      }),
      (o.prototype.once = function (h, c, u) {
        return n(this, h, c, u, !0);
      }),
      (o.prototype.removeListener = function (h, c, u, d) {
        var f = t ? t + h : h;
        if (!this._events[f]) return this;
        if (!c) return a(this, f), this;
        var p = this._events[f];
        if (p.fn)
          p.fn === c && (!d || p.once) && (!u || p.context === u) && a(this, f);
        else {
          for (var m = 0, v = [], g = p.length; m < g; m++)
            (p[m].fn !== c || (d && !p[m].once) || (u && p[m].context !== u)) &&
              v.push(p[m]);
          v.length ? (this._events[f] = v.length === 1 ? v[0] : v) : a(this, f);
        }
        return this;
      }),
      (o.prototype.removeAllListeners = function (h) {
        var c;
        return (
          h
            ? ((c = t ? t + h : h), this._events[c] && a(this, c))
            : ((this._events = new i()), (this._eventsCount = 0)),
          this
        );
      }),
      (o.prototype.off = o.prototype.removeListener),
      (o.prototype.addListener = o.prototype.on),
      (o.prefixed = t),
      (o.EventEmitter = o),
      (r.exports = o);
  })(r1);
  var tk = r1.exports;
  const gl = Wx(tk);
  var jp = { exports: {} };
  jp.exports = Dc;
  jp.exports.default = Dc;
  function Dc(r, e, t) {
    t = t || 2;
    var i = e && e.length,
      s = i ? e[0] * t : r.length,
      n = i1(r, 0, s, t, !0),
      a = [];
    if (!n || n.next === n.prev) return a;
    var o, l, h, c, u, d, f;
    if ((i && (n = ak(r, e, n, t)), r.length > 80 * t)) {
      (o = h = r[0]), (l = c = r[1]);
      for (var p = t; p < s; p += t)
        (u = r[p]),
          (d = r[p + 1]),
          u < o && (o = u),
          d < l && (l = d),
          u > h && (h = u),
          d > c && (c = d);
      (f = Math.max(h - o, c - l)), (f = f !== 0 ? 32767 / f : 0);
    }
    return Qo(n, a, t, o, l, f, 0), a;
  }
  function i1(r, e, t, i, s) {
    var n, a;
    if (s === Gd(r, e, t, i) > 0)
      for (n = e; n < t; n += i) a = N0(n, r[n], r[n + 1], a);
    else for (n = t - i; n >= e; n -= i) a = N0(n, r[n], r[n + 1], a);
    return a && Lc(a, a.next) && (tl(a), (a = a.next)), a;
  }
  function kn(r, e) {
    if (!r) return r;
    e || (e = r);
    var t = r,
      i;
    do
      if (
        ((i = !1), !t.steiner && (Lc(t, t.next) || St(t.prev, t, t.next) === 0))
      ) {
        if ((tl(t), (t = e = t.prev), t === t.next)) break;
        i = !0;
      } else t = t.next;
    while (i || t !== e);
    return e;
  }
  function Qo(r, e, t, i, s, n, a) {
    if (r) {
      !a && n && uk(r, i, s, n);
      for (var o = r, l, h; r.prev !== r.next; ) {
        if (((l = r.prev), (h = r.next), n ? ik(r, i, s, n) : rk(r))) {
          e.push((l.i / t) | 0),
            e.push((r.i / t) | 0),
            e.push((h.i / t) | 0),
            tl(r),
            (r = h.next),
            (o = h.next);
          continue;
        }
        if (((r = h), r === o)) {
          a
            ? a === 1
              ? ((r = sk(kn(r), e, t)), Qo(r, e, t, i, s, n, 2))
              : a === 2 && nk(r, e, t, i, s, n)
            : Qo(kn(r), e, t, i, s, n, 1);
          break;
        }
      }
    }
  }
  function rk(r) {
    var e = r.prev,
      t = r,
      i = r.next;
    if (St(e, t, i) >= 0) return !1;
    for (
      var s = e.x,
        n = t.x,
        a = i.x,
        o = e.y,
        l = t.y,
        h = i.y,
        c = s < n ? (s < a ? s : a) : n < a ? n : a,
        u = o < l ? (o < h ? o : h) : l < h ? l : h,
        d = s > n ? (s > a ? s : a) : n > a ? n : a,
        f = o > l ? (o > h ? o : h) : l > h ? l : h,
        p = i.next;
      p !== e;

    ) {
      if (
        p.x >= c &&
        p.x <= d &&
        p.y >= u &&
        p.y <= f &&
        ha(s, o, n, l, a, h, p.x, p.y) &&
        St(p.prev, p, p.next) >= 0
      )
        return !1;
      p = p.next;
    }
    return !0;
  }
  function ik(r, e, t, i) {
    var s = r.prev,
      n = r,
      a = r.next;
    if (St(s, n, a) >= 0) return !1;
    for (
      var o = s.x,
        l = n.x,
        h = a.x,
        c = s.y,
        u = n.y,
        d = a.y,
        f = o < l ? (o < h ? o : h) : l < h ? l : h,
        p = c < u ? (c < d ? c : d) : u < d ? u : d,
        m = o > l ? (o > h ? o : h) : l > h ? l : h,
        v = c > u ? (c > d ? c : d) : u > d ? u : d,
        g = Vd(f, p, e, t, i),
        x = Vd(m, v, e, t, i),
        b = r.prevZ,
        y = r.nextZ;
      b && b.z >= g && y && y.z <= x;

    ) {
      if (
        (b.x >= f &&
          b.x <= m &&
          b.y >= p &&
          b.y <= v &&
          b !== s &&
          b !== a &&
          ha(o, c, l, u, h, d, b.x, b.y) &&
          St(b.prev, b, b.next) >= 0) ||
        ((b = b.prevZ),
        y.x >= f &&
          y.x <= m &&
          y.y >= p &&
          y.y <= v &&
          y !== s &&
          y !== a &&
          ha(o, c, l, u, h, d, y.x, y.y) &&
          St(y.prev, y, y.next) >= 0)
      )
        return !1;
      y = y.nextZ;
    }
    for (; b && b.z >= g; ) {
      if (
        b.x >= f &&
        b.x <= m &&
        b.y >= p &&
        b.y <= v &&
        b !== s &&
        b !== a &&
        ha(o, c, l, u, h, d, b.x, b.y) &&
        St(b.prev, b, b.next) >= 0
      )
        return !1;
      b = b.prevZ;
    }
    for (; y && y.z <= x; ) {
      if (
        y.x >= f &&
        y.x <= m &&
        y.y >= p &&
        y.y <= v &&
        y !== s &&
        y !== a &&
        ha(o, c, l, u, h, d, y.x, y.y) &&
        St(y.prev, y, y.next) >= 0
      )
        return !1;
      y = y.nextZ;
    }
    return !0;
  }
  function sk(r, e, t) {
    var i = r;
    do {
      var s = i.prev,
        n = i.next.next;
      !Lc(s, n) &&
        s1(s, i, i.next, n) &&
        el(s, n) &&
        el(n, s) &&
        (e.push((s.i / t) | 0),
        e.push((i.i / t) | 0),
        e.push((n.i / t) | 0),
        tl(i),
        tl(i.next),
        (i = r = n)),
        (i = i.next);
    } while (i !== r);
    return kn(i);
  }
  function nk(r, e, t, i, s, n) {
    var a = r;
    do {
      for (var o = a.next.next; o !== a.prev; ) {
        if (a.i !== o.i && pk(a, o)) {
          var l = n1(a, o);
          (a = kn(a, a.next)),
            (l = kn(l, l.next)),
            Qo(a, e, t, i, s, n, 0),
            Qo(l, e, t, i, s, n, 0);
          return;
        }
        o = o.next;
      }
      a = a.next;
    } while (a !== r);
  }
  function ak(r, e, t, i) {
    var s = [],
      n,
      a,
      o,
      l,
      h;
    for (n = 0, a = e.length; n < a; n++)
      (o = e[n] * i),
        (l = n < a - 1 ? e[n + 1] * i : r.length),
        (h = i1(r, o, l, i, !1)),
        h === h.next && (h.steiner = !0),
        s.push(fk(h));
    for (s.sort(ok), n = 0; n < s.length; n++) t = lk(s[n], t);
    return t;
  }
  function ok(r, e) {
    return r.x - e.x;
  }
  function lk(r, e) {
    var t = hk(r, e);
    if (!t) return e;
    var i = n1(t, r);
    return kn(i, i.next), kn(t, t.next);
  }
  function hk(r, e) {
    var t = e,
      i = r.x,
      s = r.y,
      n = -1 / 0,
      a;
    do {
      if (s <= t.y && s >= t.next.y && t.next.y !== t.y) {
        var o = t.x + ((s - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
        if (
          o <= i &&
          o > n &&
          ((n = o), (a = t.x < t.next.x ? t : t.next), o === i)
        )
          return a;
      }
      t = t.next;
    } while (t !== e);
    if (!a) return null;
    var l = a,
      h = a.x,
      c = a.y,
      u = 1 / 0,
      d;
    t = a;
    do
      i >= t.x &&
        t.x >= h &&
        i !== t.x &&
        ha(s < c ? i : n, s, h, c, s < c ? n : i, s, t.x, t.y) &&
        ((d = Math.abs(s - t.y) / (i - t.x)),
        el(t, r) &&
          (d < u || (d === u && (t.x > a.x || (t.x === a.x && ck(a, t))))) &&
          ((a = t), (u = d))),
        (t = t.next);
    while (t !== l);
    return a;
  }
  function ck(r, e) {
    return St(r.prev, r, e.prev) < 0 && St(e.next, r, r.next) < 0;
  }
  function uk(r, e, t, i) {
    var s = r;
    do
      s.z === 0 && (s.z = Vd(s.x, s.y, e, t, i)),
        (s.prevZ = s.prev),
        (s.nextZ = s.next),
        (s = s.next);
    while (s !== r);
    (s.prevZ.nextZ = null), (s.prevZ = null), dk(s);
  }
  function dk(r) {
    var e,
      t,
      i,
      s,
      n,
      a,
      o,
      l,
      h = 1;
    do {
      for (t = r, r = null, n = null, a = 0; t; ) {
        for (a++, i = t, o = 0, e = 0; e < h && (o++, (i = i.nextZ), !!i); e++);
        for (l = h; o > 0 || (l > 0 && i); )
          o !== 0 && (l === 0 || !i || t.z <= i.z)
            ? ((s = t), (t = t.nextZ), o--)
            : ((s = i), (i = i.nextZ), l--),
            n ? (n.nextZ = s) : (r = s),
            (s.prevZ = n),
            (n = s);
        t = i;
      }
      (n.nextZ = null), (h *= 2);
    } while (a > 1);
    return r;
  }
  function Vd(r, e, t, i, s) {
    return (
      (r = ((r - t) * s) | 0),
      (e = ((e - i) * s) | 0),
      (r = (r | (r << 8)) & 16711935),
      (r = (r | (r << 4)) & 252645135),
      (r = (r | (r << 2)) & 858993459),
      (r = (r | (r << 1)) & 1431655765),
      (e = (e | (e << 8)) & 16711935),
      (e = (e | (e << 4)) & 252645135),
      (e = (e | (e << 2)) & 858993459),
      (e = (e | (e << 1)) & 1431655765),
      r | (e << 1)
    );
  }
  function fk(r) {
    var e = r,
      t = r;
    do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
    while (e !== r);
    return t;
  }
  function ha(r, e, t, i, s, n, a, o) {
    return (
      (s - a) * (e - o) >= (r - a) * (n - o) &&
      (r - a) * (i - o) >= (t - a) * (e - o) &&
      (t - a) * (n - o) >= (s - a) * (i - o)
    );
  }
  function pk(r, e) {
    return (
      r.next.i !== e.i &&
      r.prev.i !== e.i &&
      !mk(r, e) &&
      ((el(r, e) &&
        el(e, r) &&
        gk(r, e) &&
        (St(r.prev, r, e.prev) || St(r, e.prev, e))) ||
        (Lc(r, e) && St(r.prev, r, r.next) > 0 && St(e.prev, e, e.next) > 0))
    );
  }
  function St(r, e, t) {
    return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y);
  }
  function Lc(r, e) {
    return r.x === e.x && r.y === e.y;
  }
  function s1(r, e, t, i) {
    var s = Vl(St(r, e, t)),
      n = Vl(St(r, e, i)),
      a = Vl(St(t, i, r)),
      o = Vl(St(t, i, e));
    return !!(
      (s !== n && a !== o) ||
      (s === 0 && Ul(r, t, e)) ||
      (n === 0 && Ul(r, i, e)) ||
      (a === 0 && Ul(t, r, i)) ||
      (o === 0 && Ul(t, e, i))
    );
  }
  function Ul(r, e, t) {
    return (
      e.x <= Math.max(r.x, t.x) &&
      e.x >= Math.min(r.x, t.x) &&
      e.y <= Math.max(r.y, t.y) &&
      e.y >= Math.min(r.y, t.y)
    );
  }
  function Vl(r) {
    return r > 0 ? 1 : r < 0 ? -1 : 0;
  }
  function mk(r, e) {
    var t = r;
    do {
      if (
        t.i !== r.i &&
        t.next.i !== r.i &&
        t.i !== e.i &&
        t.next.i !== e.i &&
        s1(t, t.next, r, e)
      )
        return !0;
      t = t.next;
    } while (t !== r);
    return !1;
  }
  function el(r, e) {
    return St(r.prev, r, r.next) < 0
      ? St(r, e, r.next) >= 0 && St(r, r.prev, e) >= 0
      : St(r, e, r.prev) < 0 || St(r, r.next, e) < 0;
  }
  function gk(r, e) {
    var t = r,
      i = !1,
      s = (r.x + e.x) / 2,
      n = (r.y + e.y) / 2;
    do
      t.y > n != t.next.y > n &&
        t.next.y !== t.y &&
        s < ((t.next.x - t.x) * (n - t.y)) / (t.next.y - t.y) + t.x &&
        (i = !i),
        (t = t.next);
    while (t !== r);
    return i;
  }
  function n1(r, e) {
    var t = new $d(r.i, r.x, r.y),
      i = new $d(e.i, e.x, e.y),
      s = r.next,
      n = e.prev;
    return (
      (r.next = e),
      (e.prev = r),
      (t.next = s),
      (s.prev = t),
      (i.next = t),
      (t.prev = i),
      (n.next = i),
      (i.prev = n),
      i
    );
  }
  function N0(r, e, t, i) {
    var s = new $d(r, e, t);
    return (
      i
        ? ((s.next = i.next), (s.prev = i), (i.next.prev = s), (i.next = s))
        : ((s.prev = s), (s.next = s)),
      s
    );
  }
  function tl(r) {
    (r.next.prev = r.prev),
      (r.prev.next = r.next),
      r.prevZ && (r.prevZ.nextZ = r.nextZ),
      r.nextZ && (r.nextZ.prevZ = r.prevZ);
  }
  function $d(r, e, t) {
    (this.i = r),
      (this.x = e),
      (this.y = t),
      (this.prev = null),
      (this.next = null),
      (this.z = 0),
      (this.prevZ = null),
      (this.nextZ = null),
      (this.steiner = !1);
  }
  Dc.deviation = function (r, e, t, i) {
    var s = e && e.length,
      n = s ? e[0] * t : r.length,
      a = Math.abs(Gd(r, 0, n, t));
    if (s)
      for (var o = 0, l = e.length; o < l; o++) {
        var h = e[o] * t,
          c = o < l - 1 ? e[o + 1] * t : r.length;
        a -= Math.abs(Gd(r, h, c, t));
      }
    var u = 0;
    for (o = 0; o < i.length; o += 3) {
      var d = i[o] * t,
        f = i[o + 1] * t,
        p = i[o + 2] * t;
      u += Math.abs(
        (r[d] - r[p]) * (r[f + 1] - r[d + 1]) -
          (r[d] - r[f]) * (r[p + 1] - r[d + 1])
      );
    }
    return a === 0 && u === 0 ? 0 : Math.abs((u - a) / a);
  };
  function Gd(r, e, t, i) {
    for (var s = 0, n = e, a = t - i; n < t; n += i)
      (s += (r[a] - r[n]) * (r[n + 1] + r[a + 1])), (a = n);
    return s;
  }
  Dc.flatten = function (r) {
    for (
      var e = r[0][0].length,
        t = { vertices: [], holes: [], dimensions: e },
        i = 0,
        s = 0;
      s < r.length;
      s++
    ) {
      for (var n = 0; n < r[s].length; n++)
        for (var a = 0; a < e; a++) t.vertices.push(r[s][n][a]);
      s > 0 && ((i += r[s - 1].length), t.holes.push(i));
    }
    return t;
  };
  var vk = jp.exports;
  const yk = Wx(vk);
  var Nh = { exports: {} };
  /*! https://mths.be/punycode v1.4.1 by @mathias */ Nh.exports;
  (function (r, e) {
    (function (t) {
      var i = e && !e.nodeType && e,
        s = r && !r.nodeType && r,
        n = typeof ko == "object" && ko;
      (n.global === n || n.window === n || n.self === n) && (t = n);
      var a,
        o = 2147483647,
        l = 36,
        h = 1,
        c = 26,
        u = 38,
        d = 700,
        f = 72,
        p = 128,
        m = "-",
        v = /^xn--/,
        g = /[^\x20-\x7E]/,
        x = /[\x2E\u3002\uFF0E\uFF61]/g,
        b = {
          overflow: "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input",
        },
        y = l - h,
        _ = Math.floor,
        w = String.fromCharCode,
        E;
      function A(N) {
        throw new RangeError(b[N]);
      }
      function C(N, O) {
        for (var H = N.length, G = []; H--; ) G[H] = O(N[H]);
        return G;
      }
      function F(N, O) {
        var H = N.split("@"),
          G = "";
        H.length > 1 && ((G = H[0] + "@"), (N = H[1])), (N = N.replace(x, "."));
        var q = N.split("."),
          K = C(q, O).join(".");
        return G + K;
      }
      function B(N) {
        for (var O = [], H = 0, G = N.length, q, K; H < G; )
          (q = N.charCodeAt(H++)),
            q >= 55296 && q <= 56319 && H < G
              ? ((K = N.charCodeAt(H++)),
                (K & 64512) == 56320
                  ? O.push(((q & 1023) << 10) + (K & 1023) + 65536)
                  : (O.push(q), H--))
              : O.push(q);
        return O;
      }
      function R(N) {
        return C(N, function (O) {
          var H = "";
          return (
            O > 65535 &&
              ((O -= 65536),
              (H += w(((O >>> 10) & 1023) | 55296)),
              (O = 56320 | (O & 1023))),
            (H += w(O)),
            H
          );
        }).join("");
      }
      function I(N) {
        return N - 48 < 10
          ? N - 22
          : N - 65 < 26
          ? N - 65
          : N - 97 < 26
          ? N - 97
          : l;
      }
      function P(N, O) {
        return N + 22 + 75 * (N < 26) - ((O != 0) << 5);
      }
      function M(N, O, H) {
        var G = 0;
        for (N = H ? _(N / d) : N >> 1, N += _(N / O); N > (y * c) >> 1; G += l)
          N = _(N / y);
        return _(G + ((y + 1) * N) / (N + u));
      }
      function L(N) {
        var O = [],
          H = N.length,
          G,
          q = 0,
          K = p,
          ue = f,
          ie,
          ee,
          ve,
          ye,
          _e,
          ke,
          k,
          D,
          W;
        for (ie = N.lastIndexOf(m), ie < 0 && (ie = 0), ee = 0; ee < ie; ++ee)
          N.charCodeAt(ee) >= 128 && A("not-basic"), O.push(N.charCodeAt(ee));
        for (ve = ie > 0 ? ie + 1 : 0; ve < H; ) {
          for (
            ye = q, _e = 1, ke = l;
            ve >= H && A("invalid-input"),
              (k = I(N.charCodeAt(ve++))),
              (k >= l || k > _((o - q) / _e)) && A("overflow"),
              (q += k * _e),
              (D = ke <= ue ? h : ke >= ue + c ? c : ke - ue),
              !(k < D);
            ke += l
          )
            (W = l - D), _e > _(o / W) && A("overflow"), (_e *= W);
          (G = O.length + 1),
            (ue = M(q - ye, G, ye == 0)),
            _(q / G) > o - K && A("overflow"),
            (K += _(q / G)),
            (q %= G),
            O.splice(q++, 0, K);
        }
        return R(O);
      }
      function U(N) {
        var O,
          H,
          G,
          q,
          K,
          ue,
          ie,
          ee,
          ve,
          ye,
          _e,
          ke = [],
          k,
          D,
          W,
          te;
        for (N = B(N), k = N.length, O = p, H = 0, K = f, ue = 0; ue < k; ++ue)
          (_e = N[ue]), _e < 128 && ke.push(w(_e));
        for (G = q = ke.length, q && ke.push(m); G < k; ) {
          for (ie = o, ue = 0; ue < k; ++ue)
            (_e = N[ue]), _e >= O && _e < ie && (ie = _e);
          for (
            D = G + 1,
              ie - O > _((o - H) / D) && A("overflow"),
              H += (ie - O) * D,
              O = ie,
              ue = 0;
            ue < k;
            ++ue
          )
            if (((_e = N[ue]), _e < O && ++H > o && A("overflow"), _e == O)) {
              for (
                ee = H, ve = l;
                (ye = ve <= K ? h : ve >= K + c ? c : ve - K), !(ee < ye);
                ve += l
              )
                (te = ee - ye),
                  (W = l - ye),
                  ke.push(w(P(ye + (te % W), 0))),
                  (ee = _(te / W));
              ke.push(w(P(ee, 0))), (K = M(H, D, G == q)), (H = 0), ++G;
            }
          ++H, ++O;
        }
        return ke.join("");
      }
      function V(N) {
        return F(N, function (O) {
          return v.test(O) ? L(O.slice(4).toLowerCase()) : O;
        });
      }
      function z(N) {
        return F(N, function (O) {
          return g.test(O) ? "xn--" + U(O) : O;
        });
      }
      if (
        ((a = {
          version: "1.4.1",
          ucs2: { decode: B, encode: R },
          decode: L,
          encode: U,
          toASCII: z,
          toUnicode: V,
        }),
        i && s)
      )
        if (r.exports == i) s.exports = a;
        else for (E in a) a.hasOwnProperty(E) && (i[E] = a[E]);
      else t.punycode = a;
    })(ko);
  })(Nh, Nh.exports);
  var bk = Nh.exports,
    xk = Error,
    _k = EvalError,
    wk = RangeError,
    Tk = ReferenceError,
    a1 = SyntaxError,
    vl = TypeError,
    Ek = URIError,
    Sk = function () {
      if (
        typeof Symbol != "function" ||
        typeof Object.getOwnPropertySymbols != "function"
      )
        return !1;
      if (typeof Symbol.iterator == "symbol") return !0;
      var e = {},
        t = Symbol("test"),
        i = Object(t);
      if (
        typeof t == "string" ||
        Object.prototype.toString.call(t) !== "[object Symbol]" ||
        Object.prototype.toString.call(i) !== "[object Symbol]"
      )
        return !1;
      var s = 42;
      e[t] = s;
      for (t in e) return !1;
      if (
        (typeof Object.keys == "function" && Object.keys(e).length !== 0) ||
        (typeof Object.getOwnPropertyNames == "function" &&
          Object.getOwnPropertyNames(e).length !== 0)
      )
        return !1;
      var n = Object.getOwnPropertySymbols(e);
      if (
        n.length !== 1 ||
        n[0] !== t ||
        !Object.prototype.propertyIsEnumerable.call(e, t)
      )
        return !1;
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var a = Object.getOwnPropertyDescriptor(e, t);
        if (a.value !== s || a.enumerable !== !0) return !1;
      }
      return !0;
    },
    U0 = typeof Symbol < "u" && Symbol,
    Ak = Sk,
    Ck = function () {
      return typeof U0 != "function" ||
        typeof Symbol != "function" ||
        typeof U0("foo") != "symbol" ||
        typeof Symbol("bar") != "symbol"
        ? !1
        : Ak();
    },
    Tu = { __proto__: null, foo: {} },
    Ik = Object,
    Pk = function () {
      return { __proto__: Tu }.foo === Tu.foo && !(Tu instanceof Ik);
    },
    Rk = "Function.prototype.bind called on incompatible ",
    Mk = Object.prototype.toString,
    Fk = Math.max,
    Bk = "[object Function]",
    V0 = function (e, t) {
      for (var i = [], s = 0; s < e.length; s += 1) i[s] = e[s];
      for (var n = 0; n < t.length; n += 1) i[n + e.length] = t[n];
      return i;
    },
    Ok = function (e, t) {
      for (var i = [], s = t, n = 0; s < e.length; s += 1, n += 1) i[n] = e[s];
      return i;
    },
    kk = function (r, e) {
      for (var t = "", i = 0; i < r.length; i += 1)
        (t += r[i]), i + 1 < r.length && (t += e);
      return t;
    },
    Dk = function (e) {
      var t = this;
      if (typeof t != "function" || Mk.apply(t) !== Bk)
        throw new TypeError(Rk + t);
      for (
        var i = Ok(arguments, 1),
          s,
          n = function () {
            if (this instanceof s) {
              var c = t.apply(this, V0(i, arguments));
              return Object(c) === c ? c : this;
            }
            return t.apply(e, V0(i, arguments));
          },
          a = Fk(0, t.length - i.length),
          o = [],
          l = 0;
        l < a;
        l++
      )
        o[l] = "$" + l;
      if (
        ((s = Function(
          "binder",
          "return function (" +
            kk(o, ",") +
            "){ return binder.apply(this,arguments); }"
        )(n)),
        t.prototype)
      ) {
        var h = function () {};
        (h.prototype = t.prototype),
          (s.prototype = new h()),
          (h.prototype = null);
      }
      return s;
    },
    Lk = Dk,
    qp = Function.prototype.bind || Lk,
    Nk = Function.prototype.call,
    Uk = Object.prototype.hasOwnProperty,
    Vk = qp,
    $k = Vk.call(Nk, Uk),
    Ye,
    Gk = xk,
    Hk = _k,
    Xk = wk,
    zk = Tk,
    Ua = a1,
    Ta = vl,
    Wk = Ek,
    o1 = Function,
    Eu = function (r) {
      try {
        return o1('"use strict"; return (' + r + ").constructor;")();
      } catch {}
    },
    Tn = Object.getOwnPropertyDescriptor;
  if (Tn)
    try {
      Tn({}, "");
    } catch {
      Tn = null;
    }
  var Su = function () {
      throw new Ta();
    },
    Yk = Tn
      ? (function () {
          try {
            return arguments.callee, Su;
          } catch {
            try {
              return Tn(arguments, "callee").get;
            } catch {
              return Su;
            }
          }
        })()
      : Su,
    qn = Ck(),
    jk = Pk(),
    Xt =
      Object.getPrototypeOf ||
      (jk
        ? function (r) {
            return r.__proto__;
          }
        : null),
    ta = {},
    qk = typeof Uint8Array > "u" || !Xt ? Ye : Xt(Uint8Array),
    En = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError > "u" ? Ye : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Ye : ArrayBuffer,
      "%ArrayIteratorPrototype%": qn && Xt ? Xt([][Symbol.iterator]()) : Ye,
      "%AsyncFromSyncIteratorPrototype%": Ye,
      "%AsyncFunction%": ta,
      "%AsyncGenerator%": ta,
      "%AsyncGeneratorFunction%": ta,
      "%AsyncIteratorPrototype%": ta,
      "%Atomics%": typeof Atomics > "u" ? Ye : Atomics,
      "%BigInt%": typeof BigInt > "u" ? Ye : BigInt,
      "%BigInt64Array%": typeof BigInt64Array > "u" ? Ye : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array > "u" ? Ye : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView > "u" ? Ye : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Gk,
      "%eval%": eval,
      "%EvalError%": Hk,
      "%Float32Array%": typeof Float32Array > "u" ? Ye : Float32Array,
      "%Float64Array%": typeof Float64Array > "u" ? Ye : Float64Array,
      "%FinalizationRegistry%":
        typeof FinalizationRegistry > "u" ? Ye : FinalizationRegistry,
      "%Function%": o1,
      "%GeneratorFunction%": ta,
      "%Int8Array%": typeof Int8Array > "u" ? Ye : Int8Array,
      "%Int16Array%": typeof Int16Array > "u" ? Ye : Int16Array,
      "%Int32Array%": typeof Int32Array > "u" ? Ye : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": qn && Xt ? Xt(Xt([][Symbol.iterator]())) : Ye,
      "%JSON%": typeof JSON == "object" ? JSON : Ye,
      "%Map%": typeof Map > "u" ? Ye : Map,
      "%MapIteratorPrototype%":
        typeof Map > "u" || !qn || !Xt ? Ye : Xt(new Map()[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise > "u" ? Ye : Promise,
      "%Proxy%": typeof Proxy > "u" ? Ye : Proxy,
      "%RangeError%": Xk,
      "%ReferenceError%": zk,
      "%Reflect%": typeof Reflect > "u" ? Ye : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set > "u" ? Ye : Set,
      "%SetIteratorPrototype%":
        typeof Set > "u" || !qn || !Xt ? Ye : Xt(new Set()[Symbol.iterator]()),
      "%SharedArrayBuffer%":
        typeof SharedArrayBuffer > "u" ? Ye : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": qn && Xt ? Xt(""[Symbol.iterator]()) : Ye,
      "%Symbol%": qn ? Symbol : Ye,
      "%SyntaxError%": Ua,
      "%ThrowTypeError%": Yk,
      "%TypedArray%": qk,
      "%TypeError%": Ta,
      "%Uint8Array%": typeof Uint8Array > "u" ? Ye : Uint8Array,
      "%Uint8ClampedArray%":
        typeof Uint8ClampedArray > "u" ? Ye : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array > "u" ? Ye : Uint16Array,
      "%Uint32Array%": typeof Uint32Array > "u" ? Ye : Uint32Array,
      "%URIError%": Wk,
      "%WeakMap%": typeof WeakMap > "u" ? Ye : WeakMap,
      "%WeakRef%": typeof WeakRef > "u" ? Ye : WeakRef,
      "%WeakSet%": typeof WeakSet > "u" ? Ye : WeakSet,
    };
  if (Xt)
    try {
      null.error;
    } catch (r) {
      var Kk = Xt(Xt(r));
      En["%Error.prototype%"] = Kk;
    }
  var Zk = function r(e) {
      var t;
      if (e === "%AsyncFunction%") t = Eu("async function () {}");
      else if (e === "%GeneratorFunction%") t = Eu("function* () {}");
      else if (e === "%AsyncGeneratorFunction%")
        t = Eu("async function* () {}");
      else if (e === "%AsyncGenerator%") {
        var i = r("%AsyncGeneratorFunction%");
        i && (t = i.prototype);
      } else if (e === "%AsyncIteratorPrototype%") {
        var s = r("%AsyncGenerator%");
        s && Xt && (t = Xt(s.prototype));
      }
      return (En[e] = t), t;
    },
    $0 = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": [
        "AsyncGeneratorFunction",
        "prototype",
        "prototype",
      ],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"],
    },
    yl = qp,
    Uh = $k,
    Jk = yl.call(Function.call, Array.prototype.concat),
    Qk = yl.call(Function.apply, Array.prototype.splice),
    G0 = yl.call(Function.call, String.prototype.replace),
    Vh = yl.call(Function.call, String.prototype.slice),
    eD = yl.call(Function.call, RegExp.prototype.exec),
    tD =
      /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
    rD = /\\(\\)?/g,
    iD = function (e) {
      var t = Vh(e, 0, 1),
        i = Vh(e, -1);
      if (t === "%" && i !== "%")
        throw new Ua("invalid intrinsic syntax, expected closing `%`");
      if (i === "%" && t !== "%")
        throw new Ua("invalid intrinsic syntax, expected opening `%`");
      var s = [];
      return (
        G0(e, tD, function (n, a, o, l) {
          s[s.length] = o ? G0(l, rD, "$1") : a || n;
        }),
        s
      );
    },
    sD = function (e, t) {
      var i = e,
        s;
      if ((Uh($0, i) && ((s = $0[i]), (i = "%" + s[0] + "%")), Uh(En, i))) {
        var n = En[i];
        if ((n === ta && (n = Zk(i)), typeof n > "u" && !t))
          throw new Ta(
            "intrinsic " +
              e +
              " exists, but is not available. Please file an issue!"
          );
        return { alias: s, name: i, value: n };
      }
      throw new Ua("intrinsic " + e + " does not exist!");
    },
    Qa = function (e, t) {
      if (typeof e != "string" || e.length === 0)
        throw new Ta("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && typeof t != "boolean")
        throw new Ta('"allowMissing" argument must be a boolean');
      if (eD(/^%?[^%]*%?$/, e) === null)
        throw new Ua(
          "`%` may not be present anywhere but at the beginning and end of the intrinsic name"
        );
      var i = iD(e),
        s = i.length > 0 ? i[0] : "",
        n = sD("%" + s + "%", t),
        a = n.name,
        o = n.value,
        l = !1,
        h = n.alias;
      h && ((s = h[0]), Qk(i, Jk([0, 1], h)));
      for (var c = 1, u = !0; c < i.length; c += 1) {
        var d = i[c],
          f = Vh(d, 0, 1),
          p = Vh(d, -1);
        if (
          (f === '"' ||
            f === "'" ||
            f === "`" ||
            p === '"' ||
            p === "'" ||
            p === "`") &&
          f !== p
        )
          throw new Ua("property names with quotes must have matching quotes");
        if (
          ((d === "constructor" || !u) && (l = !0),
          (s += "." + d),
          (a = "%" + s + "%"),
          Uh(En, a))
        )
          o = En[a];
        else if (o != null) {
          if (!(d in o)) {
            if (!t)
              throw new Ta(
                "base intrinsic for " +
                  e +
                  " exists, but the property is not available."
              );
            return;
          }
          if (Tn && c + 1 >= i.length) {
            var m = Tn(o, d);
            (u = !!m),
              u && "get" in m && !("originalValue" in m.get)
                ? (o = m.get)
                : (o = o[d]);
          } else (u = Uh(o, d)), (o = o[d]);
          u && !l && (En[a] = o);
        }
      }
      return o;
    },
    l1 = { exports: {} },
    Au,
    H0;
  function Kp() {
    if (H0) return Au;
    H0 = 1;
    var r = Qa,
      e = r("%Object.defineProperty%", !0) || !1;
    if (e)
      try {
        e({}, "a", { value: 1 });
      } catch {
        e = !1;
      }
    return (Au = e), Au;
  }
  var nD = Qa,
    mh = nD("%Object.getOwnPropertyDescriptor%", !0);
  if (mh)
    try {
      mh([], "length");
    } catch {
      mh = null;
    }
  var h1 = mh,
    X0 = Kp(),
    aD = a1,
    Kn = vl,
    z0 = h1,
    oD = function (e, t, i) {
      if (!e || (typeof e != "object" && typeof e != "function"))
        throw new Kn("`obj` must be an object or a function`");
      if (typeof t != "string" && typeof t != "symbol")
        throw new Kn("`property` must be a string or a symbol`");
      if (
        arguments.length > 3 &&
        typeof arguments[3] != "boolean" &&
        arguments[3] !== null
      )
        throw new Kn("`nonEnumerable`, if provided, must be a boolean or null");
      if (
        arguments.length > 4 &&
        typeof arguments[4] != "boolean" &&
        arguments[4] !== null
      )
        throw new Kn("`nonWritable`, if provided, must be a boolean or null");
      if (
        arguments.length > 5 &&
        typeof arguments[5] != "boolean" &&
        arguments[5] !== null
      )
        throw new Kn(
          "`nonConfigurable`, if provided, must be a boolean or null"
        );
      if (arguments.length > 6 && typeof arguments[6] != "boolean")
        throw new Kn("`loose`, if provided, must be a boolean");
      var s = arguments.length > 3 ? arguments[3] : null,
        n = arguments.length > 4 ? arguments[4] : null,
        a = arguments.length > 5 ? arguments[5] : null,
        o = arguments.length > 6 ? arguments[6] : !1,
        l = !!z0 && z0(e, t);
      if (X0)
        X0(e, t, {
          configurable: a === null && l ? l.configurable : !a,
          enumerable: s === null && l ? l.enumerable : !s,
          value: i,
          writable: n === null && l ? l.writable : !n,
        });
      else if (o || (!s && !n && !a)) e[t] = i;
      else
        throw new aD(
          "This environment does not support defining a property as non-configurable, non-writable, or non-enumerable."
        );
    },
    Hd = Kp(),
    c1 = function () {
      return !!Hd;
    };
  c1.hasArrayLengthDefineBug = function () {
    if (!Hd) return null;
    try {
      return Hd([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  };
  var lD = c1,
    hD = Qa,
    W0 = oD,
    cD = lD(),
    Y0 = h1,
    j0 = vl,
    uD = hD("%Math.floor%"),
    dD = function (e, t) {
      if (typeof e != "function") throw new j0("`fn` is not a function");
      if (typeof t != "number" || t < 0 || t > 4294967295 || uD(t) !== t)
        throw new j0("`length` must be a positive 32-bit integer");
      var i = arguments.length > 2 && !!arguments[2],
        s = !0,
        n = !0;
      if ("length" in e && Y0) {
        var a = Y0(e, "length");
        a && !a.configurable && (s = !1), a && !a.writable && (n = !1);
      }
      return (
        (s || n || !i) &&
          (cD ? W0(e, "length", t, !0, !0) : W0(e, "length", t)),
        e
      );
    };
  (function (r) {
    var e = qp,
      t = Qa,
      i = dD,
      s = vl,
      n = t("%Function.prototype.apply%"),
      a = t("%Function.prototype.call%"),
      o = t("%Reflect.apply%", !0) || e.call(a, n),
      l = Kp(),
      h = t("%Math.max%");
    r.exports = function (d) {
      if (typeof d != "function") throw new s("a function is required");
      var f = o(e, a, arguments);
      return i(f, 1 + h(0, d.length - (arguments.length - 1)), !0);
    };
    var c = function () {
      return o(e, n, arguments);
    };
    l ? l(r.exports, "apply", { value: c }) : (r.exports.apply = c);
  })(l1);
  var fD = l1.exports,
    u1 = Qa,
    d1 = fD,
    pD = d1(u1("String.prototype.indexOf")),
    mD = function (e, t) {
      var i = u1(e, !!t);
      return typeof i == "function" && pD(e, ".prototype.") > -1 ? d1(i) : i;
    };
  const gD = {},
    vD = Object.freeze(
      Object.defineProperty(
        { __proto__: null, default: gD },
        Symbol.toStringTag,
        { value: "Module" }
      )
    ),
    yD = TB(vD);
  var Zp = typeof Map == "function" && Map.prototype,
    Cu =
      Object.getOwnPropertyDescriptor && Zp
        ? Object.getOwnPropertyDescriptor(Map.prototype, "size")
        : null,
    $h = Zp && Cu && typeof Cu.get == "function" ? Cu.get : null,
    q0 = Zp && Map.prototype.forEach,
    Jp = typeof Set == "function" && Set.prototype,
    Iu =
      Object.getOwnPropertyDescriptor && Jp
        ? Object.getOwnPropertyDescriptor(Set.prototype, "size")
        : null,
    Gh = Jp && Iu && typeof Iu.get == "function" ? Iu.get : null,
    K0 = Jp && Set.prototype.forEach,
    bD = typeof WeakMap == "function" && WeakMap.prototype,
    Do = bD ? WeakMap.prototype.has : null,
    xD = typeof WeakSet == "function" && WeakSet.prototype,
    Lo = xD ? WeakSet.prototype.has : null,
    _D = typeof WeakRef == "function" && WeakRef.prototype,
    Z0 = _D ? WeakRef.prototype.deref : null,
    wD = Boolean.prototype.valueOf,
    TD = Object.prototype.toString,
    ED = Function.prototype.toString,
    SD = String.prototype.match,
    Qp = String.prototype.slice,
    $s = String.prototype.replace,
    AD = String.prototype.toUpperCase,
    J0 = String.prototype.toLowerCase,
    f1 = RegExp.prototype.test,
    Q0 = Array.prototype.concat,
    ki = Array.prototype.join,
    CD = Array.prototype.slice,
    ev = Math.floor,
    Xd = typeof BigInt == "function" ? BigInt.prototype.valueOf : null,
    Pu = Object.getOwnPropertySymbols,
    zd =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? Symbol.prototype.toString
        : null,
    Va = typeof Symbol == "function" && typeof Symbol.iterator == "object",
    lr =
      typeof Symbol == "function" &&
      Symbol.toStringTag &&
      (typeof Symbol.toStringTag === Va || !0)
        ? Symbol.toStringTag
        : null,
    p1 = Object.prototype.propertyIsEnumerable,
    tv =
      (typeof Reflect == "function"
        ? Reflect.getPrototypeOf
        : Object.getPrototypeOf) ||
      ([].__proto__ === Array.prototype
        ? function (r) {
            return r.__proto__;
          }
        : null);
  function rv(r, e) {
    if (
      r === 1 / 0 ||
      r === -1 / 0 ||
      r !== r ||
      (r && r > -1e3 && r < 1e3) ||
      f1.call(/e/, e)
    )
      return e;
    var t = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof r == "number") {
      var i = r < 0 ? -ev(-r) : ev(r);
      if (i !== r) {
        var s = String(i),
          n = Qp.call(e, s.length + 1);
        return (
          $s.call(s, t, "$&_") +
          "." +
          $s.call($s.call(n, /([0-9]{3})/g, "$&_"), /_$/, "")
        );
      }
    }
    return $s.call(e, t, "$&_");
  }
  var Wd = yD,
    iv = Wd.custom,
    sv = g1(iv) ? iv : null,
    ID = function r(e, t, i, s) {
      var n = t || {};
      if (
        Os(n, "quoteStyle") &&
        n.quoteStyle !== "single" &&
        n.quoteStyle !== "double"
      )
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      if (
        Os(n, "maxStringLength") &&
        (typeof n.maxStringLength == "number"
          ? n.maxStringLength < 0 && n.maxStringLength !== 1 / 0
          : n.maxStringLength !== null)
      )
        throw new TypeError(
          'option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`'
        );
      var a = Os(n, "customInspect") ? n.customInspect : !0;
      if (typeof a != "boolean" && a !== "symbol")
        throw new TypeError(
          "option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`"
        );
      if (
        Os(n, "indent") &&
        n.indent !== null &&
        n.indent !== "	" &&
        !(parseInt(n.indent, 10) === n.indent && n.indent > 0)
      )
        throw new TypeError(
          'option "indent" must be "\\t", an integer > 0, or `null`'
        );
      if (Os(n, "numericSeparator") && typeof n.numericSeparator != "boolean")
        throw new TypeError(
          'option "numericSeparator", if provided, must be `true` or `false`'
        );
      var o = n.numericSeparator;
      if (typeof e > "u") return "undefined";
      if (e === null) return "null";
      if (typeof e == "boolean") return e ? "true" : "false";
      if (typeof e == "string") return y1(e, n);
      if (typeof e == "number") {
        if (e === 0) return 1 / 0 / e > 0 ? "0" : "-0";
        var l = String(e);
        return o ? rv(e, l) : l;
      }
      if (typeof e == "bigint") {
        var h = String(e) + "n";
        return o ? rv(e, h) : h;
      }
      var c = typeof n.depth > "u" ? 5 : n.depth;
      if ((typeof i > "u" && (i = 0), i >= c && c > 0 && typeof e == "object"))
        return Yd(e) ? "[Array]" : "[Object]";
      var u = WD(n, i);
      if (typeof s > "u") s = [];
      else if (v1(s, e) >= 0) return "[Circular]";
      function d(I, P, M) {
        if ((P && ((s = CD.call(s)), s.push(P)), M)) {
          var L = { depth: n.depth };
          return (
            Os(n, "quoteStyle") && (L.quoteStyle = n.quoteStyle),
            r(I, L, i + 1, s)
          );
        }
        return r(I, n, i + 1, s);
      }
      if (typeof e == "function" && !nv(e)) {
        var f = LD(e),
          p = $l(e, d);
        return (
          "[Function" +
          (f ? ": " + f : " (anonymous)") +
          "]" +
          (p.length > 0 ? " { " + ki.call(p, ", ") + " }" : "")
        );
      }
      if (g1(e)) {
        var m = Va
          ? $s.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1")
          : zd.call(e);
        return typeof e == "object" && !Va ? ho(m) : m;
      }
      if (HD(e)) {
        for (
          var v = "<" + J0.call(String(e.nodeName)),
            g = e.attributes || [],
            x = 0;
          x < g.length;
          x++
        )
          v += " " + g[x].name + "=" + m1(PD(g[x].value), "double", n);
        return (
          (v += ">"),
          e.childNodes && e.childNodes.length && (v += "..."),
          (v += "</" + J0.call(String(e.nodeName)) + ">"),
          v
        );
      }
      if (Yd(e)) {
        if (e.length === 0) return "[]";
        var b = $l(e, d);
        return u && !zD(b)
          ? "[" + jd(b, u) + "]"
          : "[ " + ki.call(b, ", ") + " ]";
      }
      if (MD(e)) {
        var y = $l(e, d);
        return !("cause" in Error.prototype) &&
          "cause" in e &&
          !p1.call(e, "cause")
          ? "{ [" +
              String(e) +
              "] " +
              ki.call(Q0.call("[cause]: " + d(e.cause), y), ", ") +
              " }"
          : y.length === 0
          ? "[" + String(e) + "]"
          : "{ [" + String(e) + "] " + ki.call(y, ", ") + " }";
      }
      if (typeof e == "object" && a) {
        if (sv && typeof e[sv] == "function" && Wd)
          return Wd(e, { depth: c - i });
        if (a !== "symbol" && typeof e.inspect == "function")
          return e.inspect();
      }
      if (ND(e)) {
        var _ = [];
        return (
          q0 &&
            q0.call(e, function (I, P) {
              _.push(d(P, e, !0) + " => " + d(I, e));
            }),
          av("Map", $h.call(e), _, u)
        );
      }
      if ($D(e)) {
        var w = [];
        return (
          K0 &&
            K0.call(e, function (I) {
              w.push(d(I, e));
            }),
          av("Set", Gh.call(e), w, u)
        );
      }
      if (UD(e)) return Ru("WeakMap");
      if (GD(e)) return Ru("WeakSet");
      if (VD(e)) return Ru("WeakRef");
      if (BD(e)) return ho(d(Number(e)));
      if (kD(e)) return ho(d(Xd.call(e)));
      if (OD(e)) return ho(wD.call(e));
      if (FD(e)) return ho(d(String(e)));
      if (typeof window < "u" && e === window) return "{ [object Window] }";
      if (
        (typeof globalThis < "u" && e === globalThis) ||
        (typeof ko < "u" && e === ko)
      )
        return "{ [object globalThis] }";
      if (!RD(e) && !nv(e)) {
        var E = $l(e, d),
          A = tv
            ? tv(e) === Object.prototype
            : e instanceof Object || e.constructor === Object,
          C = e instanceof Object ? "" : "null prototype",
          F =
            !A && lr && Object(e) === e && lr in e
              ? Qp.call(tn(e), 8, -1)
              : C
              ? "Object"
              : "",
          B =
            A || typeof e.constructor != "function"
              ? ""
              : e.constructor.name
              ? e.constructor.name + " "
              : "",
          R =
            B +
            (F || C
              ? "[" + ki.call(Q0.call([], F || [], C || []), ": ") + "] "
              : "");
        return E.length === 0
          ? R + "{}"
          : u
          ? R + "{" + jd(E, u) + "}"
          : R + "{ " + ki.call(E, ", ") + " }";
      }
      return String(e);
    };
  function m1(r, e, t) {
    var i = (t.quoteStyle || e) === "double" ? '"' : "'";
    return i + r + i;
  }
  function PD(r) {
    return $s.call(String(r), /"/g, "&quot;");
  }
  function Yd(r) {
    return (
      tn(r) === "[object Array]" && (!lr || !(typeof r == "object" && lr in r))
    );
  }
  function RD(r) {
    return (
      tn(r) === "[object Date]" && (!lr || !(typeof r == "object" && lr in r))
    );
  }
  function nv(r) {
    return (
      tn(r) === "[object RegExp]" && (!lr || !(typeof r == "object" && lr in r))
    );
  }
  function MD(r) {
    return (
      tn(r) === "[object Error]" && (!lr || !(typeof r == "object" && lr in r))
    );
  }
  function FD(r) {
    return (
      tn(r) === "[object String]" && (!lr || !(typeof r == "object" && lr in r))
    );
  }
  function BD(r) {
    return (
      tn(r) === "[object Number]" && (!lr || !(typeof r == "object" && lr in r))
    );
  }
  function OD(r) {
    return (
      tn(r) === "[object Boolean]" &&
      (!lr || !(typeof r == "object" && lr in r))
    );
  }
  function g1(r) {
    if (Va) return r && typeof r == "object" && r instanceof Symbol;
    if (typeof r == "symbol") return !0;
    if (!r || typeof r != "object" || !zd) return !1;
    try {
      return zd.call(r), !0;
    } catch {}
    return !1;
  }
  function kD(r) {
    if (!r || typeof r != "object" || !Xd) return !1;
    try {
      return Xd.call(r), !0;
    } catch {}
    return !1;
  }
  var DD =
    Object.prototype.hasOwnProperty ||
    function (r) {
      return r in this;
    };
  function Os(r, e) {
    return DD.call(r, e);
  }
  function tn(r) {
    return TD.call(r);
  }
  function LD(r) {
    if (r.name) return r.name;
    var e = SD.call(ED.call(r), /^function\s*([\w$]+)/);
    return e ? e[1] : null;
  }
  function v1(r, e) {
    if (r.indexOf) return r.indexOf(e);
    for (var t = 0, i = r.length; t < i; t++) if (r[t] === e) return t;
    return -1;
  }
  function ND(r) {
    if (!$h || !r || typeof r != "object") return !1;
    try {
      $h.call(r);
      try {
        Gh.call(r);
      } catch {
        return !0;
      }
      return r instanceof Map;
    } catch {}
    return !1;
  }
  function UD(r) {
    if (!Do || !r || typeof r != "object") return !1;
    try {
      Do.call(r, Do);
      try {
        Lo.call(r, Lo);
      } catch {
        return !0;
      }
      return r instanceof WeakMap;
    } catch {}
    return !1;
  }
  function VD(r) {
    if (!Z0 || !r || typeof r != "object") return !1;
    try {
      return Z0.call(r), !0;
    } catch {}
    return !1;
  }
  function $D(r) {
    if (!Gh || !r || typeof r != "object") return !1;
    try {
      Gh.call(r);
      try {
        $h.call(r);
      } catch {
        return !0;
      }
      return r instanceof Set;
    } catch {}
    return !1;
  }
  function GD(r) {
    if (!Lo || !r || typeof r != "object") return !1;
    try {
      Lo.call(r, Lo);
      try {
        Do.call(r, Do);
      } catch {
        return !0;
      }
      return r instanceof WeakSet;
    } catch {}
    return !1;
  }
  function HD(r) {
    return !r || typeof r != "object"
      ? !1
      : typeof HTMLElement < "u" && r instanceof HTMLElement
      ? !0
      : typeof r.nodeName == "string" && typeof r.getAttribute == "function";
  }
  function y1(r, e) {
    if (r.length > e.maxStringLength) {
      var t = r.length - e.maxStringLength,
        i = "... " + t + " more character" + (t > 1 ? "s" : "");
      return y1(Qp.call(r, 0, e.maxStringLength), e) + i;
    }
    var s = $s.call($s.call(r, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, XD);
    return m1(s, "single", e);
  }
  function XD(r) {
    var e = r.charCodeAt(0),
      t = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[e];
    return t ? "\\" + t : "\\x" + (e < 16 ? "0" : "") + AD.call(e.toString(16));
  }
  function ho(r) {
    return "Object(" + r + ")";
  }
  function Ru(r) {
    return r + " { ? }";
  }
  function av(r, e, t, i) {
    var s = i ? jd(t, i) : ki.call(t, ", ");
    return r + " (" + e + ") {" + s + "}";
  }
  function zD(r) {
    for (var e = 0; e < r.length; e++)
      if (
        v1(
          r[e],
          `
`
        ) >= 0
      )
        return !1;
    return !0;
  }
  function WD(r, e) {
    var t;
    if (r.indent === "	") t = "	";
    else if (typeof r.indent == "number" && r.indent > 0)
      t = ki.call(Array(r.indent + 1), " ");
    else return null;
    return { base: t, prev: ki.call(Array(e + 1), t) };
  }
  function jd(r, e) {
    if (r.length === 0) return "";
    var t =
      `
` +
      e.prev +
      e.base;
    return (
      t +
      ki.call(r, "," + t) +
      `
` +
      e.prev
    );
  }
  function $l(r, e) {
    var t = Yd(r),
      i = [];
    if (t) {
      i.length = r.length;
      for (var s = 0; s < r.length; s++) i[s] = Os(r, s) ? e(r[s], r) : "";
    }
    var n = typeof Pu == "function" ? Pu(r) : [],
      a;
    if (Va) {
      a = {};
      for (var o = 0; o < n.length; o++) a["$" + n[o]] = n[o];
    }
    for (var l in r)
      Os(r, l) &&
        ((t && String(Number(l)) === l && l < r.length) ||
          (Va && a["$" + l] instanceof Symbol) ||
          (f1.call(/[^\w$]/, l)
            ? i.push(e(l, r) + ": " + e(r[l], r))
            : i.push(l + ": " + e(r[l], r))));
    if (typeof Pu == "function")
      for (var h = 0; h < n.length; h++)
        p1.call(r, n[h]) && i.push("[" + e(n[h]) + "]: " + e(r[n[h]], r));
    return i;
  }
  var b1 = Qa,
    eo = mD,
    YD = ID,
    jD = vl,
    Gl = b1("%WeakMap%", !0),
    Hl = b1("%Map%", !0),
    qD = eo("WeakMap.prototype.get", !0),
    KD = eo("WeakMap.prototype.set", !0),
    ZD = eo("WeakMap.prototype.has", !0),
    JD = eo("Map.prototype.get", !0),
    QD = eo("Map.prototype.set", !0),
    eL = eo("Map.prototype.has", !0),
    em = function (r, e) {
      for (var t = r, i; (i = t.next) !== null; t = i)
        if (i.key === e)
          return (t.next = i.next), (i.next = r.next), (r.next = i), i;
    },
    tL = function (r, e) {
      var t = em(r, e);
      return t && t.value;
    },
    rL = function (r, e, t) {
      var i = em(r, e);
      i ? (i.value = t) : (r.next = { key: e, next: r.next, value: t });
    },
    iL = function (r, e) {
      return !!em(r, e);
    },
    sL = function () {
      var e,
        t,
        i,
        s = {
          assert: function (n) {
            if (!s.has(n))
              throw new jD("Side channel does not contain " + YD(n));
          },
          get: function (n) {
            if (Gl && n && (typeof n == "object" || typeof n == "function")) {
              if (e) return qD(e, n);
            } else if (Hl) {
              if (t) return JD(t, n);
            } else if (i) return tL(i, n);
          },
          has: function (n) {
            if (Gl && n && (typeof n == "object" || typeof n == "function")) {
              if (e) return ZD(e, n);
            } else if (Hl) {
              if (t) return eL(t, n);
            } else if (i) return iL(i, n);
            return !1;
          },
          set: function (n, a) {
            Gl && n && (typeof n == "object" || typeof n == "function")
              ? (e || (e = new Gl()), KD(e, n, a))
              : Hl
              ? (t || (t = new Hl()), QD(t, n, a))
              : (i || (i = { key: {}, next: null }), rL(i, n, a));
          },
        };
      return s;
    },
    nL = String.prototype.replace,
    aL = /%20/g,
    Mu = { RFC1738: "RFC1738", RFC3986: "RFC3986" },
    tm = {
      default: Mu.RFC3986,
      formatters: {
        RFC1738: function (r) {
          return nL.call(r, aL, "+");
        },
        RFC3986: function (r) {
          return String(r);
        },
      },
      RFC1738: Mu.RFC1738,
      RFC3986: Mu.RFC3986,
    },
    oL = tm,
    Fu = Object.prototype.hasOwnProperty,
    gn = Array.isArray,
    Ti = (function () {
      for (var r = [], e = 0; e < 256; ++e)
        r.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
      return r;
    })(),
    lL = function (e) {
      for (; e.length > 1; ) {
        var t = e.pop(),
          i = t.obj[t.prop];
        if (gn(i)) {
          for (var s = [], n = 0; n < i.length; ++n)
            typeof i[n] < "u" && s.push(i[n]);
          t.obj[t.prop] = s;
        }
      }
    },
    x1 = function (e, t) {
      for (
        var i = t && t.plainObjects ? Object.create(null) : {}, s = 0;
        s < e.length;
        ++s
      )
        typeof e[s] < "u" && (i[s] = e[s]);
      return i;
    },
    hL = function r(e, t, i) {
      if (!t) return e;
      if (typeof t != "object") {
        if (gn(e)) e.push(t);
        else if (e && typeof e == "object")
          ((i && (i.plainObjects || i.allowPrototypes)) ||
            !Fu.call(Object.prototype, t)) &&
            (e[t] = !0);
        else return [e, t];
        return e;
      }
      if (!e || typeof e != "object") return [e].concat(t);
      var s = e;
      return (
        gn(e) && !gn(t) && (s = x1(e, i)),
        gn(e) && gn(t)
          ? (t.forEach(function (n, a) {
              if (Fu.call(e, a)) {
                var o = e[a];
                o && typeof o == "object" && n && typeof n == "object"
                  ? (e[a] = r(o, n, i))
                  : e.push(n);
              } else e[a] = n;
            }),
            e)
          : Object.keys(t).reduce(function (n, a) {
              var o = t[a];
              return Fu.call(n, a) ? (n[a] = r(n[a], o, i)) : (n[a] = o), n;
            }, s)
      );
    },
    cL = function (e, t) {
      return Object.keys(t).reduce(function (i, s) {
        return (i[s] = t[s]), i;
      }, e);
    },
    uL = function (r, e, t) {
      var i = r.replace(/\+/g, " ");
      if (t === "iso-8859-1") return i.replace(/%[0-9a-f]{2}/gi, unescape);
      try {
        return decodeURIComponent(i);
      } catch {
        return i;
      }
    },
    Bu = 1024,
    dL = function (e, t, i, s, n) {
      if (e.length === 0) return e;
      var a = e;
      if (
        (typeof e == "symbol"
          ? (a = Symbol.prototype.toString.call(e))
          : typeof e != "string" && (a = String(e)),
        i === "iso-8859-1")
      )
        return escape(a).replace(/%u[0-9a-f]{4}/gi, function (f) {
          return "%26%23" + parseInt(f.slice(2), 16) + "%3B";
        });
      for (var o = "", l = 0; l < a.length; l += Bu) {
        for (
          var h = a.length >= Bu ? a.slice(l, l + Bu) : a, c = [], u = 0;
          u < h.length;
          ++u
        ) {
          var d = h.charCodeAt(u);
          if (
            d === 45 ||
            d === 46 ||
            d === 95 ||
            d === 126 ||
            (d >= 48 && d <= 57) ||
            (d >= 65 && d <= 90) ||
            (d >= 97 && d <= 122) ||
            (n === oL.RFC1738 && (d === 40 || d === 41))
          ) {
            c[c.length] = h.charAt(u);
            continue;
          }
          if (d < 128) {
            c[c.length] = Ti[d];
            continue;
          }
          if (d < 2048) {
            c[c.length] = Ti[192 | (d >> 6)] + Ti[128 | (d & 63)];
            continue;
          }
          if (d < 55296 || d >= 57344) {
            c[c.length] =
              Ti[224 | (d >> 12)] +
              Ti[128 | ((d >> 6) & 63)] +
              Ti[128 | (d & 63)];
            continue;
          }
          (u += 1),
            (d = 65536 + (((d & 1023) << 10) | (h.charCodeAt(u) & 1023))),
            (c[c.length] =
              Ti[240 | (d >> 18)] +
              Ti[128 | ((d >> 12) & 63)] +
              Ti[128 | ((d >> 6) & 63)] +
              Ti[128 | (d & 63)]);
        }
        o += c.join("");
      }
      return o;
    },
    fL = function (e) {
      for (
        var t = [{ obj: { o: e }, prop: "o" }], i = [], s = 0;
        s < t.length;
        ++s
      )
        for (
          var n = t[s], a = n.obj[n.prop], o = Object.keys(a), l = 0;
          l < o.length;
          ++l
        ) {
          var h = o[l],
            c = a[h];
          typeof c == "object" &&
            c !== null &&
            i.indexOf(c) === -1 &&
            (t.push({ obj: a, prop: h }), i.push(c));
        }
      return lL(t), e;
    },
    pL = function (e) {
      return Object.prototype.toString.call(e) === "[object RegExp]";
    },
    mL = function (e) {
      return !e || typeof e != "object"
        ? !1
        : !!(
            e.constructor &&
            e.constructor.isBuffer &&
            e.constructor.isBuffer(e)
          );
    },
    gL = function (e, t) {
      return [].concat(e, t);
    },
    vL = function (e, t) {
      if (gn(e)) {
        for (var i = [], s = 0; s < e.length; s += 1) i.push(t(e[s]));
        return i;
      }
      return t(e);
    },
    _1 = {
      arrayToObject: x1,
      assign: cL,
      combine: gL,
      compact: fL,
      decode: uL,
      encode: dL,
      isBuffer: mL,
      isRegExp: pL,
      maybeMap: vL,
      merge: hL,
    },
    w1 = sL,
    gh = _1,
    No = tm,
    yL = Object.prototype.hasOwnProperty,
    T1 = {
      brackets: function (e) {
        return e + "[]";
      },
      comma: "comma",
      indices: function (e, t) {
        return e + "[" + t + "]";
      },
      repeat: function (e) {
        return e;
      },
    },
    Fi = Array.isArray,
    bL = Array.prototype.push,
    E1 = function (r, e) {
      bL.apply(r, Fi(e) ? e : [e]);
    },
    xL = Date.prototype.toISOString,
    ov = No.default,
    Dt = {
      addQueryPrefix: !1,
      allowDots: !1,
      allowEmptyArrays: !1,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: !1,
      delimiter: "&",
      encode: !0,
      encodeDotInKeys: !1,
      encoder: gh.encode,
      encodeValuesOnly: !1,
      format: ov,
      formatter: No.formatters[ov],
      indices: !1,
      serializeDate: function (e) {
        return xL.call(e);
      },
      skipNulls: !1,
      strictNullHandling: !1,
    },
    _L = function (e) {
      return (
        typeof e == "string" ||
        typeof e == "number" ||
        typeof e == "boolean" ||
        typeof e == "symbol" ||
        typeof e == "bigint"
      );
    },
    Ou = {},
    wL = function r(e, t, i, s, n, a, o, l, h, c, u, d, f, p, m, v, g, x) {
      for (
        var b = e, y = x, _ = 0, w = !1;
        (y = y.get(Ou)) !== void 0 && !w;

      ) {
        var E = y.get(e);
        if (((_ += 1), typeof E < "u")) {
          if (E === _) throw new RangeError("Cyclic object value");
          w = !0;
        }
        typeof y.get(Ou) > "u" && (_ = 0);
      }
      if (
        (typeof c == "function"
          ? (b = c(t, b))
          : b instanceof Date
          ? (b = f(b))
          : i === "comma" &&
            Fi(b) &&
            (b = gh.maybeMap(b, function (N) {
              return N instanceof Date ? f(N) : N;
            })),
        b === null)
      ) {
        if (a) return h && !v ? h(t, Dt.encoder, g, "key", p) : t;
        b = "";
      }
      if (_L(b) || gh.isBuffer(b)) {
        if (h) {
          var A = v ? t : h(t, Dt.encoder, g, "key", p);
          return [m(A) + "=" + m(h(b, Dt.encoder, g, "value", p))];
        }
        return [m(t) + "=" + m(String(b))];
      }
      var C = [];
      if (typeof b > "u") return C;
      var F;
      if (i === "comma" && Fi(b))
        v && h && (b = gh.maybeMap(b, h)),
          (F = [{ value: b.length > 0 ? b.join(",") || null : void 0 }]);
      else if (Fi(c)) F = c;
      else {
        var B = Object.keys(b);
        F = u ? B.sort(u) : B;
      }
      var R = l ? t.replace(/\./g, "%2E") : t,
        I = s && Fi(b) && b.length === 1 ? R + "[]" : R;
      if (n && Fi(b) && b.length === 0) return I + "[]";
      for (var P = 0; P < F.length; ++P) {
        var M = F[P],
          L = typeof M == "object" && typeof M.value < "u" ? M.value : b[M];
        if (!(o && L === null)) {
          var U = d && l ? M.replace(/\./g, "%2E") : M,
            V = Fi(b)
              ? typeof i == "function"
                ? i(I, U)
                : I
              : I + (d ? "." + U : "[" + U + "]");
          x.set(e, _);
          var z = w1();
          z.set(Ou, x),
            E1(
              C,
              r(
                L,
                V,
                i,
                s,
                n,
                a,
                o,
                l,
                i === "comma" && v && Fi(b) ? null : h,
                c,
                u,
                d,
                f,
                p,
                m,
                v,
                g,
                z
              )
            );
        }
      }
      return C;
    },
    TL = function (e) {
      if (!e) return Dt;
      if (
        typeof e.allowEmptyArrays < "u" &&
        typeof e.allowEmptyArrays != "boolean"
      )
        throw new TypeError(
          "`allowEmptyArrays` option can only be `true` or `false`, when provided"
        );
      if (
        typeof e.encodeDotInKeys < "u" &&
        typeof e.encodeDotInKeys != "boolean"
      )
        throw new TypeError(
          "`encodeDotInKeys` option can only be `true` or `false`, when provided"
        );
      if (
        e.encoder !== null &&
        typeof e.encoder < "u" &&
        typeof e.encoder != "function"
      )
        throw new TypeError("Encoder has to be a function.");
      var t = e.charset || Dt.charset;
      if (
        typeof e.charset < "u" &&
        e.charset !== "utf-8" &&
        e.charset !== "iso-8859-1"
      )
        throw new TypeError(
          "The charset option must be either utf-8, iso-8859-1, or undefined"
        );
      var i = No.default;
      if (typeof e.format < "u") {
        if (!yL.call(No.formatters, e.format))
          throw new TypeError("Unknown format option provided.");
        i = e.format;
      }
      var s = No.formatters[i],
        n = Dt.filter;
      (typeof e.filter == "function" || Fi(e.filter)) && (n = e.filter);
      var a;
      if (
        (e.arrayFormat in T1
          ? (a = e.arrayFormat)
          : "indices" in e
          ? (a = e.indices ? "indices" : "repeat")
          : (a = Dt.arrayFormat),
        "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean")
      )
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      var o =
        typeof e.allowDots > "u"
          ? e.encodeDotInKeys === !0
            ? !0
            : Dt.allowDots
          : !!e.allowDots;
      return {
        addQueryPrefix:
          typeof e.addQueryPrefix == "boolean"
            ? e.addQueryPrefix
            : Dt.addQueryPrefix,
        allowDots: o,
        allowEmptyArrays:
          typeof e.allowEmptyArrays == "boolean"
            ? !!e.allowEmptyArrays
            : Dt.allowEmptyArrays,
        arrayFormat: a,
        charset: t,
        charsetSentinel:
          typeof e.charsetSentinel == "boolean"
            ? e.charsetSentinel
            : Dt.charsetSentinel,
        commaRoundTrip: e.commaRoundTrip,
        delimiter: typeof e.delimiter > "u" ? Dt.delimiter : e.delimiter,
        encode: typeof e.encode == "boolean" ? e.encode : Dt.encode,
        encodeDotInKeys:
          typeof e.encodeDotInKeys == "boolean"
            ? e.encodeDotInKeys
            : Dt.encodeDotInKeys,
        encoder: typeof e.encoder == "function" ? e.encoder : Dt.encoder,
        encodeValuesOnly:
          typeof e.encodeValuesOnly == "boolean"
            ? e.encodeValuesOnly
            : Dt.encodeValuesOnly,
        filter: n,
        format: i,
        formatter: s,
        serializeDate:
          typeof e.serializeDate == "function"
            ? e.serializeDate
            : Dt.serializeDate,
        skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : Dt.skipNulls,
        sort: typeof e.sort == "function" ? e.sort : null,
        strictNullHandling:
          typeof e.strictNullHandling == "boolean"
            ? e.strictNullHandling
            : Dt.strictNullHandling,
      };
    },
    EL = function (r, e) {
      var t = r,
        i = TL(e),
        s,
        n;
      typeof i.filter == "function"
        ? ((n = i.filter), (t = n("", t)))
        : Fi(i.filter) && ((n = i.filter), (s = n));
      var a = [];
      if (typeof t != "object" || t === null) return "";
      var o = T1[i.arrayFormat],
        l = o === "comma" && i.commaRoundTrip;
      s || (s = Object.keys(t)), i.sort && s.sort(i.sort);
      for (var h = w1(), c = 0; c < s.length; ++c) {
        var u = s[c];
        (i.skipNulls && t[u] === null) ||
          E1(
            a,
            wL(
              t[u],
              u,
              o,
              l,
              i.allowEmptyArrays,
              i.strictNullHandling,
              i.skipNulls,
              i.encodeDotInKeys,
              i.encode ? i.encoder : null,
              i.filter,
              i.sort,
              i.allowDots,
              i.serializeDate,
              i.format,
              i.formatter,
              i.encodeValuesOnly,
              i.charset,
              h
            )
          );
      }
      var d = a.join(i.delimiter),
        f = i.addQueryPrefix === !0 ? "?" : "";
      return (
        i.charsetSentinel &&
          (i.charset === "iso-8859-1"
            ? (f += "utf8=%26%2310003%3B&")
            : (f += "utf8=%E2%9C%93&")),
        d.length > 0 ? f + d : ""
      );
    },
    $a = _1,
    qd = Object.prototype.hasOwnProperty,
    SL = Array.isArray,
    Ct = {
      allowDots: !1,
      allowEmptyArrays: !1,
      allowPrototypes: !1,
      allowSparse: !1,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: !1,
      comma: !1,
      decodeDotInKeys: !1,
      decoder: $a.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: !1,
      interpretNumericEntities: !1,
      parameterLimit: 1e3,
      parseArrays: !0,
      plainObjects: !1,
      strictDepth: !1,
      strictNullHandling: !1,
    },
    AL = function (r) {
      return r.replace(/&#(\d+);/g, function (e, t) {
        return String.fromCharCode(parseInt(t, 10));
      });
    },
    S1 = function (r, e) {
      return r && typeof r == "string" && e.comma && r.indexOf(",") > -1
        ? r.split(",")
        : r;
    },
    CL = "utf8=%26%2310003%3B",
    IL = "utf8=%E2%9C%93",
    PL = function (e, t) {
      var i = { __proto__: null },
        s = t.ignoreQueryPrefix ? e.replace(/^\?/, "") : e;
      s = s.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      var n = t.parameterLimit === 1 / 0 ? void 0 : t.parameterLimit,
        a = s.split(t.delimiter, n),
        o = -1,
        l,
        h = t.charset;
      if (t.charsetSentinel)
        for (l = 0; l < a.length; ++l)
          a[l].indexOf("utf8=") === 0 &&
            (a[l] === IL ? (h = "utf-8") : a[l] === CL && (h = "iso-8859-1"),
            (o = l),
            (l = a.length));
      for (l = 0; l < a.length; ++l)
        if (l !== o) {
          var c = a[l],
            u = c.indexOf("]="),
            d = u === -1 ? c.indexOf("=") : u + 1,
            f,
            p;
          d === -1
            ? ((f = t.decoder(c, Ct.decoder, h, "key")),
              (p = t.strictNullHandling ? null : ""))
            : ((f = t.decoder(c.slice(0, d), Ct.decoder, h, "key")),
              (p = $a.maybeMap(S1(c.slice(d + 1), t), function (v) {
                return t.decoder(v, Ct.decoder, h, "value");
              }))),
            p &&
              t.interpretNumericEntities &&
              h === "iso-8859-1" &&
              (p = AL(p)),
            c.indexOf("[]=") > -1 && (p = SL(p) ? [p] : p);
          var m = qd.call(i, f);
          m && t.duplicates === "combine"
            ? (i[f] = $a.combine(i[f], p))
            : (!m || t.duplicates === "last") && (i[f] = p);
        }
      return i;
    },
    RL = function (r, e, t, i) {
      for (var s = i ? e : S1(e, t), n = r.length - 1; n >= 0; --n) {
        var a,
          o = r[n];
        if (o === "[]" && t.parseArrays)
          a =
            t.allowEmptyArrays &&
            (s === "" || (t.strictNullHandling && s === null))
              ? []
              : [].concat(s);
        else {
          a = t.plainObjects ? Object.create(null) : {};
          var l =
              o.charAt(0) === "[" && o.charAt(o.length - 1) === "]"
                ? o.slice(1, -1)
                : o,
            h = t.decodeDotInKeys ? l.replace(/%2E/g, ".") : l,
            c = parseInt(h, 10);
          !t.parseArrays && h === ""
            ? (a = { 0: s })
            : !isNaN(c) &&
              o !== h &&
              String(c) === h &&
              c >= 0 &&
              t.parseArrays &&
              c <= t.arrayLimit
            ? ((a = []), (a[c] = s))
            : h !== "__proto__" && (a[h] = s);
        }
        s = a;
      }
      return s;
    },
    ML = function (e, t, i, s) {
      if (e) {
        var n = i.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e,
          a = /(\[[^[\]]*])/,
          o = /(\[[^[\]]*])/g,
          l = i.depth > 0 && a.exec(n),
          h = l ? n.slice(0, l.index) : n,
          c = [];
        if (h) {
          if (
            !i.plainObjects &&
            qd.call(Object.prototype, h) &&
            !i.allowPrototypes
          )
            return;
          c.push(h);
        }
        for (
          var u = 0;
          i.depth > 0 && (l = o.exec(n)) !== null && u < i.depth;

        ) {
          if (
            ((u += 1),
            !i.plainObjects &&
              qd.call(Object.prototype, l[1].slice(1, -1)) &&
              !i.allowPrototypes)
          )
            return;
          c.push(l[1]);
        }
        if (l) {
          if (i.strictDepth === !0)
            throw new RangeError(
              "Input depth exceeded depth option of " +
                i.depth +
                " and strictDepth is true"
            );
          c.push("[" + n.slice(l.index) + "]");
        }
        return RL(c, t, i, s);
      }
    },
    FL = function (e) {
      if (!e) return Ct;
      if (
        typeof e.allowEmptyArrays < "u" &&
        typeof e.allowEmptyArrays != "boolean"
      )
        throw new TypeError(
          "`allowEmptyArrays` option can only be `true` or `false`, when provided"
        );
      if (
        typeof e.decodeDotInKeys < "u" &&
        typeof e.decodeDotInKeys != "boolean"
      )
        throw new TypeError(
          "`decodeDotInKeys` option can only be `true` or `false`, when provided"
        );
      if (
        e.decoder !== null &&
        typeof e.decoder < "u" &&
        typeof e.decoder != "function"
      )
        throw new TypeError("Decoder has to be a function.");
      if (
        typeof e.charset < "u" &&
        e.charset !== "utf-8" &&
        e.charset !== "iso-8859-1"
      )
        throw new TypeError(
          "The charset option must be either utf-8, iso-8859-1, or undefined"
        );
      var t = typeof e.charset > "u" ? Ct.charset : e.charset,
        i = typeof e.duplicates > "u" ? Ct.duplicates : e.duplicates;
      if (i !== "combine" && i !== "first" && i !== "last")
        throw new TypeError(
          "The duplicates option must be either combine, first, or last"
        );
      var s =
        typeof e.allowDots > "u"
          ? e.decodeDotInKeys === !0
            ? !0
            : Ct.allowDots
          : !!e.allowDots;
      return {
        allowDots: s,
        allowEmptyArrays:
          typeof e.allowEmptyArrays == "boolean"
            ? !!e.allowEmptyArrays
            : Ct.allowEmptyArrays,
        allowPrototypes:
          typeof e.allowPrototypes == "boolean"
            ? e.allowPrototypes
            : Ct.allowPrototypes,
        allowSparse:
          typeof e.allowSparse == "boolean" ? e.allowSparse : Ct.allowSparse,
        arrayLimit:
          typeof e.arrayLimit == "number" ? e.arrayLimit : Ct.arrayLimit,
        charset: t,
        charsetSentinel:
          typeof e.charsetSentinel == "boolean"
            ? e.charsetSentinel
            : Ct.charsetSentinel,
        comma: typeof e.comma == "boolean" ? e.comma : Ct.comma,
        decodeDotInKeys:
          typeof e.decodeDotInKeys == "boolean"
            ? e.decodeDotInKeys
            : Ct.decodeDotInKeys,
        decoder: typeof e.decoder == "function" ? e.decoder : Ct.decoder,
        delimiter:
          typeof e.delimiter == "string" || $a.isRegExp(e.delimiter)
            ? e.delimiter
            : Ct.delimiter,
        depth:
          typeof e.depth == "number" || e.depth === !1 ? +e.depth : Ct.depth,
        duplicates: i,
        ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
        interpretNumericEntities:
          typeof e.interpretNumericEntities == "boolean"
            ? e.interpretNumericEntities
            : Ct.interpretNumericEntities,
        parameterLimit:
          typeof e.parameterLimit == "number"
            ? e.parameterLimit
            : Ct.parameterLimit,
        parseArrays: e.parseArrays !== !1,
        plainObjects:
          typeof e.plainObjects == "boolean" ? e.plainObjects : Ct.plainObjects,
        strictDepth:
          typeof e.strictDepth == "boolean" ? !!e.strictDepth : Ct.strictDepth,
        strictNullHandling:
          typeof e.strictNullHandling == "boolean"
            ? e.strictNullHandling
            : Ct.strictNullHandling,
      };
    },
    BL = function (r, e) {
      var t = FL(e);
      if (r === "" || r === null || typeof r > "u")
        return t.plainObjects ? Object.create(null) : {};
      for (
        var i = typeof r == "string" ? PL(r, t) : r,
          s = t.plainObjects ? Object.create(null) : {},
          n = Object.keys(i),
          a = 0;
        a < n.length;
        ++a
      ) {
        var o = n[a],
          l = ML(o, i[o], t, typeof r == "string");
        s = $a.merge(s, l, t);
      }
      return t.allowSparse === !0 ? s : $a.compact(s);
    },
    OL = EL,
    kL = BL,
    DL = tm,
    LL = { formats: DL, parse: kL, stringify: OL },
    NL = bk;
  function fs() {
    (this.protocol = null),
      (this.slashes = null),
      (this.auth = null),
      (this.host = null),
      (this.port = null),
      (this.hostname = null),
      (this.hash = null),
      (this.search = null),
      (this.query = null),
      (this.pathname = null),
      (this.path = null),
      (this.href = null);
  }
  var UL = /^([a-z0-9.+-]+:)/i,
    VL = /:[0-9]*$/,
    $L = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,
    GL = [
      "<",
      ">",
      '"',
      "`",
      " ",
      "\r",
      `
`,
      "	",
    ],
    HL = ["{", "}", "|", "\\", "^", "`"].concat(GL),
    Kd = ["'"].concat(HL),
    lv = ["%", "/", "?", ";", "#"].concat(Kd),
    hv = ["/", "?", "#"],
    XL = 255,
    cv = /^[+a-z0-9A-Z_-]{0,63}$/,
    zL = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    WL = { javascript: !0, "javascript:": !0 },
    Zd = { javascript: !0, "javascript:": !0 },
    Ea = {
      http: !0,
      https: !0,
      ftp: !0,
      gopher: !0,
      file: !0,
      "http:": !0,
      "https:": !0,
      "ftp:": !0,
      "gopher:": !0,
      "file:": !0,
    },
    Jd = LL;
  function YL(r, e, t) {
    if (r && typeof r == "object" && r instanceof fs) return r;
    var i = new fs();
    return i.parse(r, e, t), i;
  }
  fs.prototype.parse = function (r, e, t) {
    if (typeof r != "string")
      throw new TypeError("Parameter 'url' must be a string, not " + typeof r);
    var i = r.indexOf("?"),
      s = i !== -1 && i < r.indexOf("#") ? "?" : "#",
      n = r.split(s),
      a = /\\/g;
    (n[0] = n[0].replace(a, "/")), (r = n.join(s));
    var o = r;
    if (((o = o.trim()), !t && r.split("#").length === 1)) {
      var l = $L.exec(o);
      if (l)
        return (
          (this.path = o),
          (this.href = o),
          (this.pathname = l[1]),
          l[2]
            ? ((this.search = l[2]),
              e
                ? (this.query = Jd.parse(this.search.substr(1)))
                : (this.query = this.search.substr(1)))
            : e && ((this.search = ""), (this.query = {})),
          this
        );
    }
    var h = UL.exec(o);
    if (h) {
      h = h[0];
      var c = h.toLowerCase();
      (this.protocol = c), (o = o.substr(h.length));
    }
    if (t || h || o.match(/^\/\/[^@/]+@[^@/]+/)) {
      var u = o.substr(0, 2) === "//";
      u && !(h && Zd[h]) && ((o = o.substr(2)), (this.slashes = !0));
    }
    if (!Zd[h] && (u || (h && !Ea[h]))) {
      for (var d = -1, f = 0; f < hv.length; f++) {
        var p = o.indexOf(hv[f]);
        p !== -1 && (d === -1 || p < d) && (d = p);
      }
      var m, v;
      d === -1 ? (v = o.lastIndexOf("@")) : (v = o.lastIndexOf("@", d)),
        v !== -1 &&
          ((m = o.slice(0, v)),
          (o = o.slice(v + 1)),
          (this.auth = decodeURIComponent(m))),
        (d = -1);
      for (var f = 0; f < lv.length; f++) {
        var p = o.indexOf(lv[f]);
        p !== -1 && (d === -1 || p < d) && (d = p);
      }
      d === -1 && (d = o.length),
        (this.host = o.slice(0, d)),
        (o = o.slice(d)),
        this.parseHost(),
        (this.hostname = this.hostname || "");
      var g =
        this.hostname[0] === "[" &&
        this.hostname[this.hostname.length - 1] === "]";
      if (!g)
        for (
          var x = this.hostname.split(/\./), f = 0, b = x.length;
          f < b;
          f++
        ) {
          var y = x[f];
          if (y && !y.match(cv)) {
            for (var _ = "", w = 0, E = y.length; w < E; w++)
              y.charCodeAt(w) > 127 ? (_ += "x") : (_ += y[w]);
            if (!_.match(cv)) {
              var A = x.slice(0, f),
                C = x.slice(f + 1),
                F = y.match(zL);
              F && (A.push(F[1]), C.unshift(F[2])),
                C.length && (o = "/" + C.join(".") + o),
                (this.hostname = A.join("."));
              break;
            }
          }
        }
      this.hostname.length > XL
        ? (this.hostname = "")
        : (this.hostname = this.hostname.toLowerCase()),
        g || (this.hostname = NL.toASCII(this.hostname));
      var B = this.port ? ":" + this.port : "",
        R = this.hostname || "";
      (this.host = R + B),
        (this.href += this.host),
        g &&
          ((this.hostname = this.hostname.substr(1, this.hostname.length - 2)),
          o[0] !== "/" && (o = "/" + o));
    }
    if (!WL[c])
      for (var f = 0, b = Kd.length; f < b; f++) {
        var I = Kd[f];
        if (o.indexOf(I) !== -1) {
          var P = encodeURIComponent(I);
          P === I && (P = escape(I)), (o = o.split(I).join(P));
        }
      }
    var M = o.indexOf("#");
    M !== -1 && ((this.hash = o.substr(M)), (o = o.slice(0, M)));
    var L = o.indexOf("?");
    if (
      (L !== -1
        ? ((this.search = o.substr(L)),
          (this.query = o.substr(L + 1)),
          e && (this.query = Jd.parse(this.query)),
          (o = o.slice(0, L)))
        : e && ((this.search = ""), (this.query = {})),
      o && (this.pathname = o),
      Ea[c] && this.hostname && !this.pathname && (this.pathname = "/"),
      this.pathname || this.search)
    ) {
      var B = this.pathname || "",
        U = this.search || "";
      this.path = B + U;
    }
    return (this.href = this.format()), this;
  };
  fs.prototype.format = function () {
    var r = this.auth || "";
    r &&
      ((r = encodeURIComponent(r)), (r = r.replace(/%3A/i, ":")), (r += "@"));
    var e = this.protocol || "",
      t = this.pathname || "",
      i = this.hash || "",
      s = !1,
      n = "";
    this.host
      ? (s = r + this.host)
      : this.hostname &&
        ((s =
          r +
          (this.hostname.indexOf(":") === -1
            ? this.hostname
            : "[" + this.hostname + "]")),
        this.port && (s += ":" + this.port)),
      this.query &&
        typeof this.query == "object" &&
        Object.keys(this.query).length &&
        (n = Jd.stringify(this.query, {
          arrayFormat: "repeat",
          addQueryPrefix: !1,
        }));
    var a = this.search || (n && "?" + n) || "";
    return (
      e && e.substr(-1) !== ":" && (e += ":"),
      this.slashes || ((!e || Ea[e]) && s !== !1)
        ? ((s = "//" + (s || "")), t && t.charAt(0) !== "/" && (t = "/" + t))
        : s || (s = ""),
      i && i.charAt(0) !== "#" && (i = "#" + i),
      a && a.charAt(0) !== "?" && (a = "?" + a),
      (t = t.replace(/[?#]/g, function (o) {
        return encodeURIComponent(o);
      })),
      (a = a.replace("#", "%23")),
      e + s + t + a + i
    );
  };
  fs.prototype.resolve = function (r) {
    return this.resolveObject(YL(r, !1, !0)).format();
  };
  fs.prototype.resolveObject = function (r) {
    if (typeof r == "string") {
      var e = new fs();
      e.parse(r, !1, !0), (r = e);
    }
    for (var t = new fs(), i = Object.keys(this), s = 0; s < i.length; s++) {
      var n = i[s];
      t[n] = this[n];
    }
    if (((t.hash = r.hash), r.href === "")) return (t.href = t.format()), t;
    if (r.slashes && !r.protocol) {
      for (var a = Object.keys(r), o = 0; o < a.length; o++) {
        var l = a[o];
        l !== "protocol" && (t[l] = r[l]);
      }
      return (
        Ea[t.protocol] &&
          t.hostname &&
          !t.pathname &&
          ((t.pathname = "/"), (t.path = t.pathname)),
        (t.href = t.format()),
        t
      );
    }
    if (r.protocol && r.protocol !== t.protocol) {
      if (!Ea[r.protocol]) {
        for (var h = Object.keys(r), c = 0; c < h.length; c++) {
          var u = h[c];
          t[u] = r[u];
        }
        return (t.href = t.format()), t;
      }
      if (((t.protocol = r.protocol), !r.host && !Zd[r.protocol])) {
        for (
          var b = (r.pathname || "").split("/");
          b.length && !(r.host = b.shift());

        );
        r.host || (r.host = ""),
          r.hostname || (r.hostname = ""),
          b[0] !== "" && b.unshift(""),
          b.length < 2 && b.unshift(""),
          (t.pathname = b.join("/"));
      } else t.pathname = r.pathname;
      if (
        ((t.search = r.search),
        (t.query = r.query),
        (t.host = r.host || ""),
        (t.auth = r.auth),
        (t.hostname = r.hostname || r.host),
        (t.port = r.port),
        t.pathname || t.search)
      ) {
        var d = t.pathname || "",
          f = t.search || "";
        t.path = d + f;
      }
      return (t.slashes = t.slashes || r.slashes), (t.href = t.format()), t;
    }
    var p = t.pathname && t.pathname.charAt(0) === "/",
      m = r.host || (r.pathname && r.pathname.charAt(0) === "/"),
      v = m || p || (t.host && r.pathname),
      g = v,
      x = (t.pathname && t.pathname.split("/")) || [],
      b = (r.pathname && r.pathname.split("/")) || [],
      y = t.protocol && !Ea[t.protocol];
    if (
      (y &&
        ((t.hostname = ""),
        (t.port = null),
        t.host && (x[0] === "" ? (x[0] = t.host) : x.unshift(t.host)),
        (t.host = ""),
        r.protocol &&
          ((r.hostname = null),
          (r.port = null),
          r.host && (b[0] === "" ? (b[0] = r.host) : b.unshift(r.host)),
          (r.host = null)),
        (v = v && (b[0] === "" || x[0] === ""))),
      m)
    )
      (t.host = r.host || r.host === "" ? r.host : t.host),
        (t.hostname =
          r.hostname || r.hostname === "" ? r.hostname : t.hostname),
        (t.search = r.search),
        (t.query = r.query),
        (x = b);
    else if (b.length)
      x || (x = []),
        x.pop(),
        (x = x.concat(b)),
        (t.search = r.search),
        (t.query = r.query);
    else if (r.search != null) {
      if (y) {
        (t.host = x.shift()), (t.hostname = t.host);
        var _ = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : !1;
        _ &&
          ((t.auth = _.shift()),
          (t.hostname = _.shift()),
          (t.host = t.hostname));
      }
      return (
        (t.search = r.search),
        (t.query = r.query),
        (t.pathname !== null || t.search !== null) &&
          (t.path =
            (t.pathname ? t.pathname : "") + (t.search ? t.search : "")),
        (t.href = t.format()),
        t
      );
    }
    if (!x.length)
      return (
        (t.pathname = null),
        t.search ? (t.path = "/" + t.search) : (t.path = null),
        (t.href = t.format()),
        t
      );
    for (
      var w = x.slice(-1)[0],
        E =
          ((t.host || r.host || x.length > 1) && (w === "." || w === "..")) ||
          w === "",
        A = 0,
        C = x.length;
      C >= 0;
      C--
    )
      (w = x[C]),
        w === "."
          ? x.splice(C, 1)
          : w === ".."
          ? (x.splice(C, 1), A++)
          : A && (x.splice(C, 1), A--);
    if (!v && !g) for (; A--; A) x.unshift("..");
    v && x[0] !== "" && (!x[0] || x[0].charAt(0) !== "/") && x.unshift(""),
      E && x.join("/").substr(-1) !== "/" && x.push("");
    var F = x[0] === "" || (x[0] && x[0].charAt(0) === "/");
    if (y) {
      (t.hostname = F ? "" : x.length ? x.shift() : ""), (t.host = t.hostname);
      var _ = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : !1;
      _ &&
        ((t.auth = _.shift()), (t.hostname = _.shift()), (t.host = t.hostname));
    }
    return (
      (v = v || (t.host && x.length)),
      v && !F && x.unshift(""),
      x.length > 0
        ? (t.pathname = x.join("/"))
        : ((t.pathname = null), (t.path = null)),
      (t.pathname !== null || t.search !== null) &&
        (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")),
      (t.auth = r.auth || t.auth),
      (t.slashes = t.slashes || r.slashes),
      (t.href = t.format()),
      t
    );
  };
  fs.prototype.parseHost = function () {
    var r = this.host,
      e = VL.exec(r);
    e &&
      ((e = e[0]),
      e !== ":" && (this.port = e.substr(1)),
      (r = r.substr(0, r.length - e.length))),
      r && (this.hostname = r);
  };
  const uv = {};
  function We(r, e, t = 3) {
    if (uv[e]) return;
    let i = new Error().stack;
    typeof i > "u"
      ? console.warn(
          "PixiJS Deprecation Warning: ",
          `${e}
Deprecated since v${r}`
        )
      : ((i = i
          .split(
            `
`
          )
          .splice(t).join(`
`)),
        console.groupCollapsed
          ? (console.groupCollapsed(
              "%cPixiJS Deprecation Warning: %c%s",
              "color:#614108;background:#fffbe6",
              "font-weight:normal;color:#614108;background:#fffbe6",
              `${e}
Deprecated since v${r}`
            ),
            console.warn(i),
            console.groupEnd())
          : (console.warn(
              "PixiJS Deprecation Warning: ",
              `${e}
Deprecated since v${r}`
            ),
            console.warn(i))),
      (uv[e] = !0);
  }
  function Zr(r) {
    if (typeof r != "string")
      throw new TypeError(
        `Path must be a string. Received ${JSON.stringify(r)}`
      );
  }
  function co(r) {
    return r.split("?")[0].split("#")[0];
  }
  function jL(r) {
    return r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function qL(r, e, t) {
    return r.replace(new RegExp(jL(e), "g"), t);
  }
  function KL(r, e) {
    let t = "",
      i = 0,
      s = -1,
      n = 0,
      a = -1;
    for (let o = 0; o <= r.length; ++o) {
      if (o < r.length) a = r.charCodeAt(o);
      else {
        if (a === 47) break;
        a = 47;
      }
      if (a === 47) {
        if (!(s === o - 1 || n === 1))
          if (s !== o - 1 && n === 2) {
            if (
              t.length < 2 ||
              i !== 2 ||
              t.charCodeAt(t.length - 1) !== 46 ||
              t.charCodeAt(t.length - 2) !== 46
            ) {
              if (t.length > 2) {
                const l = t.lastIndexOf("/");
                if (l !== t.length - 1) {
                  l === -1
                    ? ((t = ""), (i = 0))
                    : ((t = t.slice(0, l)),
                      (i = t.length - 1 - t.lastIndexOf("/"))),
                    (s = o),
                    (n = 0);
                  continue;
                }
              } else if (t.length === 2 || t.length === 1) {
                (t = ""), (i = 0), (s = o), (n = 0);
                continue;
              }
            }
          } else
            t.length > 0
              ? (t += `/${r.slice(s + 1, o)}`)
              : (t = r.slice(s + 1, o)),
              (i = o - s - 1);
        (s = o), (n = 0);
      } else a === 46 && n !== -1 ? ++n : (n = -1);
    }
    return t;
  }
  const Pt = {
    toPosix(r) {
      return qL(r, "\\", "/");
    },
    isUrl(r) {
      return /^https?:/.test(this.toPosix(r));
    },
    isDataUrl(r) {
      return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(
        r
      );
    },
    isBlobUrl(r) {
      return r.startsWith("blob:");
    },
    hasProtocol(r) {
      return /^[^/:]+:/.test(this.toPosix(r));
    },
    getProtocol(r) {
      Zr(r), (r = this.toPosix(r));
      const e = /^file:\/\/\//.exec(r);
      if (e) return e[0];
      const t = /^[^/:]+:\/{0,2}/.exec(r);
      return t ? t[0] : "";
    },
    toAbsolute(r, e, t) {
      if ((Zr(r), this.isDataUrl(r) || this.isBlobUrl(r))) return r;
      const i = co(this.toPosix(e ?? we.ADAPTER.getBaseUrl())),
        s = co(this.toPosix(t ?? this.rootname(i)));
      return (
        (r = this.toPosix(r)),
        r.startsWith("/")
          ? Pt.join(s, r.slice(1))
          : this.isAbsolute(r)
          ? r
          : this.join(i, r)
      );
    },
    normalize(r) {
      if ((Zr(r), r.length === 0)) return ".";
      if (this.isDataUrl(r) || this.isBlobUrl(r)) return r;
      r = this.toPosix(r);
      let e = "";
      const t = r.startsWith("/");
      this.hasProtocol(r) && ((e = this.rootname(r)), (r = r.slice(e.length)));
      const i = r.endsWith("/");
      return (r = KL(r)), r.length > 0 && i && (r += "/"), t ? `/${r}` : e + r;
    },
    isAbsolute(r) {
      return (
        Zr(r),
        (r = this.toPosix(r)),
        this.hasProtocol(r) ? !0 : r.startsWith("/")
      );
    },
    join(...r) {
      if (r.length === 0) return ".";
      let e;
      for (let t = 0; t < r.length; ++t) {
        const i = r[t];
        if ((Zr(i), i.length > 0))
          if (e === void 0) e = i;
          else {
            const s = r[t - 1] ?? "";
            this.joinExtensions.includes(this.extname(s).toLowerCase())
              ? (e += `/../${i}`)
              : (e += `/${i}`);
          }
      }
      return e === void 0 ? "." : this.normalize(e);
    },
    dirname(r) {
      if ((Zr(r), r.length === 0)) return ".";
      r = this.toPosix(r);
      let e = r.charCodeAt(0);
      const t = e === 47;
      let i = -1,
        s = !0;
      const n = this.getProtocol(r),
        a = r;
      r = r.slice(n.length);
      for (let o = r.length - 1; o >= 1; --o)
        if (((e = r.charCodeAt(o)), e === 47)) {
          if (!s) {
            i = o;
            break;
          }
        } else s = !1;
      return i === -1
        ? t
          ? "/"
          : this.isUrl(a)
          ? n + r
          : n
        : t && i === 1
        ? "//"
        : n + r.slice(0, i);
    },
    rootname(r) {
      Zr(r), (r = this.toPosix(r));
      let e = "";
      if (
        (r.startsWith("/") ? (e = "/") : (e = this.getProtocol(r)),
        this.isUrl(r))
      ) {
        const t = r.indexOf("/", e.length);
        t !== -1 ? (e = r.slice(0, t)) : (e = r), e.endsWith("/") || (e += "/");
      }
      return e;
    },
    basename(r, e) {
      Zr(r), e && Zr(e), (r = co(this.toPosix(r)));
      let t = 0,
        i = -1,
        s = !0,
        n;
      if (e !== void 0 && e.length > 0 && e.length <= r.length) {
        if (e.length === r.length && e === r) return "";
        let a = e.length - 1,
          o = -1;
        for (n = r.length - 1; n >= 0; --n) {
          const l = r.charCodeAt(n);
          if (l === 47) {
            if (!s) {
              t = n + 1;
              break;
            }
          } else
            o === -1 && ((s = !1), (o = n + 1)),
              a >= 0 &&
                (l === e.charCodeAt(a)
                  ? --a === -1 && (i = n)
                  : ((a = -1), (i = o)));
        }
        return t === i ? (i = o) : i === -1 && (i = r.length), r.slice(t, i);
      }
      for (n = r.length - 1; n >= 0; --n)
        if (r.charCodeAt(n) === 47) {
          if (!s) {
            t = n + 1;
            break;
          }
        } else i === -1 && ((s = !1), (i = n + 1));
      return i === -1 ? "" : r.slice(t, i);
    },
    extname(r) {
      Zr(r), (r = co(this.toPosix(r)));
      let e = -1,
        t = 0,
        i = -1,
        s = !0,
        n = 0;
      for (let a = r.length - 1; a >= 0; --a) {
        const o = r.charCodeAt(a);
        if (o === 47) {
          if (!s) {
            t = a + 1;
            break;
          }
          continue;
        }
        i === -1 && ((s = !1), (i = a + 1)),
          o === 46
            ? e === -1
              ? (e = a)
              : n !== 1 && (n = 1)
            : e !== -1 && (n = -1);
      }
      return e === -1 ||
        i === -1 ||
        n === 0 ||
        (n === 1 && e === i - 1 && e === t + 1)
        ? ""
        : r.slice(e, i);
    },
    parse(r) {
      Zr(r);
      const e = { root: "", dir: "", base: "", ext: "", name: "" };
      if (r.length === 0) return e;
      r = co(this.toPosix(r));
      let t = r.charCodeAt(0);
      const i = this.isAbsolute(r);
      let s;
      (e.root = this.rootname(r)), i || this.hasProtocol(r) ? (s = 1) : (s = 0);
      let n = -1,
        a = 0,
        o = -1,
        l = !0,
        h = r.length - 1,
        c = 0;
      for (; h >= s; --h) {
        if (((t = r.charCodeAt(h)), t === 47)) {
          if (!l) {
            a = h + 1;
            break;
          }
          continue;
        }
        o === -1 && ((l = !1), (o = h + 1)),
          t === 46
            ? n === -1
              ? (n = h)
              : c !== 1 && (c = 1)
            : n !== -1 && (c = -1);
      }
      return (
        n === -1 ||
        o === -1 ||
        c === 0 ||
        (c === 1 && n === o - 1 && n === a + 1)
          ? o !== -1 &&
            (a === 0 && i
              ? (e.base = e.name = r.slice(1, o))
              : (e.base = e.name = r.slice(a, o)))
          : (a === 0 && i
              ? ((e.name = r.slice(1, n)), (e.base = r.slice(1, o)))
              : ((e.name = r.slice(a, n)), (e.base = r.slice(a, o))),
            (e.ext = r.slice(n, o))),
        (e.dir = this.dirname(r)),
        e
      );
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [".html"],
  };
  let ku;
  async function ZL() {
    return (
      ku ??
        (ku = (async () => {
          var n;
          const r = document.createElement("canvas").getContext("webgl");
          if (!r) return sr.UNPACK;
          const e = await new Promise((a) => {
            const o = document.createElement("video");
            (o.onloadeddata = () => a(o)),
              (o.onerror = () => a(null)),
              (o.autoplay = !1),
              (o.crossOrigin = "anonymous"),
              (o.preload = "auto"),
              (o.src =
                "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM="),
              o.load();
          });
          if (!e) return sr.UNPACK;
          const t = r.createTexture();
          r.bindTexture(r.TEXTURE_2D, t);
          const i = r.createFramebuffer();
          r.bindFramebuffer(r.FRAMEBUFFER, i),
            r.framebufferTexture2D(
              r.FRAMEBUFFER,
              r.COLOR_ATTACHMENT0,
              r.TEXTURE_2D,
              t,
              0
            ),
            r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
            r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, r.NONE),
            r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, r.RGBA, r.UNSIGNED_BYTE, e);
          const s = new Uint8Array(4);
          return (
            r.readPixels(0, 0, 1, 1, r.RGBA, r.UNSIGNED_BYTE, s),
            r.deleteFramebuffer(i),
            r.deleteTexture(t),
            (n = r.getExtension("WEBGL_lose_context")) == null ||
              n.loseContext(),
            s[0] <= s[3] ? sr.PMA : sr.UNPACK
          );
        })()),
      ku
    );
  }
  let Du;
  function JL() {
    return (
      typeof Du > "u" &&
        (Du = (function () {
          var e;
          const r = {
            stencil: !0,
            failIfMajorPerformanceCaveat: we.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT,
          };
          try {
            if (!we.ADAPTER.getWebGLRenderingContext()) return !1;
            const t = we.ADAPTER.createCanvas();
            let i =
              t.getContext("webgl", r) || t.getContext("experimental-webgl", r);
            const s = !!(
              (e = i == null ? void 0 : i.getContextAttributes()) != null &&
              e.stencil
            );
            if (i) {
              const n = i.getExtension("WEBGL_lose_context");
              n && n.loseContext();
            }
            return (i = null), s;
          } catch {
            return !1;
          }
        })()),
      Du
    );
  }
  var QL = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) },
    Qi = function (r) {
      return typeof r == "string" ? r.length > 0 : typeof r == "number";
    },
    zt = function (r, e, t) {
      return (
        e === void 0 && (e = 0),
        t === void 0 && (t = Math.pow(10, e)),
        Math.round(t * r) / t + 0
      );
    },
    Vr = function (r, e, t) {
      return (
        e === void 0 && (e = 0),
        t === void 0 && (t = 1),
        r > t ? t : r > e ? r : e
      );
    },
    A1 = function (r) {
      return (r = isFinite(r) ? r % 360 : 0) > 0 ? r : r + 360;
    },
    dv = function (r) {
      return {
        r: Vr(r.r, 0, 255),
        g: Vr(r.g, 0, 255),
        b: Vr(r.b, 0, 255),
        a: Vr(r.a),
      };
    },
    Lu = function (r) {
      return { r: zt(r.r), g: zt(r.g), b: zt(r.b), a: zt(r.a, 3) };
    },
    eN = /^#([0-9a-f]{3,8})$/i,
    Xl = function (r) {
      var e = r.toString(16);
      return e.length < 2 ? "0" + e : e;
    },
    C1 = function (r) {
      var e = r.r,
        t = r.g,
        i = r.b,
        s = r.a,
        n = Math.max(e, t, i),
        a = n - Math.min(e, t, i),
        o = a
          ? n === e
            ? (t - i) / a
            : n === t
            ? 2 + (i - e) / a
            : 4 + (e - t) / a
          : 0;
      return {
        h: 60 * (o < 0 ? o + 6 : o),
        s: n ? (a / n) * 100 : 0,
        v: (n / 255) * 100,
        a: s,
      };
    },
    I1 = function (r) {
      var e = r.h,
        t = r.s,
        i = r.v,
        s = r.a;
      (e = (e / 360) * 6), (t /= 100), (i /= 100);
      var n = Math.floor(e),
        a = i * (1 - t),
        o = i * (1 - (e - n) * t),
        l = i * (1 - (1 - e + n) * t),
        h = n % 6;
      return {
        r: 255 * [i, o, a, a, l, i][h],
        g: 255 * [l, i, i, o, a, a][h],
        b: 255 * [a, a, l, i, i, o][h],
        a: s,
      };
    },
    fv = function (r) {
      return { h: A1(r.h), s: Vr(r.s, 0, 100), l: Vr(r.l, 0, 100), a: Vr(r.a) };
    },
    pv = function (r) {
      return { h: zt(r.h), s: zt(r.s), l: zt(r.l), a: zt(r.a, 3) };
    },
    mv = function (r) {
      return I1(
        ((t = (e = r).s),
        {
          h: e.h,
          s:
            (t *= ((i = e.l) < 50 ? i : 100 - i) / 100) > 0
              ? ((2 * t) / (i + t)) * 100
              : 0,
          v: i + t,
          a: e.a,
        })
      );
      var e, t, i;
    },
    Uo = function (r) {
      return {
        h: (e = C1(r)).h,
        s:
          (s = ((200 - (t = e.s)) * (i = e.v)) / 100) > 0 && s < 200
            ? ((t * i) / 100 / (s <= 100 ? s : 200 - s)) * 100
            : 0,
        l: s / 2,
        a: e.a,
      };
      var e, t, i, s;
    },
    tN =
      /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    rN =
      /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    iN =
      /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    sN =
      /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    Qd = {
      string: [
        [
          function (r) {
            var e = eN.exec(r);
            return e
              ? (r = e[1]).length <= 4
                ? {
                    r: parseInt(r[0] + r[0], 16),
                    g: parseInt(r[1] + r[1], 16),
                    b: parseInt(r[2] + r[2], 16),
                    a:
                      r.length === 4
                        ? zt(parseInt(r[3] + r[3], 16) / 255, 2)
                        : 1,
                  }
                : r.length === 6 || r.length === 8
                ? {
                    r: parseInt(r.substr(0, 2), 16),
                    g: parseInt(r.substr(2, 2), 16),
                    b: parseInt(r.substr(4, 2), 16),
                    a:
                      r.length === 8
                        ? zt(parseInt(r.substr(6, 2), 16) / 255, 2)
                        : 1,
                  }
                : null
              : null;
          },
          "hex",
        ],
        [
          function (r) {
            var e = iN.exec(r) || sN.exec(r);
            return e
              ? e[2] !== e[4] || e[4] !== e[6]
                ? null
                : dv({
                    r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
                    g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
                    b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
                    a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1),
                  })
              : null;
          },
          "rgb",
        ],
        [
          function (r) {
            var e = tN.exec(r) || rN.exec(r);
            if (!e) return null;
            var t,
              i,
              s = fv({
                h:
                  ((t = e[1]),
                  (i = e[2]),
                  i === void 0 && (i = "deg"),
                  Number(t) * (QL[i] || 1)),
                s: Number(e[3]),
                l: Number(e[4]),
                a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1),
              });
            return mv(s);
          },
          "hsl",
        ],
      ],
      object: [
        [
          function (r) {
            var e = r.r,
              t = r.g,
              i = r.b,
              s = r.a,
              n = s === void 0 ? 1 : s;
            return Qi(e) && Qi(t) && Qi(i)
              ? dv({ r: Number(e), g: Number(t), b: Number(i), a: Number(n) })
              : null;
          },
          "rgb",
        ],
        [
          function (r) {
            var e = r.h,
              t = r.s,
              i = r.l,
              s = r.a,
              n = s === void 0 ? 1 : s;
            if (!Qi(e) || !Qi(t) || !Qi(i)) return null;
            var a = fv({
              h: Number(e),
              s: Number(t),
              l: Number(i),
              a: Number(n),
            });
            return mv(a);
          },
          "hsl",
        ],
        [
          function (r) {
            var e = r.h,
              t = r.s,
              i = r.v,
              s = r.a,
              n = s === void 0 ? 1 : s;
            if (!Qi(e) || !Qi(t) || !Qi(i)) return null;
            var a = (function (o) {
              return {
                h: A1(o.h),
                s: Vr(o.s, 0, 100),
                v: Vr(o.v, 0, 100),
                a: Vr(o.a),
              };
            })({ h: Number(e), s: Number(t), v: Number(i), a: Number(n) });
            return I1(a);
          },
          "hsv",
        ],
      ],
    },
    gv = function (r, e) {
      for (var t = 0; t < e.length; t++) {
        var i = e[t][0](r);
        if (i) return [i, e[t][1]];
      }
      return [null, void 0];
    },
    nN = function (r) {
      return typeof r == "string"
        ? gv(r.trim(), Qd.string)
        : typeof r == "object" && r !== null
        ? gv(r, Qd.object)
        : [null, void 0];
    },
    Nu = function (r, e) {
      var t = Uo(r);
      return { h: t.h, s: Vr(t.s + 100 * e, 0, 100), l: t.l, a: t.a };
    },
    Uu = function (r) {
      return (299 * r.r + 587 * r.g + 114 * r.b) / 1e3 / 255;
    },
    vv = function (r, e) {
      var t = Uo(r);
      return { h: t.h, s: t.s, l: Vr(t.l + 100 * e, 0, 100), a: t.a };
    },
    ef = (function () {
      function r(e) {
        (this.parsed = nN(e)[0]),
          (this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 });
      }
      return (
        (r.prototype.isValid = function () {
          return this.parsed !== null;
        }),
        (r.prototype.brightness = function () {
          return zt(Uu(this.rgba), 2);
        }),
        (r.prototype.isDark = function () {
          return Uu(this.rgba) < 0.5;
        }),
        (r.prototype.isLight = function () {
          return Uu(this.rgba) >= 0.5;
        }),
        (r.prototype.toHex = function () {
          return (
            (e = Lu(this.rgba)),
            (t = e.r),
            (i = e.g),
            (s = e.b),
            (a = (n = e.a) < 1 ? Xl(zt(255 * n)) : ""),
            "#" + Xl(t) + Xl(i) + Xl(s) + a
          );
          var e, t, i, s, n, a;
        }),
        (r.prototype.toRgb = function () {
          return Lu(this.rgba);
        }),
        (r.prototype.toRgbString = function () {
          return (
            (e = Lu(this.rgba)),
            (t = e.r),
            (i = e.g),
            (s = e.b),
            (n = e.a) < 1
              ? "rgba(" + t + ", " + i + ", " + s + ", " + n + ")"
              : "rgb(" + t + ", " + i + ", " + s + ")"
          );
          var e, t, i, s, n;
        }),
        (r.prototype.toHsl = function () {
          return pv(Uo(this.rgba));
        }),
        (r.prototype.toHslString = function () {
          return (
            (e = pv(Uo(this.rgba))),
            (t = e.h),
            (i = e.s),
            (s = e.l),
            (n = e.a) < 1
              ? "hsla(" + t + ", " + i + "%, " + s + "%, " + n + ")"
              : "hsl(" + t + ", " + i + "%, " + s + "%)"
          );
          var e, t, i, s, n;
        }),
        (r.prototype.toHsv = function () {
          return (
            (e = C1(this.rgba)),
            { h: zt(e.h), s: zt(e.s), v: zt(e.v), a: zt(e.a, 3) }
          );
          var e;
        }),
        (r.prototype.invert = function () {
          return Ei({
            r: 255 - (e = this.rgba).r,
            g: 255 - e.g,
            b: 255 - e.b,
            a: e.a,
          });
          var e;
        }),
        (r.prototype.saturate = function (e) {
          return e === void 0 && (e = 0.1), Ei(Nu(this.rgba, e));
        }),
        (r.prototype.desaturate = function (e) {
          return e === void 0 && (e = 0.1), Ei(Nu(this.rgba, -e));
        }),
        (r.prototype.grayscale = function () {
          return Ei(Nu(this.rgba, -1));
        }),
        (r.prototype.lighten = function (e) {
          return e === void 0 && (e = 0.1), Ei(vv(this.rgba, e));
        }),
        (r.prototype.darken = function (e) {
          return e === void 0 && (e = 0.1), Ei(vv(this.rgba, -e));
        }),
        (r.prototype.rotate = function (e) {
          return e === void 0 && (e = 15), this.hue(this.hue() + e);
        }),
        (r.prototype.alpha = function (e) {
          return typeof e == "number"
            ? Ei({ r: (t = this.rgba).r, g: t.g, b: t.b, a: e })
            : zt(this.rgba.a, 3);
          var t;
        }),
        (r.prototype.hue = function (e) {
          var t = Uo(this.rgba);
          return typeof e == "number"
            ? Ei({ h: e, s: t.s, l: t.l, a: t.a })
            : zt(t.h);
        }),
        (r.prototype.isEqual = function (e) {
          return this.toHex() === Ei(e).toHex();
        }),
        r
      );
    })(),
    Ei = function (r) {
      return r instanceof ef ? r : new ef(r);
    },
    yv = [],
    aN = function (r) {
      r.forEach(function (e) {
        yv.indexOf(e) < 0 && (e(ef, Qd), yv.push(e));
      });
    };
  function oN(r, e) {
    var t = {
        white: "#ffffff",
        bisque: "#ffe4c4",
        blue: "#0000ff",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        azure: "#f0ffff",
        whitesmoke: "#f5f5f5",
        papayawhip: "#ffefd5",
        plum: "#dda0dd",
        blanchedalmond: "#ffebcd",
        black: "#000000",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gainsboro: "#dcdcdc",
        cornsilk: "#fff8dc",
        cornflowerblue: "#6495ed",
        burlywood: "#deb887",
        aquamarine: "#7fffd4",
        beige: "#f5f5dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkkhaki: "#bdb76b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        peachpuff: "#ffdab9",
        darkmagenta: "#8b008b",
        darkred: "#8b0000",
        darkorchid: "#9932cc",
        darkorange: "#ff8c00",
        darkslateblue: "#483d8b",
        gray: "#808080",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        wheat: "#f5deb3",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        ghostwhite: "#f8f8ff",
        darkviolet: "#9400d3",
        magenta: "#ff00ff",
        green: "#008000",
        dodgerblue: "#1e90ff",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        blueviolet: "#8a2be2",
        forestgreen: "#228b22",
        lawngreen: "#7cfc00",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        fuchsia: "#ff00ff",
        brown: "#a52a2a",
        maroon: "#800000",
        mediumblue: "#0000cd",
        lightcoral: "#f08080",
        darkturquoise: "#00ced1",
        lightcyan: "#e0ffff",
        ivory: "#fffff0",
        lightyellow: "#ffffe0",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        linen: "#faf0e6",
        mediumaquamarine: "#66cdaa",
        lemonchiffon: "#fffacd",
        lime: "#00ff00",
        khaki: "#f0e68c",
        mediumseagreen: "#3cb371",
        limegreen: "#32cd32",
        mediumspringgreen: "#00fa9a",
        lightskyblue: "#87cefa",
        lightblue: "#add8e6",
        midnightblue: "#191970",
        lightpink: "#ffb6c1",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        mintcream: "#f5fffa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        navajowhite: "#ffdead",
        navy: "#000080",
        mediumvioletred: "#c71585",
        powderblue: "#b0e0e6",
        palegoldenrod: "#eee8aa",
        oldlace: "#fdf5e6",
        paleturquoise: "#afeeee",
        mediumturquoise: "#48d1cc",
        mediumorchid: "#ba55d3",
        rebeccapurple: "#663399",
        lightsteelblue: "#b0c4de",
        mediumslateblue: "#7b68ee",
        thistle: "#d8bfd8",
        tan: "#d2b48c",
        orchid: "#da70d6",
        mediumpurple: "#9370db",
        purple: "#800080",
        pink: "#ffc0cb",
        skyblue: "#87ceeb",
        springgreen: "#00ff7f",
        palegreen: "#98fb98",
        red: "#ff0000",
        yellow: "#ffff00",
        slateblue: "#6a5acd",
        lavenderblush: "#fff0f5",
        peru: "#cd853f",
        palevioletred: "#db7093",
        violet: "#ee82ee",
        teal: "#008080",
        slategray: "#708090",
        slategrey: "#708090",
        aliceblue: "#f0f8ff",
        darkseagreen: "#8fbc8f",
        darkolivegreen: "#556b2f",
        greenyellow: "#adff2f",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        tomato: "#ff6347",
        silver: "#c0c0c0",
        sienna: "#a0522d",
        lavender: "#e6e6fa",
        lightgreen: "#90ee90",
        orange: "#ffa500",
        orangered: "#ff4500",
        steelblue: "#4682b4",
        royalblue: "#4169e1",
        turquoise: "#40e0d0",
        yellowgreen: "#9acd32",
        salmon: "#fa8072",
        saddlebrown: "#8b4513",
        sandybrown: "#f4a460",
        rosybrown: "#bc8f8f",
        darksalmon: "#e9967a",
        lightgoldenrodyellow: "#fafad2",
        snow: "#fffafa",
        lightgrey: "#d3d3d3",
        lightgray: "#d3d3d3",
        dimgray: "#696969",
        dimgrey: "#696969",
        olivedrab: "#6b8e23",
        olive: "#808000",
      },
      i = {};
    for (var s in t) i[t[s]] = s;
    var n = {};
    (r.prototype.toName = function (a) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
        return "transparent";
      var o,
        l,
        h = i[this.toHex()];
      if (h) return h;
      if (a != null && a.closest) {
        var c = this.toRgb(),
          u = 1 / 0,
          d = "black";
        if (!n.length) for (var f in t) n[f] = new r(t[f]).toRgb();
        for (var p in t) {
          var m =
            ((o = c),
            (l = n[p]),
            Math.pow(o.r - l.r, 2) +
              Math.pow(o.g - l.g, 2) +
              Math.pow(o.b - l.b, 2));
          m < u && ((u = m), (d = p));
        }
        return d;
      }
    }),
      e.string.push([
        function (a) {
          var o = a.toLowerCase(),
            l = o === "transparent" ? "#0000" : t[o];
          return l ? new r(l).toRgb() : null;
        },
        "name",
      ]);
  }
  aN([oN]);
  const ra = class vh {
    constructor(e = 16777215) {
      (this._value = null),
        (this._components = new Float32Array(4)),
        this._components.fill(1),
        (this._int = 16777215),
        (this.value = e);
    }
    get red() {
      return this._components[0];
    }
    get green() {
      return this._components[1];
    }
    get blue() {
      return this._components[2];
    }
    get alpha() {
      return this._components[3];
    }
    setValue(e) {
      return (this.value = e), this;
    }
    set value(e) {
      if (e instanceof vh)
        (this._value = this.cloneSource(e._value)),
          (this._int = e._int),
          this._components.set(e._components);
      else {
        if (e === null) throw new Error("Cannot set PIXI.Color#value to null");
        (this._value === null || !this.isSourceEqual(this._value, e)) &&
          (this.normalize(e), (this._value = this.cloneSource(e)));
      }
    }
    get value() {
      return this._value;
    }
    cloneSource(e) {
      return typeof e == "string" ||
        typeof e == "number" ||
        e instanceof Number ||
        e === null
        ? e
        : Array.isArray(e) || ArrayBuffer.isView(e)
        ? e.slice(0)
        : typeof e == "object" && e !== null
        ? { ...e }
        : e;
    }
    isSourceEqual(e, t) {
      const i = typeof e;
      if (i !== typeof t) return !1;
      if (i === "number" || i === "string" || e instanceof Number)
        return e === t;
      if (
        (Array.isArray(e) && Array.isArray(t)) ||
        (ArrayBuffer.isView(e) && ArrayBuffer.isView(t))
      )
        return e.length !== t.length ? !1 : e.every((s, n) => s === t[n]);
      if (e !== null && t !== null) {
        const s = Object.keys(e),
          n = Object.keys(t);
        return s.length !== n.length ? !1 : s.every((a) => e[a] === t[a]);
      }
      return e === t;
    }
    toRgba() {
      const [e, t, i, s] = this._components;
      return { r: e, g: t, b: i, a: s };
    }
    toRgb() {
      const [e, t, i] = this._components;
      return { r: e, g: t, b: i };
    }
    toRgbaString() {
      const [e, t, i] = this.toUint8RgbArray();
      return `rgba(${e},${t},${i},${this.alpha})`;
    }
    toUint8RgbArray(e) {
      const [t, i, s] = this._components;
      return (
        (e = e ?? []),
        (e[0] = Math.round(t * 255)),
        (e[1] = Math.round(i * 255)),
        (e[2] = Math.round(s * 255)),
        e
      );
    }
    toRgbArray(e) {
      e = e ?? [];
      const [t, i, s] = this._components;
      return (e[0] = t), (e[1] = i), (e[2] = s), e;
    }
    toNumber() {
      return this._int;
    }
    toLittleEndianNumber() {
      const e = this._int;
      return (e >> 16) + (e & 65280) + ((e & 255) << 16);
    }
    multiply(e) {
      const [t, i, s, n] = vh.temp.setValue(e)._components;
      return (
        (this._components[0] *= t),
        (this._components[1] *= i),
        (this._components[2] *= s),
        (this._components[3] *= n),
        this.refreshInt(),
        (this._value = null),
        this
      );
    }
    premultiply(e, t = !0) {
      return (
        t &&
          ((this._components[0] *= e),
          (this._components[1] *= e),
          (this._components[2] *= e)),
        (this._components[3] = e),
        this.refreshInt(),
        (this._value = null),
        this
      );
    }
    toPremultiplied(e, t = !0) {
      if (e === 1) return (255 << 24) + this._int;
      if (e === 0) return t ? 0 : this._int;
      let i = (this._int >> 16) & 255,
        s = (this._int >> 8) & 255,
        n = this._int & 255;
      return (
        t &&
          ((i = (i * e + 0.5) | 0),
          (s = (s * e + 0.5) | 0),
          (n = (n * e + 0.5) | 0)),
        ((e * 255) << 24) + (i << 16) + (s << 8) + n
      );
    }
    toHex() {
      const e = this._int.toString(16);
      return `#${"000000".substring(0, 6 - e.length) + e}`;
    }
    toHexa() {
      const e = Math.round(this._components[3] * 255).toString(16);
      return this.toHex() + "00".substring(0, 2 - e.length) + e;
    }
    setAlpha(e) {
      return (this._components[3] = this._clamp(e)), this;
    }
    round(e) {
      const [t, i, s] = this._components;
      return (
        (this._components[0] = Math.round(t * e) / e),
        (this._components[1] = Math.round(i * e) / e),
        (this._components[2] = Math.round(s * e) / e),
        this.refreshInt(),
        (this._value = null),
        this
      );
    }
    toArray(e) {
      e = e ?? [];
      const [t, i, s, n] = this._components;
      return (e[0] = t), (e[1] = i), (e[2] = s), (e[3] = n), e;
    }
    normalize(e) {
      let t, i, s, n;
      if (
        (typeof e == "number" || e instanceof Number) &&
        e >= 0 &&
        e <= 16777215
      ) {
        const a = e;
        (t = ((a >> 16) & 255) / 255),
          (i = ((a >> 8) & 255) / 255),
          (s = (a & 255) / 255),
          (n = 1);
      } else if (
        (Array.isArray(e) || e instanceof Float32Array) &&
        e.length >= 3 &&
        e.length <= 4
      )
        (e = this._clamp(e)), ([t, i, s, n = 1] = e);
      else if (
        (e instanceof Uint8Array || e instanceof Uint8ClampedArray) &&
        e.length >= 3 &&
        e.length <= 4
      )
        (e = this._clamp(e, 0, 255)),
          ([t, i, s, n = 255] = e),
          (t /= 255),
          (i /= 255),
          (s /= 255),
          (n /= 255);
      else if (typeof e == "string" || typeof e == "object") {
        if (typeof e == "string") {
          const o = vh.HEX_PATTERN.exec(e);
          o && (e = `#${o[2]}`);
        }
        const a = Ei(e);
        a.isValid() &&
          (({ r: t, g: i, b: s, a: n } = a.rgba),
          (t /= 255),
          (i /= 255),
          (s /= 255));
      }
      if (t !== void 0)
        (this._components[0] = t),
          (this._components[1] = i),
          (this._components[2] = s),
          (this._components[3] = n),
          this.refreshInt();
      else throw new Error(`Unable to convert color ${e}`);
    }
    refreshInt() {
      this._clamp(this._components);
      const [e, t, i] = this._components;
      this._int = ((e * 255) << 16) + ((t * 255) << 8) + ((i * 255) | 0);
    }
    _clamp(e, t = 0, i = 1) {
      return typeof e == "number"
        ? Math.min(Math.max(e, t), i)
        : (e.forEach((s, n) => {
            e[n] = Math.min(Math.max(s, t), i);
          }),
          e);
    }
  };
  (ra.shared = new ra()),
    (ra.temp = new ra()),
    (ra.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i);
  let lt = ra;
  function lN(r) {
    return (
      We("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead"),
      lt.shared.setValue(r).toHex()
    );
  }
  function hN(r) {
    return (
      We("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead"),
      lt.shared.setValue(r).toNumber()
    );
  }
  function cN() {
    const r = [],
      e = [];
    for (let i = 0; i < 32; i++) (r[i] = i), (e[i] = i);
    (r[Be.NORMAL_NPM] = Be.NORMAL),
      (r[Be.ADD_NPM] = Be.ADD),
      (r[Be.SCREEN_NPM] = Be.SCREEN),
      (e[Be.NORMAL] = Be.NORMAL_NPM),
      (e[Be.ADD] = Be.ADD_NPM),
      (e[Be.SCREEN] = Be.SCREEN_NPM);
    const t = [];
    return t.push(e), t.push(r), t;
  }
  const P1 = cN();
  function R1(r, e) {
    return P1[e ? 1 : 0][r];
  }
  function uN(r, e = null) {
    const t = r * 6;
    if (((e = e || new Uint16Array(t)), e.length !== t))
      throw new Error(
        `Out buffer length is incorrect, got ${e.length} and expected ${t}`
      );
    for (let i = 0, s = 0; i < t; i += 6, s += 4)
      (e[i + 0] = s + 0),
        (e[i + 1] = s + 1),
        (e[i + 2] = s + 2),
        (e[i + 3] = s + 0),
        (e[i + 4] = s + 2),
        (e[i + 5] = s + 3);
    return e;
  }
  function M1(r) {
    if (r.BYTES_PER_ELEMENT === 4)
      return r instanceof Float32Array
        ? "Float32Array"
        : r instanceof Uint32Array
        ? "Uint32Array"
        : "Int32Array";
    if (r.BYTES_PER_ELEMENT === 2) {
      if (r instanceof Uint16Array) return "Uint16Array";
    } else if (r.BYTES_PER_ELEMENT === 1 && r instanceof Uint8Array)
      return "Uint8Array";
    return null;
  }
  function Hh(r) {
    return (
      (r += r === 0 ? 1 : 0),
      --r,
      (r |= r >>> 1),
      (r |= r >>> 2),
      (r |= r >>> 4),
      (r |= r >>> 8),
      (r |= r >>> 16),
      r + 1
    );
  }
  function bv(r) {
    return !(r & (r - 1)) && !!r;
  }
  function xv(r) {
    let e = (r > 65535 ? 1 : 0) << 4;
    r >>>= e;
    let t = (r > 255 ? 1 : 0) << 3;
    return (
      (r >>>= t),
      (e |= t),
      (t = (r > 15 ? 1 : 0) << 2),
      (r >>>= t),
      (e |= t),
      (t = (r > 3 ? 1 : 0) << 1),
      (r >>>= t),
      (e |= t),
      e | (r >> 1)
    );
  }
  function Sa(r, e, t) {
    const i = r.length;
    let s;
    if (e >= i || t === 0) return;
    t = e + t > i ? i - e : t;
    const n = i - t;
    for (s = e; s < n; ++s) r[s] = r[s + t];
    r.length = n;
  }
  function Gs(r) {
    return r === 0 ? 0 : r < 0 ? -1 : 1;
  }
  let dN = 0;
  function Dn() {
    return ++dN;
  }
  const tf = class {
    constructor(r, e, t, i) {
      (this.left = r), (this.top = e), (this.right = t), (this.bottom = i);
    }
    get width() {
      return this.right - this.left;
    }
    get height() {
      return this.bottom - this.top;
    }
    isEmpty() {
      return this.left === this.right || this.top === this.bottom;
    }
  };
  tf.EMPTY = new tf(0, 0, 0, 0);
  let _v = tf;
  const wv = {},
    Si = Object.create(null),
    As = Object.create(null);
  class fN {
    constructor(e, t, i) {
      (this._canvas = we.ADAPTER.createCanvas()),
        (this._context = this._canvas.getContext("2d")),
        (this.resolution = i || we.RESOLUTION),
        this.resize(e, t);
    }
    clear() {
      this._checkDestroyed(),
        this._context.setTransform(1, 0, 0, 1, 0, 0),
        this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
    }
    resize(e, t) {
      this._checkDestroyed(),
        (this._canvas.width = Math.round(e * this.resolution)),
        (this._canvas.height = Math.round(t * this.resolution));
    }
    destroy() {
      (this._context = null), (this._canvas = null);
    }
    get width() {
      return this._checkDestroyed(), this._canvas.width;
    }
    set width(e) {
      this._checkDestroyed(), (this._canvas.width = Math.round(e));
    }
    get height() {
      return this._checkDestroyed(), this._canvas.height;
    }
    set height(e) {
      this._checkDestroyed(), (this._canvas.height = Math.round(e));
    }
    get canvas() {
      return this._checkDestroyed(), this._canvas;
    }
    get context() {
      return this._checkDestroyed(), this._context;
    }
    _checkDestroyed() {
      if (this._canvas === null)
        throw new TypeError(
          "The CanvasRenderTarget has already been destroyed"
        );
    }
  }
  function Tv(r, e, t) {
    for (let i = 0, s = 4 * t * e; i < e; ++i, s += 4)
      if (r[s + 3] !== 0) return !1;
    return !0;
  }
  function Ev(r, e, t, i, s) {
    const n = 4 * e;
    for (let a = i, o = i * n + 4 * t; a <= s; ++a, o += n)
      if (r[o + 3] !== 0) return !1;
    return !0;
  }
  function pN(r) {
    const { width: e, height: t } = r,
      i = r.getContext("2d", { willReadFrequently: !0 });
    if (i === null) throw new TypeError("Failed to get canvas 2D context");
    const s = i.getImageData(0, 0, e, t).data;
    let n = 0,
      a = 0,
      o = e - 1,
      l = t - 1;
    for (; a < t && Tv(s, e, a); ) ++a;
    if (a === t) return _v.EMPTY;
    for (; Tv(s, e, l); ) --l;
    for (; Ev(s, e, n, a, l); ) ++n;
    for (; Ev(s, e, o, a, l); ) --o;
    return ++o, ++l, new _v(n, a, o, l);
  }
  function mN(r) {
    const e = pN(r),
      { width: t, height: i } = e;
    let s = null;
    if (!e.isEmpty()) {
      const n = r.getContext("2d");
      if (n === null) throw new TypeError("Failed to get canvas 2D context");
      s = n.getImageData(e.left, e.top, t, i);
    }
    return { width: t, height: i, data: s };
  }
  function gN(r, e = globalThis.location) {
    if (r.startsWith("data:")) return "";
    e = e || globalThis.location;
    const t = new URL(r, document.baseURI);
    return t.hostname !== e.hostname ||
      t.port !== e.port ||
      t.protocol !== e.protocol
      ? "anonymous"
      : "";
  }
  function vs(r, e = 1) {
    var i;
    const t = (i = we.RETINA_PREFIX) == null ? void 0 : i.exec(r);
    return t ? parseFloat(t[1]) : e;
  }
  var me = ((r) => (
    (r.Renderer = "renderer"),
    (r.Application = "application"),
    (r.RendererSystem = "renderer-webgl-system"),
    (r.RendererPlugin = "renderer-webgl-plugin"),
    (r.CanvasRendererSystem = "renderer-canvas-system"),
    (r.CanvasRendererPlugin = "renderer-canvas-plugin"),
    (r.Asset = "asset"),
    (r.LoadParser = "load-parser"),
    (r.ResolveParser = "resolve-parser"),
    (r.CacheParser = "cache-parser"),
    (r.DetectionParser = "detection-parser"),
    r
  ))(me || {});
  const rf = (r) => {
      if (typeof r == "function" || (typeof r == "object" && r.extension)) {
        if (!r.extension)
          throw new Error("Extension class must have an extension object");
        r = {
          ...(typeof r.extension != "object"
            ? { type: r.extension }
            : r.extension),
          ref: r,
        };
      }
      if (typeof r == "object") r = { ...r };
      else throw new Error("Invalid extension type");
      return typeof r.type == "string" && (r.type = [r.type]), r;
    },
    Sv = (r, e) => rf(r).priority ?? e,
    Ce = {
      _addHandlers: {},
      _removeHandlers: {},
      _queue: {},
      remove(...r) {
        return (
          r.map(rf).forEach((e) => {
            e.type.forEach((t) => {
              var i, s;
              return (s = (i = this._removeHandlers)[t]) == null
                ? void 0
                : s.call(i, e);
            });
          }),
          this
        );
      },
      add(...r) {
        return (
          r.map(rf).forEach((e) => {
            e.type.forEach((t) => {
              var n, a;
              const i = this._addHandlers,
                s = this._queue;
              i[t]
                ? (n = i[t]) == null || n.call(i, e)
                : ((s[t] = s[t] || []), (a = s[t]) == null || a.push(e));
            });
          }),
          this
        );
      },
      handle(r, e, t) {
        var a;
        const i = this._addHandlers,
          s = this._removeHandlers;
        if (i[r] || s[r])
          throw new Error(`Extension type ${r} already has a handler`);
        (i[r] = e), (s[r] = t);
        const n = this._queue;
        return (
          n[r] && ((a = n[r]) == null || a.forEach((o) => e(o)), delete n[r]),
          this
        );
      },
      handleByMap(r, e) {
        return this.handle(
          r,
          (t) => {
            t.name && (e[t.name] = t.ref);
          },
          (t) => {
            t.name && delete e[t.name];
          }
        );
      },
      handleByList(r, e, t = -1) {
        return this.handle(
          r,
          (i) => {
            e.includes(i.ref) ||
              (e.push(i.ref), e.sort((s, n) => Sv(n, t) - Sv(s, t)));
          },
          (i) => {
            const s = e.indexOf(i.ref);
            s !== -1 && e.splice(s, 1);
          }
        );
      },
    };
  class sf {
    constructor(e) {
      typeof e == "number"
        ? (this.rawBinaryData = new ArrayBuffer(e))
        : e instanceof Uint8Array
        ? (this.rawBinaryData = e.buffer)
        : (this.rawBinaryData = e),
        (this.uint32View = new Uint32Array(this.rawBinaryData)),
        (this.float32View = new Float32Array(this.rawBinaryData));
    }
    get int8View() {
      return (
        this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)),
        this._int8View
      );
    }
    get uint8View() {
      return (
        this._uint8View ||
          (this._uint8View = new Uint8Array(this.rawBinaryData)),
        this._uint8View
      );
    }
    get int16View() {
      return (
        this._int16View ||
          (this._int16View = new Int16Array(this.rawBinaryData)),
        this._int16View
      );
    }
    get uint16View() {
      return (
        this._uint16View ||
          (this._uint16View = new Uint16Array(this.rawBinaryData)),
        this._uint16View
      );
    }
    get int32View() {
      return (
        this._int32View ||
          (this._int32View = new Int32Array(this.rawBinaryData)),
        this._int32View
      );
    }
    view(e) {
      return this[`${e}View`];
    }
    destroy() {
      (this.rawBinaryData = null),
        (this._int8View = null),
        (this._uint8View = null),
        (this._int16View = null),
        (this._uint16View = null),
        (this._int32View = null),
        (this.uint32View = null),
        (this.float32View = null);
    }
    static sizeOf(e) {
      switch (e) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(`${e} isn't a valid view type`);
      }
    }
  }
  const vN = [
    "precision mediump float;",
    "void main(void){",
    "float test = 0.1;",
    "%forloop%",
    "gl_FragColor = vec4(0.0);",
    "}",
  ].join(`
`);
  function yN(r) {
    let e = "";
    for (let t = 0; t < r; ++t)
      t > 0 &&
        (e += `
else `),
        t < r - 1 && (e += `if(test == ${t}.0){}`);
    return e;
  }
  function bN(r, e) {
    if (r === 0)
      throw new Error(
        "Invalid value of `0` passed to `checkMaxIfStatementsInShader`"
      );
    const t = e.createShader(e.FRAGMENT_SHADER);
    for (;;) {
      const i = vN.replace(/%forloop%/gi, yN(r));
      if (
        (e.shaderSource(t, i),
        e.compileShader(t),
        !e.getShaderParameter(t, e.COMPILE_STATUS))
      )
        r = (r / 2) | 0;
      else break;
    }
    return r;
  }
  const Vu = 0,
    $u = 1,
    Gu = 2,
    Hu = 3,
    Xu = 4,
    zu = 5;
  class ji {
    constructor() {
      (this.data = 0),
        (this.blendMode = Be.NORMAL),
        (this.polygonOffset = 0),
        (this.blend = !0),
        (this.depthMask = !0);
    }
    get blend() {
      return !!(this.data & (1 << Vu));
    }
    set blend(e) {
      !!(this.data & (1 << Vu)) !== e && (this.data ^= 1 << Vu);
    }
    get offsets() {
      return !!(this.data & (1 << $u));
    }
    set offsets(e) {
      !!(this.data & (1 << $u)) !== e && (this.data ^= 1 << $u);
    }
    get culling() {
      return !!(this.data & (1 << Gu));
    }
    set culling(e) {
      !!(this.data & (1 << Gu)) !== e && (this.data ^= 1 << Gu);
    }
    get depthTest() {
      return !!(this.data & (1 << Hu));
    }
    set depthTest(e) {
      !!(this.data & (1 << Hu)) !== e && (this.data ^= 1 << Hu);
    }
    get depthMask() {
      return !!(this.data & (1 << zu));
    }
    set depthMask(e) {
      !!(this.data & (1 << zu)) !== e && (this.data ^= 1 << zu);
    }
    get clockwiseFrontFace() {
      return !!(this.data & (1 << Xu));
    }
    set clockwiseFrontFace(e) {
      !!(this.data & (1 << Xu)) !== e && (this.data ^= 1 << Xu);
    }
    get blendMode() {
      return this._blendMode;
    }
    set blendMode(e) {
      (this.blend = e !== Be.NONE), (this._blendMode = e);
    }
    get polygonOffset() {
      return this._polygonOffset;
    }
    set polygonOffset(e) {
      (this.offsets = !!e), (this._polygonOffset = e);
    }
    static for2d() {
      const e = new ji();
      return (e.depthTest = !1), (e.blend = !0), e;
    }
  }
  ji.prototype.toString = function () {
    return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
  };
  const nf = [];
  function F1(r, e) {
    if (!r) return null;
    let t = "";
    if (typeof r == "string") {
      const i = /\.(\w{3,4})(?:$|\?|#)/i.exec(r);
      i && (t = i[1].toLowerCase());
    }
    for (let i = nf.length - 1; i >= 0; --i) {
      const s = nf[i];
      if (s.test && s.test(r, t)) return new s(r, e);
    }
    throw new Error("Unrecognized source type to auto-detect Resource");
  }
  class ui {
    constructor(e) {
      (this.items = []), (this._name = e), (this._aliasCount = 0);
    }
    emit(e, t, i, s, n, a, o, l) {
      if (arguments.length > 8) throw new Error("max arguments reached");
      const { name: h, items: c } = this;
      this._aliasCount++;
      for (let u = 0, d = c.length; u < d; u++) c[u][h](e, t, i, s, n, a, o, l);
      return c === this.items && this._aliasCount--, this;
    }
    ensureNonAliasedItems() {
      this._aliasCount > 0 &&
        this.items.length > 1 &&
        ((this._aliasCount = 0), (this.items = this.items.slice(0)));
    }
    add(e) {
      return (
        e[this._name] &&
          (this.ensureNonAliasedItems(), this.remove(e), this.items.push(e)),
        this
      );
    }
    remove(e) {
      const t = this.items.indexOf(e);
      return (
        t !== -1 && (this.ensureNonAliasedItems(), this.items.splice(t, 1)),
        this
      );
    }
    contains(e) {
      return this.items.includes(e);
    }
    removeAll() {
      return this.ensureNonAliasedItems(), (this.items.length = 0), this;
    }
    destroy() {
      this.removeAll(), (this.items.length = 0), (this._name = "");
    }
    get empty() {
      return this.items.length === 0;
    }
    get name() {
      return this._name;
    }
  }
  Object.defineProperties(ui.prototype, {
    dispatch: { value: ui.prototype.emit },
    run: { value: ui.prototype.emit },
  });
  class rl {
    constructor(e = 0, t = 0) {
      (this._width = e),
        (this._height = t),
        (this.destroyed = !1),
        (this.internal = !1),
        (this.onResize = new ui("setRealSize")),
        (this.onUpdate = new ui("update")),
        (this.onError = new ui("onError"));
    }
    bind(e) {
      this.onResize.add(e),
        this.onUpdate.add(e),
        this.onError.add(e),
        (this._width || this._height) &&
          this.onResize.emit(this._width, this._height);
    }
    unbind(e) {
      this.onResize.remove(e), this.onUpdate.remove(e), this.onError.remove(e);
    }
    resize(e, t) {
      (e !== this._width || t !== this._height) &&
        ((this._width = e), (this._height = t), this.onResize.emit(e, t));
    }
    get valid() {
      return !!this._width && !!this._height;
    }
    update() {
      this.destroyed || this.onUpdate.emit();
    }
    load() {
      return Promise.resolve(this);
    }
    get width() {
      return this._width;
    }
    get height() {
      return this._height;
    }
    style(e, t, i) {
      return !1;
    }
    dispose() {}
    destroy() {
      this.destroyed ||
        ((this.destroyed = !0),
        this.dispose(),
        this.onError.removeAll(),
        (this.onError = null),
        this.onResize.removeAll(),
        (this.onResize = null),
        this.onUpdate.removeAll(),
        (this.onUpdate = null));
    }
    static test(e, t) {
      return !1;
    }
  }
  class Nc extends rl {
    constructor(e, t) {
      const { width: i, height: s } = t || {};
      if (!i || !s) throw new Error("BufferResource width or height invalid");
      super(i, s),
        (this.data = e),
        (this.unpackAlignment = t.unpackAlignment ?? 4);
    }
    upload(e, t, i) {
      const s = e.gl;
      s.pixelStorei(s.UNPACK_ALIGNMENT, this.unpackAlignment),
        s.pixelStorei(
          s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
          t.alphaMode === sr.UNPACK
        );
      const n = t.realWidth,
        a = t.realHeight;
      return (
        i.width === n && i.height === a
          ? s.texSubImage2D(
              t.target,
              0,
              0,
              0,
              n,
              a,
              t.format,
              i.type,
              this.data
            )
          : ((i.width = n),
            (i.height = a),
            s.texImage2D(
              t.target,
              0,
              i.internalFormat,
              n,
              a,
              0,
              t.format,
              i.type,
              this.data
            )),
        !0
      );
    }
    dispose() {
      this.data = null;
    }
    static test(e) {
      return (
        e === null ||
        e instanceof Int8Array ||
        e instanceof Uint8Array ||
        e instanceof Uint8ClampedArray ||
        e instanceof Int16Array ||
        e instanceof Uint16Array ||
        e instanceof Int32Array ||
        e instanceof Uint32Array ||
        e instanceof Float32Array
      );
    }
  }
  const xN = { scaleMode: ai.NEAREST, alphaMode: sr.NPM },
    af = class ia extends gl {
      constructor(e = null, t = null) {
        super(), (t = Object.assign({}, ia.defaultOptions, t));
        const {
          alphaMode: i,
          mipmap: s,
          anisotropicLevel: n,
          scaleMode: a,
          width: o,
          height: l,
          wrapMode: h,
          format: c,
          type: u,
          target: d,
          resolution: f,
          resourceOptions: p,
        } = t;
        e && !(e instanceof rl) && ((e = F1(e, p)), (e.internal = !0)),
          (this.resolution = f || we.RESOLUTION),
          (this.width =
            Math.round((o || 0) * this.resolution) / this.resolution),
          (this.height =
            Math.round((l || 0) * this.resolution) / this.resolution),
          (this._mipmap = s),
          (this.anisotropicLevel = n),
          (this._wrapMode = h),
          (this._scaleMode = a),
          (this.format = c),
          (this.type = u),
          (this.target = d),
          (this.alphaMode = i),
          (this.uid = Dn()),
          (this.touched = 0),
          (this.isPowerOfTwo = !1),
          this._refreshPOT(),
          (this._glTextures = {}),
          (this.dirtyId = 0),
          (this.dirtyStyleId = 0),
          (this.cacheId = null),
          (this.valid = o > 0 && l > 0),
          (this.textureCacheIds = []),
          (this.destroyed = !1),
          (this.resource = null),
          (this._batchEnabled = 0),
          (this._batchLocation = 0),
          (this.parentTextureArray = null),
          this.setResource(e);
      }
      get realWidth() {
        return Math.round(this.width * this.resolution);
      }
      get realHeight() {
        return Math.round(this.height * this.resolution);
      }
      get mipmap() {
        return this._mipmap;
      }
      set mipmap(e) {
        this._mipmap !== e && ((this._mipmap = e), this.dirtyStyleId++);
      }
      get scaleMode() {
        return this._scaleMode;
      }
      set scaleMode(e) {
        this._scaleMode !== e && ((this._scaleMode = e), this.dirtyStyleId++);
      }
      get wrapMode() {
        return this._wrapMode;
      }
      set wrapMode(e) {
        this._wrapMode !== e && ((this._wrapMode = e), this.dirtyStyleId++);
      }
      setStyle(e, t) {
        let i;
        return (
          e !== void 0 &&
            e !== this.scaleMode &&
            ((this.scaleMode = e), (i = !0)),
          t !== void 0 && t !== this.mipmap && ((this.mipmap = t), (i = !0)),
          i && this.dirtyStyleId++,
          this
        );
      }
      setSize(e, t, i) {
        return (i = i || this.resolution), this.setRealSize(e * i, t * i, i);
      }
      setRealSize(e, t, i) {
        return (
          (this.resolution = i || this.resolution),
          (this.width = Math.round(e) / this.resolution),
          (this.height = Math.round(t) / this.resolution),
          this._refreshPOT(),
          this.update(),
          this
        );
      }
      _refreshPOT() {
        this.isPowerOfTwo = bv(this.realWidth) && bv(this.realHeight);
      }
      setResolution(e) {
        const t = this.resolution;
        return t === e
          ? this
          : ((this.resolution = e),
            this.valid &&
              ((this.width = Math.round(this.width * t) / e),
              (this.height = Math.round(this.height * t) / e),
              this.emit("update", this)),
            this._refreshPOT(),
            this);
      }
      setResource(e) {
        if (this.resource === e) return this;
        if (this.resource) throw new Error("Resource can be set only once");
        return e.bind(this), (this.resource = e), this;
      }
      update() {
        this.valid
          ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this))
          : this.width > 0 &&
            this.height > 0 &&
            ((this.valid = !0),
            this.emit("loaded", this),
            this.emit("update", this));
      }
      onError(e) {
        this.emit("error", this, e);
      }
      destroy() {
        this.resource &&
          (this.resource.unbind(this),
          this.resource.internal && this.resource.destroy(),
          (this.resource = null)),
          this.cacheId &&
            (delete As[this.cacheId],
            delete Si[this.cacheId],
            (this.cacheId = null)),
          (this.valid = !1),
          this.dispose(),
          ia.removeFromCache(this),
          (this.textureCacheIds = null),
          (this.destroyed = !0),
          this.emit("destroyed", this),
          this.removeAllListeners();
      }
      dispose() {
        this.emit("dispose", this);
      }
      castToBaseTexture() {
        return this;
      }
      static from(e, t, i = we.STRICT_TEXTURE_CACHE) {
        const s = typeof e == "string";
        let n = null;
        if (s) n = e;
        else {
          if (!e._pixiId) {
            const o = (t == null ? void 0 : t.pixiIdPrefix) || "pixiid";
            e._pixiId = `${o}_${Dn()}`;
          }
          n = e._pixiId;
        }
        let a = As[n];
        if (s && i && !a)
          throw new Error(
            `The cacheId "${n}" does not exist in BaseTextureCache.`
          );
        return (
          a || ((a = new ia(e, t)), (a.cacheId = n), ia.addToCache(a, n)), a
        );
      }
      static fromBuffer(e, t, i, s) {
        e = e || new Float32Array(t * i * 4);
        const n = new Nc(e, {
          width: t,
          height: i,
          ...(s == null ? void 0 : s.resourceOptions),
        });
        let a, o;
        return (
          e instanceof Float32Array
            ? ((a = le.RGBA), (o = Ae.FLOAT))
            : e instanceof Int32Array
            ? ((a = le.RGBA_INTEGER), (o = Ae.INT))
            : e instanceof Uint32Array
            ? ((a = le.RGBA_INTEGER), (o = Ae.UNSIGNED_INT))
            : e instanceof Int16Array
            ? ((a = le.RGBA_INTEGER), (o = Ae.SHORT))
            : e instanceof Uint16Array
            ? ((a = le.RGBA_INTEGER), (o = Ae.UNSIGNED_SHORT))
            : e instanceof Int8Array
            ? ((a = le.RGBA), (o = Ae.BYTE))
            : ((a = le.RGBA), (o = Ae.UNSIGNED_BYTE)),
          (n.internal = !0),
          new ia(n, Object.assign({}, xN, { type: o, format: a }, s))
        );
      }
      static addToCache(e, t) {
        t &&
          (e.textureCacheIds.includes(t) || e.textureCacheIds.push(t),
          As[t] &&
            As[t] !== e &&
            console.warn(
              `BaseTexture added to the cache with an id [${t}] that already had an entry`
            ),
          (As[t] = e));
      }
      static removeFromCache(e) {
        if (typeof e == "string") {
          const t = As[e];
          if (t) {
            const i = t.textureCacheIds.indexOf(e);
            return i > -1 && t.textureCacheIds.splice(i, 1), delete As[e], t;
          }
        } else if (e != null && e.textureCacheIds) {
          for (let t = 0; t < e.textureCacheIds.length; ++t)
            delete As[e.textureCacheIds[t]];
          return (e.textureCacheIds.length = 0), e;
        }
        return null;
      }
    };
  (af.defaultOptions = {
    mipmap: Yr.POW2,
    anisotropicLevel: 0,
    scaleMode: ai.LINEAR,
    wrapMode: ci.CLAMP,
    alphaMode: sr.UNPACK,
    target: wa.TEXTURE_2D,
    format: le.RGBA,
    type: Ae.UNSIGNED_BYTE,
  }),
    (af._globalBatch = 0);
  let Le = af;
  class of {
    constructor() {
      (this.texArray = null),
        (this.blend = 0),
        (this.type = Di.TRIANGLES),
        (this.start = 0),
        (this.size = 0),
        (this.data = null);
    }
  }
  let _N = 0;
  class gt {
    constructor(e, t = !0, i = !1) {
      (this.data = e || new Float32Array(1)),
        (this._glBuffers = {}),
        (this._updateID = 0),
        (this.index = i),
        (this.static = t),
        (this.id = _N++),
        (this.disposeRunner = new ui("disposeBuffer"));
    }
    update(e) {
      e instanceof Array && (e = new Float32Array(e)),
        (this.data = e || this.data),
        this._updateID++;
    }
    dispose() {
      this.disposeRunner.emit(this, !1);
    }
    destroy() {
      this.dispose(), (this.data = null);
    }
    set index(e) {
      this.type = e ? Gi.ELEMENT_ARRAY_BUFFER : Gi.ARRAY_BUFFER;
    }
    get index() {
      return this.type === Gi.ELEMENT_ARRAY_BUFFER;
    }
    static from(e) {
      return e instanceof Array && (e = new Float32Array(e)), new gt(e);
    }
  }
  class Xh {
    constructor(e, t = 0, i = !1, s = Ae.FLOAT, n, a, o, l = 1) {
      (this.buffer = e),
        (this.size = t),
        (this.normalized = i),
        (this.type = s),
        (this.stride = n),
        (this.start = a),
        (this.instance = o),
        (this.divisor = l);
    }
    destroy() {
      this.buffer = null;
    }
    static from(e, t, i, s, n) {
      return new Xh(e, t, i, s, n);
    }
  }
  const wN = { Float32Array, Uint32Array, Int32Array, Uint8Array };
  function TN(r, e) {
    let t = 0,
      i = 0;
    const s = {};
    for (let l = 0; l < r.length; l++) (i += e[l]), (t += r[l].length);
    const n = new ArrayBuffer(t * 4);
    let a = null,
      o = 0;
    for (let l = 0; l < r.length; l++) {
      const h = e[l],
        c = r[l],
        u = M1(c);
      s[u] || (s[u] = new wN[u](n)), (a = s[u]);
      for (let d = 0; d < c.length; d++) {
        const f = ((d / h) | 0) * i + o,
          p = d % h;
        a[f + p] = c[d];
      }
      o += h;
    }
    return new Float32Array(n);
  }
  const Av = { 5126: 4, 5123: 2, 5121: 1 };
  let EN = 0;
  const SN = { Float32Array, Uint32Array, Int32Array, Uint8Array, Uint16Array };
  class Yi {
    constructor(e = [], t = {}) {
      (this.buffers = e),
        (this.indexBuffer = null),
        (this.attributes = t),
        (this.glVertexArrayObjects = {}),
        (this.id = EN++),
        (this.instanced = !1),
        (this.instanceCount = 1),
        (this.disposeRunner = new ui("disposeGeometry")),
        (this.refCount = 0);
    }
    addAttribute(e, t, i = 0, s = !1, n, a, o, l = !1) {
      if (!t)
        throw new Error("You must pass a buffer when creating an attribute");
      t instanceof gt ||
        (t instanceof Array && (t = new Float32Array(t)), (t = new gt(t)));
      const h = e.split("|");
      if (h.length > 1) {
        for (let u = 0; u < h.length; u++) this.addAttribute(h[u], t, i, s, n);
        return this;
      }
      let c = this.buffers.indexOf(t);
      return (
        c === -1 && (this.buffers.push(t), (c = this.buffers.length - 1)),
        (this.attributes[e] = new Xh(c, i, s, n, a, o, l)),
        (this.instanced = this.instanced || l),
        this
      );
    }
    getAttribute(e) {
      return this.attributes[e];
    }
    getBuffer(e) {
      return this.buffers[this.getAttribute(e).buffer];
    }
    addIndex(e) {
      return (
        e instanceof gt ||
          (e instanceof Array && (e = new Uint16Array(e)), (e = new gt(e))),
        (e.type = Gi.ELEMENT_ARRAY_BUFFER),
        (this.indexBuffer = e),
        this.buffers.includes(e) || this.buffers.push(e),
        this
      );
    }
    getIndex() {
      return this.indexBuffer;
    }
    interleave() {
      if (
        this.buffers.length === 1 ||
        (this.buffers.length === 2 && this.indexBuffer)
      )
        return this;
      const e = [],
        t = [],
        i = new gt();
      let s;
      for (s in this.attributes) {
        const n = this.attributes[s],
          a = this.buffers[n.buffer];
        e.push(a.data), t.push((n.size * Av[n.type]) / 4), (n.buffer = 0);
      }
      for (i.data = TN(e, t), s = 0; s < this.buffers.length; s++)
        this.buffers[s] !== this.indexBuffer && this.buffers[s].destroy();
      return (
        (this.buffers = [i]),
        this.indexBuffer && this.buffers.push(this.indexBuffer),
        this
      );
    }
    getSize() {
      for (const e in this.attributes) {
        const t = this.attributes[e];
        return this.buffers[t.buffer].data.length / (t.stride / 4 || t.size);
      }
      return 0;
    }
    dispose() {
      this.disposeRunner.emit(this, !1);
    }
    destroy() {
      this.dispose(),
        (this.buffers = null),
        (this.indexBuffer = null),
        (this.attributes = null);
    }
    clone() {
      const e = new Yi();
      for (let t = 0; t < this.buffers.length; t++)
        e.buffers[t] = new gt(this.buffers[t].data.slice(0));
      for (const t in this.attributes) {
        const i = this.attributes[t];
        e.attributes[t] = new Xh(
          i.buffer,
          i.size,
          i.normalized,
          i.type,
          i.stride,
          i.start,
          i.instance
        );
      }
      return (
        this.indexBuffer &&
          ((e.indexBuffer = e.buffers[this.buffers.indexOf(this.indexBuffer)]),
          (e.indexBuffer.type = Gi.ELEMENT_ARRAY_BUFFER)),
        e
      );
    }
    static merge(e) {
      const t = new Yi(),
        i = [],
        s = [],
        n = [];
      let a;
      for (let o = 0; o < e.length; o++) {
        a = e[o];
        for (let l = 0; l < a.buffers.length; l++)
          (s[l] = s[l] || 0), (s[l] += a.buffers[l].data.length), (n[l] = 0);
      }
      for (let o = 0; o < a.buffers.length; o++)
        (i[o] = new SN[M1(a.buffers[o].data)](s[o])),
          (t.buffers[o] = new gt(i[o]));
      for (let o = 0; o < e.length; o++) {
        a = e[o];
        for (let l = 0; l < a.buffers.length; l++)
          i[l].set(a.buffers[l].data, n[l]), (n[l] += a.buffers[l].data.length);
      }
      if (((t.attributes = a.attributes), a.indexBuffer)) {
        (t.indexBuffer = t.buffers[a.buffers.indexOf(a.indexBuffer)]),
          (t.indexBuffer.type = Gi.ELEMENT_ARRAY_BUFFER);
        let o = 0,
          l = 0,
          h = 0,
          c = 0;
        for (let u = 0; u < a.buffers.length; u++)
          if (a.buffers[u] !== a.indexBuffer) {
            c = u;
            break;
          }
        for (const u in a.attributes) {
          const d = a.attributes[u];
          (d.buffer | 0) === c && (l += (d.size * Av[d.type]) / 4);
        }
        for (let u = 0; u < e.length; u++) {
          const d = e[u].indexBuffer.data;
          for (let f = 0; f < d.length; f++) t.indexBuffer.data[f + h] += o;
          (o += e[u].buffers[c].data.length / l), (h += d.length);
        }
      }
      return t;
    }
  }
  class B1 extends Yi {
    constructor(e = !1) {
      super(),
        (this._buffer = new gt(null, e, !1)),
        (this._indexBuffer = new gt(null, e, !0)),
        this.addAttribute("aVertexPosition", this._buffer, 2, !1, Ae.FLOAT)
          .addAttribute("aTextureCoord", this._buffer, 2, !1, Ae.FLOAT)
          .addAttribute("aColor", this._buffer, 4, !0, Ae.UNSIGNED_BYTE)
          .addAttribute("aTextureId", this._buffer, 1, !0, Ae.FLOAT)
          .addIndex(this._indexBuffer);
    }
  }
  const zh = Math.PI * 2,
    AN = 180 / Math.PI,
    CN = Math.PI / 180;
  var Zt = ((r) => (
    (r[(r.POLY = 0)] = "POLY"),
    (r[(r.RECT = 1)] = "RECT"),
    (r[(r.CIRC = 2)] = "CIRC"),
    (r[(r.ELIP = 3)] = "ELIP"),
    (r[(r.RREC = 4)] = "RREC"),
    r
  ))(Zt || {});
  class Je {
    constructor(e = 0, t = 0) {
      (this.x = 0), (this.y = 0), (this.x = e), (this.y = t);
    }
    clone() {
      return new Je(this.x, this.y);
    }
    copyFrom(e) {
      return this.set(e.x, e.y), this;
    }
    copyTo(e) {
      return e.set(this.x, this.y), e;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y;
    }
    set(e = 0, t = e) {
      return (this.x = e), (this.y = t), this;
    }
  }
  Je.prototype.toString = function () {
    return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
  };
  const zl = [new Je(), new Je(), new Je(), new Je()];
  class $e {
    constructor(e = 0, t = 0, i = 0, s = 0) {
      (this.x = Number(e)),
        (this.y = Number(t)),
        (this.width = Number(i)),
        (this.height = Number(s)),
        (this.type = Zt.RECT);
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
    static get EMPTY() {
      return new $e(0, 0, 0, 0);
    }
    clone() {
      return new $e(this.x, this.y, this.width, this.height);
    }
    copyFrom(e) {
      return (
        (this.x = e.x),
        (this.y = e.y),
        (this.width = e.width),
        (this.height = e.height),
        this
      );
    }
    copyTo(e) {
      return (
        (e.x = this.x),
        (e.y = this.y),
        (e.width = this.width),
        (e.height = this.height),
        e
      );
    }
    contains(e, t) {
      return this.width <= 0 || this.height <= 0
        ? !1
        : e >= this.x &&
            e < this.x + this.width &&
            t >= this.y &&
            t < this.y + this.height;
    }
    intersects(e, t) {
      if (!t) {
        const A = this.x < e.x ? e.x : this.x;
        if ((this.right > e.right ? e.right : this.right) <= A) return !1;
        const C = this.y < e.y ? e.y : this.y;
        return (this.bottom > e.bottom ? e.bottom : this.bottom) > C;
      }
      const i = this.left,
        s = this.right,
        n = this.top,
        a = this.bottom;
      if (s <= i || a <= n) return !1;
      const o = zl[0].set(e.left, e.top),
        l = zl[1].set(e.left, e.bottom),
        h = zl[2].set(e.right, e.top),
        c = zl[3].set(e.right, e.bottom);
      if (h.x <= o.x || l.y <= o.y) return !1;
      const u = Math.sign(t.a * t.d - t.b * t.c);
      if (
        u === 0 ||
        (t.apply(o, o),
        t.apply(l, l),
        t.apply(h, h),
        t.apply(c, c),
        Math.max(o.x, l.x, h.x, c.x) <= i ||
          Math.min(o.x, l.x, h.x, c.x) >= s ||
          Math.max(o.y, l.y, h.y, c.y) <= n ||
          Math.min(o.y, l.y, h.y, c.y) >= a)
      )
        return !1;
      const d = u * (l.y - o.y),
        f = u * (o.x - l.x),
        p = d * i + f * n,
        m = d * s + f * n,
        v = d * i + f * a,
        g = d * s + f * a;
      if (
        Math.max(p, m, v, g) <= d * o.x + f * o.y ||
        Math.min(p, m, v, g) >= d * c.x + f * c.y
      )
        return !1;
      const x = u * (o.y - h.y),
        b = u * (h.x - o.x),
        y = x * i + b * n,
        _ = x * s + b * n,
        w = x * i + b * a,
        E = x * s + b * a;
      return !(
        Math.max(y, _, w, E) <= x * o.x + b * o.y ||
        Math.min(y, _, w, E) >= x * c.x + b * c.y
      );
    }
    pad(e = 0, t = e) {
      return (
        (this.x -= e),
        (this.y -= t),
        (this.width += e * 2),
        (this.height += t * 2),
        this
      );
    }
    fit(e) {
      const t = Math.max(this.x, e.x),
        i = Math.min(this.x + this.width, e.x + e.width),
        s = Math.max(this.y, e.y),
        n = Math.min(this.y + this.height, e.y + e.height);
      return (
        (this.x = t),
        (this.width = Math.max(i - t, 0)),
        (this.y = s),
        (this.height = Math.max(n - s, 0)),
        this
      );
    }
    ceil(e = 1, t = 0.001) {
      const i = Math.ceil((this.x + this.width - t) * e) / e,
        s = Math.ceil((this.y + this.height - t) * e) / e;
      return (
        (this.x = Math.floor((this.x + t) * e) / e),
        (this.y = Math.floor((this.y + t) * e) / e),
        (this.width = i - this.x),
        (this.height = s - this.y),
        this
      );
    }
    enlarge(e) {
      const t = Math.min(this.x, e.x),
        i = Math.max(this.x + this.width, e.x + e.width),
        s = Math.min(this.y, e.y),
        n = Math.max(this.y + this.height, e.y + e.height);
      return (
        (this.x = t),
        (this.width = i - t),
        (this.y = s),
        (this.height = n - s),
        this
      );
    }
  }
  $e.prototype.toString = function () {
    return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  };
  class Uc {
    constructor(e = 0, t = 0, i = 0) {
      (this.x = e), (this.y = t), (this.radius = i), (this.type = Zt.CIRC);
    }
    clone() {
      return new Uc(this.x, this.y, this.radius);
    }
    contains(e, t) {
      if (this.radius <= 0) return !1;
      const i = this.radius * this.radius;
      let s = this.x - e,
        n = this.y - t;
      return (s *= s), (n *= n), s + n <= i;
    }
    getBounds() {
      return new $e(
        this.x - this.radius,
        this.y - this.radius,
        this.radius * 2,
        this.radius * 2
      );
    }
  }
  Uc.prototype.toString = function () {
    return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  };
  class Vc {
    constructor(e = 0, t = 0, i = 0, s = 0) {
      (this.x = e),
        (this.y = t),
        (this.width = i),
        (this.height = s),
        (this.type = Zt.ELIP);
    }
    clone() {
      return new Vc(this.x, this.y, this.width, this.height);
    }
    contains(e, t) {
      if (this.width <= 0 || this.height <= 0) return !1;
      let i = (e - this.x) / this.width,
        s = (t - this.y) / this.height;
      return (i *= i), (s *= s), i + s <= 1;
    }
    getBounds() {
      return new $e(
        this.x - this.width,
        this.y - this.height,
        this.width,
        this.height
      );
    }
  }
  Vc.prototype.toString = function () {
    return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  };
  class Sn {
    constructor(...e) {
      let t = Array.isArray(e[0]) ? e[0] : e;
      if (typeof t[0] != "number") {
        const i = [];
        for (let s = 0, n = t.length; s < n; s++) i.push(t[s].x, t[s].y);
        t = i;
      }
      (this.points = t), (this.type = Zt.POLY), (this.closeStroke = !0);
    }
    clone() {
      const e = this.points.slice(),
        t = new Sn(e);
      return (t.closeStroke = this.closeStroke), t;
    }
    contains(e, t) {
      let i = !1;
      const s = this.points.length / 2;
      for (let n = 0, a = s - 1; n < s; a = n++) {
        const o = this.points[n * 2],
          l = this.points[n * 2 + 1],
          h = this.points[a * 2],
          c = this.points[a * 2 + 1];
        l > t != c > t && e < (h - o) * ((t - l) / (c - l)) + o && (i = !i);
      }
      return i;
    }
  }
  Sn.prototype.toString = function () {
    return `[@pixi/math:PolygoncloseStroke=${
      this.closeStroke
    }points=${this.points.reduce((r, e) => `${r}, ${e}`, "")}]`;
  };
  class $c {
    constructor(e = 0, t = 0, i = 0, s = 0, n = 20) {
      (this.x = e),
        (this.y = t),
        (this.width = i),
        (this.height = s),
        (this.radius = n),
        (this.type = Zt.RREC);
    }
    clone() {
      return new $c(this.x, this.y, this.width, this.height, this.radius);
    }
    contains(e, t) {
      if (this.width <= 0 || this.height <= 0) return !1;
      if (
        e >= this.x &&
        e <= this.x + this.width &&
        t >= this.y &&
        t <= this.y + this.height
      ) {
        const i = Math.max(
          0,
          Math.min(this.radius, Math.min(this.width, this.height) / 2)
        );
        if (
          (t >= this.y + i && t <= this.y + this.height - i) ||
          (e >= this.x + i && e <= this.x + this.width - i)
        )
          return !0;
        let s = e - (this.x + i),
          n = t - (this.y + i);
        const a = i * i;
        if (
          s * s + n * n <= a ||
          ((s = e - (this.x + this.width - i)), s * s + n * n <= a) ||
          ((n = t - (this.y + this.height - i)), s * s + n * n <= a) ||
          ((s = e - (this.x + i)), s * s + n * n <= a)
        )
          return !0;
      }
      return !1;
    }
  }
  $c.prototype.toString = function () {
    return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  };
  class vt {
    constructor(e = 1, t = 0, i = 0, s = 1, n = 0, a = 0) {
      (this.array = null),
        (this.a = e),
        (this.b = t),
        (this.c = i),
        (this.d = s),
        (this.tx = n),
        (this.ty = a);
    }
    fromArray(e) {
      (this.a = e[0]),
        (this.b = e[1]),
        (this.c = e[3]),
        (this.d = e[4]),
        (this.tx = e[2]),
        (this.ty = e[5]);
    }
    set(e, t, i, s, n, a) {
      return (
        (this.a = e),
        (this.b = t),
        (this.c = i),
        (this.d = s),
        (this.tx = n),
        (this.ty = a),
        this
      );
    }
    toArray(e, t) {
      this.array || (this.array = new Float32Array(9));
      const i = t || this.array;
      return (
        e
          ? ((i[0] = this.a),
            (i[1] = this.b),
            (i[2] = 0),
            (i[3] = this.c),
            (i[4] = this.d),
            (i[5] = 0),
            (i[6] = this.tx),
            (i[7] = this.ty),
            (i[8] = 1))
          : ((i[0] = this.a),
            (i[1] = this.c),
            (i[2] = this.tx),
            (i[3] = this.b),
            (i[4] = this.d),
            (i[5] = this.ty),
            (i[6] = 0),
            (i[7] = 0),
            (i[8] = 1)),
        i
      );
    }
    apply(e, t) {
      t = t || new Je();
      const i = e.x,
        s = e.y;
      return (
        (t.x = this.a * i + this.c * s + this.tx),
        (t.y = this.b * i + this.d * s + this.ty),
        t
      );
    }
    applyInverse(e, t) {
      t = t || new Je();
      const i = 1 / (this.a * this.d + this.c * -this.b),
        s = e.x,
        n = e.y;
      return (
        (t.x =
          this.d * i * s +
          -this.c * i * n +
          (this.ty * this.c - this.tx * this.d) * i),
        (t.y =
          this.a * i * n +
          -this.b * i * s +
          (-this.ty * this.a + this.tx * this.b) * i),
        t
      );
    }
    translate(e, t) {
      return (this.tx += e), (this.ty += t), this;
    }
    scale(e, t) {
      return (
        (this.a *= e),
        (this.d *= t),
        (this.c *= e),
        (this.b *= t),
        (this.tx *= e),
        (this.ty *= t),
        this
      );
    }
    rotate(e) {
      const t = Math.cos(e),
        i = Math.sin(e),
        s = this.a,
        n = this.c,
        a = this.tx;
      return (
        (this.a = s * t - this.b * i),
        (this.b = s * i + this.b * t),
        (this.c = n * t - this.d * i),
        (this.d = n * i + this.d * t),
        (this.tx = a * t - this.ty * i),
        (this.ty = a * i + this.ty * t),
        this
      );
    }
    append(e) {
      const t = this.a,
        i = this.b,
        s = this.c,
        n = this.d;
      return (
        (this.a = e.a * t + e.b * s),
        (this.b = e.a * i + e.b * n),
        (this.c = e.c * t + e.d * s),
        (this.d = e.c * i + e.d * n),
        (this.tx = e.tx * t + e.ty * s + this.tx),
        (this.ty = e.tx * i + e.ty * n + this.ty),
        this
      );
    }
    setTransform(e, t, i, s, n, a, o, l, h) {
      return (
        (this.a = Math.cos(o + h) * n),
        (this.b = Math.sin(o + h) * n),
        (this.c = -Math.sin(o - l) * a),
        (this.d = Math.cos(o - l) * a),
        (this.tx = e - (i * this.a + s * this.c)),
        (this.ty = t - (i * this.b + s * this.d)),
        this
      );
    }
    prepend(e) {
      const t = this.tx;
      if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
        const i = this.a,
          s = this.c;
        (this.a = i * e.a + this.b * e.c),
          (this.b = i * e.b + this.b * e.d),
          (this.c = s * e.a + this.d * e.c),
          (this.d = s * e.b + this.d * e.d);
      }
      return (
        (this.tx = t * e.a + this.ty * e.c + e.tx),
        (this.ty = t * e.b + this.ty * e.d + e.ty),
        this
      );
    }
    decompose(e) {
      const t = this.a,
        i = this.b,
        s = this.c,
        n = this.d,
        a = e.pivot,
        o = -Math.atan2(-s, n),
        l = Math.atan2(i, t),
        h = Math.abs(o + l);
      return (
        h < 1e-5 || Math.abs(zh - h) < 1e-5
          ? ((e.rotation = l), (e.skew.x = e.skew.y = 0))
          : ((e.rotation = 0), (e.skew.x = o), (e.skew.y = l)),
        (e.scale.x = Math.sqrt(t * t + i * i)),
        (e.scale.y = Math.sqrt(s * s + n * n)),
        (e.position.x = this.tx + (a.x * t + a.y * s)),
        (e.position.y = this.ty + (a.x * i + a.y * n)),
        e
      );
    }
    invert() {
      const e = this.a,
        t = this.b,
        i = this.c,
        s = this.d,
        n = this.tx,
        a = e * s - t * i;
      return (
        (this.a = s / a),
        (this.b = -t / a),
        (this.c = -i / a),
        (this.d = e / a),
        (this.tx = (i * this.ty - s * n) / a),
        (this.ty = -(e * this.ty - t * n) / a),
        this
      );
    }
    identity() {
      return (
        (this.a = 1),
        (this.b = 0),
        (this.c = 0),
        (this.d = 1),
        (this.tx = 0),
        (this.ty = 0),
        this
      );
    }
    clone() {
      const e = new vt();
      return (
        (e.a = this.a),
        (e.b = this.b),
        (e.c = this.c),
        (e.d = this.d),
        (e.tx = this.tx),
        (e.ty = this.ty),
        e
      );
    }
    copyTo(e) {
      return (
        (e.a = this.a),
        (e.b = this.b),
        (e.c = this.c),
        (e.d = this.d),
        (e.tx = this.tx),
        (e.ty = this.ty),
        e
      );
    }
    copyFrom(e) {
      return (
        (this.a = e.a),
        (this.b = e.b),
        (this.c = e.c),
        (this.d = e.d),
        (this.tx = e.tx),
        (this.ty = e.ty),
        this
      );
    }
    static get IDENTITY() {
      return new vt();
    }
    static get TEMP_MATRIX() {
      return new vt();
    }
  }
  vt.prototype.toString = function () {
    return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  };
  const cn = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
    un = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
    dn = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
    fn = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
    lf = [],
    O1 = [],
    Wl = Math.sign;
  function IN() {
    for (let r = 0; r < 16; r++) {
      const e = [];
      lf.push(e);
      for (let t = 0; t < 16; t++) {
        const i = Wl(cn[r] * cn[t] + dn[r] * un[t]),
          s = Wl(un[r] * cn[t] + fn[r] * un[t]),
          n = Wl(cn[r] * dn[t] + dn[r] * fn[t]),
          a = Wl(un[r] * dn[t] + fn[r] * fn[t]);
        for (let o = 0; o < 16; o++)
          if (cn[o] === i && un[o] === s && dn[o] === n && fn[o] === a) {
            e.push(o);
            break;
          }
      }
    }
    for (let r = 0; r < 16; r++) {
      const e = new vt();
      e.set(cn[r], un[r], dn[r], fn[r], 0, 0), O1.push(e);
    }
  }
  IN();
  const wt = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: (r) => cn[r],
    uY: (r) => un[r],
    vX: (r) => dn[r],
    vY: (r) => fn[r],
    inv: (r) => (r & 8 ? r & 15 : -r & 7),
    add: (r, e) => lf[r][e],
    sub: (r, e) => lf[r][wt.inv(e)],
    rotate180: (r) => r ^ 4,
    isVertical: (r) => (r & 3) === 2,
    byDirection: (r, e) =>
      Math.abs(r) * 2 <= Math.abs(e)
        ? e >= 0
          ? wt.S
          : wt.N
        : Math.abs(e) * 2 <= Math.abs(r)
        ? r > 0
          ? wt.E
          : wt.W
        : e > 0
        ? r > 0
          ? wt.SE
          : wt.SW
        : r > 0
        ? wt.NE
        : wt.NW,
    matrixAppendRotationInv: (r, e, t = 0, i = 0) => {
      const s = O1[wt.inv(e)];
      (s.tx = t), (s.ty = i), r.append(s);
    },
  };
  class us {
    constructor(e, t, i = 0, s = 0) {
      (this._x = i), (this._y = s), (this.cb = e), (this.scope = t);
    }
    clone(e = this.cb, t = this.scope) {
      return new us(e, t, this._x, this._y);
    }
    set(e = 0, t = e) {
      return (
        (this._x !== e || this._y !== t) &&
          ((this._x = e), (this._y = t), this.cb.call(this.scope)),
        this
      );
    }
    copyFrom(e) {
      return (
        (this._x !== e.x || this._y !== e.y) &&
          ((this._x = e.x), (this._y = e.y), this.cb.call(this.scope)),
        this
      );
    }
    copyTo(e) {
      return e.set(this._x, this._y), e;
    }
    equals(e) {
      return e.x === this._x && e.y === this._y;
    }
    get x() {
      return this._x;
    }
    set x(e) {
      this._x !== e && ((this._x = e), this.cb.call(this.scope));
    }
    get y() {
      return this._y;
    }
    set y(e) {
      this._y !== e && ((this._y = e), this.cb.call(this.scope));
    }
  }
  us.prototype.toString = function () {
    return `[@pixi/math:ObservablePoint x=${this.x} y=${this.y} scope=${this.scope}]`;
  };
  const hf = class {
    constructor() {
      (this.worldTransform = new vt()),
        (this.localTransform = new vt()),
        (this.position = new us(this.onChange, this, 0, 0)),
        (this.scale = new us(this.onChange, this, 1, 1)),
        (this.pivot = new us(this.onChange, this, 0, 0)),
        (this.skew = new us(this.updateSkew, this, 0, 0)),
        (this._rotation = 0),
        (this._cx = 1),
        (this._sx = 0),
        (this._cy = 0),
        (this._sy = 1),
        (this._localID = 0),
        (this._currentLocalID = 0),
        (this._worldID = 0),
        (this._parentID = 0);
    }
    onChange() {
      this._localID++;
    }
    updateSkew() {
      (this._cx = Math.cos(this._rotation + this.skew.y)),
        (this._sx = Math.sin(this._rotation + this.skew.y)),
        (this._cy = -Math.sin(this._rotation - this.skew.x)),
        (this._sy = Math.cos(this._rotation - this.skew.x)),
        this._localID++;
    }
    updateLocalTransform() {
      const r = this.localTransform;
      this._localID !== this._currentLocalID &&
        ((r.a = this._cx * this.scale.x),
        (r.b = this._sx * this.scale.x),
        (r.c = this._cy * this.scale.y),
        (r.d = this._sy * this.scale.y),
        (r.tx = this.position.x - (this.pivot.x * r.a + this.pivot.y * r.c)),
        (r.ty = this.position.y - (this.pivot.x * r.b + this.pivot.y * r.d)),
        (this._currentLocalID = this._localID),
        (this._parentID = -1));
    }
    updateTransform(r) {
      const e = this.localTransform;
      if (
        (this._localID !== this._currentLocalID &&
          ((e.a = this._cx * this.scale.x),
          (e.b = this._sx * this.scale.x),
          (e.c = this._cy * this.scale.y),
          (e.d = this._sy * this.scale.y),
          (e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c)),
          (e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d)),
          (this._currentLocalID = this._localID),
          (this._parentID = -1)),
        this._parentID !== r._worldID)
      ) {
        const t = r.worldTransform,
          i = this.worldTransform;
        (i.a = e.a * t.a + e.b * t.c),
          (i.b = e.a * t.b + e.b * t.d),
          (i.c = e.c * t.a + e.d * t.c),
          (i.d = e.c * t.b + e.d * t.d),
          (i.tx = e.tx * t.a + e.ty * t.c + t.tx),
          (i.ty = e.tx * t.b + e.ty * t.d + t.ty),
          (this._parentID = r._worldID),
          this._worldID++;
      }
    }
    setFromMatrix(r) {
      r.decompose(this), this._localID++;
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(r) {
      this._rotation !== r && ((this._rotation = r), this.updateSkew());
    }
  };
  hf.IDENTITY = new hf();
  let rm = hf;
  rm.prototype.toString = function () {
    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
  };
  var PN = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`,
    RN = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`;
  function Cv(r, e, t) {
    const i = r.createShader(e);
    return r.shaderSource(i, t), r.compileShader(i), i;
  }
  function Wu(r) {
    const e = new Array(r);
    for (let t = 0; t < e.length; t++) e[t] = !1;
    return e;
  }
  function k1(r, e) {
    switch (r) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * e);
      case "vec3":
        return new Float32Array(3 * e);
      case "vec4":
        return new Float32Array(4 * e);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * e);
      case "ivec3":
        return new Int32Array(3 * e);
      case "ivec4":
        return new Int32Array(4 * e);
      case "uvec2":
        return new Uint32Array(2 * e);
      case "uvec3":
        return new Uint32Array(3 * e);
      case "uvec4":
        return new Uint32Array(4 * e);
      case "bool":
        return !1;
      case "bvec2":
        return Wu(2 * e);
      case "bvec3":
        return Wu(3 * e);
      case "bvec4":
        return Wu(4 * e);
      case "mat2":
        return new Float32Array([1, 0, 0, 1]);
      case "mat3":
        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      case "mat4":
        return new Float32Array([
          1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        ]);
    }
    return null;
  }
  const Aa = [
      {
        test: (r) => r.type === "float" && r.size === 1 && !r.isArray,
        code: (r) => `
            if(uv["${r}"] !== ud["${r}"].value)
            {
                ud["${r}"].value = uv["${r}"]
                gl.uniform1f(ud["${r}"].location, uv["${r}"])
            }
            `,
      },
      {
        test: (r, e) =>
          (r.type === "sampler2D" ||
            r.type === "samplerCube" ||
            r.type === "sampler2DArray") &&
          r.size === 1 &&
          !r.isArray &&
          (e == null || e.castToBaseTexture !== void 0),
        code: (r) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${r}"], t);

            if(ud["${r}"].value !== t)
            {
                ud["${r}"].value = t;
                gl.uniform1i(ud["${r}"].location, t);
; // eslint-disable-line max-len
            }`,
      },
      {
        test: (r, e) =>
          r.type === "mat3" && r.size === 1 && !r.isArray && e.a !== void 0,
        code: (r) => `
            gl.uniformMatrix3fv(ud["${r}"].location, false, uv["${r}"].toArray(true));
            `,
        codeUbo: (r) => `
                var ${r}_matrix = uv.${r}.toArray(true);

                data[offset] = ${r}_matrix[0];
                data[offset+1] = ${r}_matrix[1];
                data[offset+2] = ${r}_matrix[2];
        
                data[offset + 4] = ${r}_matrix[3];
                data[offset + 5] = ${r}_matrix[4];
                data[offset + 6] = ${r}_matrix[5];
        
                data[offset + 8] = ${r}_matrix[6];
                data[offset + 9] = ${r}_matrix[7];
                data[offset + 10] = ${r}_matrix[8];
            `,
      },
      {
        test: (r, e) =>
          r.type === "vec2" && r.size === 1 && !r.isArray && e.x !== void 0,
        code: (r) => `
                cv = ud["${r}"].value;
                v = uv["${r}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${r}"].location, v.x, v.y);
                }`,
        codeUbo: (r) => `
                v = uv.${r};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `,
      },
      {
        test: (r) => r.type === "vec2" && r.size === 1 && !r.isArray,
        code: (r) => `
                cv = ud["${r}"].value;
                v = uv["${r}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${r}"].location, v[0], v[1]);
                }
            `,
      },
      {
        test: (r, e) =>
          r.type === "vec4" && r.size === 1 && !r.isArray && e.width !== void 0,
        code: (r) => `
                cv = ud["${r}"].value;
                v = uv["${r}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${r}"].location, v.x, v.y, v.width, v.height)
                }`,
        codeUbo: (r) => `
                    v = uv.${r};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `,
      },
      {
        test: (r, e) =>
          r.type === "vec4" && r.size === 1 && !r.isArray && e.red !== void 0,
        code: (r) => `
                cv = ud["${r}"].value;
                v = uv["${r}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${r}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
        codeUbo: (r) => `
                    v = uv.${r};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `,
      },
      {
        test: (r, e) =>
          r.type === "vec3" && r.size === 1 && !r.isArray && e.red !== void 0,
        code: (r) => `
                cv = ud["${r}"].value;
                v = uv["${r}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${r}"].location, v.red, v.green, v.blue)
                }`,
        codeUbo: (r) => `
                    v = uv.${r};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `,
      },
      {
        test: (r) => r.type === "vec4" && r.size === 1 && !r.isArray,
        code: (r) => `
                cv = ud["${r}"].value;
                v = uv["${r}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${r}"].location, v[0], v[1], v[2], v[3])
                }`,
      },
    ],
    MN = {
      float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
      vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
      vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
      vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
      int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
      ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
      ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
      ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
      uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
      uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
      uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
      uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
      bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
      bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
      bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
      bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
      mat2: "gl.uniformMatrix2fv(location, false, v)",
      mat3: "gl.uniformMatrix3fv(location, false, v)",
      mat4: "gl.uniformMatrix4fv(location, false, v)",
      sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
      samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
      sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    },
    FN = {
      float: "gl.uniform1fv(location, v)",
      vec2: "gl.uniform2fv(location, v)",
      vec3: "gl.uniform3fv(location, v)",
      vec4: "gl.uniform4fv(location, v)",
      mat4: "gl.uniformMatrix4fv(location, false, v)",
      mat3: "gl.uniformMatrix3fv(location, false, v)",
      mat2: "gl.uniformMatrix2fv(location, false, v)",
      int: "gl.uniform1iv(location, v)",
      ivec2: "gl.uniform2iv(location, v)",
      ivec3: "gl.uniform3iv(location, v)",
      ivec4: "gl.uniform4iv(location, v)",
      uint: "gl.uniform1uiv(location, v)",
      uvec2: "gl.uniform2uiv(location, v)",
      uvec3: "gl.uniform3uiv(location, v)",
      uvec4: "gl.uniform4uiv(location, v)",
      bool: "gl.uniform1iv(location, v)",
      bvec2: "gl.uniform2iv(location, v)",
      bvec3: "gl.uniform3iv(location, v)",
      bvec4: "gl.uniform4iv(location, v)",
      sampler2D: "gl.uniform1iv(location, v)",
      samplerCube: "gl.uniform1iv(location, v)",
      sampler2DArray: "gl.uniform1iv(location, v)",
    };
  function BN(r, e) {
    var i;
    const t = [
      `
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `,
    ];
    for (const s in r.uniforms) {
      const n = e[s];
      if (!n) {
        ((i = r.uniforms[s]) == null ? void 0 : i.group) === !0 &&
          (r.uniforms[s].ubo
            ? t.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${s}, '${s}');
                    `)
            : t.push(`
                        renderer.shader.syncUniformGroup(uv.${s}, syncData);
                    `));
        continue;
      }
      const a = r.uniforms[s];
      let o = !1;
      for (let l = 0; l < Aa.length; l++)
        if (Aa[l].test(n, a)) {
          t.push(Aa[l].code(s, a)), (o = !0);
          break;
        }
      if (!o) {
        const l = (n.size === 1 && !n.isArray ? MN : FN)[n.type].replace(
          "location",
          `ud["${s}"].location`
        );
        t.push(`
            cu = ud["${s}"];
            cv = cu.value;
            v = uv["${s}"];
            ${l};`);
      }
    }
    return new Function(
      "ud",
      "uv",
      "renderer",
      "syncData",
      t.join(`
`)
    );
  }
  const D1 = {};
  let Zn = D1;
  function ON() {
    if (Zn === D1 || (Zn != null && Zn.isContextLost())) {
      const r = we.ADAPTER.createCanvas();
      let e;
      we.PREFER_ENV >= $n.WEBGL2 && (e = r.getContext("webgl2", {})),
        e ||
          ((e =
            r.getContext("webgl", {}) ||
            r.getContext("experimental-webgl", {})),
          e ? e.getExtension("WEBGL_draw_buffers") : (e = null)),
        (Zn = e);
    }
    return Zn;
  }
  let Yl;
  function kN() {
    if (!Yl) {
      Yl = Ur.MEDIUM;
      const r = ON();
      if (r && r.getShaderPrecisionFormat) {
        const e = r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT);
        e && (Yl = e.precision ? Ur.HIGH : Ur.MEDIUM);
      }
    }
    return Yl;
  }
  function Iv(r, e) {
    const t = r
        .getShaderSource(e)
        .split(
          `
`
        )
        .map((h, c) => `${c}: ${h}`),
      i = r.getShaderInfoLog(e),
      s = i.split(`
`),
      n = {},
      a = s
        .map((h) => parseFloat(h.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1")))
        .filter((h) => (h && !n[h] ? ((n[h] = !0), !0) : !1)),
      o = [""];
    a.forEach((h) => {
      (t[h - 1] = `%c${t[h - 1]}%c`),
        o.push(
          "background: #FF0000; color:#FFFFFF; font-size: 10px",
          "font-size: 10px"
        );
    });
    const l = t.join(`
`);
    (o[0] = l),
      console.error(i),
      console.groupCollapsed("click to view full shader code"),
      console.warn(...o),
      console.groupEnd();
  }
  function DN(r, e, t, i) {
    r.getProgramParameter(e, r.LINK_STATUS) ||
      (r.getShaderParameter(t, r.COMPILE_STATUS) || Iv(r, t),
      r.getShaderParameter(i, r.COMPILE_STATUS) || Iv(r, i),
      console.error("PixiJS Error: Could not initialize shader."),
      r.getProgramInfoLog(e) !== "" &&
        console.warn(
          "PixiJS Warning: gl.getProgramInfoLog()",
          r.getProgramInfoLog(e)
        ));
  }
  const LN = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    uint: 1,
    uvec2: 2,
    uvec3: 3,
    uvec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1,
  };
  function L1(r) {
    return LN[r];
  }
  let jl = null;
  const Pv = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  };
  function N1(r, e) {
    if (!jl) {
      const t = Object.keys(Pv);
      jl = {};
      for (let i = 0; i < t.length; ++i) {
        const s = t[i];
        jl[r[s]] = Pv[s];
      }
    }
    return jl[e];
  }
  function Rv(r, e, t) {
    if (r.substring(0, 9) !== "precision") {
      let i = e;
      return (
        e === Ur.HIGH && t !== Ur.HIGH && (i = Ur.MEDIUM),
        `precision ${i} float;
${r}`
      );
    } else if (t !== Ur.HIGH && r.substring(0, 15) === "precision highp")
      return r.replace("precision highp", "precision mediump");
    return r;
  }
  let uo;
  function NN() {
    if (typeof uo == "boolean") return uo;
    try {
      uo =
        new Function(
          "param1",
          "param2",
          "param3",
          "return param1[param2] === param3;"
        )({ a: "b" }, "a", "b") === !0;
    } catch {
      uo = !1;
    }
    return uo;
  }
  let UN = 0;
  const ql = {},
    cf = class sa {
      constructor(e, t, i = "pixi-shader", s = {}) {
        (this.extra = {}),
          (this.id = UN++),
          (this.vertexSrc = e || sa.defaultVertexSrc),
          (this.fragmentSrc = t || sa.defaultFragmentSrc),
          (this.vertexSrc = this.vertexSrc.trim()),
          (this.fragmentSrc = this.fragmentSrc.trim()),
          (this.extra = s),
          this.vertexSrc.substring(0, 8) !== "#version" &&
            ((i = i.replace(/\s+/g, "-")),
            ql[i] ? (ql[i]++, (i += `-${ql[i]}`)) : (ql[i] = 1),
            (this.vertexSrc = `#define SHADER_NAME ${i}
${this.vertexSrc}`),
            (this.fragmentSrc = `#define SHADER_NAME ${i}
${this.fragmentSrc}`),
            (this.vertexSrc = Rv(
              this.vertexSrc,
              sa.defaultVertexPrecision,
              Ur.HIGH
            )),
            (this.fragmentSrc = Rv(
              this.fragmentSrc,
              sa.defaultFragmentPrecision,
              kN()
            ))),
          (this.glPrograms = {}),
          (this.syncUniforms = null);
      }
      static get defaultVertexSrc() {
        return RN;
      }
      static get defaultFragmentSrc() {
        return PN;
      }
      static from(e, t, i) {
        const s = e + t;
        let n = wv[s];
        return n || (wv[s] = n = new sa(e, t, i)), n;
      }
    };
  (cf.defaultVertexPrecision = Ur.HIGH),
    (cf.defaultFragmentPrecision = cs.apple.device ? Ur.HIGH : Ur.MEDIUM);
  let Li = cf,
    VN = 0;
  class di {
    constructor(e, t, i) {
      (this.group = !0),
        (this.syncUniforms = {}),
        (this.dirtyId = 0),
        (this.id = VN++),
        (this.static = !!t),
        (this.ubo = !!i),
        e instanceof gt
          ? ((this.buffer = e),
            (this.buffer.type = Gi.UNIFORM_BUFFER),
            (this.autoManage = !1),
            (this.ubo = !0))
          : ((this.uniforms = e),
            this.ubo &&
              ((this.buffer = new gt(new Float32Array(1))),
              (this.buffer.type = Gi.UNIFORM_BUFFER),
              (this.autoManage = !0)));
    }
    update() {
      this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
    }
    add(e, t, i) {
      if (!this.ubo) this.uniforms[e] = new di(t, i);
      else
        throw new Error(
          "[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them"
        );
    }
    static from(e, t, i) {
      return new di(e, t, i);
    }
    static uboFrom(e, t) {
      return new di(e, t ?? !0, !0);
    }
  }
  class fi {
    constructor(e, t) {
      (this.uniformBindCount = 0),
        (this.program = e),
        t
          ? t instanceof di
            ? (this.uniformGroup = t)
            : (this.uniformGroup = new di(t))
          : (this.uniformGroup = new di({})),
        (this.disposeRunner = new ui("disposeShader"));
    }
    checkUniformExists(e, t) {
      if (t.uniforms[e]) return !0;
      for (const i in t.uniforms) {
        const s = t.uniforms[i];
        if (s.group === !0 && this.checkUniformExists(e, s)) return !0;
      }
      return !1;
    }
    destroy() {
      (this.uniformGroup = null),
        this.disposeRunner.emit(this),
        this.disposeRunner.destroy();
    }
    get uniforms() {
      return this.uniformGroup.uniforms;
    }
    static from(e, t, i) {
      const s = Li.from(e, t);
      return new fi(s, i);
    }
  }
  class U1 {
    constructor(e, t) {
      if (
        ((this.vertexSrc = e),
        (this.fragTemplate = t),
        (this.programCache = {}),
        (this.defaultGroupCache = {}),
        !t.includes("%count%"))
      )
        throw new Error('Fragment template must contain "%count%".');
      if (!t.includes("%forloop%"))
        throw new Error('Fragment template must contain "%forloop%".');
    }
    generateShader(e) {
      if (!this.programCache[e]) {
        const i = new Int32Array(e);
        for (let n = 0; n < e; n++) i[n] = n;
        this.defaultGroupCache[e] = di.from({ uSamplers: i }, !0);
        let s = this.fragTemplate;
        (s = s.replace(/%count%/gi, `${e}`)),
          (s = s.replace(/%forloop%/gi, this.generateSampleSrc(e))),
          (this.programCache[e] = new Li(this.vertexSrc, s));
      }
      const t = {
        tint: new Float32Array([1, 1, 1, 1]),
        translationMatrix: new vt(),
        default: this.defaultGroupCache[e],
      };
      return new fi(this.programCache[e], t);
    }
    generateSampleSrc(e) {
      let t = "";
      (t += `
`),
        (t += `
`);
      for (let i = 0; i < e; i++)
        i > 0 &&
          (t += `
else `),
          i < e - 1 && (t += `if(vTextureId < ${i}.5)`),
          (t += `
{`),
          (t += `
	color = texture2D(uSamplers[${i}], vTextureCoord);`),
          (t += `
}`);
      return (
        (t += `
`),
        (t += `
`),
        t
      );
    }
  }
  class uf {
    constructor() {
      (this.elements = []), (this.ids = []), (this.count = 0);
    }
    clear() {
      for (let e = 0; e < this.count; e++) this.elements[e] = null;
      this.count = 0;
    }
  }
  function $N() {
    return !cs.apple.device;
  }
  function GN(r) {
    let e = !0;
    const t = we.ADAPTER.getNavigator();
    if (cs.tablet || cs.phone) {
      if (cs.apple.device) {
        const i = t.userAgent.match(/OS (\d+)_(\d+)?/);
        i && parseInt(i[1], 10) < 11 && (e = !1);
      }
      if (cs.android.device) {
        const i = t.userAgent.match(/Android\s([0-9.]*)/);
        i && parseInt(i[1], 10) < 7 && (e = !1);
      }
    }
    return e ? r : 4;
  }
  class Gc {
    constructor(e) {
      this.renderer = e;
    }
    flush() {}
    destroy() {
      this.renderer = null;
    }
    start() {}
    stop() {
      this.flush();
    }
    render(e) {}
  }
  var HN = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`,
    XN = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`;
  const yo = class ti extends Gc {
    constructor(e) {
      super(e),
        this.setShaderGenerator(),
        (this.geometryClass = B1),
        (this.vertexSize = 6),
        (this.state = ji.for2d()),
        (this.size = ti.defaultBatchSize * 4),
        (this._vertexCount = 0),
        (this._indexCount = 0),
        (this._bufferedElements = []),
        (this._bufferedTextures = []),
        (this._bufferSize = 0),
        (this._shader = null),
        (this._packedGeometries = []),
        (this._packedGeometryPoolSize = 2),
        (this._flushId = 0),
        (this._aBuffers = {}),
        (this._iBuffers = {}),
        (this.maxTextures = 1),
        this.renderer.on("prerender", this.onPrerender, this),
        e.runners.contextChange.add(this),
        (this._dcIndex = 0),
        (this._aIndex = 0),
        (this._iIndex = 0),
        (this._attributeBuffer = null),
        (this._indexBuffer = null),
        (this._tempBoundTextures = []);
    }
    static get defaultMaxTextures() {
      return (
        (this._defaultMaxTextures = this._defaultMaxTextures ?? GN(32)),
        this._defaultMaxTextures
      );
    }
    static set defaultMaxTextures(e) {
      this._defaultMaxTextures = e;
    }
    static get canUploadSameBuffer() {
      return (
        (this._canUploadSameBuffer = this._canUploadSameBuffer ?? $N()),
        this._canUploadSameBuffer
      );
    }
    static set canUploadSameBuffer(e) {
      this._canUploadSameBuffer = e;
    }
    get MAX_TEXTURES() {
      return (
        We(
          "7.1.0",
          "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"
        ),
        this.maxTextures
      );
    }
    static get defaultVertexSrc() {
      return XN;
    }
    static get defaultFragmentTemplate() {
      return HN;
    }
    setShaderGenerator({
      vertex: e = ti.defaultVertexSrc,
      fragment: t = ti.defaultFragmentTemplate,
    } = {}) {
      this.shaderGenerator = new U1(e, t);
    }
    contextChange() {
      const e = this.renderer.gl;
      we.PREFER_ENV === $n.WEBGL_LEGACY
        ? (this.maxTextures = 1)
        : ((this.maxTextures = Math.min(
            e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
            ti.defaultMaxTextures
          )),
          (this.maxTextures = bN(this.maxTextures, e))),
        (this._shader = this.shaderGenerator.generateShader(this.maxTextures));
      for (let t = 0; t < this._packedGeometryPoolSize; t++)
        this._packedGeometries[t] = new this.geometryClass();
      this.initFlushBuffers();
    }
    initFlushBuffers() {
      const { _drawCallPool: e, _textureArrayPool: t } = ti,
        i = this.size / 4,
        s = Math.floor(i / this.maxTextures) + 1;
      for (; e.length < i; ) e.push(new of());
      for (; t.length < s; ) t.push(new uf());
      for (let n = 0; n < this.maxTextures; n++)
        this._tempBoundTextures[n] = null;
    }
    onPrerender() {
      this._flushId = 0;
    }
    render(e) {
      e._texture.valid &&
        (this._vertexCount + e.vertexData.length / 2 > this.size &&
          this.flush(),
        (this._vertexCount += e.vertexData.length / 2),
        (this._indexCount += e.indices.length),
        (this._bufferedTextures[this._bufferSize] = e._texture.baseTexture),
        (this._bufferedElements[this._bufferSize++] = e));
    }
    buildTexturesAndDrawCalls() {
      const { _bufferedTextures: e, maxTextures: t } = this,
        i = ti._textureArrayPool,
        s = this.renderer.batch,
        n = this._tempBoundTextures,
        a = this.renderer.textureGC.count;
      let o = ++Le._globalBatch,
        l = 0,
        h = i[0],
        c = 0;
      s.copyBoundTextures(n, t);
      for (let u = 0; u < this._bufferSize; ++u) {
        const d = e[u];
        (e[u] = null),
          d._batchEnabled !== o &&
            (h.count >= t &&
              (s.boundArray(h, n, o, t),
              this.buildDrawCalls(h, c, u),
              (c = u),
              (h = i[++l]),
              ++o),
            (d._batchEnabled = o),
            (d.touched = a),
            (h.elements[h.count++] = d));
      }
      h.count > 0 &&
        (s.boundArray(h, n, o, t),
        this.buildDrawCalls(h, c, this._bufferSize),
        ++l,
        ++o);
      for (let u = 0; u < n.length; u++) n[u] = null;
      Le._globalBatch = o;
    }
    buildDrawCalls(e, t, i) {
      const {
          _bufferedElements: s,
          _attributeBuffer: n,
          _indexBuffer: a,
          vertexSize: o,
        } = this,
        l = ti._drawCallPool;
      let h = this._dcIndex,
        c = this._aIndex,
        u = this._iIndex,
        d = l[h];
      (d.start = this._iIndex), (d.texArray = e);
      for (let f = t; f < i; ++f) {
        const p = s[f],
          m = p._texture.baseTexture,
          v = P1[m.alphaMode ? 1 : 0][p.blendMode];
        (s[f] = null),
          t < f &&
            d.blend !== v &&
            ((d.size = u - d.start),
            (t = f),
            (d = l[++h]),
            (d.texArray = e),
            (d.start = u)),
          this.packInterleavedGeometry(p, n, a, c, u),
          (c += (p.vertexData.length / 2) * o),
          (u += p.indices.length),
          (d.blend = v);
      }
      t < i && ((d.size = u - d.start), ++h),
        (this._dcIndex = h),
        (this._aIndex = c),
        (this._iIndex = u);
    }
    bindAndClearTexArray(e) {
      const t = this.renderer.texture;
      for (let i = 0; i < e.count; i++)
        t.bind(e.elements[i], e.ids[i]), (e.elements[i] = null);
      e.count = 0;
    }
    updateGeometry() {
      const {
        _packedGeometries: e,
        _attributeBuffer: t,
        _indexBuffer: i,
      } = this;
      ti.canUploadSameBuffer
        ? (e[this._flushId]._buffer.update(t.rawBinaryData),
          e[this._flushId]._indexBuffer.update(i),
          this.renderer.geometry.updateBuffers())
        : (this._packedGeometryPoolSize <= this._flushId &&
            (this._packedGeometryPoolSize++,
            (e[this._flushId] = new this.geometryClass())),
          e[this._flushId]._buffer.update(t.rawBinaryData),
          e[this._flushId]._indexBuffer.update(i),
          this.renderer.geometry.bind(e[this._flushId]),
          this.renderer.geometry.updateBuffers(),
          this._flushId++);
    }
    drawBatches() {
      const e = this._dcIndex,
        { gl: t, state: i } = this.renderer,
        s = ti._drawCallPool;
      let n = null;
      for (let a = 0; a < e; a++) {
        const { texArray: o, type: l, size: h, start: c, blend: u } = s[a];
        n !== o && ((n = o), this.bindAndClearTexArray(o)),
          (this.state.blendMode = u),
          i.set(this.state),
          t.drawElements(l, h, t.UNSIGNED_SHORT, c * 2);
      }
    }
    flush() {
      this._vertexCount !== 0 &&
        ((this._attributeBuffer = this.getAttributeBuffer(this._vertexCount)),
        (this._indexBuffer = this.getIndexBuffer(this._indexCount)),
        (this._aIndex = 0),
        (this._iIndex = 0),
        (this._dcIndex = 0),
        this.buildTexturesAndDrawCalls(),
        this.updateGeometry(),
        this.drawBatches(),
        (this._bufferSize = 0),
        (this._vertexCount = 0),
        (this._indexCount = 0));
    }
    start() {
      this.renderer.state.set(this.state),
        this.renderer.texture.ensureSamplerType(this.maxTextures),
        this.renderer.shader.bind(this._shader),
        ti.canUploadSameBuffer &&
          this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }
    stop() {
      this.flush();
    }
    destroy() {
      for (let e = 0; e < this._packedGeometryPoolSize; e++)
        this._packedGeometries[e] && this._packedGeometries[e].destroy();
      this.renderer.off("prerender", this.onPrerender, this),
        (this._aBuffers = null),
        (this._iBuffers = null),
        (this._packedGeometries = null),
        (this._attributeBuffer = null),
        (this._indexBuffer = null),
        this._shader && (this._shader.destroy(), (this._shader = null)),
        super.destroy();
    }
    getAttributeBuffer(e) {
      const t = Hh(Math.ceil(e / 8)),
        i = xv(t),
        s = t * 8;
      this._aBuffers.length <= i && (this._iBuffers.length = i + 1);
      let n = this._aBuffers[s];
      return n || (this._aBuffers[s] = n = new sf(s * this.vertexSize * 4)), n;
    }
    getIndexBuffer(e) {
      const t = Hh(Math.ceil(e / 12)),
        i = xv(t),
        s = t * 12;
      this._iBuffers.length <= i && (this._iBuffers.length = i + 1);
      let n = this._iBuffers[i];
      return n || (this._iBuffers[i] = n = new Uint16Array(s)), n;
    }
    packInterleavedGeometry(e, t, i, s, n) {
      const { uint32View: a, float32View: o } = t,
        l = s / this.vertexSize,
        h = e.uvs,
        c = e.indices,
        u = e.vertexData,
        d = e._texture.baseTexture._batchLocation,
        f = Math.min(e.worldAlpha, 1),
        p = lt.shared
          .setValue(e._tintRGB)
          .toPremultiplied(f, e._texture.baseTexture.alphaMode > 0);
      for (let m = 0; m < u.length; m += 2)
        (o[s++] = u[m]),
          (o[s++] = u[m + 1]),
          (o[s++] = h[m]),
          (o[s++] = h[m + 1]),
          (a[s++] = p),
          (o[s++] = d);
      for (let m = 0; m < c.length; m++) i[n++] = l + c[m];
    }
  };
  (yo.defaultBatchSize = 4096),
    (yo.extension = { name: "batch", type: me.RendererPlugin }),
    (yo._drawCallPool = []),
    (yo._textureArrayPool = []);
  let ks = yo;
  Ce.add(ks);
  var zN = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`,
    WN = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
  const df = class bo extends fi {
    constructor(e, t, i) {
      const s = Li.from(e || bo.defaultVertexSrc, t || bo.defaultFragmentSrc);
      super(s, i),
        (this.padding = 0),
        (this.resolution = bo.defaultResolution),
        (this.multisample = bo.defaultMultisample),
        (this.enabled = !0),
        (this.autoFit = !0),
        (this.state = new ji());
    }
    apply(e, t, i, s, n) {
      e.applyFilter(this, t, i, s);
    }
    get blendMode() {
      return this.state.blendMode;
    }
    set blendMode(e) {
      this.state.blendMode = e;
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(e) {
      this._resolution = e;
    }
    static get defaultVertexSrc() {
      return WN;
    }
    static get defaultFragmentSrc() {
      return zN;
    }
  };
  (df.defaultResolution = 1), (df.defaultMultisample = Ft.NONE);
  let fr = df;
  class Wh {
    constructor() {
      (this.clearBeforeRender = !0),
        (this._backgroundColor = new lt(0)),
        (this.alpha = 1);
    }
    init(e) {
      this.clearBeforeRender = e.clearBeforeRender;
      const { backgroundColor: t, background: i, backgroundAlpha: s } = e,
        n = i ?? t;
      n !== void 0 && (this.color = n), (this.alpha = s);
    }
    get color() {
      return this._backgroundColor.value;
    }
    set color(e) {
      this._backgroundColor.setValue(e);
    }
    get alpha() {
      return this._backgroundColor.alpha;
    }
    set alpha(e) {
      this._backgroundColor.setAlpha(e);
    }
    get backgroundColor() {
      return this._backgroundColor;
    }
    destroy() {}
  }
  (Wh.defaultOptions = {
    backgroundAlpha: 1,
    backgroundColor: 0,
    clearBeforeRender: !0,
  }),
    (Wh.extension = {
      type: [me.RendererSystem, me.CanvasRendererSystem],
      name: "background",
    });
  Ce.add(Wh);
  class V1 {
    constructor(e) {
      (this.renderer = e),
        (this.emptyRenderer = new Gc(e)),
        (this.currentRenderer = this.emptyRenderer);
    }
    setObjectRenderer(e) {
      this.currentRenderer !== e &&
        (this.currentRenderer.stop(),
        (this.currentRenderer = e),
        this.currentRenderer.start());
    }
    flush() {
      this.setObjectRenderer(this.emptyRenderer);
    }
    reset() {
      this.setObjectRenderer(this.emptyRenderer);
    }
    copyBoundTextures(e, t) {
      const { boundTextures: i } = this.renderer.texture;
      for (let s = t - 1; s >= 0; --s)
        (e[s] = i[s] || null), e[s] && (e[s]._batchLocation = s);
    }
    boundArray(e, t, i, s) {
      const { elements: n, ids: a, count: o } = e;
      let l = 0;
      for (let h = 0; h < o; h++) {
        const c = n[h],
          u = c._batchLocation;
        if (u >= 0 && u < s && t[u] === c) {
          a[h] = u;
          continue;
        }
        for (; l < s; ) {
          const d = t[l];
          if (d && d._batchEnabled === i && d._batchLocation === l) {
            l++;
            continue;
          }
          (a[h] = l), (c._batchLocation = l), (t[l] = c);
          break;
        }
      }
    }
    destroy() {
      this.renderer = null;
    }
  }
  V1.extension = { type: me.RendererSystem, name: "batch" };
  Ce.add(V1);
  let Mv = 0;
  class Yh {
    constructor(e) {
      (this.renderer = e),
        (this.webGLVersion = 1),
        (this.extensions = {}),
        (this.supports = { uint32Indices: !1 }),
        (this.handleContextLost = this.handleContextLost.bind(this)),
        (this.handleContextRestored = this.handleContextRestored.bind(this));
    }
    get isLost() {
      return !this.gl || this.gl.isContextLost();
    }
    contextChange(e) {
      (this.gl = e), (this.renderer.gl = e), (this.renderer.CONTEXT_UID = Mv++);
    }
    init(e) {
      if (e.context) this.initFromContext(e.context);
      else {
        const t = this.renderer.background.alpha < 1,
          i = e.premultipliedAlpha;
        (this.preserveDrawingBuffer = e.preserveDrawingBuffer),
          (this.useContextAlpha = e.useContextAlpha),
          (this.powerPreference = e.powerPreference),
          this.initFromOptions({
            alpha: t,
            premultipliedAlpha: i,
            antialias: e.antialias,
            stencil: !0,
            preserveDrawingBuffer: e.preserveDrawingBuffer,
            powerPreference: e.powerPreference,
          });
      }
    }
    initFromContext(e) {
      (this.gl = e),
        this.validateContext(e),
        (this.renderer.gl = e),
        (this.renderer.CONTEXT_UID = Mv++),
        this.renderer.runners.contextChange.emit(e);
      const t = this.renderer.view;
      t.addEventListener !== void 0 &&
        (t.addEventListener("webglcontextlost", this.handleContextLost, !1),
        t.addEventListener(
          "webglcontextrestored",
          this.handleContextRestored,
          !1
        ));
    }
    initFromOptions(e) {
      const t = this.createContext(this.renderer.view, e);
      this.initFromContext(t);
    }
    createContext(e, t) {
      let i;
      if ((we.PREFER_ENV >= $n.WEBGL2 && (i = e.getContext("webgl2", t)), i))
        this.webGLVersion = 2;
      else if (
        ((this.webGLVersion = 1),
        (i = e.getContext("webgl", t) || e.getContext("experimental-webgl", t)),
        !i)
      )
        throw new Error(
          "This browser does not support WebGL. Try using the canvas renderer"
        );
      return (this.gl = i), this.getExtensions(), this.gl;
    }
    getExtensions() {
      const { gl: e } = this,
        t = {
          loseContext: e.getExtension("WEBGL_lose_context"),
          anisotropicFiltering: e.getExtension(
            "EXT_texture_filter_anisotropic"
          ),
          floatTextureLinear: e.getExtension("OES_texture_float_linear"),
          s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
          s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
          etc: e.getExtension("WEBGL_compressed_texture_etc"),
          etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
          pvrtc:
            e.getExtension("WEBGL_compressed_texture_pvrtc") ||
            e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          atc: e.getExtension("WEBGL_compressed_texture_atc"),
          astc: e.getExtension("WEBGL_compressed_texture_astc"),
          bptc: e.getExtension("EXT_texture_compression_bptc"),
        };
      this.webGLVersion === 1
        ? Object.assign(this.extensions, t, {
            drawBuffers: e.getExtension("WEBGL_draw_buffers"),
            depthTexture: e.getExtension("WEBGL_depth_texture"),
            vertexArrayObject:
              e.getExtension("OES_vertex_array_object") ||
              e.getExtension("MOZ_OES_vertex_array_object") ||
              e.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: e.getExtension("OES_element_index_uint"),
            floatTexture: e.getExtension("OES_texture_float"),
            floatTextureLinear: e.getExtension("OES_texture_float_linear"),
            textureHalfFloat: e.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: e.getExtension(
              "OES_texture_half_float_linear"
            ),
          })
        : this.webGLVersion === 2 &&
          Object.assign(this.extensions, t, {
            colorBufferFloat: e.getExtension("EXT_color_buffer_float"),
          });
    }
    handleContextLost(e) {
      e.preventDefault(),
        setTimeout(() => {
          this.gl.isContextLost() &&
            this.extensions.loseContext &&
            this.extensions.loseContext.restoreContext();
        }, 0);
    }
    handleContextRestored() {
      this.renderer.runners.contextChange.emit(this.gl);
    }
    destroy() {
      const e = this.renderer.view;
      (this.renderer = null),
        e.removeEventListener !== void 0 &&
          (e.removeEventListener("webglcontextlost", this.handleContextLost),
          e.removeEventListener(
            "webglcontextrestored",
            this.handleContextRestored
          )),
        this.gl.useProgram(null),
        this.extensions.loseContext &&
          this.extensions.loseContext.loseContext();
    }
    postrender() {
      this.renderer.objectRenderer.renderingToScreen && this.gl.flush();
    }
    validateContext(e) {
      const t = e.getContextAttributes(),
        i =
          "WebGL2RenderingContext" in globalThis &&
          e instanceof globalThis.WebGL2RenderingContext;
      i && (this.webGLVersion = 2),
        t &&
          !t.stencil &&
          console.warn(
            "Provided WebGL context does not have a stencil buffer, masks may not render correctly"
          );
      const s = i || !!e.getExtension("OES_element_index_uint");
      (this.supports.uint32Indices = s),
        s ||
          console.warn(
            "Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly"
          );
    }
  }
  (Yh.defaultOptions = {
    context: null,
    antialias: !1,
    premultipliedAlpha: !0,
    preserveDrawingBuffer: !1,
    powerPreference: "default",
  }),
    (Yh.extension = { type: me.RendererSystem, name: "context" });
  Ce.add(Yh);
  class ff {
    constructor(e, t) {
      if (
        ((this.width = Math.round(e)),
        (this.height = Math.round(t)),
        !this.width || !this.height)
      )
        throw new Error("Framebuffer width or height is zero");
      (this.stencil = !1),
        (this.depth = !1),
        (this.dirtyId = 0),
        (this.dirtyFormat = 0),
        (this.dirtySize = 0),
        (this.depthTexture = null),
        (this.colorTextures = []),
        (this.glFramebuffers = {}),
        (this.disposeRunner = new ui("disposeFramebuffer")),
        (this.multisample = Ft.NONE);
    }
    get colorTexture() {
      return this.colorTextures[0];
    }
    addColorTexture(e = 0, t) {
      return (
        (this.colorTextures[e] =
          t ||
          new Le(null, {
            scaleMode: ai.NEAREST,
            resolution: 1,
            mipmap: Yr.OFF,
            width: this.width,
            height: this.height,
          })),
        this.dirtyId++,
        this.dirtyFormat++,
        this
      );
    }
    addDepthTexture(e) {
      return (
        (this.depthTexture =
          e ||
          new Le(null, {
            scaleMode: ai.NEAREST,
            resolution: 1,
            width: this.width,
            height: this.height,
            mipmap: Yr.OFF,
            format: le.DEPTH_COMPONENT,
            type: Ae.UNSIGNED_SHORT,
          })),
        this.dirtyId++,
        this.dirtyFormat++,
        this
      );
    }
    enableDepth() {
      return (this.depth = !0), this.dirtyId++, this.dirtyFormat++, this;
    }
    enableStencil() {
      return (this.stencil = !0), this.dirtyId++, this.dirtyFormat++, this;
    }
    resize(e, t) {
      if (((e = Math.round(e)), (t = Math.round(t)), !e || !t))
        throw new Error("Framebuffer width and height must not be zero");
      if (!(e === this.width && t === this.height)) {
        (this.width = e), (this.height = t), this.dirtyId++, this.dirtySize++;
        for (let i = 0; i < this.colorTextures.length; i++) {
          const s = this.colorTextures[i],
            n = s.resolution;
          s.setSize(e / n, t / n);
        }
        if (this.depthTexture) {
          const i = this.depthTexture.resolution;
          this.depthTexture.setSize(e / i, t / i);
        }
      }
    }
    dispose() {
      this.disposeRunner.emit(this, !1);
    }
    destroyDepthTexture() {
      this.depthTexture &&
        (this.depthTexture.destroy(),
        (this.depthTexture = null),
        ++this.dirtyId,
        ++this.dirtyFormat);
    }
  }
  class $1 extends Le {
    constructor(e = {}) {
      if (typeof e == "number") {
        const t = arguments[0],
          i = arguments[1],
          s = arguments[2],
          n = arguments[3];
        e = { width: t, height: i, scaleMode: s, resolution: n };
      }
      (e.width = e.width ?? 100),
        (e.height = e.height ?? 100),
        e.multisample ?? (e.multisample = Ft.NONE),
        super(null, e),
        (this.mipmap = Yr.OFF),
        (this.valid = !0),
        (this._clear = new lt([0, 0, 0, 0])),
        (this.framebuffer = new ff(
          this.realWidth,
          this.realHeight
        ).addColorTexture(0, this)),
        (this.framebuffer.multisample = e.multisample),
        (this.maskStack = []),
        (this.filterStack = [{}]);
    }
    set clearColor(e) {
      this._clear.setValue(e);
    }
    get clearColor() {
      return this._clear.value;
    }
    get clear() {
      return this._clear;
    }
    get multisample() {
      return this.framebuffer.multisample;
    }
    set multisample(e) {
      this.framebuffer.multisample = e;
    }
    resize(e, t) {
      this.framebuffer.resize(e * this.resolution, t * this.resolution),
        this.setRealSize(this.framebuffer.width, this.framebuffer.height);
    }
    dispose() {
      this.framebuffer.dispose(), super.dispose();
    }
    destroy() {
      super.destroy(),
        this.framebuffer.destroyDepthTexture(),
        (this.framebuffer = null);
    }
  }
  class ys extends rl {
    constructor(e) {
      const t = e,
        i = t.naturalWidth || t.videoWidth || t.displayWidth || t.width,
        s = t.naturalHeight || t.videoHeight || t.displayHeight || t.height;
      super(i, s), (this.source = e), (this.noSubImage = !1);
    }
    static crossOrigin(e, t, i) {
      i === void 0 && !t.startsWith("data:")
        ? (e.crossOrigin = gN(t))
        : i !== !1 && (e.crossOrigin = typeof i == "string" ? i : "anonymous");
    }
    upload(e, t, i, s) {
      const n = e.gl,
        a = t.realWidth,
        o = t.realHeight;
      if (
        ((s = s || this.source),
        typeof HTMLImageElement < "u" && s instanceof HTMLImageElement)
      ) {
        if (!s.complete || s.naturalWidth === 0) return !1;
      } else if (
        typeof HTMLVideoElement < "u" &&
        s instanceof HTMLVideoElement &&
        s.readyState <= 1
      )
        return !1;
      return (
        n.pixelStorei(
          n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
          t.alphaMode === sr.UNPACK
        ),
        !this.noSubImage &&
        t.target === n.TEXTURE_2D &&
        i.width === a &&
        i.height === o
          ? n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, t.format, i.type, s)
          : ((i.width = a),
            (i.height = o),
            n.texImage2D(t.target, 0, i.internalFormat, t.format, i.type, s)),
        !0
      );
    }
    update() {
      if (this.destroyed) return;
      const e = this.source,
        t = e.naturalWidth || e.videoWidth || e.width,
        i = e.naturalHeight || e.videoHeight || e.height;
      this.resize(t, i), super.update();
    }
    dispose() {
      this.source = null;
    }
  }
  class G1 extends ys {
    constructor(e, t) {
      if (((t = t || {}), typeof e == "string")) {
        const i = new Image();
        ys.crossOrigin(i, e, t.crossorigin), (i.src = e), (e = i);
      }
      super(e),
        !e.complete &&
          this._width &&
          this._height &&
          ((this._width = 0), (this._height = 0)),
        (this.url = e.src),
        (this._process = null),
        (this.preserveBitmap = !1),
        (this.createBitmap =
          (t.createBitmap ?? we.CREATE_IMAGE_BITMAP) &&
          !!globalThis.createImageBitmap),
        (this.alphaMode = typeof t.alphaMode == "number" ? t.alphaMode : null),
        (this.bitmap = null),
        (this._load = null),
        t.autoLoad !== !1 && this.load();
    }
    load(e) {
      return this._load
        ? this._load
        : (e !== void 0 && (this.createBitmap = e),
          (this._load = new Promise((t, i) => {
            const s = this.source;
            this.url = s.src;
            const n = () => {
              this.destroyed ||
                ((s.onload = null),
                (s.onerror = null),
                this.update(),
                (this._load = null),
                this.createBitmap ? t(this.process()) : t(this));
            };
            s.complete && s.src
              ? n()
              : ((s.onload = n),
                (s.onerror = (a) => {
                  i(a), this.onError.emit(a);
                }));
          })),
          this._load);
    }
    process() {
      const e = this.source;
      if (this._process !== null) return this._process;
      if (this.bitmap !== null || !globalThis.createImageBitmap)
        return Promise.resolve(this);
      const t = globalThis.createImageBitmap,
        i = !e.crossOrigin || e.crossOrigin === "anonymous";
      return (
        (this._process = fetch(e.src, { mode: i ? "cors" : "no-cors" })
          .then((s) => s.blob())
          .then((s) =>
            t(s, 0, 0, e.width, e.height, {
              premultiplyAlpha:
                this.alphaMode === null || this.alphaMode === sr.UNPACK
                  ? "premultiply"
                  : "none",
            })
          )
          .then((s) =>
            this.destroyed
              ? Promise.reject()
              : ((this.bitmap = s),
                this.update(),
                (this._process = null),
                Promise.resolve(this))
          )),
        this._process
      );
    }
    upload(e, t, i) {
      if (
        (typeof this.alphaMode == "number" && (t.alphaMode = this.alphaMode),
        !this.createBitmap)
      )
        return super.upload(e, t, i);
      if (!this.bitmap && (this.process(), !this.bitmap)) return !1;
      if ((super.upload(e, t, i, this.bitmap), !this.preserveBitmap)) {
        let s = !0;
        const n = t._glTextures;
        for (const a in n) {
          const o = n[a];
          if (o !== i && o.dirtyId !== t.dirtyId) {
            s = !1;
            break;
          }
        }
        s && (this.bitmap.close && this.bitmap.close(), (this.bitmap = null));
      }
      return !0;
    }
    dispose() {
      (this.source.onload = null),
        (this.source.onerror = null),
        super.dispose(),
        this.bitmap && (this.bitmap.close(), (this.bitmap = null)),
        (this._process = null),
        (this._load = null);
    }
    static test(e) {
      return (
        typeof HTMLImageElement < "u" &&
        (typeof e == "string" || e instanceof HTMLImageElement)
      );
    }
  }
  class im {
    constructor() {
      (this.x0 = 0),
        (this.y0 = 0),
        (this.x1 = 1),
        (this.y1 = 0),
        (this.x2 = 1),
        (this.y2 = 1),
        (this.x3 = 0),
        (this.y3 = 1),
        (this.uvsFloat32 = new Float32Array(8));
    }
    set(e, t, i) {
      const s = t.width,
        n = t.height;
      if (i) {
        const a = e.width / 2 / s,
          o = e.height / 2 / n,
          l = e.x / s + a,
          h = e.y / n + o;
        (i = wt.add(i, wt.NW)),
          (this.x0 = l + a * wt.uX(i)),
          (this.y0 = h + o * wt.uY(i)),
          (i = wt.add(i, 2)),
          (this.x1 = l + a * wt.uX(i)),
          (this.y1 = h + o * wt.uY(i)),
          (i = wt.add(i, 2)),
          (this.x2 = l + a * wt.uX(i)),
          (this.y2 = h + o * wt.uY(i)),
          (i = wt.add(i, 2)),
          (this.x3 = l + a * wt.uX(i)),
          (this.y3 = h + o * wt.uY(i));
      } else
        (this.x0 = e.x / s),
          (this.y0 = e.y / n),
          (this.x1 = (e.x + e.width) / s),
          (this.y1 = e.y / n),
          (this.x2 = (e.x + e.width) / s),
          (this.y2 = (e.y + e.height) / n),
          (this.x3 = e.x / s),
          (this.y3 = (e.y + e.height) / n);
      (this.uvsFloat32[0] = this.x0),
        (this.uvsFloat32[1] = this.y0),
        (this.uvsFloat32[2] = this.x1),
        (this.uvsFloat32[3] = this.y1),
        (this.uvsFloat32[4] = this.x2),
        (this.uvsFloat32[5] = this.y2),
        (this.uvsFloat32[6] = this.x3),
        (this.uvsFloat32[7] = this.y3);
    }
  }
  im.prototype.toString = function () {
    return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
  };
  const Fv = new im();
  function Kl(r) {
    (r.destroy = function () {}),
      (r.on = function () {}),
      (r.once = function () {}),
      (r.emit = function () {});
  }
  let ze = class pt extends gl {
    constructor(e, t, i, s, n, a, o) {
      if (
        (super(),
        (this.noFrame = !1),
        t || ((this.noFrame = !0), (t = new $e(0, 0, 1, 1))),
        e instanceof pt && (e = e.baseTexture),
        (this.baseTexture = e),
        (this._frame = t),
        (this.trim = s),
        (this.valid = !1),
        (this.destroyed = !1),
        (this._uvs = Fv),
        (this.uvMatrix = null),
        (this.orig = i || t),
        (this._rotate = Number(n || 0)),
        n === !0)
      )
        this._rotate = 2;
      else if (this._rotate % 2 !== 0)
        throw new Error(
          "attempt to use diamond-shaped UVs. If you are sure, set rotation manually"
        );
      (this.defaultAnchor = a ? new Je(a.x, a.y) : new Je(0, 0)),
        (this.defaultBorders = o),
        (this._updateID = 0),
        (this.textureCacheIds = []),
        e.valid
          ? this.noFrame
            ? e.valid && this.onBaseTextureUpdated(e)
            : (this.frame = t)
          : e.once("loaded", this.onBaseTextureUpdated, this),
        this.noFrame && e.on("update", this.onBaseTextureUpdated, this);
    }
    update() {
      this.baseTexture.resource && this.baseTexture.resource.update();
    }
    onBaseTextureUpdated(e) {
      if (this.noFrame) {
        if (!this.baseTexture.valid) return;
        (this._frame.width = e.width),
          (this._frame.height = e.height),
          (this.valid = !0),
          this.updateUvs();
      } else this.frame = this._frame;
      this.emit("update", this);
    }
    destroy(e) {
      if (this.baseTexture) {
        if (e) {
          const { resource: t } = this.baseTexture;
          t != null && t.url && Si[t.url] && pt.removeFromCache(t.url),
            this.baseTexture.destroy();
        }
        this.baseTexture.off("loaded", this.onBaseTextureUpdated, this),
          this.baseTexture.off("update", this.onBaseTextureUpdated, this),
          (this.baseTexture = null);
      }
      (this._frame = null),
        (this._uvs = null),
        (this.trim = null),
        (this.orig = null),
        (this.valid = !1),
        pt.removeFromCache(this),
        (this.textureCacheIds = null),
        (this.destroyed = !0),
        this.emit("destroyed", this),
        this.removeAllListeners();
    }
    clone() {
      var s;
      const e = this._frame.clone(),
        t = this._frame === this.orig ? e : this.orig.clone(),
        i = new pt(
          this.baseTexture,
          !this.noFrame && e,
          t,
          (s = this.trim) == null ? void 0 : s.clone(),
          this.rotate,
          this.defaultAnchor,
          this.defaultBorders
        );
      return this.noFrame && (i._frame = e), i;
    }
    updateUvs() {
      this._uvs === Fv && (this._uvs = new im()),
        this._uvs.set(this._frame, this.baseTexture, this.rotate),
        this._updateID++;
    }
    static from(e, t = {}, i = we.STRICT_TEXTURE_CACHE) {
      const s = typeof e == "string";
      let n = null;
      if (s) n = e;
      else if (e instanceof Le) {
        if (!e.cacheId) {
          const o = (t == null ? void 0 : t.pixiIdPrefix) || "pixiid";
          (e.cacheId = `${o}-${Dn()}`), Le.addToCache(e, e.cacheId);
        }
        n = e.cacheId;
      } else {
        if (!e._pixiId) {
          const o = (t == null ? void 0 : t.pixiIdPrefix) || "pixiid";
          e._pixiId = `${o}_${Dn()}`;
        }
        n = e._pixiId;
      }
      let a = Si[n];
      if (s && i && !a)
        throw new Error(`The cacheId "${n}" does not exist in TextureCache.`);
      return (
        !a && !(e instanceof Le)
          ? (t.resolution || (t.resolution = vs(e)),
            (a = new pt(new Le(e, t))),
            (a.baseTexture.cacheId = n),
            Le.addToCache(a.baseTexture, n),
            pt.addToCache(a, n))
          : !a && e instanceof Le && ((a = new pt(e)), pt.addToCache(a, n)),
        a
      );
    }
    static fromURL(e, t) {
      const i = Object.assign(
          { autoLoad: !1 },
          t == null ? void 0 : t.resourceOptions
        ),
        s = pt.from(e, Object.assign({ resourceOptions: i }, t), !1),
        n = s.baseTexture.resource;
      return s.baseTexture.valid
        ? Promise.resolve(s)
        : n.load().then(() => Promise.resolve(s));
    }
    static fromBuffer(e, t, i, s) {
      return new pt(Le.fromBuffer(e, t, i, s));
    }
    static fromLoader(e, t, i, s) {
      const n = new Le(
          e,
          Object.assign(
            { scaleMode: Le.defaultOptions.scaleMode, resolution: vs(t) },
            s
          )
        ),
        { resource: a } = n;
      a instanceof G1 && (a.url = t);
      const o = new pt(n);
      return (
        i || (i = t),
        Le.addToCache(o.baseTexture, i),
        pt.addToCache(o, i),
        i !== t && (Le.addToCache(o.baseTexture, t), pt.addToCache(o, t)),
        o.baseTexture.valid
          ? Promise.resolve(o)
          : new Promise((l) => {
              o.baseTexture.once("loaded", () => l(o));
            })
      );
    }
    static addToCache(e, t) {
      t &&
        (e.textureCacheIds.includes(t) || e.textureCacheIds.push(t),
        Si[t] &&
          Si[t] !== e &&
          console.warn(
            `Texture added to the cache with an id [${t}] that already had an entry`
          ),
        (Si[t] = e));
    }
    static removeFromCache(e) {
      if (typeof e == "string") {
        const t = Si[e];
        if (t) {
          const i = t.textureCacheIds.indexOf(e);
          return i > -1 && t.textureCacheIds.splice(i, 1), delete Si[e], t;
        }
      } else if (e != null && e.textureCacheIds) {
        for (let t = 0; t < e.textureCacheIds.length; ++t)
          Si[e.textureCacheIds[t]] === e && delete Si[e.textureCacheIds[t]];
        return (e.textureCacheIds.length = 0), e;
      }
      return null;
    }
    get resolution() {
      return this.baseTexture.resolution;
    }
    get frame() {
      return this._frame;
    }
    set frame(e) {
      (this._frame = e), (this.noFrame = !1);
      const { x: t, y: i, width: s, height: n } = e,
        a = t + s > this.baseTexture.width,
        o = i + n > this.baseTexture.height;
      if (a || o) {
        const l = a && o ? "and" : "or",
          h = `X: ${t} + ${s} = ${t + s} > ${this.baseTexture.width}`,
          c = `Y: ${i} + ${n} = ${i + n} > ${this.baseTexture.height}`;
        throw new Error(
          `Texture Error: frame does not fit inside the base Texture dimensions: ${h} ${l} ${c}`
        );
      }
      (this.valid = s && n && this.baseTexture.valid),
        !this.trim && !this.rotate && (this.orig = e),
        this.valid && this.updateUvs();
    }
    get rotate() {
      return this._rotate;
    }
    set rotate(e) {
      (this._rotate = e), this.valid && this.updateUvs();
    }
    get width() {
      return this.orig.width;
    }
    get height() {
      return this.orig.height;
    }
    castToBaseTexture() {
      return this.baseTexture;
    }
    static get EMPTY() {
      return (
        pt._EMPTY ||
          ((pt._EMPTY = new pt(new Le())),
          Kl(pt._EMPTY),
          Kl(pt._EMPTY.baseTexture)),
        pt._EMPTY
      );
    }
    static get WHITE() {
      if (!pt._WHITE) {
        const e = we.ADAPTER.createCanvas(16, 16),
          t = e.getContext("2d");
        (e.width = 16),
          (e.height = 16),
          (t.fillStyle = "white"),
          t.fillRect(0, 0, 16, 16),
          (pt._WHITE = new pt(Le.from(e))),
          Kl(pt._WHITE),
          Kl(pt._WHITE.baseTexture);
      }
      return pt._WHITE;
    }
  };
  class Gn extends ze {
    constructor(e, t) {
      super(e, t),
        (this.valid = !0),
        (this.filterFrame = null),
        (this.filterPoolKey = null),
        this.updateUvs();
    }
    get framebuffer() {
      return this.baseTexture.framebuffer;
    }
    get multisample() {
      return this.framebuffer.multisample;
    }
    set multisample(e) {
      this.framebuffer.multisample = e;
    }
    resize(e, t, i = !0) {
      const s = this.baseTexture.resolution,
        n = Math.round(e * s) / s,
        a = Math.round(t * s) / s;
      (this.valid = n > 0 && a > 0),
        (this._frame.width = this.orig.width = n),
        (this._frame.height = this.orig.height = a),
        i && this.baseTexture.resize(n, a),
        this.updateUvs();
    }
    setResolution(e) {
      const { baseTexture: t } = this;
      t.resolution !== e &&
        (t.setResolution(e), this.resize(t.width, t.height, !1));
    }
    static create(e) {
      return new Gn(new $1(e));
    }
  }
  class H1 {
    constructor(e) {
      (this.texturePool = {}),
        (this.textureOptions = e || {}),
        (this.enableFullScreen = !1),
        (this._pixelsWidth = 0),
        (this._pixelsHeight = 0);
    }
    createTexture(e, t, i = Ft.NONE) {
      const s = new $1(
        Object.assign(
          { width: e, height: t, resolution: 1, multisample: i },
          this.textureOptions
        )
      );
      return new Gn(s);
    }
    getOptimalTexture(e, t, i = 1, s = Ft.NONE) {
      let n;
      (e = Math.max(Math.ceil(e * i - 1e-6), 1)),
        (t = Math.max(Math.ceil(t * i - 1e-6), 1)),
        !this.enableFullScreen ||
        e !== this._pixelsWidth ||
        t !== this._pixelsHeight
          ? ((e = Hh(e)),
            (t = Hh(t)),
            (n = (((e & 65535) << 16) | (t & 65535)) >>> 0),
            s > 1 && (n += s * 4294967296))
          : (n = s > 1 ? -s : -1),
        this.texturePool[n] || (this.texturePool[n] = []);
      let a = this.texturePool[n].pop();
      return (
        a || (a = this.createTexture(e, t, s)),
        (a.filterPoolKey = n),
        a.setResolution(i),
        a
      );
    }
    getFilterTexture(e, t, i) {
      const s = this.getOptimalTexture(
        e.width,
        e.height,
        t || e.resolution,
        i || Ft.NONE
      );
      return (s.filterFrame = e.filterFrame), s;
    }
    returnTexture(e) {
      const t = e.filterPoolKey;
      (e.filterFrame = null), this.texturePool[t].push(e);
    }
    returnFilterTexture(e) {
      this.returnTexture(e);
    }
    clear(e) {
      if (((e = e !== !1), e))
        for (const t in this.texturePool) {
          const i = this.texturePool[t];
          if (i) for (let s = 0; s < i.length; s++) i[s].destroy(!0);
        }
      this.texturePool = {};
    }
    setScreenSize(e) {
      if (!(e.width === this._pixelsWidth && e.height === this._pixelsHeight)) {
        this.enableFullScreen = e.width > 0 && e.height > 0;
        for (const t in this.texturePool) {
          if (!(Number(t) < 0)) continue;
          const i = this.texturePool[t];
          if (i) for (let s = 0; s < i.length; s++) i[s].destroy(!0);
          this.texturePool[t] = [];
        }
        (this._pixelsWidth = e.width), (this._pixelsHeight = e.height);
      }
    }
  }
  H1.SCREEN_KEY = -1;
  class YN extends Yi {
    constructor() {
      super(),
        this.addAttribute(
          "aVertexPosition",
          new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])
        ).addIndex([0, 1, 3, 2]);
    }
  }
  class X1 extends Yi {
    constructor() {
      super(),
        (this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1])),
        (this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])),
        (this.vertexBuffer = new gt(this.vertices)),
        (this.uvBuffer = new gt(this.uvs)),
        this.addAttribute("aVertexPosition", this.vertexBuffer)
          .addAttribute("aTextureCoord", this.uvBuffer)
          .addIndex([0, 1, 2, 0, 2, 3]);
    }
    map(e, t) {
      let i = 0,
        s = 0;
      return (
        (this.uvs[0] = i),
        (this.uvs[1] = s),
        (this.uvs[2] = i + t.width / e.width),
        (this.uvs[3] = s),
        (this.uvs[4] = i + t.width / e.width),
        (this.uvs[5] = s + t.height / e.height),
        (this.uvs[6] = i),
        (this.uvs[7] = s + t.height / e.height),
        (i = t.x),
        (s = t.y),
        (this.vertices[0] = i),
        (this.vertices[1] = s),
        (this.vertices[2] = i + t.width),
        (this.vertices[3] = s),
        (this.vertices[4] = i + t.width),
        (this.vertices[5] = s + t.height),
        (this.vertices[6] = i),
        (this.vertices[7] = s + t.height),
        this.invalidate(),
        this
      );
    }
    invalidate() {
      return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
    }
  }
  class jN {
    constructor() {
      (this.renderTexture = null),
        (this.target = null),
        (this.legacy = !1),
        (this.resolution = 1),
        (this.multisample = Ft.NONE),
        (this.sourceFrame = new $e()),
        (this.destinationFrame = new $e()),
        (this.bindingSourceFrame = new $e()),
        (this.bindingDestinationFrame = new $e()),
        (this.filters = []),
        (this.transform = null);
    }
    clear() {
      (this.target = null), (this.filters = null), (this.renderTexture = null);
    }
  }
  const Zl = [new Je(), new Je(), new Je(), new Je()],
    Yu = new vt();
  class z1 {
    constructor(e) {
      (this.renderer = e),
        (this.defaultFilterStack = [{}]),
        (this.texturePool = new H1()),
        (this.statePool = []),
        (this.quad = new YN()),
        (this.quadUv = new X1()),
        (this.tempRect = new $e()),
        (this.activeState = {}),
        (this.globalUniforms = new di(
          {
            outputFrame: new $e(),
            inputSize: new Float32Array(4),
            inputPixel: new Float32Array(4),
            inputClamp: new Float32Array(4),
            resolution: 1,
            filterArea: new Float32Array(4),
            filterClamp: new Float32Array(4),
          },
          !0
        )),
        (this.forceClear = !1),
        (this.useMaxPadding = !1);
    }
    init() {
      this.texturePool.setScreenSize(this.renderer.view);
    }
    push(e, t) {
      const i = this.renderer,
        s = this.defaultFilterStack,
        n = this.statePool.pop() || new jN(),
        a = i.renderTexture;
      let o, l;
      if (a.current) {
        const v = a.current;
        (o = v.resolution), (l = v.multisample);
      } else (o = i.resolution), (l = i.multisample);
      let h = t[0].resolution || o,
        c = t[0].multisample ?? l,
        u = t[0].padding,
        d = t[0].autoFit,
        f = t[0].legacy ?? !0;
      for (let v = 1; v < t.length; v++) {
        const g = t[v];
        (h = Math.min(h, g.resolution || o)),
          (c = Math.min(c, g.multisample ?? l)),
          (u = this.useMaxPadding ? Math.max(u, g.padding) : u + g.padding),
          (d = d && g.autoFit),
          (f = f || (g.legacy ?? !0));
      }
      s.length === 1 && (this.defaultFilterStack[0].renderTexture = a.current),
        s.push(n),
        (n.resolution = h),
        (n.multisample = c),
        (n.legacy = f),
        (n.target = e),
        n.sourceFrame.copyFrom(e.filterArea || e.getBounds(!0)),
        n.sourceFrame.pad(u);
      const p = this.tempRect.copyFrom(a.sourceFrame);
      i.projection.transform &&
        this.transformAABB(Yu.copyFrom(i.projection.transform).invert(), p),
        d
          ? (n.sourceFrame.fit(p),
            (n.sourceFrame.width <= 0 || n.sourceFrame.height <= 0) &&
              ((n.sourceFrame.width = 0), (n.sourceFrame.height = 0)))
          : n.sourceFrame.intersects(p) ||
            ((n.sourceFrame.width = 0), (n.sourceFrame.height = 0)),
        this.roundFrame(
          n.sourceFrame,
          a.current ? a.current.resolution : i.resolution,
          a.sourceFrame,
          a.destinationFrame,
          i.projection.transform
        ),
        (n.renderTexture = this.getOptimalFilterTexture(
          n.sourceFrame.width,
          n.sourceFrame.height,
          h,
          c
        )),
        (n.filters = t),
        (n.destinationFrame.width = n.renderTexture.width),
        (n.destinationFrame.height = n.renderTexture.height);
      const m = this.tempRect;
      (m.x = 0),
        (m.y = 0),
        (m.width = n.sourceFrame.width),
        (m.height = n.sourceFrame.height),
        (n.renderTexture.filterFrame = n.sourceFrame),
        n.bindingSourceFrame.copyFrom(a.sourceFrame),
        n.bindingDestinationFrame.copyFrom(a.destinationFrame),
        (n.transform = i.projection.transform),
        (i.projection.transform = null),
        a.bind(n.renderTexture, n.sourceFrame, m),
        i.framebuffer.clear(0, 0, 0, 0);
    }
    pop() {
      const e = this.defaultFilterStack,
        t = e.pop(),
        i = t.filters;
      this.activeState = t;
      const s = this.globalUniforms.uniforms;
      (s.outputFrame = t.sourceFrame), (s.resolution = t.resolution);
      const n = s.inputSize,
        a = s.inputPixel,
        o = s.inputClamp;
      if (
        ((n[0] = t.destinationFrame.width),
        (n[1] = t.destinationFrame.height),
        (n[2] = 1 / n[0]),
        (n[3] = 1 / n[1]),
        (a[0] = Math.round(n[0] * t.resolution)),
        (a[1] = Math.round(n[1] * t.resolution)),
        (a[2] = 1 / a[0]),
        (a[3] = 1 / a[1]),
        (o[0] = 0.5 * a[2]),
        (o[1] = 0.5 * a[3]),
        (o[2] = t.sourceFrame.width * n[2] - 0.5 * a[2]),
        (o[3] = t.sourceFrame.height * n[3] - 0.5 * a[3]),
        t.legacy)
      ) {
        const h = s.filterArea;
        (h[0] = t.destinationFrame.width),
          (h[1] = t.destinationFrame.height),
          (h[2] = t.sourceFrame.x),
          (h[3] = t.sourceFrame.y),
          (s.filterClamp = s.inputClamp);
      }
      this.globalUniforms.update();
      const l = e[e.length - 1];
      if ((this.renderer.framebuffer.blit(), i.length === 1))
        i[0].apply(this, t.renderTexture, l.renderTexture, Oi.BLEND, t),
          this.returnFilterTexture(t.renderTexture);
      else {
        let h = t.renderTexture,
          c = this.getOptimalFilterTexture(h.width, h.height, t.resolution);
        c.filterFrame = h.filterFrame;
        let u = 0;
        for (u = 0; u < i.length - 1; ++u) {
          u === 1 &&
            t.multisample > 1 &&
            ((c = this.getOptimalFilterTexture(
              h.width,
              h.height,
              t.resolution
            )),
            (c.filterFrame = h.filterFrame)),
            i[u].apply(this, h, c, Oi.CLEAR, t);
          const d = h;
          (h = c), (c = d);
        }
        i[u].apply(this, h, l.renderTexture, Oi.BLEND, t),
          u > 1 &&
            t.multisample > 1 &&
            this.returnFilterTexture(t.renderTexture),
          this.returnFilterTexture(h),
          this.returnFilterTexture(c);
      }
      t.clear(), this.statePool.push(t);
    }
    bindAndClear(e, t = Oi.CLEAR) {
      const { renderTexture: i, state: s } = this.renderer;
      if (
        (e ===
        this.defaultFilterStack[this.defaultFilterStack.length - 1]
          .renderTexture
          ? (this.renderer.projection.transform = this.activeState.transform)
          : (this.renderer.projection.transform = null),
        e == null ? void 0 : e.filterFrame)
      ) {
        const a = this.tempRect;
        (a.x = 0),
          (a.y = 0),
          (a.width = e.filterFrame.width),
          (a.height = e.filterFrame.height),
          i.bind(e, e.filterFrame, a);
      } else
        e !==
        this.defaultFilterStack[this.defaultFilterStack.length - 1]
          .renderTexture
          ? i.bind(e)
          : this.renderer.renderTexture.bind(
              e,
              this.activeState.bindingSourceFrame,
              this.activeState.bindingDestinationFrame
            );
      const n = s.stateId & 1 || this.forceClear;
      (t === Oi.CLEAR || (t === Oi.BLIT && n)) &&
        this.renderer.framebuffer.clear(0, 0, 0, 0);
    }
    applyFilter(e, t, i, s) {
      const n = this.renderer;
      n.state.set(e.state),
        this.bindAndClear(i, s),
        (e.uniforms.uSampler = t),
        (e.uniforms.filterGlobals = this.globalUniforms),
        n.shader.bind(e),
        (e.legacy = !!e.program.attributeData.aTextureCoord),
        e.legacy
          ? (this.quadUv.map(t._frame, t.filterFrame),
            n.geometry.bind(this.quadUv),
            n.geometry.draw(Di.TRIANGLES))
          : (n.geometry.bind(this.quad), n.geometry.draw(Di.TRIANGLE_STRIP));
    }
    calculateSpriteMatrix(e, t) {
      const { sourceFrame: i, destinationFrame: s } = this.activeState,
        { orig: n } = t._texture,
        a = e.set(s.width, 0, 0, s.height, i.x, i.y),
        o = t.worldTransform.copyTo(vt.TEMP_MATRIX);
      return (
        o.invert(),
        a.prepend(o),
        a.scale(1 / n.width, 1 / n.height),
        a.translate(t.anchor.x, t.anchor.y),
        a
      );
    }
    destroy() {
      (this.renderer = null), this.texturePool.clear(!1);
    }
    getOptimalFilterTexture(e, t, i = 1, s = Ft.NONE) {
      return this.texturePool.getOptimalTexture(e, t, i, s);
    }
    getFilterTexture(e, t, i) {
      if (typeof e == "number") {
        const n = e;
        (e = t), (t = n);
      }
      e = e || this.activeState.renderTexture;
      const s = this.texturePool.getOptimalTexture(
        e.width,
        e.height,
        t || e.resolution,
        i || Ft.NONE
      );
      return (s.filterFrame = e.filterFrame), s;
    }
    returnFilterTexture(e) {
      this.texturePool.returnTexture(e);
    }
    emptyPool() {
      this.texturePool.clear(!0);
    }
    resize() {
      this.texturePool.setScreenSize(this.renderer.view);
    }
    transformAABB(e, t) {
      const i = Zl[0],
        s = Zl[1],
        n = Zl[2],
        a = Zl[3];
      i.set(t.left, t.top),
        s.set(t.left, t.bottom),
        n.set(t.right, t.top),
        a.set(t.right, t.bottom),
        e.apply(i, i),
        e.apply(s, s),
        e.apply(n, n),
        e.apply(a, a);
      const o = Math.min(i.x, s.x, n.x, a.x),
        l = Math.min(i.y, s.y, n.y, a.y),
        h = Math.max(i.x, s.x, n.x, a.x),
        c = Math.max(i.y, s.y, n.y, a.y);
      (t.x = o), (t.y = l), (t.width = h - o), (t.height = c - l);
    }
    roundFrame(e, t, i, s, n) {
      if (!(e.width <= 0 || e.height <= 0 || i.width <= 0 || i.height <= 0)) {
        if (n) {
          const { a, b: o, c: l, d: h } = n;
          if (
            (Math.abs(o) > 1e-4 || Math.abs(l) > 1e-4) &&
            (Math.abs(a) > 1e-4 || Math.abs(h) > 1e-4)
          )
            return;
        }
        (n = n ? Yu.copyFrom(n) : Yu.identity()),
          n
            .translate(-i.x, -i.y)
            .scale(s.width / i.width, s.height / i.height)
            .translate(s.x, s.y),
          this.transformAABB(n, e),
          e.ceil(t),
          this.transformAABB(n.invert(), e);
      }
    }
  }
  z1.extension = { type: me.RendererSystem, name: "filter" };
  Ce.add(z1);
  class qN {
    constructor(e) {
      (this.framebuffer = e),
        (this.stencil = null),
        (this.dirtyId = -1),
        (this.dirtyFormat = -1),
        (this.dirtySize = -1),
        (this.multisample = Ft.NONE),
        (this.msaaBuffer = null),
        (this.blitFramebuffer = null),
        (this.mipLevel = 0);
    }
  }
  const KN = new $e();
  class W1 {
    constructor(e) {
      (this.renderer = e),
        (this.managedFramebuffers = []),
        (this.unknownFramebuffer = new ff(10, 10)),
        (this.msaaSamples = null);
    }
    contextChange() {
      this.disposeAll(!0);
      const e = (this.gl = this.renderer.gl);
      if (
        ((this.CONTEXT_UID = this.renderer.CONTEXT_UID),
        (this.current = this.unknownFramebuffer),
        (this.viewport = new $e()),
        (this.hasMRT = !0),
        (this.writeDepthTexture = !0),
        this.renderer.context.webGLVersion === 1)
      ) {
        let t = this.renderer.context.extensions.drawBuffers,
          i = this.renderer.context.extensions.depthTexture;
        we.PREFER_ENV === $n.WEBGL_LEGACY && ((t = null), (i = null)),
          t
            ? (e.drawBuffers = (s) => t.drawBuffersWEBGL(s))
            : ((this.hasMRT = !1), (e.drawBuffers = () => {})),
          i || (this.writeDepthTexture = !1);
      } else
        this.msaaSamples = e.getInternalformatParameter(
          e.RENDERBUFFER,
          e.RGBA8,
          e.SAMPLES
        );
    }
    bind(e, t, i = 0) {
      const { gl: s } = this;
      if (e) {
        const n = e.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(e);
        this.current !== e &&
          ((this.current = e), s.bindFramebuffer(s.FRAMEBUFFER, n.framebuffer)),
          n.mipLevel !== i && (e.dirtyId++, e.dirtyFormat++, (n.mipLevel = i)),
          n.dirtyId !== e.dirtyId &&
            ((n.dirtyId = e.dirtyId),
            n.dirtyFormat !== e.dirtyFormat
              ? ((n.dirtyFormat = e.dirtyFormat),
                (n.dirtySize = e.dirtySize),
                this.updateFramebuffer(e, i))
              : n.dirtySize !== e.dirtySize &&
                ((n.dirtySize = e.dirtySize), this.resizeFramebuffer(e)));
        for (let a = 0; a < e.colorTextures.length; a++) {
          const o = e.colorTextures[a];
          this.renderer.texture.unbind(o.parentTextureArray || o);
        }
        if (
          (e.depthTexture && this.renderer.texture.unbind(e.depthTexture), t)
        ) {
          const a = t.width >> i,
            o = t.height >> i,
            l = a / t.width;
          this.setViewport(t.x * l, t.y * l, a, o);
        } else {
          const a = e.width >> i,
            o = e.height >> i;
          this.setViewport(0, 0, a, o);
        }
      } else
        this.current &&
          ((this.current = null), s.bindFramebuffer(s.FRAMEBUFFER, null)),
          t
            ? this.setViewport(t.x, t.y, t.width, t.height)
            : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
    }
    setViewport(e, t, i, s) {
      const n = this.viewport;
      (e = Math.round(e)),
        (t = Math.round(t)),
        (i = Math.round(i)),
        (s = Math.round(s)),
        (n.width !== i || n.height !== s || n.x !== e || n.y !== t) &&
          ((n.x = e),
          (n.y = t),
          (n.width = i),
          (n.height = s),
          this.gl.viewport(e, t, i, s));
    }
    get size() {
      return this.current
        ? { x: 0, y: 0, width: this.current.width, height: this.current.height }
        : {
            x: 0,
            y: 0,
            width: this.renderer.width,
            height: this.renderer.height,
          };
    }
    clear(e, t, i, s, n = Ud.COLOR | Ud.DEPTH) {
      const { gl: a } = this;
      a.clearColor(e, t, i, s), a.clear(n);
    }
    initFramebuffer(e) {
      const { gl: t } = this,
        i = new qN(t.createFramebuffer());
      return (
        (i.multisample = this.detectSamples(e.multisample)),
        (e.glFramebuffers[this.CONTEXT_UID] = i),
        this.managedFramebuffers.push(e),
        e.disposeRunner.add(this),
        i
      );
    }
    resizeFramebuffer(e) {
      const { gl: t } = this,
        i = e.glFramebuffers[this.CONTEXT_UID];
      if (i.stencil) {
        t.bindRenderbuffer(t.RENDERBUFFER, i.stencil);
        let a;
        this.renderer.context.webGLVersion === 1
          ? (a = t.DEPTH_STENCIL)
          : e.depth && e.stencil
          ? (a = t.DEPTH24_STENCIL8)
          : e.depth
          ? (a = t.DEPTH_COMPONENT24)
          : (a = t.STENCIL_INDEX8),
          i.msaaBuffer
            ? t.renderbufferStorageMultisample(
                t.RENDERBUFFER,
                i.multisample,
                a,
                e.width,
                e.height
              )
            : t.renderbufferStorage(t.RENDERBUFFER, a, e.width, e.height);
      }
      const s = e.colorTextures;
      let n = s.length;
      t.drawBuffers || (n = Math.min(n, 1));
      for (let a = 0; a < n; a++) {
        const o = s[a],
          l = o.parentTextureArray || o;
        this.renderer.texture.bind(l, 0),
          a === 0 &&
            i.msaaBuffer &&
            (t.bindRenderbuffer(t.RENDERBUFFER, i.msaaBuffer),
            t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              i.multisample,
              l._glTextures[this.CONTEXT_UID].internalFormat,
              e.width,
              e.height
            ));
      }
      e.depthTexture &&
        this.writeDepthTexture &&
        this.renderer.texture.bind(e.depthTexture, 0);
    }
    updateFramebuffer(e, t) {
      const { gl: i } = this,
        s = e.glFramebuffers[this.CONTEXT_UID],
        n = e.colorTextures;
      let a = n.length;
      i.drawBuffers || (a = Math.min(a, 1)),
        s.multisample > 1 && this.canMultisampleFramebuffer(e)
          ? (s.msaaBuffer = s.msaaBuffer || i.createRenderbuffer())
          : s.msaaBuffer &&
            (i.deleteRenderbuffer(s.msaaBuffer),
            (s.msaaBuffer = null),
            s.blitFramebuffer &&
              (s.blitFramebuffer.dispose(), (s.blitFramebuffer = null)));
      const o = [];
      for (let l = 0; l < a; l++) {
        const h = n[l],
          c = h.parentTextureArray || h;
        this.renderer.texture.bind(c, 0),
          l === 0 && s.msaaBuffer
            ? (i.bindRenderbuffer(i.RENDERBUFFER, s.msaaBuffer),
              i.renderbufferStorageMultisample(
                i.RENDERBUFFER,
                s.multisample,
                c._glTextures[this.CONTEXT_UID].internalFormat,
                e.width,
                e.height
              ),
              i.framebufferRenderbuffer(
                i.FRAMEBUFFER,
                i.COLOR_ATTACHMENT0,
                i.RENDERBUFFER,
                s.msaaBuffer
              ))
            : (i.framebufferTexture2D(
                i.FRAMEBUFFER,
                i.COLOR_ATTACHMENT0 + l,
                h.target,
                c._glTextures[this.CONTEXT_UID].texture,
                t
              ),
              o.push(i.COLOR_ATTACHMENT0 + l));
      }
      if (
        (o.length > 1 && i.drawBuffers(o),
        e.depthTexture && this.writeDepthTexture)
      ) {
        const l = e.depthTexture;
        this.renderer.texture.bind(l, 0),
          i.framebufferTexture2D(
            i.FRAMEBUFFER,
            i.DEPTH_ATTACHMENT,
            i.TEXTURE_2D,
            l._glTextures[this.CONTEXT_UID].texture,
            t
          );
      }
      if (
        (e.stencil || e.depth) &&
        !(e.depthTexture && this.writeDepthTexture)
      ) {
        s.stencil = s.stencil || i.createRenderbuffer();
        let l, h;
        this.renderer.context.webGLVersion === 1
          ? ((l = i.DEPTH_STENCIL_ATTACHMENT), (h = i.DEPTH_STENCIL))
          : e.depth && e.stencil
          ? ((l = i.DEPTH_STENCIL_ATTACHMENT), (h = i.DEPTH24_STENCIL8))
          : e.depth
          ? ((l = i.DEPTH_ATTACHMENT), (h = i.DEPTH_COMPONENT24))
          : ((l = i.STENCIL_ATTACHMENT), (h = i.STENCIL_INDEX8)),
          i.bindRenderbuffer(i.RENDERBUFFER, s.stencil),
          s.msaaBuffer
            ? i.renderbufferStorageMultisample(
                i.RENDERBUFFER,
                s.multisample,
                h,
                e.width,
                e.height
              )
            : i.renderbufferStorage(i.RENDERBUFFER, h, e.width, e.height),
          i.framebufferRenderbuffer(
            i.FRAMEBUFFER,
            l,
            i.RENDERBUFFER,
            s.stencil
          );
      } else s.stencil && (i.deleteRenderbuffer(s.stencil), (s.stencil = null));
    }
    canMultisampleFramebuffer(e) {
      return (
        this.renderer.context.webGLVersion !== 1 &&
        e.colorTextures.length <= 1 &&
        !e.depthTexture
      );
    }
    detectSamples(e) {
      const { msaaSamples: t } = this;
      let i = Ft.NONE;
      if (e <= 1 || t === null) return i;
      for (let s = 0; s < t.length; s++)
        if (t[s] <= e) {
          i = t[s];
          break;
        }
      return i === 1 && (i = Ft.NONE), i;
    }
    blit(e, t, i) {
      const { current: s, renderer: n, gl: a, CONTEXT_UID: o } = this;
      if (n.context.webGLVersion !== 2 || !s) return;
      const l = s.glFramebuffers[o];
      if (!l) return;
      if (!e) {
        if (!l.msaaBuffer) return;
        const c = s.colorTextures[0];
        if (!c) return;
        l.blitFramebuffer ||
          ((l.blitFramebuffer = new ff(s.width, s.height)),
          l.blitFramebuffer.addColorTexture(0, c)),
          (e = l.blitFramebuffer),
          e.colorTextures[0] !== c &&
            ((e.colorTextures[0] = c), e.dirtyId++, e.dirtyFormat++),
          (e.width !== s.width || e.height !== s.height) &&
            ((e.width = s.width),
            (e.height = s.height),
            e.dirtyId++,
            e.dirtySize++);
      }
      t || ((t = KN), (t.width = s.width), (t.height = s.height)), i || (i = t);
      const h = t.width === i.width && t.height === i.height;
      this.bind(e),
        a.bindFramebuffer(a.READ_FRAMEBUFFER, l.framebuffer),
        a.blitFramebuffer(
          t.left,
          t.top,
          t.right,
          t.bottom,
          i.left,
          i.top,
          i.right,
          i.bottom,
          a.COLOR_BUFFER_BIT,
          h ? a.NEAREST : a.LINEAR
        ),
        a.bindFramebuffer(
          a.READ_FRAMEBUFFER,
          e.glFramebuffers[this.CONTEXT_UID].framebuffer
        );
    }
    disposeFramebuffer(e, t) {
      const i = e.glFramebuffers[this.CONTEXT_UID],
        s = this.gl;
      if (!i) return;
      delete e.glFramebuffers[this.CONTEXT_UID];
      const n = this.managedFramebuffers.indexOf(e);
      n >= 0 && this.managedFramebuffers.splice(n, 1),
        e.disposeRunner.remove(this),
        t ||
          (s.deleteFramebuffer(i.framebuffer),
          i.msaaBuffer && s.deleteRenderbuffer(i.msaaBuffer),
          i.stencil && s.deleteRenderbuffer(i.stencil)),
        i.blitFramebuffer && this.disposeFramebuffer(i.blitFramebuffer, t);
    }
    disposeAll(e) {
      const t = this.managedFramebuffers;
      this.managedFramebuffers = [];
      for (let i = 0; i < t.length; i++) this.disposeFramebuffer(t[i], e);
    }
    forceStencil() {
      const e = this.current;
      if (!e) return;
      const t = e.glFramebuffers[this.CONTEXT_UID];
      if (!t || (t.stencil && e.stencil)) return;
      e.stencil = !0;
      const i = e.width,
        s = e.height,
        n = this.gl,
        a = (t.stencil = n.createRenderbuffer());
      n.bindRenderbuffer(n.RENDERBUFFER, a);
      let o, l;
      this.renderer.context.webGLVersion === 1
        ? ((o = n.DEPTH_STENCIL_ATTACHMENT), (l = n.DEPTH_STENCIL))
        : e.depth
        ? ((o = n.DEPTH_STENCIL_ATTACHMENT), (l = n.DEPTH24_STENCIL8))
        : ((o = n.STENCIL_ATTACHMENT), (l = n.STENCIL_INDEX8)),
        t.msaaBuffer
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              t.multisample,
              l,
              i,
              s
            )
          : n.renderbufferStorage(n.RENDERBUFFER, l, i, s),
        n.framebufferRenderbuffer(n.FRAMEBUFFER, o, n.RENDERBUFFER, a);
    }
    reset() {
      (this.current = this.unknownFramebuffer), (this.viewport = new $e());
    }
    destroy() {
      this.renderer = null;
    }
  }
  W1.extension = { type: me.RendererSystem, name: "framebuffer" };
  Ce.add(W1);
  const ju = { 5126: 4, 5123: 2, 5121: 1 };
  class Y1 {
    constructor(e) {
      (this.renderer = e),
        (this._activeGeometry = null),
        (this._activeVao = null),
        (this.hasVao = !0),
        (this.hasInstance = !0),
        (this.canUseUInt32ElementIndex = !1),
        (this.managedGeometries = {});
    }
    contextChange() {
      this.disposeAll(!0);
      const e = (this.gl = this.renderer.gl),
        t = this.renderer.context;
      if (
        ((this.CONTEXT_UID = this.renderer.CONTEXT_UID), t.webGLVersion !== 2)
      ) {
        let i = this.renderer.context.extensions.vertexArrayObject;
        we.PREFER_ENV === $n.WEBGL_LEGACY && (i = null),
          i
            ? ((e.createVertexArray = () => i.createVertexArrayOES()),
              (e.bindVertexArray = (s) => i.bindVertexArrayOES(s)),
              (e.deleteVertexArray = (s) => i.deleteVertexArrayOES(s)))
            : ((this.hasVao = !1),
              (e.createVertexArray = () => null),
              (e.bindVertexArray = () => null),
              (e.deleteVertexArray = () => null));
      }
      if (t.webGLVersion !== 2) {
        const i = e.getExtension("ANGLE_instanced_arrays");
        i
          ? ((e.vertexAttribDivisor = (s, n) =>
              i.vertexAttribDivisorANGLE(s, n)),
            (e.drawElementsInstanced = (s, n, a, o, l) =>
              i.drawElementsInstancedANGLE(s, n, a, o, l)),
            (e.drawArraysInstanced = (s, n, a, o) =>
              i.drawArraysInstancedANGLE(s, n, a, o)))
          : (this.hasInstance = !1);
      }
      this.canUseUInt32ElementIndex =
        t.webGLVersion === 2 || !!t.extensions.uint32ElementIndex;
    }
    bind(e, t) {
      t = t || this.renderer.shader.shader;
      const { gl: i } = this;
      let s = e.glVertexArrayObjects[this.CONTEXT_UID],
        n = !1;
      s ||
        ((this.managedGeometries[e.id] = e),
        e.disposeRunner.add(this),
        (e.glVertexArrayObjects[this.CONTEXT_UID] = s = {}),
        (n = !0));
      const a = s[t.program.id] || this.initGeometryVao(e, t, n);
      (this._activeGeometry = e),
        this._activeVao !== a &&
          ((this._activeVao = a),
          this.hasVao ? i.bindVertexArray(a) : this.activateVao(e, t.program)),
        this.updateBuffers();
    }
    reset() {
      this.unbind();
    }
    updateBuffers() {
      const e = this._activeGeometry,
        t = this.renderer.buffer;
      for (let i = 0; i < e.buffers.length; i++) {
        const s = e.buffers[i];
        t.update(s);
      }
    }
    checkCompatibility(e, t) {
      const i = e.attributes,
        s = t.attributeData;
      for (const n in s)
        if (!i[n])
          throw new Error(
            `shader and geometry incompatible, geometry missing the "${n}" attribute`
          );
    }
    getSignature(e, t) {
      const i = e.attributes,
        s = t.attributeData,
        n = ["g", e.id];
      for (const a in i) s[a] && n.push(a, s[a].location);
      return n.join("-");
    }
    initGeometryVao(e, t, i = !0) {
      const s = this.gl,
        n = this.CONTEXT_UID,
        a = this.renderer.buffer,
        o = t.program;
      o.glPrograms[n] || this.renderer.shader.generateProgram(t),
        this.checkCompatibility(e, o);
      const l = this.getSignature(e, o),
        h = e.glVertexArrayObjects[this.CONTEXT_UID];
      let c = h[l];
      if (c) return (h[o.id] = c), c;
      const u = e.buffers,
        d = e.attributes,
        f = {},
        p = {};
      for (const m in u) (f[m] = 0), (p[m] = 0);
      for (const m in d)
        !d[m].size && o.attributeData[m]
          ? (d[m].size = o.attributeData[m].size)
          : d[m].size ||
            console.warn(
              `PIXI Geometry attribute '${m}' size cannot be determined (likely the bound shader does not have the attribute)`
            ),
          (f[d[m].buffer] += d[m].size * ju[d[m].type]);
      for (const m in d) {
        const v = d[m],
          g = v.size;
        v.stride === void 0 &&
          (f[v.buffer] === g * ju[v.type]
            ? (v.stride = 0)
            : (v.stride = f[v.buffer])),
          v.start === void 0 &&
            ((v.start = p[v.buffer]), (p[v.buffer] += g * ju[v.type]));
      }
      (c = s.createVertexArray()), s.bindVertexArray(c);
      for (let m = 0; m < u.length; m++) {
        const v = u[m];
        a.bind(v), i && v._glBuffers[n].refCount++;
      }
      return (
        this.activateVao(e, o),
        (h[o.id] = c),
        (h[l] = c),
        s.bindVertexArray(null),
        a.unbind(Gi.ARRAY_BUFFER),
        c
      );
    }
    disposeGeometry(e, t) {
      var o;
      if (!this.managedGeometries[e.id]) return;
      delete this.managedGeometries[e.id];
      const i = e.glVertexArrayObjects[this.CONTEXT_UID],
        s = this.gl,
        n = e.buffers,
        a = (o = this.renderer) == null ? void 0 : o.buffer;
      if ((e.disposeRunner.remove(this), !!i)) {
        if (a)
          for (let l = 0; l < n.length; l++) {
            const h = n[l]._glBuffers[this.CONTEXT_UID];
            h && (h.refCount--, h.refCount === 0 && !t && a.dispose(n[l], t));
          }
        if (!t) {
          for (const l in i)
            if (l[0] === "g") {
              const h = i[l];
              this._activeVao === h && this.unbind(), s.deleteVertexArray(h);
            }
        }
        delete e.glVertexArrayObjects[this.CONTEXT_UID];
      }
    }
    disposeAll(e) {
      const t = Object.keys(this.managedGeometries);
      for (let i = 0; i < t.length; i++)
        this.disposeGeometry(this.managedGeometries[t[i]], e);
    }
    activateVao(e, t) {
      const i = this.gl,
        s = this.CONTEXT_UID,
        n = this.renderer.buffer,
        a = e.buffers,
        o = e.attributes;
      e.indexBuffer && n.bind(e.indexBuffer);
      let l = null;
      for (const h in o) {
        const c = o[h],
          u = a[c.buffer],
          d = u._glBuffers[s];
        if (t.attributeData[h]) {
          l !== d && (n.bind(u), (l = d));
          const f = t.attributeData[h].location;
          if (
            (i.enableVertexAttribArray(f),
            i.vertexAttribPointer(
              f,
              c.size,
              c.type || i.FLOAT,
              c.normalized,
              c.stride,
              c.start
            ),
            c.instance)
          )
            if (this.hasInstance) i.vertexAttribDivisor(f, c.divisor);
            else
              throw new Error(
                "geometry error, GPU Instancing is not supported on this device"
              );
        }
      }
    }
    draw(e, t, i, s) {
      const { gl: n } = this,
        a = this._activeGeometry;
      if (a.indexBuffer) {
        const o = a.indexBuffer.data.BYTES_PER_ELEMENT,
          l = o === 2 ? n.UNSIGNED_SHORT : n.UNSIGNED_INT;
        o === 2 || (o === 4 && this.canUseUInt32ElementIndex)
          ? a.instanced
            ? n.drawElementsInstanced(
                e,
                t || a.indexBuffer.data.length,
                l,
                (i || 0) * o,
                s || 1
              )
            : n.drawElements(e, t || a.indexBuffer.data.length, l, (i || 0) * o)
          : console.warn("unsupported index buffer type: uint32");
      } else
        a.instanced
          ? n.drawArraysInstanced(e, i, t || a.getSize(), s || 1)
          : n.drawArrays(e, i, t || a.getSize());
      return this;
    }
    unbind() {
      this.gl.bindVertexArray(null),
        (this._activeVao = null),
        (this._activeGeometry = null);
    }
    destroy() {
      this.renderer = null;
    }
  }
  Y1.extension = { type: me.RendererSystem, name: "geometry" };
  Ce.add(Y1);
  const Bv = new vt();
  class sm {
    constructor(e, t) {
      (this._texture = e),
        (this.mapCoord = new vt()),
        (this.uClampFrame = new Float32Array(4)),
        (this.uClampOffset = new Float32Array(2)),
        (this._textureID = -1),
        (this._updateID = 0),
        (this.clampOffset = 0),
        (this.clampMargin = typeof t > "u" ? 0.5 : t),
        (this.isSimple = !1);
    }
    get texture() {
      return this._texture;
    }
    set texture(e) {
      (this._texture = e), (this._textureID = -1);
    }
    multiplyUvs(e, t) {
      t === void 0 && (t = e);
      const i = this.mapCoord;
      for (let s = 0; s < e.length; s += 2) {
        const n = e[s],
          a = e[s + 1];
        (t[s] = n * i.a + a * i.c + i.tx),
          (t[s + 1] = n * i.b + a * i.d + i.ty);
      }
      return t;
    }
    update(e) {
      const t = this._texture;
      if (!t || !t.valid || (!e && this._textureID === t._updateID)) return !1;
      (this._textureID = t._updateID), this._updateID++;
      const i = t._uvs;
      this.mapCoord.set(
        i.x1 - i.x0,
        i.y1 - i.y0,
        i.x3 - i.x0,
        i.y3 - i.y0,
        i.x0,
        i.y0
      );
      const s = t.orig,
        n = t.trim;
      n &&
        (Bv.set(
          s.width / n.width,
          0,
          0,
          s.height / n.height,
          -n.x / n.width,
          -n.y / n.height
        ),
        this.mapCoord.append(Bv));
      const a = t.baseTexture,
        o = this.uClampFrame,
        l = this.clampMargin / a.resolution,
        h = this.clampOffset;
      return (
        (o[0] = (t._frame.x + l + h) / a.width),
        (o[1] = (t._frame.y + l + h) / a.height),
        (o[2] = (t._frame.x + t._frame.width - l + h) / a.width),
        (o[3] = (t._frame.y + t._frame.height - l + h) / a.height),
        (this.uClampOffset[0] = h / a.realWidth),
        (this.uClampOffset[1] = h / a.realHeight),
        (this.isSimple =
          t._frame.width === a.width &&
          t._frame.height === a.height &&
          t.rotate === 0),
        !0
      );
    }
  }
  var ZN = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`,
    JN = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`;
  class QN extends fr {
    constructor(e, t, i) {
      let s = null;
      typeof e != "string" &&
        t === void 0 &&
        i === void 0 &&
        ((s = e), (e = void 0), (t = void 0), (i = void 0)),
        super(e || JN, t || ZN, i),
        (this.maskSprite = s),
        (this.maskMatrix = new vt());
    }
    get maskSprite() {
      return this._maskSprite;
    }
    set maskSprite(e) {
      (this._maskSprite = e),
        this._maskSprite && (this._maskSprite.renderable = !1);
    }
    apply(e, t, i, s) {
      const n = this._maskSprite,
        a = n._texture;
      a.valid &&
        (a.uvMatrix || (a.uvMatrix = new sm(a, 0)),
        a.uvMatrix.update(),
        (this.uniforms.npmAlpha = a.baseTexture.alphaMode ? 0 : 1),
        (this.uniforms.mask = a),
        (this.uniforms.otherMatrix = e
          .calculateSpriteMatrix(this.maskMatrix, n)
          .prepend(a.uvMatrix.mapCoord)),
        (this.uniforms.alpha = n.worldAlpha),
        (this.uniforms.maskClamp = a.uvMatrix.uClampFrame),
        e.applyFilter(this, t, i, s));
    }
  }
  class e4 {
    constructor(e = null) {
      (this.type = Lt.NONE),
        (this.autoDetect = !0),
        (this.maskObject = e || null),
        (this.pooled = !1),
        (this.isMaskData = !0),
        (this.resolution = null),
        (this.multisample = fr.defaultMultisample),
        (this.enabled = !0),
        (this.colorMask = 15),
        (this._filters = null),
        (this._stencilCounter = 0),
        (this._scissorCounter = 0),
        (this._scissorRect = null),
        (this._scissorRectLocal = null),
        (this._colorMask = 15),
        (this._target = null);
    }
    get filter() {
      return this._filters ? this._filters[0] : null;
    }
    set filter(e) {
      e
        ? this._filters
          ? (this._filters[0] = e)
          : (this._filters = [e])
        : (this._filters = null);
    }
    reset() {
      this.pooled &&
        ((this.maskObject = null),
        (this.type = Lt.NONE),
        (this.autoDetect = !0)),
        (this._target = null),
        (this._scissorRectLocal = null);
    }
    copyCountersOrReset(e) {
      e
        ? ((this._stencilCounter = e._stencilCounter),
          (this._scissorCounter = e._scissorCounter),
          (this._scissorRect = e._scissorRect))
        : ((this._stencilCounter = 0),
          (this._scissorCounter = 0),
          (this._scissorRect = null));
    }
  }
  class j1 {
    constructor(e) {
      (this.renderer = e),
        (this.enableScissor = !0),
        (this.alphaMaskPool = []),
        (this.maskDataPool = []),
        (this.maskStack = []),
        (this.alphaMaskIndex = 0);
    }
    setMaskStack(e) {
      (this.maskStack = e),
        this.renderer.scissor.setMaskStack(e),
        this.renderer.stencil.setMaskStack(e);
    }
    push(e, t) {
      let i = t;
      if (!i.isMaskData) {
        const n = this.maskDataPool.pop() || new e4();
        (n.pooled = !0), (n.maskObject = t), (i = n);
      }
      const s =
        this.maskStack.length !== 0
          ? this.maskStack[this.maskStack.length - 1]
          : null;
      if (
        (i.copyCountersOrReset(s),
        (i._colorMask = s ? s._colorMask : 15),
        i.autoDetect && this.detect(i),
        (i._target = e),
        i.type !== Lt.SPRITE && this.maskStack.push(i),
        i.enabled)
      )
        switch (i.type) {
          case Lt.SCISSOR:
            this.renderer.scissor.push(i);
            break;
          case Lt.STENCIL:
            this.renderer.stencil.push(i);
            break;
          case Lt.SPRITE:
            i.copyCountersOrReset(null), this.pushSpriteMask(i);
            break;
          case Lt.COLOR:
            this.pushColorMask(i);
            break;
        }
      i.type === Lt.SPRITE && this.maskStack.push(i);
    }
    pop(e) {
      const t = this.maskStack.pop();
      if (!(!t || t._target !== e)) {
        if (t.enabled)
          switch (t.type) {
            case Lt.SCISSOR:
              this.renderer.scissor.pop(t);
              break;
            case Lt.STENCIL:
              this.renderer.stencil.pop(t.maskObject);
              break;
            case Lt.SPRITE:
              this.popSpriteMask(t);
              break;
            case Lt.COLOR:
              this.popColorMask(t);
              break;
          }
        if (
          (t.reset(),
          t.pooled && this.maskDataPool.push(t),
          this.maskStack.length !== 0)
        ) {
          const i = this.maskStack[this.maskStack.length - 1];
          i.type === Lt.SPRITE &&
            i._filters &&
            (i._filters[0].maskSprite = i.maskObject);
        }
      }
    }
    detect(e) {
      const t = e.maskObject;
      t
        ? t.isSprite
          ? (e.type = Lt.SPRITE)
          : this.enableScissor && this.renderer.scissor.testScissor(e)
          ? (e.type = Lt.SCISSOR)
          : (e.type = Lt.STENCIL)
        : (e.type = Lt.COLOR);
    }
    pushSpriteMask(e) {
      const { maskObject: t } = e,
        i = e._target;
      let s = e._filters;
      s ||
        ((s = this.alphaMaskPool[this.alphaMaskIndex]),
        s || (s = this.alphaMaskPool[this.alphaMaskIndex] = [new QN()])),
        (s[0].resolution = e.resolution),
        (s[0].multisample = e.multisample),
        (s[0].maskSprite = t);
      const n = i.filterArea;
      (i.filterArea = t.getBounds(!0)),
        this.renderer.filter.push(i, s),
        (i.filterArea = n),
        e._filters || this.alphaMaskIndex++;
    }
    popSpriteMask(e) {
      this.renderer.filter.pop(),
        e._filters
          ? (e._filters[0].maskSprite = null)
          : (this.alphaMaskIndex--,
            (this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null));
    }
    pushColorMask(e) {
      const t = e._colorMask,
        i = (e._colorMask = t & e.colorMask);
      i !== t &&
        this.renderer.gl.colorMask(
          (i & 1) !== 0,
          (i & 2) !== 0,
          (i & 4) !== 0,
          (i & 8) !== 0
        );
    }
    popColorMask(e) {
      const t = e._colorMask,
        i =
          this.maskStack.length > 0
            ? this.maskStack[this.maskStack.length - 1]._colorMask
            : 15;
      i !== t &&
        this.renderer.gl.colorMask(
          (i & 1) !== 0,
          (i & 2) !== 0,
          (i & 4) !== 0,
          (i & 8) !== 0
        );
    }
    destroy() {
      this.renderer = null;
    }
  }
  j1.extension = { type: me.RendererSystem, name: "mask" };
  Ce.add(j1);
  class q1 {
    constructor(e) {
      (this.renderer = e), (this.maskStack = []), (this.glConst = 0);
    }
    getStackLength() {
      return this.maskStack.length;
    }
    setMaskStack(e) {
      const { gl: t } = this.renderer,
        i = this.getStackLength();
      this.maskStack = e;
      const s = this.getStackLength();
      s !== i &&
        (s === 0
          ? t.disable(this.glConst)
          : (t.enable(this.glConst), this._useCurrent()));
    }
    _useCurrent() {}
    destroy() {
      (this.renderer = null), (this.maskStack = null);
    }
  }
  const Ov = new vt(),
    kv = [],
    K1 = class yh extends q1 {
      constructor(e) {
        super(e),
          (this.glConst = we.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST);
      }
      getStackLength() {
        const e = this.maskStack[this.maskStack.length - 1];
        return e ? e._scissorCounter : 0;
      }
      calcScissorRect(e) {
        if (e._scissorRectLocal) return;
        const t = e._scissorRect,
          { maskObject: i } = e,
          { renderer: s } = this,
          n = s.renderTexture,
          a = i.getBounds(!0, kv.pop() ?? new $e());
        this.roundFrameToPixels(
          a,
          n.current ? n.current.resolution : s.resolution,
          n.sourceFrame,
          n.destinationFrame,
          s.projection.transform
        ),
          t && a.fit(t),
          (e._scissorRectLocal = a);
      }
      static isMatrixRotated(e) {
        if (!e) return !1;
        const { a: t, b: i, c: s, d: n } = e;
        return (
          (Math.abs(i) > 1e-4 || Math.abs(s) > 1e-4) &&
          (Math.abs(t) > 1e-4 || Math.abs(n) > 1e-4)
        );
      }
      testScissor(e) {
        const { maskObject: t } = e;
        if (
          !t.isFastRect ||
          !t.isFastRect() ||
          yh.isMatrixRotated(t.worldTransform) ||
          yh.isMatrixRotated(this.renderer.projection.transform)
        )
          return !1;
        this.calcScissorRect(e);
        const i = e._scissorRectLocal;
        return i.width > 0 && i.height > 0;
      }
      roundFrameToPixels(e, t, i, s, n) {
        yh.isMatrixRotated(n) ||
          ((n = n ? Ov.copyFrom(n) : Ov.identity()),
          n
            .translate(-i.x, -i.y)
            .scale(s.width / i.width, s.height / i.height)
            .translate(s.x, s.y),
          this.renderer.filter.transformAABB(n, e),
          e.fit(s),
          (e.x = Math.round(e.x * t)),
          (e.y = Math.round(e.y * t)),
          (e.width = Math.round(e.width * t)),
          (e.height = Math.round(e.height * t)));
      }
      push(e) {
        e._scissorRectLocal || this.calcScissorRect(e);
        const { gl: t } = this.renderer;
        e._scissorRect || t.enable(t.SCISSOR_TEST),
          e._scissorCounter++,
          (e._scissorRect = e._scissorRectLocal),
          this._useCurrent();
      }
      pop(e) {
        const { gl: t } = this.renderer;
        e && kv.push(e._scissorRectLocal),
          this.getStackLength() > 0
            ? this._useCurrent()
            : t.disable(t.SCISSOR_TEST);
      }
      _useCurrent() {
        const e = this.maskStack[this.maskStack.length - 1]._scissorRect;
        let t;
        this.renderer.renderTexture.current
          ? (t = e.y)
          : (t = this.renderer.height - e.height - e.y),
          this.renderer.gl.scissor(e.x, t, e.width, e.height);
      }
    };
  K1.extension = { type: me.RendererSystem, name: "scissor" };
  let t4 = K1;
  Ce.add(t4);
  class Z1 extends q1 {
    constructor(e) {
      super(e),
        (this.glConst = we.ADAPTER.getWebGLRenderingContext().STENCIL_TEST);
    }
    getStackLength() {
      const e = this.maskStack[this.maskStack.length - 1];
      return e ? e._stencilCounter : 0;
    }
    push(e) {
      const t = e.maskObject,
        { gl: i } = this.renderer,
        s = e._stencilCounter;
      s === 0 &&
        (this.renderer.framebuffer.forceStencil(),
        i.clearStencil(0),
        i.clear(i.STENCIL_BUFFER_BIT),
        i.enable(i.STENCIL_TEST)),
        e._stencilCounter++;
      const n = e._colorMask;
      n !== 0 && ((e._colorMask = 0), i.colorMask(!1, !1, !1, !1)),
        i.stencilFunc(i.EQUAL, s, 4294967295),
        i.stencilOp(i.KEEP, i.KEEP, i.INCR),
        (t.renderable = !0),
        t.render(this.renderer),
        this.renderer.batch.flush(),
        (t.renderable = !1),
        n !== 0 &&
          ((e._colorMask = n),
          i.colorMask(
            (n & 1) !== 0,
            (n & 2) !== 0,
            (n & 4) !== 0,
            (n & 8) !== 0
          )),
        this._useCurrent();
    }
    pop(e) {
      const t = this.renderer.gl;
      if (this.getStackLength() === 0) t.disable(t.STENCIL_TEST);
      else {
        const i =
            this.maskStack.length !== 0
              ? this.maskStack[this.maskStack.length - 1]
              : null,
          s = i ? i._colorMask : 15;
        s !== 0 && ((i._colorMask = 0), t.colorMask(!1, !1, !1, !1)),
          t.stencilOp(t.KEEP, t.KEEP, t.DECR),
          (e.renderable = !0),
          e.render(this.renderer),
          this.renderer.batch.flush(),
          (e.renderable = !1),
          s !== 0 &&
            ((i._colorMask = s),
            t.colorMask(
              (s & 1) !== 0,
              (s & 2) !== 0,
              (s & 4) !== 0,
              (s & 8) !== 0
            )),
          this._useCurrent();
      }
    }
    _useCurrent() {
      const e = this.renderer.gl;
      e.stencilFunc(e.EQUAL, this.getStackLength(), 4294967295),
        e.stencilOp(e.KEEP, e.KEEP, e.KEEP);
    }
  }
  Z1.extension = { type: me.RendererSystem, name: "stencil" };
  Ce.add(Z1);
  class J1 {
    constructor(e) {
      (this.renderer = e),
        (this.plugins = {}),
        Object.defineProperties(this.plugins, {
          extract: {
            enumerable: !1,
            get() {
              return (
                We(
                  "7.0.0",
                  "renderer.plugins.extract has moved to renderer.extract"
                ),
                e.extract
              );
            },
          },
          prepare: {
            enumerable: !1,
            get() {
              return (
                We(
                  "7.0.0",
                  "renderer.plugins.prepare has moved to renderer.prepare"
                ),
                e.prepare
              );
            },
          },
          interaction: {
            enumerable: !1,
            get() {
              return (
                We(
                  "7.0.0",
                  "renderer.plugins.interaction has been deprecated, use renderer.events"
                ),
                e.events
              );
            },
          },
        });
    }
    init() {
      const e = this.rendererPlugins;
      for (const t in e) this.plugins[t] = new e[t](this.renderer);
    }
    destroy() {
      for (const e in this.plugins)
        this.plugins[e].destroy(), (this.plugins[e] = null);
    }
  }
  J1.extension = {
    type: [me.RendererSystem, me.CanvasRendererSystem],
    name: "_plugin",
  };
  Ce.add(J1);
  class Q1 {
    constructor(e) {
      (this.renderer = e),
        (this.destinationFrame = null),
        (this.sourceFrame = null),
        (this.defaultFrame = null),
        (this.projectionMatrix = new vt()),
        (this.transform = null);
    }
    update(e, t, i, s) {
      (this.destinationFrame = e || this.destinationFrame || this.defaultFrame),
        (this.sourceFrame = t || this.sourceFrame || e),
        this.calculateProjection(this.destinationFrame, this.sourceFrame, i, s),
        this.transform && this.projectionMatrix.append(this.transform);
      const n = this.renderer;
      (n.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix),
        n.globalUniforms.update(),
        n.shader.shader &&
          n.shader.syncUniformGroup(n.shader.shader.uniforms.globals);
    }
    calculateProjection(e, t, i, s) {
      const n = this.projectionMatrix,
        a = s ? -1 : 1;
      n.identity(),
        (n.a = (1 / t.width) * 2),
        (n.d = a * ((1 / t.height) * 2)),
        (n.tx = -1 - t.x * n.a),
        (n.ty = -a - t.y * n.d);
    }
    setTransform(e) {}
    destroy() {
      this.renderer = null;
    }
  }
  Q1.extension = { type: me.RendererSystem, name: "projection" };
  Ce.add(Q1);
  const r4 = new rm(),
    Dv = new $e();
  class e_ {
    constructor(e) {
      (this.renderer = e), (this._tempMatrix = new vt());
    }
    generateTexture(e, t) {
      const { region: i, ...s } = t || {},
        n = (i == null ? void 0 : i.copyTo(Dv)) || e.getLocalBounds(Dv, !0),
        a = s.resolution || this.renderer.resolution;
      (n.width = Math.max(n.width, 1 / a)),
        (n.height = Math.max(n.height, 1 / a)),
        (s.width = n.width),
        (s.height = n.height),
        (s.resolution = a),
        s.multisample ?? (s.multisample = this.renderer.multisample);
      const o = Gn.create(s);
      (this._tempMatrix.tx = -n.x), (this._tempMatrix.ty = -n.y);
      const l = e.transform;
      return (
        (e.transform = r4),
        this.renderer.render(e, {
          renderTexture: o,
          transform: this._tempMatrix,
          skipUpdateTransform: !!e.parent,
          blit: !0,
        }),
        (e.transform = l),
        o
      );
    }
    destroy() {}
  }
  e_.extension = {
    type: [me.RendererSystem, me.CanvasRendererSystem],
    name: "textureGenerator",
  };
  Ce.add(e_);
  const on = new $e(),
    fo = new $e();
  class t_ {
    constructor(e) {
      (this.renderer = e),
        (this.defaultMaskStack = []),
        (this.current = null),
        (this.sourceFrame = new $e()),
        (this.destinationFrame = new $e()),
        (this.viewportFrame = new $e());
    }
    contextChange() {
      var t;
      const e =
        (t = this.renderer) == null ? void 0 : t.gl.getContextAttributes();
      this._rendererPremultipliedAlpha = !!(
        e &&
        e.alpha &&
        e.premultipliedAlpha
      );
    }
    bind(e = null, t, i) {
      const s = this.renderer;
      this.current = e;
      let n, a, o;
      e
        ? ((n = e.baseTexture),
          (o = n.resolution),
          t ||
            ((on.width = e.frame.width),
            (on.height = e.frame.height),
            (t = on)),
          i ||
            ((fo.x = e.frame.x),
            (fo.y = e.frame.y),
            (fo.width = t.width),
            (fo.height = t.height),
            (i = fo)),
          (a = n.framebuffer))
        : ((o = s.resolution),
          t ||
            ((on.width = s._view.screen.width),
            (on.height = s._view.screen.height),
            (t = on)),
          i || ((i = on), (i.width = t.width), (i.height = t.height)));
      const l = this.viewportFrame;
      (l.x = i.x * o),
        (l.y = i.y * o),
        (l.width = i.width * o),
        (l.height = i.height * o),
        e || (l.y = s.view.height - (l.y + l.height)),
        l.ceil(),
        this.renderer.framebuffer.bind(a, l),
        this.renderer.projection.update(i, t, o, !a),
        e
          ? this.renderer.mask.setMaskStack(n.maskStack)
          : this.renderer.mask.setMaskStack(this.defaultMaskStack),
        this.sourceFrame.copyFrom(t),
        this.destinationFrame.copyFrom(i);
    }
    clear(e, t) {
      const i = this.current
          ? this.current.baseTexture.clear
          : this.renderer.background.backgroundColor,
        s = lt.shared.setValue(e || i);
      ((this.current && this.current.baseTexture.alphaMode > 0) ||
        (!this.current && this._rendererPremultipliedAlpha)) &&
        s.premultiply(s.alpha);
      const n = this.destinationFrame,
        a = this.current
          ? this.current.baseTexture
          : this.renderer._view.screen,
        o = n.width !== a.width || n.height !== a.height;
      if (o) {
        let { x: l, y: h, width: c, height: u } = this.viewportFrame;
        (l = Math.round(l)),
          (h = Math.round(h)),
          (c = Math.round(c)),
          (u = Math.round(u)),
          this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST),
          this.renderer.gl.scissor(l, h, c, u);
      }
      this.renderer.framebuffer.clear(s.red, s.green, s.blue, s.alpha, t),
        o && this.renderer.scissor.pop();
    }
    resize() {
      this.bind(null);
    }
    reset() {
      this.bind(null);
    }
    destroy() {
      this.renderer = null;
    }
  }
  t_.extension = { type: me.RendererSystem, name: "renderTexture" };
  Ce.add(t_);
  class i4 {
    constructor(e, t) {
      (this.program = e),
        (this.uniformData = t),
        (this.uniformGroups = {}),
        (this.uniformDirtyGroups = {}),
        (this.uniformBufferBindings = {});
    }
    destroy() {
      (this.uniformData = null),
        (this.uniformGroups = null),
        (this.uniformDirtyGroups = null),
        (this.uniformBufferBindings = null),
        (this.program = null);
    }
  }
  function s4(r, e) {
    const t = {},
      i = e.getProgramParameter(r, e.ACTIVE_ATTRIBUTES);
    for (let s = 0; s < i; s++) {
      const n = e.getActiveAttrib(r, s);
      if (n.name.startsWith("gl_")) continue;
      const a = N1(e, n.type),
        o = {
          type: a,
          name: n.name,
          size: L1(a),
          location: e.getAttribLocation(r, n.name),
        };
      t[n.name] = o;
    }
    return t;
  }
  function n4(r, e) {
    const t = {},
      i = e.getProgramParameter(r, e.ACTIVE_UNIFORMS);
    for (let s = 0; s < i; s++) {
      const n = e.getActiveUniform(r, s),
        a = n.name.replace(/\[.*?\]$/, ""),
        o = !!n.name.match(/\[.*?\]$/),
        l = N1(e, n.type);
      t[a] = {
        name: a,
        index: s,
        type: l,
        size: n.size,
        isArray: o,
        value: k1(l, n.size),
      };
    }
    return t;
  }
  function a4(r, e) {
    var o;
    const t = Cv(r, r.VERTEX_SHADER, e.vertexSrc),
      i = Cv(r, r.FRAGMENT_SHADER, e.fragmentSrc),
      s = r.createProgram();
    r.attachShader(s, t), r.attachShader(s, i);
    const n = (o = e.extra) == null ? void 0 : o.transformFeedbackVaryings;
    if (
      (n &&
        (typeof r.transformFeedbackVaryings != "function"
          ? console.warn(
              "TransformFeedback is not supported but TransformFeedbackVaryings are given."
            )
          : r.transformFeedbackVaryings(
              s,
              n.names,
              n.bufferMode === "separate"
                ? r.SEPARATE_ATTRIBS
                : r.INTERLEAVED_ATTRIBS
            )),
      r.linkProgram(s),
      r.getProgramParameter(s, r.LINK_STATUS) || DN(r, s, t, i),
      (e.attributeData = s4(s, r)),
      (e.uniformData = n4(s, r)),
      !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc))
    ) {
      const l = Object.keys(e.attributeData);
      l.sort((h, c) => (h > c ? 1 : -1));
      for (let h = 0; h < l.length; h++)
        (e.attributeData[l[h]].location = h), r.bindAttribLocation(s, h, l[h]);
      r.linkProgram(s);
    }
    r.deleteShader(t), r.deleteShader(i);
    const a = {};
    for (const l in e.uniformData) {
      const h = e.uniformData[l];
      a[l] = {
        location: r.getUniformLocation(s, l),
        value: k1(h.type, h.size),
      };
    }
    return new i4(s, a);
  }
  function o4(r, e, t, i, s) {
    t.buffer.update(s);
  }
  const l4 = {
      float: `
        data[offset] = v;
    `,
      vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
      vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
      vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
      mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
      mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
      mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `,
    },
    r_ = {
      float: 4,
      vec2: 8,
      vec3: 12,
      vec4: 16,
      int: 4,
      ivec2: 8,
      ivec3: 12,
      ivec4: 16,
      uint: 4,
      uvec2: 8,
      uvec3: 12,
      uvec4: 16,
      bool: 4,
      bvec2: 8,
      bvec3: 12,
      bvec4: 16,
      mat2: 16 * 2,
      mat3: 16 * 3,
      mat4: 16 * 4,
    };
  function h4(r) {
    const e = r.map((n) => ({ data: n, offset: 0, dataLen: 0, dirty: 0 }));
    let t = 0,
      i = 0,
      s = 0;
    for (let n = 0; n < e.length; n++) {
      const a = e[n];
      if (
        ((t = r_[a.data.type]),
        a.data.size > 1 && (t = Math.max(t, 16) * a.data.size),
        (a.dataLen = t),
        i % t !== 0 && i < 16)
      ) {
        const o = (i % t) % 16;
        (i += o), (s += o);
      }
      i + t > 16
        ? ((s = Math.ceil(s / 16) * 16), (a.offset = s), (s += t), (i = t))
        : ((a.offset = s), (i += t), (s += t));
    }
    return (s = Math.ceil(s / 16) * 16), { uboElements: e, size: s };
  }
  function c4(r, e) {
    const t = [];
    for (const i in r) e[i] && t.push(e[i]);
    return t.sort((i, s) => i.index - s.index), t;
  }
  function u4(r, e) {
    if (!r.autoManage) return { size: 0, syncFunc: o4 };
    const t = c4(r.uniforms, e),
      { uboElements: i, size: s } = h4(t),
      n = [
        `
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `,
      ];
    for (let a = 0; a < i.length; a++) {
      const o = i[a],
        l = r.uniforms[o.data.name],
        h = o.data.name;
      let c = !1;
      for (let u = 0; u < Aa.length; u++) {
        const d = Aa[u];
        if (d.codeUbo && d.test(o.data, l)) {
          n.push(`offset = ${o.offset / 4};`, Aa[u].codeUbo(o.data.name, l)),
            (c = !0);
          break;
        }
      }
      if (!c)
        if (o.data.size > 1) {
          const u = L1(o.data.type),
            d = Math.max(r_[o.data.type] / 16, 1),
            f = u / d,
            p = (4 - (f % 4)) % 4;
          n.push(`
                cv = ud.${h}.value;
                v = uv.${h};
                offset = ${o.offset / 4};

                t = 0;

                for(var i=0; i < ${o.data.size * d}; i++)
                {
                    for(var j = 0; j < ${f}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${p};
                }

                `);
        } else {
          const u = l4[o.data.type];
          n.push(`
                cv = ud.${h}.value;
                v = uv.${h};
                offset = ${o.offset / 4};
                ${u};
                `);
        }
    }
    return (
      n.push(`
       renderer.buffer.update(buffer);
    `),
      {
        size: s,
        syncFunc: new Function(
          "ud",
          "uv",
          "renderer",
          "syncData",
          "buffer",
          n.join(`
`)
        ),
      }
    );
  }
  let d4 = 0;
  const Jl = { textureCount: 0, uboCount: 0 };
  class i_ {
    constructor(e) {
      (this.destroyed = !1),
        (this.renderer = e),
        this.systemCheck(),
        (this.gl = null),
        (this.shader = null),
        (this.program = null),
        (this.cache = {}),
        (this._uboCache = {}),
        (this.id = d4++);
    }
    systemCheck() {
      if (!NN())
        throw new Error(
          "Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support."
        );
    }
    contextChange(e) {
      (this.gl = e), this.reset();
    }
    bind(e, t) {
      e.disposeRunner.add(this),
        (e.uniforms.globals = this.renderer.globalUniforms);
      const i = e.program,
        s = i.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(e);
      return (
        (this.shader = e),
        this.program !== i &&
          ((this.program = i), this.gl.useProgram(s.program)),
        t ||
          ((Jl.textureCount = 0),
          (Jl.uboCount = 0),
          this.syncUniformGroup(e.uniformGroup, Jl)),
        s
      );
    }
    setUniforms(e) {
      const t = this.shader.program,
        i = t.glPrograms[this.renderer.CONTEXT_UID];
      t.syncUniforms(i.uniformData, e, this.renderer);
    }
    syncUniformGroup(e, t) {
      const i = this.getGlProgram();
      (!e.static || e.dirtyId !== i.uniformDirtyGroups[e.id]) &&
        ((i.uniformDirtyGroups[e.id] = e.dirtyId), this.syncUniforms(e, i, t));
    }
    syncUniforms(e, t, i) {
      (e.syncUniforms[this.shader.program.id] || this.createSyncGroups(e))(
        t.uniformData,
        e.uniforms,
        this.renderer,
        i
      );
    }
    createSyncGroups(e) {
      const t = this.getSignature(e, this.shader.program.uniformData, "u");
      return (
        this.cache[t] ||
          (this.cache[t] = BN(e, this.shader.program.uniformData)),
        (e.syncUniforms[this.shader.program.id] = this.cache[t]),
        e.syncUniforms[this.shader.program.id]
      );
    }
    syncUniformBufferGroup(e, t) {
      const i = this.getGlProgram();
      if (!e.static || e.dirtyId !== 0 || !i.uniformGroups[e.id]) {
        e.dirtyId = 0;
        const s = i.uniformGroups[e.id] || this.createSyncBufferGroup(e, i, t);
        e.buffer.update(),
          s(i.uniformData, e.uniforms, this.renderer, Jl, e.buffer);
      }
      this.renderer.buffer.bindBufferBase(e.buffer, i.uniformBufferBindings[t]);
    }
    createSyncBufferGroup(e, t, i) {
      const { gl: s } = this.renderer;
      this.renderer.buffer.bind(e.buffer);
      const n = this.gl.getUniformBlockIndex(t.program, i);
      (t.uniformBufferBindings[i] = this.shader.uniformBindCount),
        s.uniformBlockBinding(t.program, n, this.shader.uniformBindCount),
        this.shader.uniformBindCount++;
      const a = this.getSignature(e, this.shader.program.uniformData, "ubo");
      let o = this._uboCache[a];
      if (
        (o || (o = this._uboCache[a] = u4(e, this.shader.program.uniformData)),
        e.autoManage)
      ) {
        const l = new Float32Array(o.size / 4);
        e.buffer.update(l);
      }
      return (t.uniformGroups[e.id] = o.syncFunc), t.uniformGroups[e.id];
    }
    getSignature(e, t, i) {
      const s = e.uniforms,
        n = [`${i}-`];
      for (const a in s) n.push(a), t[a] && n.push(t[a].type);
      return n.join("-");
    }
    getGlProgram() {
      return this.shader
        ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID]
        : null;
    }
    generateProgram(e) {
      const t = this.gl,
        i = e.program,
        s = a4(t, i);
      return (i.glPrograms[this.renderer.CONTEXT_UID] = s), s;
    }
    reset() {
      (this.program = null), (this.shader = null);
    }
    disposeShader(e) {
      this.shader === e && (this.shader = null);
    }
    destroy() {
      (this.renderer = null), (this.destroyed = !0);
    }
  }
  i_.extension = { type: me.RendererSystem, name: "shader" };
  Ce.add(i_);
  class jh {
    constructor(e) {
      this.renderer = e;
    }
    run(e) {
      const { renderer: t } = this;
      t.runners.init.emit(t.options),
        e.hello &&
          console.log(`PixiJS 7.4.2 - ${t.rendererLogId} - https://pixijs.com`),
        t.resize(t.screen.width, t.screen.height);
    }
    destroy() {}
  }
  (jh.defaultOptions = { hello: !1 }),
    (jh.extension = {
      type: [me.RendererSystem, me.CanvasRendererSystem],
      name: "startup",
    });
  Ce.add(jh);
  function f4(r, e = []) {
    return (
      (e[Be.NORMAL] = [r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e[Be.ADD] = [r.ONE, r.ONE]),
      (e[Be.MULTIPLY] = [
        r.DST_COLOR,
        r.ONE_MINUS_SRC_ALPHA,
        r.ONE,
        r.ONE_MINUS_SRC_ALPHA,
      ]),
      (e[Be.SCREEN] = [
        r.ONE,
        r.ONE_MINUS_SRC_COLOR,
        r.ONE,
        r.ONE_MINUS_SRC_ALPHA,
      ]),
      (e[Be.OVERLAY] = [r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e[Be.DARKEN] = [r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e[Be.LIGHTEN] = [r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e[Be.COLOR_DODGE] = [r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e[Be.COLOR_BURN] = [r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e[Be.HARD_LIGHT] = [r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e[Be.SOFT_LIGHT] = [r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e[Be.DIFFERENCE] = [r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e[Be.EXCLUSION] = [r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e[Be.HUE] = [r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e[Be.SATURATION] = [r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e[Be.COLOR] = [r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e[Be.LUMINOSITY] = [r.ONE, r.ONE_MINUS_SRC_ALPHA]),
      (e[Be.NONE] = [0, 0]),
      (e[Be.NORMAL_NPM] = [
        r.SRC_ALPHA,
        r.ONE_MINUS_SRC_ALPHA,
        r.ONE,
        r.ONE_MINUS_SRC_ALPHA,
      ]),
      (e[Be.ADD_NPM] = [r.SRC_ALPHA, r.ONE, r.ONE, r.ONE]),
      (e[Be.SCREEN_NPM] = [
        r.SRC_ALPHA,
        r.ONE_MINUS_SRC_COLOR,
        r.ONE,
        r.ONE_MINUS_SRC_ALPHA,
      ]),
      (e[Be.SRC_IN] = [r.DST_ALPHA, r.ZERO]),
      (e[Be.SRC_OUT] = [r.ONE_MINUS_DST_ALPHA, r.ZERO]),
      (e[Be.SRC_ATOP] = [r.DST_ALPHA, r.ONE_MINUS_SRC_ALPHA]),
      (e[Be.DST_OVER] = [r.ONE_MINUS_DST_ALPHA, r.ONE]),
      (e[Be.DST_IN] = [r.ZERO, r.SRC_ALPHA]),
      (e[Be.DST_OUT] = [r.ZERO, r.ONE_MINUS_SRC_ALPHA]),
      (e[Be.DST_ATOP] = [r.ONE_MINUS_DST_ALPHA, r.SRC_ALPHA]),
      (e[Be.XOR] = [r.ONE_MINUS_DST_ALPHA, r.ONE_MINUS_SRC_ALPHA]),
      (e[Be.SUBTRACT] = [
        r.ONE,
        r.ONE,
        r.ONE,
        r.ONE,
        r.FUNC_REVERSE_SUBTRACT,
        r.FUNC_ADD,
      ]),
      e
    );
  }
  const p4 = 0,
    m4 = 1,
    g4 = 2,
    v4 = 3,
    y4 = 4,
    b4 = 5,
    s_ = class pf {
      constructor() {
        (this.gl = null),
          (this.stateId = 0),
          (this.polygonOffset = 0),
          (this.blendMode = Be.NONE),
          (this._blendEq = !1),
          (this.map = []),
          (this.map[p4] = this.setBlend),
          (this.map[m4] = this.setOffset),
          (this.map[g4] = this.setCullFace),
          (this.map[v4] = this.setDepthTest),
          (this.map[y4] = this.setFrontFace),
          (this.map[b4] = this.setDepthMask),
          (this.checks = []),
          (this.defaultState = new ji()),
          (this.defaultState.blend = !0);
      }
      contextChange(e) {
        (this.gl = e),
          (this.blendModes = f4(e)),
          this.set(this.defaultState),
          this.reset();
      }
      set(e) {
        if (((e = e || this.defaultState), this.stateId !== e.data)) {
          let t = this.stateId ^ e.data,
            i = 0;
          for (; t; )
            t & 1 && this.map[i].call(this, !!(e.data & (1 << i))),
              (t = t >> 1),
              i++;
          this.stateId = e.data;
        }
        for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e);
      }
      forceState(e) {
        e = e || this.defaultState;
        for (let t = 0; t < this.map.length; t++)
          this.map[t].call(this, !!(e.data & (1 << t)));
        for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e);
        this.stateId = e.data;
      }
      setBlend(e) {
        this.updateCheck(pf.checkBlendMode, e),
          this.gl[e ? "enable" : "disable"](this.gl.BLEND);
      }
      setOffset(e) {
        this.updateCheck(pf.checkPolygonOffset, e),
          this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
      }
      setDepthTest(e) {
        this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST);
      }
      setDepthMask(e) {
        this.gl.depthMask(e);
      }
      setCullFace(e) {
        this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE);
      }
      setFrontFace(e) {
        this.gl.frontFace(this.gl[e ? "CW" : "CCW"]);
      }
      setBlendMode(e) {
        if (e === this.blendMode) return;
        this.blendMode = e;
        const t = this.blendModes[e],
          i = this.gl;
        t.length === 2
          ? i.blendFunc(t[0], t[1])
          : i.blendFuncSeparate(t[0], t[1], t[2], t[3]),
          t.length === 6
            ? ((this._blendEq = !0), i.blendEquationSeparate(t[4], t[5]))
            : this._blendEq &&
              ((this._blendEq = !1),
              i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD));
      }
      setPolygonOffset(e, t) {
        this.gl.polygonOffset(e, t);
      }
      reset() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
          this.forceState(this.defaultState),
          (this._blendEq = !0),
          (this.blendMode = -1),
          this.setBlendMode(0);
      }
      updateCheck(e, t) {
        const i = this.checks.indexOf(e);
        t && i === -1
          ? this.checks.push(e)
          : !t && i !== -1 && this.checks.splice(i, 1);
      }
      static checkBlendMode(e, t) {
        e.setBlendMode(t.blendMode);
      }
      static checkPolygonOffset(e, t) {
        e.setPolygonOffset(1, t.polygonOffset);
      }
      destroy() {
        this.gl = null;
      }
    };
  s_.extension = { type: me.RendererSystem, name: "state" };
  let x4 = s_;
  Ce.add(x4);
  class _4 extends gl {
    constructor() {
      super(...arguments), (this.runners = {}), (this._systemsHash = {});
    }
    setup(e) {
      this.addRunners(...e.runners);
      const t = (e.priority ?? []).filter((s) => e.systems[s]),
        i = [...t, ...Object.keys(e.systems).filter((s) => !t.includes(s))];
      for (const s of i) this.addSystem(e.systems[s], s);
    }
    addRunners(...e) {
      e.forEach((t) => {
        this.runners[t] = new ui(t);
      });
    }
    addSystem(e, t) {
      const i = new e(this);
      if (this[t]) throw new Error(`Whoops! The name "${t}" is already in use`);
      (this[t] = i), (this._systemsHash[t] = i);
      for (const s in this.runners) this.runners[s].add(i);
      return this;
    }
    emitWithCustomOptions(e, t) {
      const i = Object.keys(this._systemsHash);
      e.items.forEach((s) => {
        const n = i.find((a) => this._systemsHash[a] === s);
        s[e.name](t[n]);
      });
    }
    destroy() {
      Object.values(this.runners).forEach((e) => {
        e.destroy();
      }),
        (this._systemsHash = {});
    }
  }
  const xo = class bh {
    constructor(e) {
      (this.renderer = e),
        (this.count = 0),
        (this.checkCount = 0),
        (this.maxIdle = bh.defaultMaxIdle),
        (this.checkCountMax = bh.defaultCheckCountMax),
        (this.mode = bh.defaultMode);
    }
    postrender() {
      this.renderer.objectRenderer.renderingToScreen &&
        (this.count++,
        this.mode !== Yp.MANUAL &&
          (this.checkCount++,
          this.checkCount > this.checkCountMax &&
            ((this.checkCount = 0), this.run())));
    }
    run() {
      const e = this.renderer.texture,
        t = e.managedTextures;
      let i = !1;
      for (let s = 0; s < t.length; s++) {
        const n = t[s];
        n.resource &&
          this.count - n.touched > this.maxIdle &&
          (e.destroyTexture(n, !0), (t[s] = null), (i = !0));
      }
      if (i) {
        let s = 0;
        for (let n = 0; n < t.length; n++) t[n] !== null && (t[s++] = t[n]);
        t.length = s;
      }
    }
    unload(e) {
      const t = this.renderer.texture,
        i = e._texture;
      i && !i.framebuffer && t.destroyTexture(i);
      for (let s = e.children.length - 1; s >= 0; s--)
        this.unload(e.children[s]);
    }
    destroy() {
      this.renderer = null;
    }
  };
  (xo.defaultMode = Yp.AUTO),
    (xo.defaultMaxIdle = 60 * 60),
    (xo.defaultCheckCountMax = 60 * 10),
    (xo.extension = { type: me.RendererSystem, name: "textureGC" });
  let pn = xo;
  Ce.add(pn);
  class qu {
    constructor(e) {
      (this.texture = e),
        (this.width = -1),
        (this.height = -1),
        (this.dirtyId = -1),
        (this.dirtyStyleId = -1),
        (this.mipmap = !1),
        (this.wrapMode = 33071),
        (this.type = Ae.UNSIGNED_BYTE),
        (this.internalFormat = le.RGBA),
        (this.samplerType = 0);
    }
  }
  function w4(r) {
    let e;
    return (
      "WebGL2RenderingContext" in globalThis &&
      r instanceof globalThis.WebGL2RenderingContext
        ? (e = {
            [r.RGB]: Ee.FLOAT,
            [r.RGBA]: Ee.FLOAT,
            [r.ALPHA]: Ee.FLOAT,
            [r.LUMINANCE]: Ee.FLOAT,
            [r.LUMINANCE_ALPHA]: Ee.FLOAT,
            [r.R8]: Ee.FLOAT,
            [r.R8_SNORM]: Ee.FLOAT,
            [r.RG8]: Ee.FLOAT,
            [r.RG8_SNORM]: Ee.FLOAT,
            [r.RGB8]: Ee.FLOAT,
            [r.RGB8_SNORM]: Ee.FLOAT,
            [r.RGB565]: Ee.FLOAT,
            [r.RGBA4]: Ee.FLOAT,
            [r.RGB5_A1]: Ee.FLOAT,
            [r.RGBA8]: Ee.FLOAT,
            [r.RGBA8_SNORM]: Ee.FLOAT,
            [r.RGB10_A2]: Ee.FLOAT,
            [r.RGB10_A2UI]: Ee.FLOAT,
            [r.SRGB8]: Ee.FLOAT,
            [r.SRGB8_ALPHA8]: Ee.FLOAT,
            [r.R16F]: Ee.FLOAT,
            [r.RG16F]: Ee.FLOAT,
            [r.RGB16F]: Ee.FLOAT,
            [r.RGBA16F]: Ee.FLOAT,
            [r.R32F]: Ee.FLOAT,
            [r.RG32F]: Ee.FLOAT,
            [r.RGB32F]: Ee.FLOAT,
            [r.RGBA32F]: Ee.FLOAT,
            [r.R11F_G11F_B10F]: Ee.FLOAT,
            [r.RGB9_E5]: Ee.FLOAT,
            [r.R8I]: Ee.INT,
            [r.R8UI]: Ee.UINT,
            [r.R16I]: Ee.INT,
            [r.R16UI]: Ee.UINT,
            [r.R32I]: Ee.INT,
            [r.R32UI]: Ee.UINT,
            [r.RG8I]: Ee.INT,
            [r.RG8UI]: Ee.UINT,
            [r.RG16I]: Ee.INT,
            [r.RG16UI]: Ee.UINT,
            [r.RG32I]: Ee.INT,
            [r.RG32UI]: Ee.UINT,
            [r.RGB8I]: Ee.INT,
            [r.RGB8UI]: Ee.UINT,
            [r.RGB16I]: Ee.INT,
            [r.RGB16UI]: Ee.UINT,
            [r.RGB32I]: Ee.INT,
            [r.RGB32UI]: Ee.UINT,
            [r.RGBA8I]: Ee.INT,
            [r.RGBA8UI]: Ee.UINT,
            [r.RGBA16I]: Ee.INT,
            [r.RGBA16UI]: Ee.UINT,
            [r.RGBA32I]: Ee.INT,
            [r.RGBA32UI]: Ee.UINT,
            [r.DEPTH_COMPONENT16]: Ee.FLOAT,
            [r.DEPTH_COMPONENT24]: Ee.FLOAT,
            [r.DEPTH_COMPONENT32F]: Ee.FLOAT,
            [r.DEPTH_STENCIL]: Ee.FLOAT,
            [r.DEPTH24_STENCIL8]: Ee.FLOAT,
            [r.DEPTH32F_STENCIL8]: Ee.FLOAT,
          })
        : (e = {
            [r.RGB]: Ee.FLOAT,
            [r.RGBA]: Ee.FLOAT,
            [r.ALPHA]: Ee.FLOAT,
            [r.LUMINANCE]: Ee.FLOAT,
            [r.LUMINANCE_ALPHA]: Ee.FLOAT,
            [r.DEPTH_STENCIL]: Ee.FLOAT,
          }),
      e
    );
  }
  function T4(r) {
    let e;
    return (
      "WebGL2RenderingContext" in globalThis &&
      r instanceof globalThis.WebGL2RenderingContext
        ? (e = {
            [Ae.UNSIGNED_BYTE]: {
              [le.RGBA]: r.RGBA8,
              [le.RGB]: r.RGB8,
              [le.RG]: r.RG8,
              [le.RED]: r.R8,
              [le.RGBA_INTEGER]: r.RGBA8UI,
              [le.RGB_INTEGER]: r.RGB8UI,
              [le.RG_INTEGER]: r.RG8UI,
              [le.RED_INTEGER]: r.R8UI,
              [le.ALPHA]: r.ALPHA,
              [le.LUMINANCE]: r.LUMINANCE,
              [le.LUMINANCE_ALPHA]: r.LUMINANCE_ALPHA,
            },
            [Ae.BYTE]: {
              [le.RGBA]: r.RGBA8_SNORM,
              [le.RGB]: r.RGB8_SNORM,
              [le.RG]: r.RG8_SNORM,
              [le.RED]: r.R8_SNORM,
              [le.RGBA_INTEGER]: r.RGBA8I,
              [le.RGB_INTEGER]: r.RGB8I,
              [le.RG_INTEGER]: r.RG8I,
              [le.RED_INTEGER]: r.R8I,
            },
            [Ae.UNSIGNED_SHORT]: {
              [le.RGBA_INTEGER]: r.RGBA16UI,
              [le.RGB_INTEGER]: r.RGB16UI,
              [le.RG_INTEGER]: r.RG16UI,
              [le.RED_INTEGER]: r.R16UI,
              [le.DEPTH_COMPONENT]: r.DEPTH_COMPONENT16,
            },
            [Ae.SHORT]: {
              [le.RGBA_INTEGER]: r.RGBA16I,
              [le.RGB_INTEGER]: r.RGB16I,
              [le.RG_INTEGER]: r.RG16I,
              [le.RED_INTEGER]: r.R16I,
            },
            [Ae.UNSIGNED_INT]: {
              [le.RGBA_INTEGER]: r.RGBA32UI,
              [le.RGB_INTEGER]: r.RGB32UI,
              [le.RG_INTEGER]: r.RG32UI,
              [le.RED_INTEGER]: r.R32UI,
              [le.DEPTH_COMPONENT]: r.DEPTH_COMPONENT24,
            },
            [Ae.INT]: {
              [le.RGBA_INTEGER]: r.RGBA32I,
              [le.RGB_INTEGER]: r.RGB32I,
              [le.RG_INTEGER]: r.RG32I,
              [le.RED_INTEGER]: r.R32I,
            },
            [Ae.FLOAT]: {
              [le.RGBA]: r.RGBA32F,
              [le.RGB]: r.RGB32F,
              [le.RG]: r.RG32F,
              [le.RED]: r.R32F,
              [le.DEPTH_COMPONENT]: r.DEPTH_COMPONENT32F,
            },
            [Ae.HALF_FLOAT]: {
              [le.RGBA]: r.RGBA16F,
              [le.RGB]: r.RGB16F,
              [le.RG]: r.RG16F,
              [le.RED]: r.R16F,
            },
            [Ae.UNSIGNED_SHORT_5_6_5]: { [le.RGB]: r.RGB565 },
            [Ae.UNSIGNED_SHORT_4_4_4_4]: { [le.RGBA]: r.RGBA4 },
            [Ae.UNSIGNED_SHORT_5_5_5_1]: { [le.RGBA]: r.RGB5_A1 },
            [Ae.UNSIGNED_INT_2_10_10_10_REV]: {
              [le.RGBA]: r.RGB10_A2,
              [le.RGBA_INTEGER]: r.RGB10_A2UI,
            },
            [Ae.UNSIGNED_INT_10F_11F_11F_REV]: { [le.RGB]: r.R11F_G11F_B10F },
            [Ae.UNSIGNED_INT_5_9_9_9_REV]: { [le.RGB]: r.RGB9_E5 },
            [Ae.UNSIGNED_INT_24_8]: { [le.DEPTH_STENCIL]: r.DEPTH24_STENCIL8 },
            [Ae.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
              [le.DEPTH_STENCIL]: r.DEPTH32F_STENCIL8,
            },
          })
        : (e = {
            [Ae.UNSIGNED_BYTE]: {
              [le.RGBA]: r.RGBA,
              [le.RGB]: r.RGB,
              [le.ALPHA]: r.ALPHA,
              [le.LUMINANCE]: r.LUMINANCE,
              [le.LUMINANCE_ALPHA]: r.LUMINANCE_ALPHA,
            },
            [Ae.UNSIGNED_SHORT_5_6_5]: { [le.RGB]: r.RGB },
            [Ae.UNSIGNED_SHORT_4_4_4_4]: { [le.RGBA]: r.RGBA },
            [Ae.UNSIGNED_SHORT_5_5_5_1]: { [le.RGBA]: r.RGBA },
          }),
      e
    );
  }
  class n_ {
    constructor(e) {
      (this.renderer = e),
        (this.boundTextures = []),
        (this.currentLocation = -1),
        (this.managedTextures = []),
        (this._unknownBoundTextures = !1),
        (this.unknownTexture = new Le()),
        (this.hasIntegerTextures = !1);
    }
    contextChange() {
      const e = (this.gl = this.renderer.gl);
      (this.CONTEXT_UID = this.renderer.CONTEXT_UID),
        (this.webGLVersion = this.renderer.context.webGLVersion),
        (this.internalFormats = T4(e)),
        (this.samplerTypes = w4(e));
      const t = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);
      this.boundTextures.length = t;
      for (let s = 0; s < t; s++) this.boundTextures[s] = null;
      this.emptyTextures = {};
      const i = new qu(e.createTexture());
      e.bindTexture(e.TEXTURE_2D, i.texture),
        e.texImage2D(
          e.TEXTURE_2D,
          0,
          e.RGBA,
          1,
          1,
          0,
          e.RGBA,
          e.UNSIGNED_BYTE,
          new Uint8Array(4)
        ),
        (this.emptyTextures[e.TEXTURE_2D] = i),
        (this.emptyTextures[e.TEXTURE_CUBE_MAP] = new qu(e.createTexture())),
        e.bindTexture(
          e.TEXTURE_CUBE_MAP,
          this.emptyTextures[e.TEXTURE_CUBE_MAP].texture
        );
      for (let s = 0; s < 6; s++)
        e.texImage2D(
          e.TEXTURE_CUBE_MAP_POSITIVE_X + s,
          0,
          e.RGBA,
          1,
          1,
          0,
          e.RGBA,
          e.UNSIGNED_BYTE,
          null
        );
      e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MAG_FILTER, e.LINEAR),
        e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MIN_FILTER, e.LINEAR);
      for (let s = 0; s < this.boundTextures.length; s++) this.bind(null, s);
    }
    bind(e, t = 0) {
      const { gl: i } = this;
      if (
        ((e = e == null ? void 0 : e.castToBaseTexture()),
        (e == null ? void 0 : e.valid) && !e.parentTextureArray)
      ) {
        e.touched = this.renderer.textureGC.count;
        const s = e._glTextures[this.CONTEXT_UID] || this.initTexture(e);
        this.boundTextures[t] !== e &&
          (this.currentLocation !== t &&
            ((this.currentLocation = t), i.activeTexture(i.TEXTURE0 + t)),
          i.bindTexture(e.target, s.texture)),
          s.dirtyId !== e.dirtyId
            ? (this.currentLocation !== t &&
                ((this.currentLocation = t), i.activeTexture(i.TEXTURE0 + t)),
              this.updateTexture(e))
            : s.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(e),
          (this.boundTextures[t] = e);
      } else
        this.currentLocation !== t &&
          ((this.currentLocation = t), i.activeTexture(i.TEXTURE0 + t)),
          i.bindTexture(i.TEXTURE_2D, this.emptyTextures[i.TEXTURE_2D].texture),
          (this.boundTextures[t] = null);
    }
    reset() {
      (this._unknownBoundTextures = !0),
        (this.hasIntegerTextures = !1),
        (this.currentLocation = -1);
      for (let e = 0; e < this.boundTextures.length; e++)
        this.boundTextures[e] = this.unknownTexture;
    }
    unbind(e) {
      const { gl: t, boundTextures: i } = this;
      if (this._unknownBoundTextures) {
        this._unknownBoundTextures = !1;
        for (let s = 0; s < i.length; s++)
          i[s] === this.unknownTexture && this.bind(null, s);
      }
      for (let s = 0; s < i.length; s++)
        i[s] === e &&
          (this.currentLocation !== s &&
            (t.activeTexture(t.TEXTURE0 + s), (this.currentLocation = s)),
          t.bindTexture(e.target, this.emptyTextures[e.target].texture),
          (i[s] = null));
    }
    ensureSamplerType(e) {
      const { boundTextures: t, hasIntegerTextures: i, CONTEXT_UID: s } = this;
      if (i)
        for (let n = e - 1; n >= 0; --n) {
          const a = t[n];
          a &&
            a._glTextures[s].samplerType !== Ee.FLOAT &&
            this.renderer.texture.unbind(a);
        }
    }
    initTexture(e) {
      const t = new qu(this.gl.createTexture());
      return (
        (t.dirtyId = -1),
        (e._glTextures[this.CONTEXT_UID] = t),
        this.managedTextures.push(e),
        e.on("dispose", this.destroyTexture, this),
        t
      );
    }
    initTextureType(e, t) {
      var i;
      (t.internalFormat =
        ((i = this.internalFormats[e.type]) == null ? void 0 : i[e.format]) ??
        e.format),
        (t.samplerType = this.samplerTypes[t.internalFormat] ?? Ee.FLOAT),
        this.webGLVersion === 2 && e.type === Ae.HALF_FLOAT
          ? (t.type = this.gl.HALF_FLOAT)
          : (t.type = e.type);
    }
    updateTexture(e) {
      var s;
      const t = e._glTextures[this.CONTEXT_UID];
      if (!t) return;
      const i = this.renderer;
      if (
        (this.initTextureType(e, t),
        (s = e.resource) == null ? void 0 : s.upload(i, e, t))
      )
        t.samplerType !== Ee.FLOAT && (this.hasIntegerTextures = !0);
      else {
        const n = e.realWidth,
          a = e.realHeight,
          o = i.gl;
        (t.width !== n || t.height !== a || t.dirtyId < 0) &&
          ((t.width = n),
          (t.height = a),
          o.texImage2D(
            e.target,
            0,
            t.internalFormat,
            n,
            a,
            0,
            e.format,
            t.type,
            null
          ));
      }
      e.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(e),
        (t.dirtyId = e.dirtyId);
    }
    destroyTexture(e, t) {
      const { gl: i } = this;
      if (
        ((e = e.castToBaseTexture()),
        e._glTextures[this.CONTEXT_UID] &&
          (this.unbind(e),
          i.deleteTexture(e._glTextures[this.CONTEXT_UID].texture),
          e.off("dispose", this.destroyTexture, this),
          delete e._glTextures[this.CONTEXT_UID],
          !t))
      ) {
        const s = this.managedTextures.indexOf(e);
        s !== -1 && Sa(this.managedTextures, s, 1);
      }
    }
    updateTextureStyle(e) {
      var i;
      const t = e._glTextures[this.CONTEXT_UID];
      t &&
        ((e.mipmap === Yr.POW2 || this.webGLVersion !== 2) && !e.isPowerOfTwo
          ? (t.mipmap = !1)
          : (t.mipmap = e.mipmap >= 1),
        this.webGLVersion !== 2 && !e.isPowerOfTwo
          ? (t.wrapMode = ci.CLAMP)
          : (t.wrapMode = e.wrapMode),
        ((i = e.resource) != null && i.style(this.renderer, e, t)) ||
          this.setStyle(e, t),
        (t.dirtyStyleId = e.dirtyStyleId));
    }
    setStyle(e, t) {
      const i = this.gl;
      if (
        (t.mipmap && e.mipmap !== Yr.ON_MANUAL && i.generateMipmap(e.target),
        i.texParameteri(e.target, i.TEXTURE_WRAP_S, t.wrapMode),
        i.texParameteri(e.target, i.TEXTURE_WRAP_T, t.wrapMode),
        t.mipmap)
      ) {
        i.texParameteri(
          e.target,
          i.TEXTURE_MIN_FILTER,
          e.scaleMode === ai.LINEAR
            ? i.LINEAR_MIPMAP_LINEAR
            : i.NEAREST_MIPMAP_NEAREST
        );
        const s = this.renderer.context.extensions.anisotropicFiltering;
        if (s && e.anisotropicLevel > 0 && e.scaleMode === ai.LINEAR) {
          const n = Math.min(
            e.anisotropicLevel,
            i.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
          );
          i.texParameterf(e.target, s.TEXTURE_MAX_ANISOTROPY_EXT, n);
        }
      } else
        i.texParameteri(
          e.target,
          i.TEXTURE_MIN_FILTER,
          e.scaleMode === ai.LINEAR ? i.LINEAR : i.NEAREST
        );
      i.texParameteri(
        e.target,
        i.TEXTURE_MAG_FILTER,
        e.scaleMode === ai.LINEAR ? i.LINEAR : i.NEAREST
      );
    }
    destroy() {
      this.renderer = null;
    }
  }
  n_.extension = { type: me.RendererSystem, name: "texture" };
  Ce.add(n_);
  class a_ {
    constructor(e) {
      this.renderer = e;
    }
    contextChange() {
      (this.gl = this.renderer.gl),
        (this.CONTEXT_UID = this.renderer.CONTEXT_UID);
    }
    bind(e) {
      const { gl: t, CONTEXT_UID: i } = this,
        s = e._glTransformFeedbacks[i] || this.createGLTransformFeedback(e);
      t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, s);
    }
    unbind() {
      const { gl: e } = this;
      e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, null);
    }
    beginTransformFeedback(e, t) {
      const { gl: i, renderer: s } = this;
      t && s.shader.bind(t), i.beginTransformFeedback(e);
    }
    endTransformFeedback() {
      const { gl: e } = this;
      e.endTransformFeedback();
    }
    createGLTransformFeedback(e) {
      const { gl: t, renderer: i, CONTEXT_UID: s } = this,
        n = t.createTransformFeedback();
      (e._glTransformFeedbacks[s] = n),
        t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, n);
      for (let a = 0; a < e.buffers.length; a++) {
        const o = e.buffers[a];
        o &&
          (i.buffer.update(o),
          o._glBuffers[s].refCount++,
          t.bindBufferBase(
            t.TRANSFORM_FEEDBACK_BUFFER,
            a,
            o._glBuffers[s].buffer || null
          ));
      }
      return (
        t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, null),
        e.disposeRunner.add(this),
        n
      );
    }
    disposeTransformFeedback(e, t) {
      const i = e._glTransformFeedbacks[this.CONTEXT_UID],
        s = this.gl;
      e.disposeRunner.remove(this);
      const n = this.renderer.buffer;
      if (n)
        for (let a = 0; a < e.buffers.length; a++) {
          const o = e.buffers[a];
          if (!o) continue;
          const l = o._glBuffers[this.CONTEXT_UID];
          l && (l.refCount--, l.refCount === 0 && !t && n.dispose(o, t));
        }
      i &&
        (t || s.deleteTransformFeedback(i),
        delete e._glTransformFeedbacks[this.CONTEXT_UID]);
    }
    destroy() {
      this.renderer = null;
    }
  }
  a_.extension = { type: me.RendererSystem, name: "transformFeedback" };
  Ce.add(a_);
  class qh {
    constructor(e) {
      this.renderer = e;
    }
    init(e) {
      (this.screen = new $e(0, 0, e.width, e.height)),
        (this.element = e.view || we.ADAPTER.createCanvas()),
        (this.resolution = e.resolution || we.RESOLUTION),
        (this.autoDensity = !!e.autoDensity);
    }
    resizeView(e, t) {
      (this.element.width = Math.round(e * this.resolution)),
        (this.element.height = Math.round(t * this.resolution));
      const i = this.element.width / this.resolution,
        s = this.element.height / this.resolution;
      (this.screen.width = i),
        (this.screen.height = s),
        this.autoDensity &&
          ((this.element.style.width = `${i}px`),
          (this.element.style.height = `${s}px`)),
        this.renderer.emit("resize", i, s),
        this.renderer.runners.resize.emit(
          this.screen.width,
          this.screen.height
        );
    }
    destroy(e) {
      var t;
      e &&
        ((t = this.element.parentNode) == null || t.removeChild(this.element)),
        (this.renderer = null),
        (this.element = null),
        (this.screen = null);
    }
  }
  (qh.defaultOptions = {
    width: 800,
    height: 600,
    resolution: void 0,
    autoDensity: !1,
  }),
    (qh.extension = {
      type: [me.RendererSystem, me.CanvasRendererSystem],
      name: "_view",
    });
  Ce.add(qh);
  we.PREFER_ENV = $n.WEBGL2;
  we.STRICT_TEXTURE_CACHE = !1;
  we.RENDER_OPTIONS = {
    ...Yh.defaultOptions,
    ...Wh.defaultOptions,
    ...qh.defaultOptions,
    ...jh.defaultOptions,
  };
  Object.defineProperties(we, {
    WRAP_MODE: {
      get() {
        return Le.defaultOptions.wrapMode;
      },
      set(r) {
        We(
          "7.1.0",
          "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"
        ),
          (Le.defaultOptions.wrapMode = r);
      },
    },
    SCALE_MODE: {
      get() {
        return Le.defaultOptions.scaleMode;
      },
      set(r) {
        We(
          "7.1.0",
          "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"
        ),
          (Le.defaultOptions.scaleMode = r);
      },
    },
    MIPMAP_TEXTURES: {
      get() {
        return Le.defaultOptions.mipmap;
      },
      set(r) {
        We(
          "7.1.0",
          "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"
        ),
          (Le.defaultOptions.mipmap = r);
      },
    },
    ANISOTROPIC_LEVEL: {
      get() {
        return Le.defaultOptions.anisotropicLevel;
      },
      set(r) {
        We(
          "7.1.0",
          "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"
        ),
          (Le.defaultOptions.anisotropicLevel = r);
      },
    },
    FILTER_RESOLUTION: {
      get() {
        return (
          We(
            "7.1.0",
            "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"
          ),
          fr.defaultResolution
        );
      },
      set(r) {
        fr.defaultResolution = r;
      },
    },
    FILTER_MULTISAMPLE: {
      get() {
        return (
          We(
            "7.1.0",
            "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"
          ),
          fr.defaultMultisample
        );
      },
      set(r) {
        fr.defaultMultisample = r;
      },
    },
    SPRITE_MAX_TEXTURES: {
      get() {
        return ks.defaultMaxTextures;
      },
      set(r) {
        We(
          "7.1.0",
          "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"
        ),
          (ks.defaultMaxTextures = r);
      },
    },
    SPRITE_BATCH_SIZE: {
      get() {
        return ks.defaultBatchSize;
      },
      set(r) {
        We(
          "7.1.0",
          "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"
        ),
          (ks.defaultBatchSize = r);
      },
    },
    CAN_UPLOAD_SAME_BUFFER: {
      get() {
        return ks.canUploadSameBuffer;
      },
      set(r) {
        We(
          "7.1.0",
          "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"
        ),
          (ks.canUploadSameBuffer = r);
      },
    },
    GC_MODE: {
      get() {
        return pn.defaultMode;
      },
      set(r) {
        We(
          "7.1.0",
          "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"
        ),
          (pn.defaultMode = r);
      },
    },
    GC_MAX_IDLE: {
      get() {
        return pn.defaultMaxIdle;
      },
      set(r) {
        We(
          "7.1.0",
          "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"
        ),
          (pn.defaultMaxIdle = r);
      },
    },
    GC_MAX_CHECK_COUNT: {
      get() {
        return pn.defaultCheckCountMax;
      },
      set(r) {
        We(
          "7.1.0",
          "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"
        ),
          (pn.defaultCheckCountMax = r);
      },
    },
    PRECISION_VERTEX: {
      get() {
        return Li.defaultVertexPrecision;
      },
      set(r) {
        We(
          "7.1.0",
          "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"
        ),
          (Li.defaultVertexPrecision = r);
      },
    },
    PRECISION_FRAGMENT: {
      get() {
        return Li.defaultFragmentPrecision;
      },
      set(r) {
        We(
          "7.1.0",
          "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"
        ),
          (Li.defaultFragmentPrecision = r);
      },
    },
  });
  var Ln = ((r) => (
    (r[(r.INTERACTION = 50)] = "INTERACTION"),
    (r[(r.HIGH = 25)] = "HIGH"),
    (r[(r.NORMAL = 0)] = "NORMAL"),
    (r[(r.LOW = -25)] = "LOW"),
    (r[(r.UTILITY = -50)] = "UTILITY"),
    r
  ))(Ln || {});
  class Ku {
    constructor(e, t = null, i = 0, s = !1) {
      (this.next = null),
        (this.previous = null),
        (this._destroyed = !1),
        (this.fn = e),
        (this.context = t),
        (this.priority = i),
        (this.once = s);
    }
    match(e, t = null) {
      return this.fn === e && this.context === t;
    }
    emit(e) {
      this.fn && (this.context ? this.fn.call(this.context, e) : this.fn(e));
      const t = this.next;
      return (
        this.once && this.destroy(!0), this._destroyed && (this.next = null), t
      );
    }
    connect(e) {
      (this.previous = e),
        e.next && (e.next.previous = this),
        (this.next = e.next),
        (e.next = this);
    }
    destroy(e = !1) {
      (this._destroyed = !0),
        (this.fn = null),
        (this.context = null),
        this.previous && (this.previous.next = this.next),
        this.next && (this.next.previous = this.previous);
      const t = this.next;
      return (this.next = e ? null : t), (this.previous = null), t;
    }
  }
  const o_ = class Sr {
    constructor() {
      (this.autoStart = !1),
        (this.deltaTime = 1),
        (this.lastTime = -1),
        (this.speed = 1),
        (this.started = !1),
        (this._requestId = null),
        (this._maxElapsedMS = 100),
        (this._minElapsedMS = 0),
        (this._protected = !1),
        (this._lastFrame = -1),
        (this._head = new Ku(null, null, 1 / 0)),
        (this.deltaMS = 1 / Sr.targetFPMS),
        (this.elapsedMS = 1 / Sr.targetFPMS),
        (this._tick = (e) => {
          (this._requestId = null),
            this.started &&
              (this.update(e),
              this.started &&
                this._requestId === null &&
                this._head.next &&
                (this._requestId = requestAnimationFrame(this._tick)));
        });
    }
    _requestIfNeeded() {
      this._requestId === null &&
        this._head.next &&
        ((this.lastTime = performance.now()),
        (this._lastFrame = this.lastTime),
        (this._requestId = requestAnimationFrame(this._tick)));
    }
    _cancelIfNeeded() {
      this._requestId !== null &&
        (cancelAnimationFrame(this._requestId), (this._requestId = null));
    }
    _startIfPossible() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }
    add(e, t, i = Ln.NORMAL) {
      return this._addListener(new Ku(e, t, i));
    }
    addOnce(e, t, i = Ln.NORMAL) {
      return this._addListener(new Ku(e, t, i, !0));
    }
    _addListener(e) {
      let t = this._head.next,
        i = this._head;
      if (!t) e.connect(i);
      else {
        for (; t; ) {
          if (e.priority > t.priority) {
            e.connect(i);
            break;
          }
          (i = t), (t = t.next);
        }
        e.previous || e.connect(i);
      }
      return this._startIfPossible(), this;
    }
    remove(e, t) {
      let i = this._head.next;
      for (; i; ) i.match(e, t) ? (i = i.destroy()) : (i = i.next);
      return this._head.next || this._cancelIfNeeded(), this;
    }
    get count() {
      if (!this._head) return 0;
      let e = 0,
        t = this._head;
      for (; (t = t.next); ) e++;
      return e;
    }
    start() {
      this.started || ((this.started = !0), this._requestIfNeeded());
    }
    stop() {
      this.started && ((this.started = !1), this._cancelIfNeeded());
    }
    destroy() {
      if (!this._protected) {
        this.stop();
        let e = this._head.next;
        for (; e; ) e = e.destroy(!0);
        this._head.destroy(), (this._head = null);
      }
    }
    update(e = performance.now()) {
      let t;
      if (e > this.lastTime) {
        if (
          ((t = this.elapsedMS = e - this.lastTime),
          t > this._maxElapsedMS && (t = this._maxElapsedMS),
          (t *= this.speed),
          this._minElapsedMS)
        ) {
          const n = (e - this._lastFrame) | 0;
          if (n < this._minElapsedMS) return;
          this._lastFrame = e - (n % this._minElapsedMS);
        }
        (this.deltaMS = t), (this.deltaTime = this.deltaMS * Sr.targetFPMS);
        const i = this._head;
        let s = i.next;
        for (; s; ) s = s.emit(this.deltaTime);
        i.next || this._cancelIfNeeded();
      } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      this.lastTime = e;
    }
    get FPS() {
      return 1e3 / this.elapsedMS;
    }
    get minFPS() {
      return 1e3 / this._maxElapsedMS;
    }
    set minFPS(e) {
      const t = Math.min(this.maxFPS, e),
        i = Math.min(Math.max(0, t) / 1e3, Sr.targetFPMS);
      this._maxElapsedMS = 1 / i;
    }
    get maxFPS() {
      return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
    }
    set maxFPS(e) {
      if (e === 0) this._minElapsedMS = 0;
      else {
        const t = Math.max(this.minFPS, e);
        this._minElapsedMS = 1 / (t / 1e3);
      }
    }
    static get shared() {
      if (!Sr._shared) {
        const e = (Sr._shared = new Sr());
        (e.autoStart = !0), (e._protected = !0);
      }
      return Sr._shared;
    }
    static get system() {
      if (!Sr._system) {
        const e = (Sr._system = new Sr());
        (e.autoStart = !0), (e._protected = !0);
      }
      return Sr._system;
    }
  };
  o_.targetFPMS = 0.06;
  let nr = o_;
  Object.defineProperties(we, {
    TARGET_FPMS: {
      get() {
        return nr.targetFPMS;
      },
      set(r) {
        We(
          "7.1.0",
          "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"
        ),
          (nr.targetFPMS = r);
      },
    },
  });
  class l_ {
    static init(e) {
      (e = Object.assign({ autoStart: !0, sharedTicker: !1 }, e)),
        Object.defineProperty(this, "ticker", {
          set(t) {
            this._ticker && this._ticker.remove(this.render, this),
              (this._ticker = t),
              t && t.add(this.render, this, Ln.LOW);
          },
          get() {
            return this._ticker;
          },
        }),
        (this.stop = () => {
          this._ticker.stop();
        }),
        (this.start = () => {
          this._ticker.start();
        }),
        (this._ticker = null),
        (this.ticker = e.sharedTicker ? nr.shared : new nr()),
        e.autoStart && this.start();
    }
    static destroy() {
      if (this._ticker) {
        const e = this._ticker;
        (this.ticker = null), e.destroy();
      }
    }
  }
  l_.extension = me.Application;
  Ce.add(l_);
  const h_ = [];
  Ce.handleByList(me.Renderer, h_);
  function E4(r) {
    for (const e of h_) if (e.test(r)) return new e(r);
    throw new Error("Unable to auto-detect a suitable renderer.");
  }
  var S4 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`,
    A4 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
  const C4 = S4,
    c_ = A4;
  class u_ {
    constructor(e) {
      this.renderer = e;
    }
    contextChange(e) {
      let t;
      if (this.renderer.context.webGLVersion === 1) {
        const i = e.getParameter(e.FRAMEBUFFER_BINDING);
        e.bindFramebuffer(e.FRAMEBUFFER, null),
          (t = e.getParameter(e.SAMPLES)),
          e.bindFramebuffer(e.FRAMEBUFFER, i);
      } else {
        const i = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);
        e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
          (t = e.getParameter(e.SAMPLES)),
          e.bindFramebuffer(e.DRAW_FRAMEBUFFER, i);
      }
      t >= Ft.HIGH
        ? (this.multisample = Ft.HIGH)
        : t >= Ft.MEDIUM
        ? (this.multisample = Ft.MEDIUM)
        : t >= Ft.LOW
        ? (this.multisample = Ft.LOW)
        : (this.multisample = Ft.NONE);
    }
    destroy() {}
  }
  u_.extension = { type: me.RendererSystem, name: "_multisample" };
  Ce.add(u_);
  class I4 {
    constructor(e) {
      (this.buffer = e || null),
        (this.updateID = -1),
        (this.byteLength = -1),
        (this.refCount = 0);
    }
  }
  class d_ {
    constructor(e) {
      (this.renderer = e),
        (this.managedBuffers = {}),
        (this.boundBufferBases = {});
    }
    destroy() {
      this.renderer = null;
    }
    contextChange() {
      this.disposeAll(!0),
        (this.gl = this.renderer.gl),
        (this.CONTEXT_UID = this.renderer.CONTEXT_UID);
    }
    bind(e) {
      const { gl: t, CONTEXT_UID: i } = this,
        s = e._glBuffers[i] || this.createGLBuffer(e);
      t.bindBuffer(e.type, s.buffer);
    }
    unbind(e) {
      const { gl: t } = this;
      t.bindBuffer(e, null);
    }
    bindBufferBase(e, t) {
      const { gl: i, CONTEXT_UID: s } = this;
      if (this.boundBufferBases[t] !== e) {
        const n = e._glBuffers[s] || this.createGLBuffer(e);
        (this.boundBufferBases[t] = e),
          i.bindBufferBase(i.UNIFORM_BUFFER, t, n.buffer);
      }
    }
    bindBufferRange(e, t, i) {
      const { gl: s, CONTEXT_UID: n } = this;
      i = i || 0;
      const a = e._glBuffers[n] || this.createGLBuffer(e);
      s.bindBufferRange(s.UNIFORM_BUFFER, t || 0, a.buffer, i * 256, 256);
    }
    update(e) {
      const { gl: t, CONTEXT_UID: i } = this,
        s = e._glBuffers[i] || this.createGLBuffer(e);
      if (e._updateID !== s.updateID)
        if (
          ((s.updateID = e._updateID),
          t.bindBuffer(e.type, s.buffer),
          s.byteLength >= e.data.byteLength)
        )
          t.bufferSubData(e.type, 0, e.data);
        else {
          const n = e.static ? t.STATIC_DRAW : t.DYNAMIC_DRAW;
          (s.byteLength = e.data.byteLength), t.bufferData(e.type, e.data, n);
        }
    }
    dispose(e, t) {
      if (!this.managedBuffers[e.id]) return;
      delete this.managedBuffers[e.id];
      const i = e._glBuffers[this.CONTEXT_UID],
        s = this.gl;
      e.disposeRunner.remove(this),
        i &&
          (t || s.deleteBuffer(i.buffer),
          delete e._glBuffers[this.CONTEXT_UID]);
    }
    disposeAll(e) {
      const t = Object.keys(this.managedBuffers);
      for (let i = 0; i < t.length; i++)
        this.dispose(this.managedBuffers[t[i]], e);
    }
    createGLBuffer(e) {
      const { CONTEXT_UID: t, gl: i } = this;
      return (
        (e._glBuffers[t] = new I4(i.createBuffer())),
        (this.managedBuffers[e.id] = e),
        e.disposeRunner.add(this),
        e._glBuffers[t]
      );
    }
  }
  d_.extension = { type: me.RendererSystem, name: "buffer" };
  Ce.add(d_);
  class f_ {
    constructor(e) {
      this.renderer = e;
    }
    render(e, t) {
      const i = this.renderer;
      let s, n, a, o;
      if (
        (t &&
          ((s = t.renderTexture),
          (n = t.clear),
          (a = t.transform),
          (o = t.skipUpdateTransform)),
        (this.renderingToScreen = !s),
        i.runners.prerender.emit(),
        i.emit("prerender"),
        (i.projection.transform = a),
        !i.context.isLost)
      ) {
        if ((s || (this.lastObjectRendered = e), !o)) {
          const l = e.enableTempParent();
          e.updateTransform(), e.disableTempParent(l);
        }
        i.renderTexture.bind(s),
          i.batch.currentRenderer.start(),
          (n ?? i.background.clearBeforeRender) && i.renderTexture.clear(),
          e.render(i),
          i.batch.currentRenderer.flush(),
          s && (t.blit && i.framebuffer.blit(), s.baseTexture.update()),
          i.runners.postrender.emit(),
          (i.projection.transform = null),
          i.emit("postrender");
      }
    }
    destroy() {
      (this.renderer = null), (this.lastObjectRendered = null);
    }
  }
  f_.extension = { type: me.RendererSystem, name: "objectRenderer" };
  Ce.add(f_);
  const xh = class mf extends _4 {
    constructor(e) {
      super(),
        (this.type = t1.WEBGL),
        (e = Object.assign({}, we.RENDER_OPTIONS, e)),
        (this.gl = null),
        (this.CONTEXT_UID = 0),
        (this.globalUniforms = new di({ projectionMatrix: new vt() }, !0));
      const t = {
        runners: [
          "init",
          "destroy",
          "contextChange",
          "resolutionChange",
          "reset",
          "update",
          "postrender",
          "prerender",
          "resize",
        ],
        systems: mf.__systems,
        priority: [
          "_view",
          "textureGenerator",
          "background",
          "_plugin",
          "startup",
          "context",
          "state",
          "texture",
          "buffer",
          "geometry",
          "framebuffer",
          "transformFeedback",
          "mask",
          "scissor",
          "stencil",
          "projection",
          "textureGC",
          "filter",
          "renderTexture",
          "batch",
          "objectRenderer",
          "_multisample",
        ],
      };
      this.setup(t),
        "useContextAlpha" in e &&
          (We(
            "7.0.0",
            "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"
          ),
          (e.premultipliedAlpha =
            e.useContextAlpha && e.useContextAlpha !== "notMultiplied"),
          (e.backgroundAlpha =
            e.useContextAlpha === !1 ? 1 : e.backgroundAlpha)),
        (this._plugin.rendererPlugins = mf.__plugins),
        (this.options = e),
        this.startup.run(this.options);
    }
    static test(e) {
      return e != null && e.forceCanvas ? !1 : JL();
    }
    render(e, t) {
      this.objectRenderer.render(e, t);
    }
    resize(e, t) {
      this._view.resizeView(e, t);
    }
    reset() {
      return this.runners.reset.emit(), this;
    }
    clear() {
      this.renderTexture.bind(), this.renderTexture.clear();
    }
    destroy(e = !1) {
      this.runners.destroy.items.reverse(),
        this.emitWithCustomOptions(this.runners.destroy, { _view: e }),
        super.destroy();
    }
    get plugins() {
      return this._plugin.plugins;
    }
    get multisample() {
      return this._multisample.multisample;
    }
    get width() {
      return this._view.element.width;
    }
    get height() {
      return this._view.element.height;
    }
    get resolution() {
      return this._view.resolution;
    }
    set resolution(e) {
      (this._view.resolution = e), this.runners.resolutionChange.emit(e);
    }
    get autoDensity() {
      return this._view.autoDensity;
    }
    get view() {
      return this._view.element;
    }
    get screen() {
      return this._view.screen;
    }
    get lastObjectRendered() {
      return this.objectRenderer.lastObjectRendered;
    }
    get renderingToScreen() {
      return this.objectRenderer.renderingToScreen;
    }
    get rendererLogId() {
      return `WebGL ${this.context.webGLVersion}`;
    }
    get clearBeforeRender() {
      return (
        We(
          "7.0.0",
          "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."
        ),
        this.background.clearBeforeRender
      );
    }
    get useContextAlpha() {
      return (
        We(
          "7.0.0",
          "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."
        ),
        this.context.useContextAlpha
      );
    }
    get preserveDrawingBuffer() {
      return (
        We(
          "7.0.0",
          "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"
        ),
        this.context.preserveDrawingBuffer
      );
    }
    get backgroundColor() {
      return (
        We(
          "7.0.0",
          "renderer.backgroundColor has been deprecated, use renderer.background.color instead."
        ),
        this.background.color
      );
    }
    set backgroundColor(e) {
      We(
        "7.0.0",
        "renderer.backgroundColor has been deprecated, use renderer.background.color instead."
      ),
        (this.background.color = e);
    }
    get backgroundAlpha() {
      return (
        We(
          "7.0.0",
          "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."
        ),
        this.background.alpha
      );
    }
    set backgroundAlpha(e) {
      We(
        "7.0.0",
        "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."
      ),
        (this.background.alpha = e);
    }
    get powerPreference() {
      return (
        We(
          "7.0.0",
          "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"
        ),
        this.context.powerPreference
      );
    }
    generateTexture(e, t) {
      return this.textureGenerator.generateTexture(e, t);
    }
  };
  (xh.extension = { type: me.Renderer, priority: 1 }),
    (xh.__plugins = {}),
    (xh.__systems = {});
  let nm = xh;
  Ce.handleByMap(me.RendererPlugin, nm.__plugins);
  Ce.handleByMap(me.RendererSystem, nm.__systems);
  Ce.add(nm);
  class p_ extends rl {
    constructor(e, t) {
      const { width: i, height: s } = t || {};
      super(i, s), (this.items = []), (this.itemDirtyIds = []);
      for (let n = 0; n < e; n++) {
        const a = new Le();
        this.items.push(a), this.itemDirtyIds.push(-2);
      }
      (this.length = e), (this._load = null), (this.baseTexture = null);
    }
    initFromArray(e, t) {
      for (let i = 0; i < this.length; i++)
        e[i] &&
          (e[i].castToBaseTexture
            ? this.addBaseTextureAt(e[i].castToBaseTexture(), i)
            : e[i] instanceof rl
            ? this.addResourceAt(e[i], i)
            : this.addResourceAt(F1(e[i], t), i));
    }
    dispose() {
      for (let e = 0, t = this.length; e < t; e++) this.items[e].destroy();
      (this.items = null), (this.itemDirtyIds = null), (this._load = null);
    }
    addResourceAt(e, t) {
      if (!this.items[t]) throw new Error(`Index ${t} is out of bounds`);
      return (
        e.valid && !this.valid && this.resize(e.width, e.height),
        this.items[t].setResource(e),
        this
      );
    }
    bind(e) {
      if (this.baseTexture !== null)
        throw new Error("Only one base texture per TextureArray is allowed");
      super.bind(e);
      for (let t = 0; t < this.length; t++)
        (this.items[t].parentTextureArray = e),
          this.items[t].on("update", e.update, e);
    }
    unbind(e) {
      super.unbind(e);
      for (let t = 0; t < this.length; t++)
        (this.items[t].parentTextureArray = null),
          this.items[t].off("update", e.update, e);
    }
    load() {
      if (this._load) return this._load;
      const e = this.items
        .map((t) => t.resource)
        .filter((t) => t)
        .map((t) => t.load());
      return (
        (this._load = Promise.all(e).then(() => {
          const { realWidth: t, realHeight: i } = this.items[0];
          return this.resize(t, i), this.update(), Promise.resolve(this);
        })),
        this._load
      );
    }
  }
  class P4 extends p_ {
    constructor(e, t) {
      const { width: i, height: s } = t || {};
      let n, a;
      Array.isArray(e) ? ((n = e), (a = e.length)) : (a = e),
        super(a, { width: i, height: s }),
        n && this.initFromArray(n, t);
    }
    addBaseTextureAt(e, t) {
      if (e.resource) this.addResourceAt(e.resource, t);
      else throw new Error("ArrayResource does not support RenderTexture");
      return this;
    }
    bind(e) {
      super.bind(e), (e.target = wa.TEXTURE_2D_ARRAY);
    }
    upload(e, t, i) {
      const { length: s, itemDirtyIds: n, items: a } = this,
        { gl: o } = e;
      i.dirtyId < 0 &&
        o.texImage3D(
          o.TEXTURE_2D_ARRAY,
          0,
          i.internalFormat,
          this._width,
          this._height,
          s,
          0,
          t.format,
          i.type,
          null
        );
      for (let l = 0; l < s; l++) {
        const h = a[l];
        n[l] < h.dirtyId &&
          ((n[l] = h.dirtyId),
          h.valid &&
            o.texSubImage3D(
              o.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              l,
              h.resource.width,
              h.resource.height,
              1,
              t.format,
              i.type,
              h.resource.source
            ));
      }
      return !0;
    }
  }
  class R4 extends ys {
    constructor(e) {
      super(e);
    }
    static test(e) {
      const { OffscreenCanvas: t } = globalThis;
      return t && e instanceof t
        ? !0
        : globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement;
    }
  }
  const m_ = class _o extends p_ {
    constructor(e, t) {
      const { width: i, height: s, autoLoad: n, linkBaseTexture: a } = t || {};
      if (e && e.length !== _o.SIDES)
        throw new Error(`Invalid length. Got ${e.length}, expected 6`);
      super(6, { width: i, height: s });
      for (let o = 0; o < _o.SIDES; o++)
        this.items[o].target = wa.TEXTURE_CUBE_MAP_POSITIVE_X + o;
      (this.linkBaseTexture = a !== !1),
        e && this.initFromArray(e, t),
        n !== !1 && this.load();
    }
    bind(e) {
      super.bind(e), (e.target = wa.TEXTURE_CUBE_MAP);
    }
    addBaseTextureAt(e, t, i) {
      if ((i === void 0 && (i = this.linkBaseTexture), !this.items[t]))
        throw new Error(`Index ${t} is out of bounds`);
      if (
        !this.linkBaseTexture ||
        e.parentTextureArray ||
        Object.keys(e._glTextures).length > 0
      )
        if (e.resource) this.addResourceAt(e.resource, t);
        else
          throw new Error(
            "CubeResource does not support copying of renderTexture."
          );
      else
        (e.target = wa.TEXTURE_CUBE_MAP_POSITIVE_X + t),
          (e.parentTextureArray = this.baseTexture),
          (this.items[t] = e);
      return (
        e.valid && !this.valid && this.resize(e.realWidth, e.realHeight),
        (this.items[t] = e),
        this
      );
    }
    upload(e, t, i) {
      const s = this.itemDirtyIds;
      for (let n = 0; n < _o.SIDES; n++) {
        const a = this.items[n];
        (s[n] < a.dirtyId || i.dirtyId < t.dirtyId) &&
          (a.valid && a.resource
            ? (a.resource.upload(e, a, i), (s[n] = a.dirtyId))
            : s[n] < -1 &&
              (e.gl.texImage2D(
                a.target,
                0,
                i.internalFormat,
                t.realWidth,
                t.realHeight,
                0,
                t.format,
                i.type,
                null
              ),
              (s[n] = -1)));
      }
      return !0;
    }
    static test(e) {
      return Array.isArray(e) && e.length === _o.SIDES;
    }
  };
  m_.SIDES = 6;
  let M4 = m_;
  class ca extends ys {
    constructor(e, t) {
      t = t || {};
      let i, s, n;
      typeof e == "string"
        ? ((i = ca.EMPTY), (s = e), (n = !0))
        : ((i = e), (s = null), (n = !1)),
        super(i),
        (this.url = s),
        (this.crossOrigin = t.crossOrigin ?? !0),
        (this.alphaMode = typeof t.alphaMode == "number" ? t.alphaMode : null),
        (this.ownsImageBitmap = t.ownsImageBitmap ?? n),
        (this._load = null),
        t.autoLoad !== !1 && this.load();
    }
    load() {
      return this._load
        ? this._load
        : ((this._load = new Promise(async (e, t) => {
            if (this.url === null) {
              e(this);
              return;
            }
            try {
              const i = await we.ADAPTER.fetch(this.url, {
                mode: this.crossOrigin ? "cors" : "no-cors",
              });
              if (this.destroyed) return;
              const s = await i.blob();
              if (this.destroyed) return;
              const n = await createImageBitmap(s, {
                premultiplyAlpha:
                  this.alphaMode === null || this.alphaMode === sr.UNPACK
                    ? "premultiply"
                    : "none",
              });
              if (this.destroyed) {
                n.close();
                return;
              }
              (this.source = n), this.update(), e(this);
            } catch (i) {
              if (this.destroyed) return;
              t(i), this.onError.emit(i);
            }
          })),
          this._load);
    }
    upload(e, t, i) {
      return this.source instanceof ImageBitmap
        ? (typeof this.alphaMode == "number" && (t.alphaMode = this.alphaMode),
          super.upload(e, t, i))
        : (this.load(), !1);
    }
    dispose() {
      this.ownsImageBitmap &&
        this.source instanceof ImageBitmap &&
        this.source.close(),
        super.dispose(),
        (this._load = null);
    }
    static test(e) {
      return (
        !!globalThis.createImageBitmap &&
        typeof ImageBitmap < "u" &&
        (typeof e == "string" || e instanceof ImageBitmap)
      );
    }
    static get EMPTY() {
      return (
        (ca._EMPTY = ca._EMPTY ?? we.ADAPTER.createCanvas(0, 0)), ca._EMPTY
      );
    }
  }
  const gf = class _h extends ys {
    constructor(e, t) {
      (t = t || {}),
        super(we.ADAPTER.createCanvas()),
        (this._width = 0),
        (this._height = 0),
        (this.svg = e),
        (this.scale = t.scale || 1),
        (this._overrideWidth = t.width),
        (this._overrideHeight = t.height),
        (this._resolve = null),
        (this._crossorigin = t.crossorigin),
        (this._load = null),
        t.autoLoad !== !1 && this.load();
    }
    load() {
      return this._load
        ? this._load
        : ((this._load = new Promise((e) => {
            if (
              ((this._resolve = () => {
                this.update(), e(this);
              }),
              _h.SVG_XML.test(this.svg.trim()))
            ) {
              if (!btoa)
                throw new Error(
                  "Your browser doesn't support base64 conversions."
                );
              this.svg = `data:image/svg+xml;base64,${btoa(
                unescape(encodeURIComponent(this.svg))
              )}`;
            }
            this._loadSvg();
          })),
          this._load);
    }
    _loadSvg() {
      const e = new Image();
      ys.crossOrigin(e, this.svg, this._crossorigin),
        (e.src = this.svg),
        (e.onerror = (t) => {
          this._resolve && ((e.onerror = null), this.onError.emit(t));
        }),
        (e.onload = () => {
          if (!this._resolve) return;
          const t = e.width,
            i = e.height;
          if (!t || !i)
            throw new Error(
              "The SVG image must have width and height defined (in pixels), canvas API needs them."
            );
          let s = t * this.scale,
            n = i * this.scale;
          (this._overrideWidth || this._overrideHeight) &&
            ((s = this._overrideWidth || (this._overrideHeight / i) * t),
            (n = this._overrideHeight || (this._overrideWidth / t) * i)),
            (s = Math.round(s)),
            (n = Math.round(n));
          const a = this.source;
          (a.width = s),
            (a.height = n),
            (a._pixiId = `canvas_${Dn()}`),
            a.getContext("2d").drawImage(e, 0, 0, t, i, 0, 0, s, n),
            this._resolve(),
            (this._resolve = null);
        });
    }
    static getSize(e) {
      const t = _h.SVG_SIZE.exec(e),
        i = {};
      return (
        t &&
          ((i[t[1]] = Math.round(parseFloat(t[3]))),
          (i[t[5]] = Math.round(parseFloat(t[7])))),
        i
      );
    }
    dispose() {
      super.dispose(), (this._resolve = null), (this._crossorigin = null);
    }
    static test(e, t) {
      return (
        t === "svg" ||
        (typeof e == "string" && e.startsWith("data:image/svg+xml")) ||
        (typeof e == "string" && _h.SVG_XML.test(e))
      );
    }
  };
  (gf.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m),
    (gf.SVG_SIZE =
      /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i);
  let vf = gf;
  class F4 extends ys {
    constructor(e) {
      super(e);
    }
    static test(e) {
      return !!globalThis.VideoFrame && e instanceof globalThis.VideoFrame;
    }
  }
  const yf = class bf extends ys {
    constructor(e, t) {
      if (((t = t || {}), !(e instanceof HTMLVideoElement))) {
        const i = document.createElement("video");
        t.autoLoad !== !1 && i.setAttribute("preload", "auto"),
          t.playsinline !== !1 &&
            (i.setAttribute("webkit-playsinline", ""),
            i.setAttribute("playsinline", "")),
          t.muted === !0 && (i.setAttribute("muted", ""), (i.muted = !0)),
          t.loop === !0 && i.setAttribute("loop", ""),
          t.autoPlay !== !1 && i.setAttribute("autoplay", ""),
          typeof e == "string" && (e = [e]);
        const s = e[0].src || e[0];
        ys.crossOrigin(i, s, t.crossorigin);
        for (let n = 0; n < e.length; ++n) {
          const a = document.createElement("source");
          let { src: o, mime: l } = e[n];
          if (((o = o || e[n]), o.startsWith("data:")))
            l = o.slice(5, o.indexOf(";"));
          else if (!o.startsWith("blob:")) {
            const h = o.split("?").shift().toLowerCase(),
              c = h.slice(h.lastIndexOf(".") + 1);
            l = l || bf.MIME_TYPES[c] || `video/${c}`;
          }
          (a.src = o), l && (a.type = l), i.appendChild(a);
        }
        e = i;
      }
      super(e),
        (this.noSubImage = !0),
        (this._autoUpdate = !0),
        (this._isConnectedToTicker = !1),
        (this._updateFPS = t.updateFPS || 0),
        (this._msToNextUpdate = 0),
        (this.autoPlay = t.autoPlay !== !1),
        (this._videoFrameRequestCallback =
          this._videoFrameRequestCallback.bind(this)),
        (this._videoFrameRequestCallbackHandle = null),
        (this._load = null),
        (this._resolve = null),
        (this._reject = null),
        (this._onCanPlay = this._onCanPlay.bind(this)),
        (this._onError = this._onError.bind(this)),
        (this._onPlayStart = this._onPlayStart.bind(this)),
        (this._onPlayStop = this._onPlayStop.bind(this)),
        (this._onSeeked = this._onSeeked.bind(this)),
        t.autoLoad !== !1 && this.load();
    }
    update(e = 0) {
      if (!this.destroyed) {
        if (this._updateFPS) {
          const t = nr.shared.elapsedMS * this.source.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - t);
        }
        (!this._updateFPS || this._msToNextUpdate <= 0) &&
          (super.update(),
          (this._msToNextUpdate = this._updateFPS
            ? Math.floor(1e3 / this._updateFPS)
            : 0));
      }
    }
    _videoFrameRequestCallback() {
      this.update(),
        this.destroyed
          ? (this._videoFrameRequestCallbackHandle = null)
          : (this._videoFrameRequestCallbackHandle =
              this.source.requestVideoFrameCallback(
                this._videoFrameRequestCallback
              ));
    }
    load() {
      if (this._load) return this._load;
      const e = this.source;
      return (
        (e.readyState === e.HAVE_ENOUGH_DATA ||
          e.readyState === e.HAVE_FUTURE_DATA) &&
          e.width &&
          e.height &&
          (e.complete = !0),
        e.addEventListener("play", this._onPlayStart),
        e.addEventListener("pause", this._onPlayStop),
        e.addEventListener("seeked", this._onSeeked),
        this._isSourceReady()
          ? this._onCanPlay()
          : (e.addEventListener("canplay", this._onCanPlay),
            e.addEventListener("canplaythrough", this._onCanPlay),
            e.addEventListener("error", this._onError, !0)),
        (this._load = new Promise((t, i) => {
          this.valid
            ? t(this)
            : ((this._resolve = t), (this._reject = i), e.load());
        })),
        this._load
      );
    }
    _onError(e) {
      this.source.removeEventListener("error", this._onError, !0),
        this.onError.emit(e),
        this._reject &&
          (this._reject(e), (this._reject = null), (this._resolve = null));
    }
    _isSourcePlaying() {
      const e = this.source;
      return !e.paused && !e.ended;
    }
    _isSourceReady() {
      return this.source.readyState > 2;
    }
    _onPlayStart() {
      this.valid || this._onCanPlay(), this._configureAutoUpdate();
    }
    _onPlayStop() {
      this._configureAutoUpdate();
    }
    _onSeeked() {
      this._autoUpdate &&
        !this._isSourcePlaying() &&
        ((this._msToNextUpdate = 0), this.update(), (this._msToNextUpdate = 0));
    }
    _onCanPlay() {
      const e = this.source;
      e.removeEventListener("canplay", this._onCanPlay),
        e.removeEventListener("canplaythrough", this._onCanPlay);
      const t = this.valid;
      (this._msToNextUpdate = 0),
        this.update(),
        (this._msToNextUpdate = 0),
        !t &&
          this._resolve &&
          (this._resolve(this), (this._resolve = null), (this._reject = null)),
        this._isSourcePlaying()
          ? this._onPlayStart()
          : this.autoPlay && e.play();
    }
    dispose() {
      this._configureAutoUpdate();
      const e = this.source;
      e &&
        (e.removeEventListener("play", this._onPlayStart),
        e.removeEventListener("pause", this._onPlayStop),
        e.removeEventListener("seeked", this._onSeeked),
        e.removeEventListener("canplay", this._onCanPlay),
        e.removeEventListener("canplaythrough", this._onCanPlay),
        e.removeEventListener("error", this._onError, !0),
        e.pause(),
        (e.src = ""),
        e.load()),
        super.dispose();
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(e) {
      e !== this._autoUpdate &&
        ((this._autoUpdate = e), this._configureAutoUpdate());
    }
    get updateFPS() {
      return this._updateFPS;
    }
    set updateFPS(e) {
      e !== this._updateFPS &&
        ((this._updateFPS = e), this._configureAutoUpdate());
    }
    _configureAutoUpdate() {
      this._autoUpdate && this._isSourcePlaying()
        ? !this._updateFPS && this.source.requestVideoFrameCallback
          ? (this._isConnectedToTicker &&
              (nr.shared.remove(this.update, this),
              (this._isConnectedToTicker = !1),
              (this._msToNextUpdate = 0)),
            this._videoFrameRequestCallbackHandle === null &&
              (this._videoFrameRequestCallbackHandle =
                this.source.requestVideoFrameCallback(
                  this._videoFrameRequestCallback
                )))
          : (this._videoFrameRequestCallbackHandle !== null &&
              (this.source.cancelVideoFrameCallback(
                this._videoFrameRequestCallbackHandle
              ),
              (this._videoFrameRequestCallbackHandle = null)),
            this._isConnectedToTicker ||
              (nr.shared.add(this.update, this),
              (this._isConnectedToTicker = !0),
              (this._msToNextUpdate = 0)))
        : (this._videoFrameRequestCallbackHandle !== null &&
            (this.source.cancelVideoFrameCallback(
              this._videoFrameRequestCallbackHandle
            ),
            (this._videoFrameRequestCallbackHandle = null)),
          this._isConnectedToTicker &&
            (nr.shared.remove(this.update, this),
            (this._isConnectedToTicker = !1),
            (this._msToNextUpdate = 0)));
    }
    static test(e, t) {
      return (
        (globalThis.HTMLVideoElement && e instanceof HTMLVideoElement) ||
        bf.TYPES.includes(t)
      );
    }
  };
  (yf.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"]),
    (yf.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4",
    });
  let g_ = yf;
  nf.push(ca, G1, R4, g_, F4, vf, Nc, M4, P4);
  class Kh {
    constructor() {
      (this.minX = 1 / 0),
        (this.minY = 1 / 0),
        (this.maxX = -1 / 0),
        (this.maxY = -1 / 0),
        (this.rect = null),
        (this.updateID = -1);
    }
    isEmpty() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }
    clear() {
      (this.minX = 1 / 0),
        (this.minY = 1 / 0),
        (this.maxX = -1 / 0),
        (this.maxY = -1 / 0);
    }
    getRectangle(e) {
      return this.minX > this.maxX || this.minY > this.maxY
        ? $e.EMPTY
        : ((e = e || new $e(0, 0, 1, 1)),
          (e.x = this.minX),
          (e.y = this.minY),
          (e.width = this.maxX - this.minX),
          (e.height = this.maxY - this.minY),
          e);
    }
    addPoint(e) {
      (this.minX = Math.min(this.minX, e.x)),
        (this.maxX = Math.max(this.maxX, e.x)),
        (this.minY = Math.min(this.minY, e.y)),
        (this.maxY = Math.max(this.maxY, e.y));
    }
    addPointMatrix(e, t) {
      const { a: i, b: s, c: n, d: a, tx: o, ty: l } = e,
        h = i * t.x + n * t.y + o,
        c = s * t.x + a * t.y + l;
      (this.minX = Math.min(this.minX, h)),
        (this.maxX = Math.max(this.maxX, h)),
        (this.minY = Math.min(this.minY, c)),
        (this.maxY = Math.max(this.maxY, c));
    }
    addQuad(e) {
      let t = this.minX,
        i = this.minY,
        s = this.maxX,
        n = this.maxY,
        a = e[0],
        o = e[1];
      (t = a < t ? a : t),
        (i = o < i ? o : i),
        (s = a > s ? a : s),
        (n = o > n ? o : n),
        (a = e[2]),
        (o = e[3]),
        (t = a < t ? a : t),
        (i = o < i ? o : i),
        (s = a > s ? a : s),
        (n = o > n ? o : n),
        (a = e[4]),
        (o = e[5]),
        (t = a < t ? a : t),
        (i = o < i ? o : i),
        (s = a > s ? a : s),
        (n = o > n ? o : n),
        (a = e[6]),
        (o = e[7]),
        (t = a < t ? a : t),
        (i = o < i ? o : i),
        (s = a > s ? a : s),
        (n = o > n ? o : n),
        (this.minX = t),
        (this.minY = i),
        (this.maxX = s),
        (this.maxY = n);
    }
    addFrame(e, t, i, s, n) {
      this.addFrameMatrix(e.worldTransform, t, i, s, n);
    }
    addFrameMatrix(e, t, i, s, n) {
      const a = e.a,
        o = e.b,
        l = e.c,
        h = e.d,
        c = e.tx,
        u = e.ty;
      let d = this.minX,
        f = this.minY,
        p = this.maxX,
        m = this.maxY,
        v = a * t + l * i + c,
        g = o * t + h * i + u;
      (d = v < d ? v : d),
        (f = g < f ? g : f),
        (p = v > p ? v : p),
        (m = g > m ? g : m),
        (v = a * s + l * i + c),
        (g = o * s + h * i + u),
        (d = v < d ? v : d),
        (f = g < f ? g : f),
        (p = v > p ? v : p),
        (m = g > m ? g : m),
        (v = a * t + l * n + c),
        (g = o * t + h * n + u),
        (d = v < d ? v : d),
        (f = g < f ? g : f),
        (p = v > p ? v : p),
        (m = g > m ? g : m),
        (v = a * s + l * n + c),
        (g = o * s + h * n + u),
        (d = v < d ? v : d),
        (f = g < f ? g : f),
        (p = v > p ? v : p),
        (m = g > m ? g : m),
        (this.minX = d),
        (this.minY = f),
        (this.maxX = p),
        (this.maxY = m);
    }
    addVertexData(e, t, i) {
      let s = this.minX,
        n = this.minY,
        a = this.maxX,
        o = this.maxY;
      for (let l = t; l < i; l += 2) {
        const h = e[l],
          c = e[l + 1];
        (s = h < s ? h : s),
          (n = c < n ? c : n),
          (a = h > a ? h : a),
          (o = c > o ? c : o);
      }
      (this.minX = s), (this.minY = n), (this.maxX = a), (this.maxY = o);
    }
    addVertices(e, t, i, s) {
      this.addVerticesMatrix(e.worldTransform, t, i, s);
    }
    addVerticesMatrix(e, t, i, s, n = 0, a = n) {
      const o = e.a,
        l = e.b,
        h = e.c,
        c = e.d,
        u = e.tx,
        d = e.ty;
      let f = this.minX,
        p = this.minY,
        m = this.maxX,
        v = this.maxY;
      for (let g = i; g < s; g += 2) {
        const x = t[g],
          b = t[g + 1],
          y = o * x + h * b + u,
          _ = c * b + l * x + d;
        (f = Math.min(f, y - n)),
          (m = Math.max(m, y + n)),
          (p = Math.min(p, _ - a)),
          (v = Math.max(v, _ + a));
      }
      (this.minX = f), (this.minY = p), (this.maxX = m), (this.maxY = v);
    }
    addBounds(e) {
      const t = this.minX,
        i = this.minY,
        s = this.maxX,
        n = this.maxY;
      (this.minX = e.minX < t ? e.minX : t),
        (this.minY = e.minY < i ? e.minY : i),
        (this.maxX = e.maxX > s ? e.maxX : s),
        (this.maxY = e.maxY > n ? e.maxY : n);
    }
    addBoundsMask(e, t) {
      const i = e.minX > t.minX ? e.minX : t.minX,
        s = e.minY > t.minY ? e.minY : t.minY,
        n = e.maxX < t.maxX ? e.maxX : t.maxX,
        a = e.maxY < t.maxY ? e.maxY : t.maxY;
      if (i <= n && s <= a) {
        const o = this.minX,
          l = this.minY,
          h = this.maxX,
          c = this.maxY;
        (this.minX = i < o ? i : o),
          (this.minY = s < l ? s : l),
          (this.maxX = n > h ? n : h),
          (this.maxY = a > c ? a : c);
      }
    }
    addBoundsMatrix(e, t) {
      this.addFrameMatrix(t, e.minX, e.minY, e.maxX, e.maxY);
    }
    addBoundsArea(e, t) {
      const i = e.minX > t.x ? e.minX : t.x,
        s = e.minY > t.y ? e.minY : t.y,
        n = e.maxX < t.x + t.width ? e.maxX : t.x + t.width,
        a = e.maxY < t.y + t.height ? e.maxY : t.y + t.height;
      if (i <= n && s <= a) {
        const o = this.minX,
          l = this.minY,
          h = this.maxX,
          c = this.maxY;
        (this.minX = i < o ? i : o),
          (this.minY = s < l ? s : l),
          (this.maxX = n > h ? n : h),
          (this.maxY = a > c ? a : c);
      }
    }
    pad(e = 0, t = e) {
      this.isEmpty() ||
        ((this.minX -= e),
        (this.maxX += e),
        (this.minY -= t),
        (this.maxY += t));
    }
    addFramePad(e, t, i, s, n, a) {
      (e -= n),
        (t -= a),
        (i += n),
        (s += a),
        (this.minX = this.minX < e ? this.minX : e),
        (this.maxX = this.maxX > i ? this.maxX : i),
        (this.minY = this.minY < t ? this.minY : t),
        (this.maxY = this.maxY > s ? this.maxY : s);
    }
  }
  class At extends gl {
    constructor() {
      super(),
        (this.tempDisplayObjectParent = null),
        (this.transform = new rm()),
        (this.alpha = 1),
        (this.visible = !0),
        (this.renderable = !0),
        (this.cullable = !1),
        (this.cullArea = null),
        (this.parent = null),
        (this.worldAlpha = 1),
        (this._lastSortedIndex = 0),
        (this._zIndex = 0),
        (this.filterArea = null),
        (this.filters = null),
        (this._enabledFilters = null),
        (this._bounds = new Kh()),
        (this._localBounds = null),
        (this._boundsID = 0),
        (this._boundsRect = null),
        (this._localBoundsRect = null),
        (this._mask = null),
        (this._maskRefCount = 0),
        (this._destroyed = !1),
        (this.isSprite = !1),
        (this.isMask = !1);
    }
    static mixin(e) {
      const t = Object.keys(e);
      for (let i = 0; i < t.length; ++i) {
        const s = t[i];
        Object.defineProperty(
          At.prototype,
          s,
          Object.getOwnPropertyDescriptor(e, s)
        );
      }
    }
    get destroyed() {
      return this._destroyed;
    }
    _recursivePostUpdateTransform() {
      this.parent
        ? (this.parent._recursivePostUpdateTransform(),
          this.transform.updateTransform(this.parent.transform))
        : this.transform.updateTransform(
            this._tempDisplayObjectParent.transform
          );
    }
    updateTransform() {
      this._boundsID++,
        this.transform.updateTransform(this.parent.transform),
        (this.worldAlpha = this.alpha * this.parent.worldAlpha);
    }
    getBounds(e, t) {
      return (
        e ||
          (this.parent
            ? (this._recursivePostUpdateTransform(), this.updateTransform())
            : ((this.parent = this._tempDisplayObjectParent),
              this.updateTransform(),
              (this.parent = null))),
        this._bounds.updateID !== this._boundsID &&
          (this.calculateBounds(), (this._bounds.updateID = this._boundsID)),
        t ||
          (this._boundsRect || (this._boundsRect = new $e()),
          (t = this._boundsRect)),
        this._bounds.getRectangle(t)
      );
    }
    getLocalBounds(e) {
      e ||
        (this._localBoundsRect || (this._localBoundsRect = new $e()),
        (e = this._localBoundsRect)),
        this._localBounds || (this._localBounds = new Kh());
      const t = this.transform,
        i = this.parent;
      (this.parent = null),
        (this._tempDisplayObjectParent.worldAlpha =
          (i == null ? void 0 : i.worldAlpha) ?? 1),
        (this.transform = this._tempDisplayObjectParent.transform);
      const s = this._bounds,
        n = this._boundsID;
      this._bounds = this._localBounds;
      const a = this.getBounds(!1, e);
      return (
        (this.parent = i),
        (this.transform = t),
        (this._bounds = s),
        (this._bounds.updateID += this._boundsID - n),
        a
      );
    }
    toGlobal(e, t, i = !1) {
      return (
        i ||
          (this._recursivePostUpdateTransform(),
          this.parent
            ? this.displayObjectUpdateTransform()
            : ((this.parent = this._tempDisplayObjectParent),
              this.displayObjectUpdateTransform(),
              (this.parent = null))),
        this.worldTransform.apply(e, t)
      );
    }
    toLocal(e, t, i, s) {
      return (
        t && (e = t.toGlobal(e, i, s)),
        s ||
          (this._recursivePostUpdateTransform(),
          this.parent
            ? this.displayObjectUpdateTransform()
            : ((this.parent = this._tempDisplayObjectParent),
              this.displayObjectUpdateTransform(),
              (this.parent = null))),
        this.worldTransform.applyInverse(e, i)
      );
    }
    setParent(e) {
      if (!e || !e.addChild)
        throw new Error("setParent: Argument must be a Container");
      return e.addChild(this), e;
    }
    removeFromParent() {
      var e;
      (e = this.parent) == null || e.removeChild(this);
    }
    setTransform(
      e = 0,
      t = 0,
      i = 1,
      s = 1,
      n = 0,
      a = 0,
      o = 0,
      l = 0,
      h = 0
    ) {
      return (
        (this.position.x = e),
        (this.position.y = t),
        (this.scale.x = i || 1),
        (this.scale.y = s || 1),
        (this.rotation = n),
        (this.skew.x = a),
        (this.skew.y = o),
        (this.pivot.x = l),
        (this.pivot.y = h),
        this
      );
    }
    destroy(e) {
      this.removeFromParent(),
        (this._destroyed = !0),
        (this.transform = null),
        (this.parent = null),
        (this._bounds = null),
        (this.mask = null),
        (this.cullArea = null),
        (this.filters = null),
        (this.filterArea = null),
        (this.hitArea = null),
        (this.eventMode = "auto"),
        (this.interactiveChildren = !1),
        this.emit("destroyed"),
        this.removeAllListeners();
    }
    get _tempDisplayObjectParent() {
      return (
        this.tempDisplayObjectParent === null &&
          (this.tempDisplayObjectParent = new B4()),
        this.tempDisplayObjectParent
      );
    }
    enableTempParent() {
      const e = this.parent;
      return (this.parent = this._tempDisplayObjectParent), e;
    }
    disableTempParent(e) {
      this.parent = e;
    }
    get x() {
      return this.position.x;
    }
    set x(e) {
      this.transform.position.x = e;
    }
    get y() {
      return this.position.y;
    }
    set y(e) {
      this.transform.position.y = e;
    }
    get worldTransform() {
      return this.transform.worldTransform;
    }
    get localTransform() {
      return this.transform.localTransform;
    }
    get position() {
      return this.transform.position;
    }
    set position(e) {
      this.transform.position.copyFrom(e);
    }
    get scale() {
      return this.transform.scale;
    }
    set scale(e) {
      this.transform.scale.copyFrom(e);
    }
    get pivot() {
      return this.transform.pivot;
    }
    set pivot(e) {
      this.transform.pivot.copyFrom(e);
    }
    get skew() {
      return this.transform.skew;
    }
    set skew(e) {
      this.transform.skew.copyFrom(e);
    }
    get rotation() {
      return this.transform.rotation;
    }
    set rotation(e) {
      this.transform.rotation = e;
    }
    get angle() {
      return this.transform.rotation * AN;
    }
    set angle(e) {
      this.transform.rotation = e * CN;
    }
    get zIndex() {
      return this._zIndex;
    }
    set zIndex(e) {
      this._zIndex !== e &&
        ((this._zIndex = e), this.parent && (this.parent.sortDirty = !0));
    }
    get worldVisible() {
      let e = this;
      do {
        if (!e.visible) return !1;
        e = e.parent;
      } while (e);
      return !0;
    }
    get mask() {
      return this._mask;
    }
    set mask(e) {
      if (this._mask !== e) {
        if (this._mask) {
          const t = this._mask.isMaskData ? this._mask.maskObject : this._mask;
          t &&
            (t._maskRefCount--,
            t._maskRefCount === 0 && ((t.renderable = !0), (t.isMask = !1)));
        }
        if (((this._mask = e), this._mask)) {
          const t = this._mask.isMaskData ? this._mask.maskObject : this._mask;
          t &&
            (t._maskRefCount === 0 && ((t.renderable = !1), (t.isMask = !0)),
            t._maskRefCount++);
        }
      }
    }
  }
  class B4 extends At {
    constructor() {
      super(...arguments), (this.sortDirty = null);
    }
  }
  At.prototype.displayObjectUpdateTransform = At.prototype.updateTransform;
  const O4 = new vt();
  function k4(r, e) {
    return r.zIndex === e.zIndex
      ? r._lastSortedIndex - e._lastSortedIndex
      : r.zIndex - e.zIndex;
  }
  const v_ = class xf extends At {
    constructor() {
      super(),
        (this.children = []),
        (this.sortableChildren = xf.defaultSortableChildren),
        (this.sortDirty = !1);
    }
    onChildrenChange(e) {}
    addChild(...e) {
      if (e.length > 1) for (let t = 0; t < e.length; t++) this.addChild(e[t]);
      else {
        const t = e[0];
        t.parent && t.parent.removeChild(t),
          (t.parent = this),
          (this.sortDirty = !0),
          (t.transform._parentID = -1),
          this.children.push(t),
          this._boundsID++,
          this.onChildrenChange(this.children.length - 1),
          this.emit("childAdded", t, this, this.children.length - 1),
          t.emit("added", this);
      }
      return e[0];
    }
    addChildAt(e, t) {
      if (t < 0 || t > this.children.length)
        throw new Error(
          `${e}addChildAt: The index ${t} supplied is out of bounds ${this.children.length}`
        );
      return (
        e.parent && e.parent.removeChild(e),
        (e.parent = this),
        (this.sortDirty = !0),
        (e.transform._parentID = -1),
        this.children.splice(t, 0, e),
        this._boundsID++,
        this.onChildrenChange(t),
        e.emit("added", this),
        this.emit("childAdded", e, this, t),
        e
      );
    }
    swapChildren(e, t) {
      if (e === t) return;
      const i = this.getChildIndex(e),
        s = this.getChildIndex(t);
      (this.children[i] = t),
        (this.children[s] = e),
        this.onChildrenChange(i < s ? i : s);
    }
    getChildIndex(e) {
      const t = this.children.indexOf(e);
      if (t === -1)
        throw new Error(
          "The supplied DisplayObject must be a child of the caller"
        );
      return t;
    }
    setChildIndex(e, t) {
      if (t < 0 || t >= this.children.length)
        throw new Error(
          `The index ${t} supplied is out of bounds ${this.children.length}`
        );
      const i = this.getChildIndex(e);
      Sa(this.children, i, 1),
        this.children.splice(t, 0, e),
        this.onChildrenChange(t);
    }
    getChildAt(e) {
      if (e < 0 || e >= this.children.length)
        throw new Error(`getChildAt: Index (${e}) does not exist.`);
      return this.children[e];
    }
    removeChild(...e) {
      if (e.length > 1)
        for (let t = 0; t < e.length; t++) this.removeChild(e[t]);
      else {
        const t = e[0],
          i = this.children.indexOf(t);
        if (i === -1) return null;
        (t.parent = null),
          (t.transform._parentID = -1),
          Sa(this.children, i, 1),
          this._boundsID++,
          this.onChildrenChange(i),
          t.emit("removed", this),
          this.emit("childRemoved", t, this, i);
      }
      return e[0];
    }
    removeChildAt(e) {
      const t = this.getChildAt(e);
      return (
        (t.parent = null),
        (t.transform._parentID = -1),
        Sa(this.children, e, 1),
        this._boundsID++,
        this.onChildrenChange(e),
        t.emit("removed", this),
        this.emit("childRemoved", t, this, e),
        t
      );
    }
    removeChildren(e = 0, t = this.children.length) {
      const i = e,
        s = t,
        n = s - i;
      let a;
      if (n > 0 && n <= s) {
        a = this.children.splice(i, n);
        for (let o = 0; o < a.length; ++o)
          (a[o].parent = null),
            a[o].transform && (a[o].transform._parentID = -1);
        this._boundsID++, this.onChildrenChange(e);
        for (let o = 0; o < a.length; ++o)
          a[o].emit("removed", this), this.emit("childRemoved", a[o], this, o);
        return a;
      } else if (n === 0 && this.children.length === 0) return [];
      throw new RangeError(
        "removeChildren: numeric values are outside the acceptable range."
      );
    }
    sortChildren() {
      let e = !1;
      for (let t = 0, i = this.children.length; t < i; ++t) {
        const s = this.children[t];
        (s._lastSortedIndex = t), !e && s.zIndex !== 0 && (e = !0);
      }
      e && this.children.length > 1 && this.children.sort(k4),
        (this.sortDirty = !1);
    }
    updateTransform() {
      this.sortableChildren && this.sortDirty && this.sortChildren(),
        this._boundsID++,
        this.transform.updateTransform(this.parent.transform),
        (this.worldAlpha = this.alpha * this.parent.worldAlpha);
      for (let e = 0, t = this.children.length; e < t; ++e) {
        const i = this.children[e];
        i.visible && i.updateTransform();
      }
    }
    calculateBounds() {
      this._bounds.clear(), this._calculateBounds();
      for (let e = 0; e < this.children.length; e++) {
        const t = this.children[e];
        if (!(!t.visible || !t.renderable))
          if ((t.calculateBounds(), t._mask)) {
            const i = t._mask.isMaskData ? t._mask.maskObject : t._mask;
            i
              ? (i.calculateBounds(),
                this._bounds.addBoundsMask(t._bounds, i._bounds))
              : this._bounds.addBounds(t._bounds);
          } else
            t.filterArea
              ? this._bounds.addBoundsArea(t._bounds, t.filterArea)
              : this._bounds.addBounds(t._bounds);
      }
      this._bounds.updateID = this._boundsID;
    }
    getLocalBounds(e, t = !1) {
      const i = super.getLocalBounds(e);
      if (!t)
        for (let s = 0, n = this.children.length; s < n; ++s) {
          const a = this.children[s];
          a.visible && a.updateTransform();
        }
      return i;
    }
    _calculateBounds() {}
    _renderWithCulling(e) {
      const t = e.renderTexture.sourceFrame;
      if (!(t.width > 0 && t.height > 0)) return;
      let i, s;
      this.cullArea
        ? ((i = this.cullArea), (s = this.worldTransform))
        : this._render !== xf.prototype._render && (i = this.getBounds(!0));
      const n = e.projection.transform;
      if (
        (n && (s ? ((s = O4.copyFrom(s)), s.prepend(n)) : (s = n)),
        i && t.intersects(i, s))
      )
        this._render(e);
      else if (this.cullArea) return;
      for (let a = 0, o = this.children.length; a < o; ++a) {
        const l = this.children[a],
          h = l.cullable;
        (l.cullable = h || !this.cullArea), l.render(e), (l.cullable = h);
      }
    }
    render(e) {
      var t;
      if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
        if (this._mask || ((t = this.filters) != null && t.length))
          this.renderAdvanced(e);
        else if (this.cullable) this._renderWithCulling(e);
        else {
          this._render(e);
          for (let i = 0, s = this.children.length; i < s; ++i)
            this.children[i].render(e);
        }
    }
    renderAdvanced(e) {
      var n, a, o;
      const t = this.filters,
        i = this._mask;
      if (t) {
        this._enabledFilters || (this._enabledFilters = []),
          (this._enabledFilters.length = 0);
        for (let l = 0; l < t.length; l++)
          t[l].enabled && this._enabledFilters.push(t[l]);
      }
      const s =
        (t && ((n = this._enabledFilters) == null ? void 0 : n.length)) ||
        (i &&
          (!i.isMaskData ||
            (i.enabled && (i.autoDetect || i.type !== Lt.NONE))));
      if (
        (s && e.batch.flush(),
        t &&
          (a = this._enabledFilters) != null &&
          a.length &&
          e.filter.push(this, this._enabledFilters),
        i && e.mask.push(this, this._mask),
        this.cullable)
      )
        this._renderWithCulling(e);
      else {
        this._render(e);
        for (let l = 0, h = this.children.length; l < h; ++l)
          this.children[l].render(e);
      }
      s && e.batch.flush(),
        i && e.mask.pop(this),
        t && (o = this._enabledFilters) != null && o.length && e.filter.pop();
    }
    _render(e) {}
    destroy(e) {
      super.destroy(), (this.sortDirty = !1);
      const t = typeof e == "boolean" ? e : e == null ? void 0 : e.children,
        i = this.removeChildren(0, this.children.length);
      if (t) for (let s = 0; s < i.length; ++s) i[s].destroy(e);
    }
    get width() {
      return this.scale.x * this.getLocalBounds().width;
    }
    set width(e) {
      const t = this.getLocalBounds().width;
      t !== 0 ? (this.scale.x = e / t) : (this.scale.x = 1), (this._width = e);
    }
    get height() {
      return this.scale.y * this.getLocalBounds().height;
    }
    set height(e) {
      const t = this.getLocalBounds().height;
      t !== 0 ? (this.scale.y = e / t) : (this.scale.y = 1), (this._height = e);
    }
  };
  v_.defaultSortableChildren = !1;
  let jr = v_;
  jr.prototype.containerUpdateTransform = jr.prototype.updateTransform;
  Object.defineProperties(we, {
    SORTABLE_CHILDREN: {
      get() {
        return jr.defaultSortableChildren;
      },
      set(r) {
        We(
          "7.1.0",
          "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"
        ),
          (jr.defaultSortableChildren = r);
      },
    },
  });
  const po = new Je(),
    D4 = new Uint16Array([0, 1, 2, 0, 2, 3]);
  class to extends jr {
    constructor(e) {
      super(),
        (this._anchor = new us(
          this._onAnchorUpdate,
          this,
          e ? e.defaultAnchor.x : 0,
          e ? e.defaultAnchor.y : 0
        )),
        (this._texture = null),
        (this._width = 0),
        (this._height = 0),
        (this._tintColor = new lt(16777215)),
        (this._tintRGB = null),
        (this.tint = 16777215),
        (this.blendMode = Be.NORMAL),
        (this._cachedTint = 16777215),
        (this.uvs = null),
        (this.texture = e || ze.EMPTY),
        (this.vertexData = new Float32Array(8)),
        (this.vertexTrimmedData = null),
        (this._transformID = -1),
        (this._textureID = -1),
        (this._transformTrimmedID = -1),
        (this._textureTrimmedID = -1),
        (this.indices = D4),
        (this.pluginName = "batch"),
        (this.isSprite = !0),
        (this._roundPixels = we.ROUND_PIXELS);
    }
    _onTextureUpdate() {
      (this._textureID = -1),
        (this._textureTrimmedID = -1),
        (this._cachedTint = 16777215),
        this._width &&
          (this.scale.x =
            (Gs(this.scale.x) * this._width) / this._texture.orig.width),
        this._height &&
          (this.scale.y =
            (Gs(this.scale.y) * this._height) / this._texture.orig.height);
    }
    _onAnchorUpdate() {
      (this._transformID = -1), (this._transformTrimmedID = -1);
    }
    calculateVertices() {
      const e = this._texture;
      if (
        this._transformID === this.transform._worldID &&
        this._textureID === e._updateID
      )
        return;
      this._textureID !== e._updateID &&
        (this.uvs = this._texture._uvs.uvsFloat32),
        (this._transformID = this.transform._worldID),
        (this._textureID = e._updateID);
      const t = this.transform.worldTransform,
        i = t.a,
        s = t.b,
        n = t.c,
        a = t.d,
        o = t.tx,
        l = t.ty,
        h = this.vertexData,
        c = e.trim,
        u = e.orig,
        d = this._anchor;
      let f = 0,
        p = 0,
        m = 0,
        v = 0;
      if (
        (c
          ? ((p = c.x - d._x * u.width),
            (f = p + c.width),
            (v = c.y - d._y * u.height),
            (m = v + c.height))
          : ((p = -d._x * u.width),
            (f = p + u.width),
            (v = -d._y * u.height),
            (m = v + u.height)),
        (h[0] = i * p + n * v + o),
        (h[1] = a * v + s * p + l),
        (h[2] = i * f + n * v + o),
        (h[3] = a * v + s * f + l),
        (h[4] = i * f + n * m + o),
        (h[5] = a * m + s * f + l),
        (h[6] = i * p + n * m + o),
        (h[7] = a * m + s * p + l),
        this._roundPixels)
      ) {
        const g = we.RESOLUTION;
        for (let x = 0; x < h.length; ++x) h[x] = Math.round(h[x] * g) / g;
      }
    }
    calculateTrimmedVertices() {
      if (!this.vertexTrimmedData) this.vertexTrimmedData = new Float32Array(8);
      else if (
        this._transformTrimmedID === this.transform._worldID &&
        this._textureTrimmedID === this._texture._updateID
      )
        return;
      (this._transformTrimmedID = this.transform._worldID),
        (this._textureTrimmedID = this._texture._updateID);
      const e = this._texture,
        t = this.vertexTrimmedData,
        i = e.orig,
        s = this._anchor,
        n = this.transform.worldTransform,
        a = n.a,
        o = n.b,
        l = n.c,
        h = n.d,
        c = n.tx,
        u = n.ty,
        d = -s._x * i.width,
        f = d + i.width,
        p = -s._y * i.height,
        m = p + i.height;
      if (
        ((t[0] = a * d + l * p + c),
        (t[1] = h * p + o * d + u),
        (t[2] = a * f + l * p + c),
        (t[3] = h * p + o * f + u),
        (t[4] = a * f + l * m + c),
        (t[5] = h * m + o * f + u),
        (t[6] = a * d + l * m + c),
        (t[7] = h * m + o * d + u),
        this._roundPixels)
      ) {
        const v = we.RESOLUTION;
        for (let g = 0; g < t.length; ++g) t[g] = Math.round(t[g] * v) / v;
      }
    }
    _render(e) {
      this.calculateVertices(),
        e.batch.setObjectRenderer(e.plugins[this.pluginName]),
        e.plugins[this.pluginName].render(this);
    }
    _calculateBounds() {
      const e = this._texture.trim,
        t = this._texture.orig;
      !e || (e.width === t.width && e.height === t.height)
        ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData))
        : (this.calculateTrimmedVertices(),
          this._bounds.addQuad(this.vertexTrimmedData));
    }
    getLocalBounds(e) {
      return this.children.length === 0
        ? (this._localBounds || (this._localBounds = new Kh()),
          (this._localBounds.minX =
            this._texture.orig.width * -this._anchor._x),
          (this._localBounds.minY =
            this._texture.orig.height * -this._anchor._y),
          (this._localBounds.maxX =
            this._texture.orig.width * (1 - this._anchor._x)),
          (this._localBounds.maxY =
            this._texture.orig.height * (1 - this._anchor._y)),
          e ||
            (this._localBoundsRect || (this._localBoundsRect = new $e()),
            (e = this._localBoundsRect)),
          this._localBounds.getRectangle(e))
        : super.getLocalBounds.call(this, e);
    }
    containsPoint(e) {
      this.worldTransform.applyInverse(e, po);
      const t = this._texture.orig.width,
        i = this._texture.orig.height,
        s = -t * this.anchor.x;
      let n = 0;
      return (
        po.x >= s &&
        po.x < s + t &&
        ((n = -i * this.anchor.y), po.y >= n && po.y < n + i)
      );
    }
    destroy(e) {
      if (
        (super.destroy(e),
        this._texture.off("update", this._onTextureUpdate, this),
        (this._anchor = null),
        typeof e == "boolean" ? e : e == null ? void 0 : e.texture)
      ) {
        const t =
          typeof e == "boolean" ? e : e == null ? void 0 : e.baseTexture;
        this._texture.destroy(!!t);
      }
      this._texture = null;
    }
    static from(e, t) {
      const i = e instanceof ze ? e : ze.from(e, t);
      return new to(i);
    }
    set roundPixels(e) {
      this._roundPixels !== e &&
        ((this._transformID = -1), (this._transformTrimmedID = -1)),
        (this._roundPixels = e);
    }
    get roundPixels() {
      return this._roundPixels;
    }
    get width() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(e) {
      const t = Gs(this.scale.x) || 1;
      (this.scale.x = (t * e) / this._texture.orig.width), (this._width = e);
    }
    get height() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(e) {
      const t = Gs(this.scale.y) || 1;
      (this.scale.y = (t * e) / this._texture.orig.height), (this._height = e);
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(e) {
      this._anchor.copyFrom(e);
    }
    get tint() {
      return this._tintColor.value;
    }
    set tint(e) {
      this._tintColor.setValue(e),
        (this._tintRGB = this._tintColor.toLittleEndianNumber());
    }
    get tintValue() {
      return this._tintColor.toNumber();
    }
    get texture() {
      return this._texture;
    }
    set texture(e) {
      this._texture !== e &&
        (this._texture &&
          this._texture.off("update", this._onTextureUpdate, this),
        (this._texture = e || ze.EMPTY),
        (this._cachedTint = 16777215),
        (this._textureID = -1),
        (this._textureTrimmedID = -1),
        e &&
          (e.baseTexture.valid
            ? this._onTextureUpdate()
            : e.once("update", this._onTextureUpdate, this)));
    }
  }
  const y_ = new vt();
  At.prototype._cacheAsBitmap = !1;
  At.prototype._cacheData = null;
  At.prototype._cacheAsBitmapResolution = null;
  At.prototype._cacheAsBitmapMultisample = null;
  class L4 {
    constructor() {
      (this.textureCacheId = null),
        (this.originalRender = null),
        (this.originalRenderCanvas = null),
        (this.originalCalculateBounds = null),
        (this.originalGetLocalBounds = null),
        (this.originalUpdateTransform = null),
        (this.originalDestroy = null),
        (this.originalMask = null),
        (this.originalFilterArea = null),
        (this.originalContainsPoint = null),
        (this.sprite = null);
    }
  }
  Object.defineProperties(At.prototype, {
    cacheAsBitmapResolution: {
      get() {
        return this._cacheAsBitmapResolution;
      },
      set(r) {
        r !== this._cacheAsBitmapResolution &&
          ((this._cacheAsBitmapResolution = r),
          this.cacheAsBitmap &&
            ((this.cacheAsBitmap = !1), (this.cacheAsBitmap = !0)));
      },
    },
    cacheAsBitmapMultisample: {
      get() {
        return this._cacheAsBitmapMultisample;
      },
      set(r) {
        r !== this._cacheAsBitmapMultisample &&
          ((this._cacheAsBitmapMultisample = r),
          this.cacheAsBitmap &&
            ((this.cacheAsBitmap = !1), (this.cacheAsBitmap = !0)));
      },
    },
    cacheAsBitmap: {
      get() {
        return this._cacheAsBitmap;
      },
      set(r) {
        if (this._cacheAsBitmap === r) return;
        this._cacheAsBitmap = r;
        let e;
        r
          ? (this._cacheData || (this._cacheData = new L4()),
            (e = this._cacheData),
            (e.originalRender = this.render),
            (e.originalRenderCanvas = this.renderCanvas),
            (e.originalUpdateTransform = this.updateTransform),
            (e.originalCalculateBounds = this.calculateBounds),
            (e.originalGetLocalBounds = this.getLocalBounds),
            (e.originalDestroy = this.destroy),
            (e.originalContainsPoint = this.containsPoint),
            (e.originalMask = this._mask),
            (e.originalFilterArea = this.filterArea),
            (this.render = this._renderCached),
            (this.renderCanvas = this._renderCachedCanvas),
            (this.destroy = this._cacheAsBitmapDestroy))
          : ((e = this._cacheData),
            e.sprite && this._destroyCachedDisplayObject(),
            (this.render = e.originalRender),
            (this.renderCanvas = e.originalRenderCanvas),
            (this.calculateBounds = e.originalCalculateBounds),
            (this.getLocalBounds = e.originalGetLocalBounds),
            (this.destroy = e.originalDestroy),
            (this.updateTransform = e.originalUpdateTransform),
            (this.containsPoint = e.originalContainsPoint),
            (this._mask = e.originalMask),
            (this.filterArea = e.originalFilterArea));
      },
    },
  });
  At.prototype._renderCached = function (r) {
    !this.visible ||
      this.worldAlpha <= 0 ||
      !this.renderable ||
      (this._initCachedDisplayObject(r),
      (this._cacheData.sprite.transform._worldID = this.transform._worldID),
      (this._cacheData.sprite.worldAlpha = this.worldAlpha),
      this._cacheData.sprite._render(r));
  };
  At.prototype._initCachedDisplayObject = function (r) {
    var d, f;
    if ((d = this._cacheData) != null && d.sprite) return;
    const e = this.alpha;
    (this.alpha = 1), r.batch.flush();
    const t = this.getLocalBounds(new $e(), !0);
    if ((f = this.filters) != null && f.length) {
      const p = this.filters[0].padding;
      t.pad(p);
    }
    const i = this.cacheAsBitmapResolution || r.resolution;
    t.ceil(i),
      (t.width = Math.max(t.width, 1 / i)),
      (t.height = Math.max(t.height, 1 / i));
    const s = r.renderTexture.current,
      n = r.renderTexture.sourceFrame.clone(),
      a = r.renderTexture.destinationFrame.clone(),
      o = r.projection.transform,
      l = Gn.create({
        width: t.width,
        height: t.height,
        resolution: i,
        multisample: this.cacheAsBitmapMultisample ?? r.multisample,
      }),
      h = `cacheAsBitmap_${Dn()}`;
    (this._cacheData.textureCacheId = h),
      Le.addToCache(l.baseTexture, h),
      ze.addToCache(l, h);
    const c = this.transform.localTransform
      .copyTo(y_)
      .invert()
      .translate(-t.x, -t.y);
    (this.render = this._cacheData.originalRender),
      r.render(this, {
        renderTexture: l,
        clear: !0,
        transform: c,
        skipUpdateTransform: !1,
      }),
      r.framebuffer.blit(),
      (r.projection.transform = o),
      r.renderTexture.bind(s, n, a),
      (this.render = this._renderCached),
      (this.updateTransform = this.displayObjectUpdateTransform),
      (this.calculateBounds = this._calculateCachedBounds),
      (this.getLocalBounds = this._getCachedLocalBounds),
      (this._mask = null),
      (this.filterArea = null),
      (this.alpha = e);
    const u = new to(l);
    (u.transform.worldTransform = this.transform.worldTransform),
      (u.anchor.x = -(t.x / t.width)),
      (u.anchor.y = -(t.y / t.height)),
      (u.alpha = e),
      (u._bounds = this._bounds),
      (this._cacheData.sprite = u),
      (this.transform._parentID = -1),
      this.parent
        ? this.updateTransform()
        : (this.enableTempParent(),
          this.updateTransform(),
          this.disableTempParent(null)),
      (this.containsPoint = u.containsPoint.bind(u));
  };
  At.prototype._renderCachedCanvas = function (r) {
    !this.visible ||
      this.worldAlpha <= 0 ||
      !this.renderable ||
      (this._initCachedDisplayObjectCanvas(r),
      (this._cacheData.sprite.worldAlpha = this.worldAlpha),
      this._cacheData.sprite._renderCanvas(r));
  };
  At.prototype._initCachedDisplayObjectCanvas = function (r) {
    var c;
    if ((c = this._cacheData) != null && c.sprite) return;
    const e = this.getLocalBounds(new $e(), !0),
      t = this.alpha;
    this.alpha = 1;
    const i = r.canvasContext.activeContext,
      s = r._projTransform,
      n = this.cacheAsBitmapResolution || r.resolution;
    e.ceil(n),
      (e.width = Math.max(e.width, 1 / n)),
      (e.height = Math.max(e.height, 1 / n));
    const a = Gn.create({ width: e.width, height: e.height, resolution: n }),
      o = `cacheAsBitmap_${Dn()}`;
    (this._cacheData.textureCacheId = o),
      Le.addToCache(a.baseTexture, o),
      ze.addToCache(a, o);
    const l = y_;
    this.transform.localTransform.copyTo(l),
      l.invert(),
      (l.tx -= e.x),
      (l.ty -= e.y),
      (this.renderCanvas = this._cacheData.originalRenderCanvas),
      r.render(this, {
        renderTexture: a,
        clear: !0,
        transform: l,
        skipUpdateTransform: !1,
      }),
      (r.canvasContext.activeContext = i),
      (r._projTransform = s),
      (this.renderCanvas = this._renderCachedCanvas),
      (this.updateTransform = this.displayObjectUpdateTransform),
      (this.calculateBounds = this._calculateCachedBounds),
      (this.getLocalBounds = this._getCachedLocalBounds),
      (this._mask = null),
      (this.filterArea = null),
      (this.alpha = t);
    const h = new to(a);
    (h.transform.worldTransform = this.transform.worldTransform),
      (h.anchor.x = -(e.x / e.width)),
      (h.anchor.y = -(e.y / e.height)),
      (h.alpha = t),
      (h._bounds = this._bounds),
      (this._cacheData.sprite = h),
      (this.transform._parentID = -1),
      this.parent
        ? this.updateTransform()
        : ((this.parent = r._tempDisplayObjectParent),
          this.updateTransform(),
          (this.parent = null)),
      (this.containsPoint = h.containsPoint.bind(h));
  };
  At.prototype._calculateCachedBounds = function () {
    this._bounds.clear(),
      (this._cacheData.sprite.transform._worldID = this.transform._worldID),
      this._cacheData.sprite._calculateBounds(),
      (this._bounds.updateID = this._boundsID);
  };
  At.prototype._getCachedLocalBounds = function () {
    return this._cacheData.sprite.getLocalBounds(null);
  };
  At.prototype._destroyCachedDisplayObject = function () {
    this._cacheData.sprite._texture.destroy(!0),
      (this._cacheData.sprite = null),
      Le.removeFromCache(this._cacheData.textureCacheId),
      ze.removeFromCache(this._cacheData.textureCacheId),
      (this._cacheData.textureCacheId = null);
  };
  At.prototype._cacheAsBitmapDestroy = function (r) {
    (this.cacheAsBitmap = !1), this.destroy(r);
  };
  At.prototype.name = null;
  jr.prototype.getChildByName = function (r, e) {
    for (let t = 0, i = this.children.length; t < i; t++)
      if (this.children[t].name === r) return this.children[t];
    if (e)
      for (let t = 0, i = this.children.length; t < i; t++) {
        const s = this.children[t];
        if (!s.getChildByName) continue;
        const n = s.getChildByName(r, !0);
        if (n) return n;
      }
    return null;
  };
  At.prototype.getGlobalPosition = function (r = new Je(), e = !1) {
    return (
      this.parent
        ? this.parent.toGlobal(this.position, r, e)
        : ((r.x = this.position.x), (r.y = this.position.y)),
      r
    );
  };
  var N4 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
  class U4 extends fr {
    constructor(e = 1) {
      super(C4, N4, { uAlpha: 1 }), (this.alpha = e);
    }
    get alpha() {
      return this.uniforms.uAlpha;
    }
    set alpha(e) {
      this.uniforms.uAlpha = e;
    }
  }
  const V4 = {
      5: [0.153388, 0.221461, 0.250301],
      7: [0.071303, 0.131514, 0.189879, 0.214607],
      9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
      11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
      13: [
        0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641,
      ],
      15: [
        489e-6, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697,
        0.197448,
      ],
    },
    $4 = [
      "varying vec2 vBlurTexCoords[%size%];",
      "uniform sampler2D uSampler;",
      "void main(void)",
      "{",
      "    gl_FragColor = vec4(0.0);",
      "    %blur%",
      "}",
    ].join(`
`);
  function G4(r) {
    const e = V4[r],
      t = e.length;
    let i = $4,
      s = "";
    const n =
      "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
    let a;
    for (let o = 0; o < r; o++) {
      let l = n.replace("%index%", o.toString());
      (a = o),
        o >= t && (a = r - o - 1),
        (l = l.replace("%value%", e[a].toString())),
        (s += l),
        (s += `
`);
    }
    return (
      (i = i.replace("%blur%", s)), (i = i.replace("%size%", r.toString())), i
    );
  }
  const H4 = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
  function X4(r, e) {
    const t = Math.ceil(r / 2);
    let i = H4,
      s = "",
      n;
    e
      ? (n =
          "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);")
      : (n =
          "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);");
    for (let a = 0; a < r; a++) {
      let o = n.replace("%index%", a.toString());
      (o = o.replace("%sampleIndex%", `${a - (t - 1)}.0`)),
        (s += o),
        (s += `
`);
    }
    return (
      (i = i.replace("%blur%", s)), (i = i.replace("%size%", r.toString())), i
    );
  }
  class _f extends fr {
    constructor(e, t = 8, i = 4, s = fr.defaultResolution, n = 5) {
      const a = X4(n, e),
        o = G4(n);
      super(a, o),
        (this.horizontal = e),
        (this.resolution = s),
        (this._quality = 0),
        (this.quality = i),
        (this.blur = t);
    }
    apply(e, t, i, s) {
      if (
        (i
          ? this.horizontal
            ? (this.uniforms.strength = (1 / i.width) * (i.width / t.width))
            : (this.uniforms.strength = (1 / i.height) * (i.height / t.height))
          : this.horizontal
          ? (this.uniforms.strength =
              (1 / e.renderer.width) * (e.renderer.width / t.width))
          : (this.uniforms.strength =
              (1 / e.renderer.height) * (e.renderer.height / t.height)),
        (this.uniforms.strength *= this.strength),
        (this.uniforms.strength /= this.passes),
        this.passes === 1)
      )
        e.applyFilter(this, t, i, s);
      else {
        const n = e.getFilterTexture(),
          a = e.renderer;
        let o = t,
          l = n;
        (this.state.blend = !1), e.applyFilter(this, o, l, Oi.CLEAR);
        for (let h = 1; h < this.passes - 1; h++) {
          e.bindAndClear(o, Oi.BLIT), (this.uniforms.uSampler = l);
          const c = l;
          (l = o), (o = c), a.shader.bind(this), a.geometry.draw(5);
        }
        (this.state.blend = !0),
          e.applyFilter(this, l, i, s),
          e.returnFilterTexture(n);
      }
    }
    get blur() {
      return this.strength;
    }
    set blur(e) {
      (this.padding = 1 + Math.abs(e) * 2), (this.strength = e);
    }
    get quality() {
      return this._quality;
    }
    set quality(e) {
      (this._quality = e), (this.passes = e);
    }
  }
  class z4 extends fr {
    constructor(e = 8, t = 4, i = fr.defaultResolution, s = 5) {
      super(),
        (this._repeatEdgePixels = !1),
        (this.blurXFilter = new _f(!0, e, t, i, s)),
        (this.blurYFilter = new _f(!1, e, t, i, s)),
        (this.resolution = i),
        (this.quality = t),
        (this.blur = e),
        (this.repeatEdgePixels = !1);
    }
    apply(e, t, i, s) {
      const n = Math.abs(this.blurXFilter.strength),
        a = Math.abs(this.blurYFilter.strength);
      if (n && a) {
        const o = e.getFilterTexture();
        this.blurXFilter.apply(e, t, o, Oi.CLEAR),
          this.blurYFilter.apply(e, o, i, s),
          e.returnFilterTexture(o);
      } else
        a
          ? this.blurYFilter.apply(e, t, i, s)
          : this.blurXFilter.apply(e, t, i, s);
    }
    updatePadding() {
      this._repeatEdgePixels
        ? (this.padding = 0)
        : (this.padding =
            Math.max(
              Math.abs(this.blurXFilter.strength),
              Math.abs(this.blurYFilter.strength)
            ) * 2);
    }
    get blur() {
      return this.blurXFilter.blur;
    }
    set blur(e) {
      (this.blurXFilter.blur = this.blurYFilter.blur = e), this.updatePadding();
    }
    get quality() {
      return this.blurXFilter.quality;
    }
    set quality(e) {
      this.blurXFilter.quality = this.blurYFilter.quality = e;
    }
    get blurX() {
      return this.blurXFilter.blur;
    }
    set blurX(e) {
      (this.blurXFilter.blur = e), this.updatePadding();
    }
    get blurY() {
      return this.blurYFilter.blur;
    }
    set blurY(e) {
      (this.blurYFilter.blur = e), this.updatePadding();
    }
    get blendMode() {
      return this.blurYFilter.blendMode;
    }
    set blendMode(e) {
      this.blurYFilter.blendMode = e;
    }
    get repeatEdgePixels() {
      return this._repeatEdgePixels;
    }
    set repeatEdgePixels(e) {
      (this._repeatEdgePixels = e), this.updatePadding();
    }
  }
  var W4 = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`;
  class wf extends fr {
    constructor() {
      const e = {
        m: new Float32Array([
          1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0,
        ]),
        uAlpha: 1,
      };
      super(c_, W4, e), (this.alpha = 1);
    }
    _loadMatrix(e, t = !1) {
      let i = e;
      t && (this._multiply(i, this.uniforms.m, e), (i = this._colorMatrix(i))),
        (this.uniforms.m = i);
    }
    _multiply(e, t, i) {
      return (
        (e[0] = t[0] * i[0] + t[1] * i[5] + t[2] * i[10] + t[3] * i[15]),
        (e[1] = t[0] * i[1] + t[1] * i[6] + t[2] * i[11] + t[3] * i[16]),
        (e[2] = t[0] * i[2] + t[1] * i[7] + t[2] * i[12] + t[3] * i[17]),
        (e[3] = t[0] * i[3] + t[1] * i[8] + t[2] * i[13] + t[3] * i[18]),
        (e[4] = t[0] * i[4] + t[1] * i[9] + t[2] * i[14] + t[3] * i[19] + t[4]),
        (e[5] = t[5] * i[0] + t[6] * i[5] + t[7] * i[10] + t[8] * i[15]),
        (e[6] = t[5] * i[1] + t[6] * i[6] + t[7] * i[11] + t[8] * i[16]),
        (e[7] = t[5] * i[2] + t[6] * i[7] + t[7] * i[12] + t[8] * i[17]),
        (e[8] = t[5] * i[3] + t[6] * i[8] + t[7] * i[13] + t[8] * i[18]),
        (e[9] = t[5] * i[4] + t[6] * i[9] + t[7] * i[14] + t[8] * i[19] + t[9]),
        (e[10] = t[10] * i[0] + t[11] * i[5] + t[12] * i[10] + t[13] * i[15]),
        (e[11] = t[10] * i[1] + t[11] * i[6] + t[12] * i[11] + t[13] * i[16]),
        (e[12] = t[10] * i[2] + t[11] * i[7] + t[12] * i[12] + t[13] * i[17]),
        (e[13] = t[10] * i[3] + t[11] * i[8] + t[12] * i[13] + t[13] * i[18]),
        (e[14] =
          t[10] * i[4] + t[11] * i[9] + t[12] * i[14] + t[13] * i[19] + t[14]),
        (e[15] = t[15] * i[0] + t[16] * i[5] + t[17] * i[10] + t[18] * i[15]),
        (e[16] = t[15] * i[1] + t[16] * i[6] + t[17] * i[11] + t[18] * i[16]),
        (e[17] = t[15] * i[2] + t[16] * i[7] + t[17] * i[12] + t[18] * i[17]),
        (e[18] = t[15] * i[3] + t[16] * i[8] + t[17] * i[13] + t[18] * i[18]),
        (e[19] =
          t[15] * i[4] + t[16] * i[9] + t[17] * i[14] + t[18] * i[19] + t[19]),
        e
      );
    }
    _colorMatrix(e) {
      const t = new Float32Array(e);
      return (t[4] /= 255), (t[9] /= 255), (t[14] /= 255), (t[19] /= 255), t;
    }
    brightness(e, t) {
      const i = [e, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(i, t);
    }
    tint(e, t) {
      const [i, s, n] = lt.shared.setValue(e).toArray(),
        a = [i, 0, 0, 0, 0, 0, s, 0, 0, 0, 0, 0, n, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(a, t);
    }
    greyscale(e, t) {
      const i = [e, e, e, 0, 0, e, e, e, 0, 0, e, e, e, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(i, t);
    }
    blackAndWhite(e) {
      const t = [
        0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0,
        1, 0,
      ];
      this._loadMatrix(t, e);
    }
    hue(e, t) {
      e = ((e || 0) / 180) * Math.PI;
      const i = Math.cos(e),
        s = Math.sin(e),
        n = Math.sqrt,
        a = 1 / 3,
        o = n(a),
        l = i + (1 - i) * a,
        h = a * (1 - i) - o * s,
        c = a * (1 - i) + o * s,
        u = a * (1 - i) + o * s,
        d = i + a * (1 - i),
        f = a * (1 - i) - o * s,
        p = a * (1 - i) - o * s,
        m = a * (1 - i) + o * s,
        v = i + a * (1 - i),
        g = [l, h, c, 0, 0, u, d, f, 0, 0, p, m, v, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(g, t);
    }
    contrast(e, t) {
      const i = (e || 0) + 1,
        s = -0.5 * (i - 1),
        n = [i, 0, 0, 0, s, 0, i, 0, 0, s, 0, 0, i, 0, s, 0, 0, 0, 1, 0];
      this._loadMatrix(n, t);
    }
    saturate(e = 0, t) {
      const i = (e * 2) / 3 + 1,
        s = (i - 1) * -0.5,
        n = [i, s, s, 0, 0, s, i, s, 0, 0, s, s, i, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(n, t);
    }
    desaturate() {
      this.saturate(-1);
    }
    negative(e) {
      const t = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(t, e);
    }
    sepia(e) {
      const t = [
        0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0,
        0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0,
      ];
      this._loadMatrix(t, e);
    }
    technicolor(e) {
      const t = [
        1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0,
        11.793603434377337, -0.3087833385928097, 1.7658908555458428,
        -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616,
        -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0,
        1, 0,
      ];
      this._loadMatrix(t, e);
    }
    polaroid(e) {
      const t = [
        1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016,
        -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0,
      ];
      this._loadMatrix(t, e);
    }
    toBGR(e) {
      const t = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(t, e);
    }
    kodachrome(e) {
      const t = [
        1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0,
        63.72958762196502, -0.16404339962244616, 1.0835251566291304,
        -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763,
        -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0,
        1, 0,
      ];
      this._loadMatrix(t, e);
    }
    browni(e) {
      const t = [
        0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0,
        47.43192855600873, -0.037703249837783157, 0.8609577587992641,
        0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335,
        -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0,
        0, 1, 0,
      ];
      this._loadMatrix(t, e);
    }
    vintage(e) {
      const t = [
        0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0,
        9.651285835294123, 0.02578397704808868, 0.6441188644374771,
        0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719,
        -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0,
        1, 0,
      ];
      this._loadMatrix(t, e);
    }
    colorTone(e, t, i, s, n) {
      (e = e || 0.2), (t = t || 0.15), (i = i || 16770432), (s = s || 3375104);
      const a = lt.shared,
        [o, l, h] = a.setValue(i).toArray(),
        [c, u, d] = a.setValue(s).toArray(),
        f = [
          0.3,
          0.59,
          0.11,
          0,
          0,
          o,
          l,
          h,
          e,
          0,
          c,
          u,
          d,
          t,
          0,
          o - c,
          l - u,
          h - d,
          0,
          0,
        ];
      this._loadMatrix(f, n);
    }
    night(e, t) {
      e = e || 0.1;
      const i = [
        e * -2,
        -e,
        0,
        0,
        0,
        -e,
        0,
        e,
        0,
        0,
        0,
        e,
        e * 2,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
      ];
      this._loadMatrix(i, t);
    }
    predator(e, t) {
      const i = [
        11.224130630493164 * e,
        -4.794486999511719 * e,
        -2.8746118545532227 * e,
        0 * e,
        0.40342438220977783 * e,
        -3.6330697536468506 * e,
        9.193157196044922 * e,
        -2.951810836791992 * e,
        0 * e,
        -1.316135048866272 * e,
        -3.2184197902679443 * e,
        -4.2375030517578125 * e,
        7.476448059082031 * e,
        0 * e,
        0.8044459223747253 * e,
        0,
        0,
        0,
        1,
        0,
      ];
      this._loadMatrix(i, t);
    }
    lsd(e) {
      const t = [
        2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0,
        1, 0,
      ];
      this._loadMatrix(t, e);
    }
    reset() {
      const e = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(e, !1);
    }
    get matrix() {
      return this.uniforms.m;
    }
    set matrix(e) {
      this.uniforms.m = e;
    }
    get alpha() {
      return this.uniforms.uAlpha;
    }
    set alpha(e) {
      this.uniforms.uAlpha = e;
    }
  }
  wf.prototype.grayscale = wf.prototype.greyscale;
  var Y4 = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`,
    j4 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
  class q4 extends fr {
    constructor(e, t) {
      const i = new vt();
      (e.renderable = !1),
        super(j4, Y4, {
          mapSampler: e._texture,
          filterMatrix: i,
          scale: { x: 1, y: 1 },
          rotation: new Float32Array([1, 0, 0, 1]),
        }),
        (this.maskSprite = e),
        (this.maskMatrix = i),
        t == null && (t = 20),
        (this.scale = new Je(t, t));
    }
    apply(e, t, i, s) {
      (this.uniforms.filterMatrix = e.calculateSpriteMatrix(
        this.maskMatrix,
        this.maskSprite
      )),
        (this.uniforms.scale.x = this.scale.x),
        (this.uniforms.scale.y = this.scale.y);
      const n = this.maskSprite.worldTransform,
        a = Math.sqrt(n.a * n.a + n.b * n.b),
        o = Math.sqrt(n.c * n.c + n.d * n.d);
      a !== 0 &&
        o !== 0 &&
        ((this.uniforms.rotation[0] = n.a / a),
        (this.uniforms.rotation[1] = n.b / a),
        (this.uniforms.rotation[2] = n.c / o),
        (this.uniforms.rotation[3] = n.d / o)),
        e.applyFilter(this, t, i, s);
    }
    get map() {
      return this.uniforms.mapSampler;
    }
    set map(e) {
      this.uniforms.mapSampler = e;
    }
  }
  var K4 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`,
    Z4 = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`;
  class J4 extends fr {
    constructor() {
      super(Z4, K4);
    }
  }
  var Q4 = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
  class e8 extends fr {
    constructor(e = 0.5, t = Math.random()) {
      super(c_, Q4, { uNoise: 0, uSeed: 0 }), (this.noise = e), (this.seed = t);
    }
    get noise() {
      return this.uniforms.uNoise;
    }
    set noise(e) {
      this.uniforms.uNoise = e;
    }
    get seed() {
      return this.uniforms.uSeed;
    }
    set seed(e) {
      this.uniforms.uSeed = e;
    }
  }
  const Lv = {
    AlphaFilter: U4,
    BlurFilter: z4,
    BlurFilterPass: _f,
    ColorMatrixFilter: wf,
    DisplacementFilter: q4,
    FXAAFilter: J4,
    NoiseFilter: e8,
  };
  Object.entries(Lv).forEach(([r, e]) => {
    Object.defineProperty(Lv, r, {
      get() {
        return We("7.1.0", `filters.${r} has moved to ${r}`), e;
      },
    });
  });
  class t8 {
    constructor() {
      (this.interactionFrequency = 10),
        (this._deltaTime = 0),
        (this._didMove = !1),
        (this.tickerAdded = !1),
        (this._pauseUpdate = !0);
    }
    init(e) {
      this.removeTickerListener(),
        (this.events = e),
        (this.interactionFrequency = 10),
        (this._deltaTime = 0),
        (this._didMove = !1),
        (this.tickerAdded = !1),
        (this._pauseUpdate = !0);
    }
    get pauseUpdate() {
      return this._pauseUpdate;
    }
    set pauseUpdate(e) {
      this._pauseUpdate = e;
    }
    addTickerListener() {
      this.tickerAdded ||
        !this.domElement ||
        (nr.system.add(this.tickerUpdate, this, Ln.INTERACTION),
        (this.tickerAdded = !0));
    }
    removeTickerListener() {
      this.tickerAdded &&
        (nr.system.remove(this.tickerUpdate, this), (this.tickerAdded = !1));
    }
    pointerMoved() {
      this._didMove = !0;
    }
    update() {
      if (!this.domElement || this._pauseUpdate) return;
      if (this._didMove) {
        this._didMove = !1;
        return;
      }
      const e = this.events.rootPointerEvent;
      (this.events.supportsTouchEvents && e.pointerType === "touch") ||
        globalThis.document.dispatchEvent(
          new PointerEvent("pointermove", {
            clientX: e.clientX,
            clientY: e.clientY,
          })
        );
    }
    tickerUpdate(e) {
      (this._deltaTime += e),
        !(this._deltaTime < this.interactionFrequency) &&
          ((this._deltaTime = 0), this.update());
    }
  }
  const Ns = new t8();
  class bl {
    constructor(e) {
      (this.bubbles = !0),
        (this.cancelBubble = !0),
        (this.cancelable = !1),
        (this.composed = !1),
        (this.defaultPrevented = !1),
        (this.eventPhase = bl.prototype.NONE),
        (this.propagationStopped = !1),
        (this.propagationImmediatelyStopped = !1),
        (this.layer = new Je()),
        (this.page = new Je()),
        (this.NONE = 0),
        (this.CAPTURING_PHASE = 1),
        (this.AT_TARGET = 2),
        (this.BUBBLING_PHASE = 3),
        (this.manager = e);
    }
    get layerX() {
      return this.layer.x;
    }
    get layerY() {
      return this.layer.y;
    }
    get pageX() {
      return this.page.x;
    }
    get pageY() {
      return this.page.y;
    }
    get data() {
      return this;
    }
    composedPath() {
      return (
        this.manager &&
          (!this.path || this.path[this.path.length - 1] !== this.target) &&
          (this.path = this.target
            ? this.manager.propagationPath(this.target)
            : []),
        this.path
      );
    }
    initEvent(e, t, i) {
      throw new Error(
        "initEvent() is a legacy DOM API. It is not implemented in the Federated Events API."
      );
    }
    initUIEvent(e, t, i, s, n) {
      throw new Error(
        "initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API."
      );
    }
    preventDefault() {
      this.nativeEvent instanceof Event &&
        this.nativeEvent.cancelable &&
        this.nativeEvent.preventDefault(),
        (this.defaultPrevented = !0);
    }
    stopImmediatePropagation() {
      this.propagationImmediatelyStopped = !0;
    }
    stopPropagation() {
      this.propagationStopped = !0;
    }
  }
  class Zh extends bl {
    constructor() {
      super(...arguments),
        (this.client = new Je()),
        (this.movement = new Je()),
        (this.offset = new Je()),
        (this.global = new Je()),
        (this.screen = new Je());
    }
    get clientX() {
      return this.client.x;
    }
    get clientY() {
      return this.client.y;
    }
    get x() {
      return this.clientX;
    }
    get y() {
      return this.clientY;
    }
    get movementX() {
      return this.movement.x;
    }
    get movementY() {
      return this.movement.y;
    }
    get offsetX() {
      return this.offset.x;
    }
    get offsetY() {
      return this.offset.y;
    }
    get globalX() {
      return this.global.x;
    }
    get globalY() {
      return this.global.y;
    }
    get screenX() {
      return this.screen.x;
    }
    get screenY() {
      return this.screen.y;
    }
    getLocalPosition(e, t, i) {
      return e.worldTransform.applyInverse(i || this.global, t);
    }
    getModifierState(e) {
      return (
        "getModifierState" in this.nativeEvent &&
        this.nativeEvent.getModifierState(e)
      );
    }
    initMouseEvent(e, t, i, s, n, a, o, l, h, c, u, d, f, p, m) {
      throw new Error("Method not implemented.");
    }
  }
  class ri extends Zh {
    constructor() {
      super(...arguments),
        (this.width = 0),
        (this.height = 0),
        (this.isPrimary = !1);
    }
    getCoalescedEvents() {
      return this.type === "pointermove" ||
        this.type === "mousemove" ||
        this.type === "touchmove"
        ? [this]
        : [];
    }
    getPredictedEvents() {
      throw new Error("getPredictedEvents is not supported!");
    }
  }
  class Ca extends Zh {
    constructor() {
      super(...arguments),
        (this.DOM_DELTA_PIXEL = 0),
        (this.DOM_DELTA_LINE = 1),
        (this.DOM_DELTA_PAGE = 2);
    }
  }
  (Ca.DOM_DELTA_PIXEL = 0), (Ca.DOM_DELTA_LINE = 1), (Ca.DOM_DELTA_PAGE = 2);
  const r8 = 2048,
    i8 = new Je(),
    Zu = new Je();
  class s8 {
    constructor(e) {
      (this.dispatch = new gl()),
        (this.moveOnAll = !1),
        (this.enableGlobalMoveEvents = !0),
        (this.mappingState = { trackingData: {} }),
        (this.eventPool = new Map()),
        (this._allInteractiveElements = []),
        (this._hitElements = []),
        (this._isPointerMoveEvent = !1),
        (this.rootTarget = e),
        (this.hitPruneFn = this.hitPruneFn.bind(this)),
        (this.hitTestFn = this.hitTestFn.bind(this)),
        (this.mapPointerDown = this.mapPointerDown.bind(this)),
        (this.mapPointerMove = this.mapPointerMove.bind(this)),
        (this.mapPointerOut = this.mapPointerOut.bind(this)),
        (this.mapPointerOver = this.mapPointerOver.bind(this)),
        (this.mapPointerUp = this.mapPointerUp.bind(this)),
        (this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this)),
        (this.mapWheel = this.mapWheel.bind(this)),
        (this.mappingTable = {}),
        this.addEventMapping("pointerdown", this.mapPointerDown),
        this.addEventMapping("pointermove", this.mapPointerMove),
        this.addEventMapping("pointerout", this.mapPointerOut),
        this.addEventMapping("pointerleave", this.mapPointerOut),
        this.addEventMapping("pointerover", this.mapPointerOver),
        this.addEventMapping("pointerup", this.mapPointerUp),
        this.addEventMapping("pointerupoutside", this.mapPointerUpOutside),
        this.addEventMapping("wheel", this.mapWheel);
    }
    addEventMapping(e, t) {
      this.mappingTable[e] || (this.mappingTable[e] = []),
        this.mappingTable[e].push({ fn: t, priority: 0 }),
        this.mappingTable[e].sort((i, s) => i.priority - s.priority);
    }
    dispatchEvent(e, t) {
      (e.propagationStopped = !1),
        (e.propagationImmediatelyStopped = !1),
        this.propagate(e, t),
        this.dispatch.emit(t || e.type, e);
    }
    mapEvent(e) {
      if (!this.rootTarget) return;
      const t = this.mappingTable[e.type];
      if (t) for (let i = 0, s = t.length; i < s; i++) t[i].fn(e);
      else
        console.warn(
          `[EventBoundary]: Event mapping not defined for ${e.type}`
        );
    }
    hitTest(e, t) {
      Ns.pauseUpdate = !0;
      const i =
          this._isPointerMoveEvent && this.enableGlobalMoveEvents
            ? "hitTestMoveRecursive"
            : "hitTestRecursive",
        s = this[i](
          this.rootTarget,
          this.rootTarget.eventMode,
          i8.set(e, t),
          this.hitTestFn,
          this.hitPruneFn
        );
      return s && s[0];
    }
    propagate(e, t) {
      if (!e.target) return;
      const i = e.composedPath();
      e.eventPhase = e.CAPTURING_PHASE;
      for (let s = 0, n = i.length - 1; s < n; s++)
        if (
          ((e.currentTarget = i[s]),
          this.notifyTarget(e, t),
          e.propagationStopped || e.propagationImmediatelyStopped)
        )
          return;
      if (
        ((e.eventPhase = e.AT_TARGET),
        (e.currentTarget = e.target),
        this.notifyTarget(e, t),
        !(e.propagationStopped || e.propagationImmediatelyStopped))
      ) {
        e.eventPhase = e.BUBBLING_PHASE;
        for (let s = i.length - 2; s >= 0; s--)
          if (
            ((e.currentTarget = i[s]),
            this.notifyTarget(e, t),
            e.propagationStopped || e.propagationImmediatelyStopped)
          )
            return;
      }
    }
    all(e, t, i = this._allInteractiveElements) {
      if (i.length === 0) return;
      e.eventPhase = e.BUBBLING_PHASE;
      const s = Array.isArray(t) ? t : [t];
      for (let n = i.length - 1; n >= 0; n--)
        s.forEach((a) => {
          (e.currentTarget = i[n]), this.notifyTarget(e, a);
        });
    }
    propagationPath(e) {
      const t = [e];
      for (let i = 0; i < r8 && e !== this.rootTarget; i++) {
        if (!e.parent)
          throw new Error(
            "Cannot find propagation path to disconnected target"
          );
        t.push(e.parent), (e = e.parent);
      }
      return t.reverse(), t;
    }
    hitTestMoveRecursive(e, t, i, s, n, a = !1) {
      let o = !1;
      if (this._interactivePrune(e)) return null;
      if (
        ((e.eventMode === "dynamic" || t === "dynamic") &&
          (Ns.pauseUpdate = !1),
        e.interactiveChildren && e.children)
      ) {
        const c = e.children;
        for (let u = c.length - 1; u >= 0; u--) {
          const d = c[u],
            f = this.hitTestMoveRecursive(
              d,
              this._isInteractive(t) ? t : d.eventMode,
              i,
              s,
              n,
              a || n(e, i)
            );
          if (f) {
            if (f.length > 0 && !f[f.length - 1].parent) continue;
            const p = e.isInteractive();
            (f.length > 0 || p) &&
              (p && this._allInteractiveElements.push(e), f.push(e)),
              this._hitElements.length === 0 && (this._hitElements = f),
              (o = !0);
          }
        }
      }
      const l = this._isInteractive(t),
        h = e.isInteractive();
      return (
        l && h && this._allInteractiveElements.push(e),
        a || this._hitElements.length > 0
          ? null
          : o
          ? this._hitElements
          : l && !n(e, i) && s(e, i)
          ? h
            ? [e]
            : []
          : null
      );
    }
    hitTestRecursive(e, t, i, s, n) {
      if (this._interactivePrune(e) || n(e, i)) return null;
      if (
        ((e.eventMode === "dynamic" || t === "dynamic") &&
          (Ns.pauseUpdate = !1),
        e.interactiveChildren && e.children)
      ) {
        const l = e.children;
        for (let h = l.length - 1; h >= 0; h--) {
          const c = l[h],
            u = this.hitTestRecursive(
              c,
              this._isInteractive(t) ? t : c.eventMode,
              i,
              s,
              n
            );
          if (u) {
            if (u.length > 0 && !u[u.length - 1].parent) continue;
            const d = e.isInteractive();
            return (u.length > 0 || d) && u.push(e), u;
          }
        }
      }
      const a = this._isInteractive(t),
        o = e.isInteractive();
      return a && s(e, i) ? (o ? [e] : []) : null;
    }
    _isInteractive(e) {
      return e === "static" || e === "dynamic";
    }
    _interactivePrune(e) {
      return !!(
        !e ||
        e.isMask ||
        !e.visible ||
        !e.renderable ||
        e.eventMode === "none" ||
        (e.eventMode === "passive" && !e.interactiveChildren) ||
        e.isMask
      );
    }
    hitPruneFn(e, t) {
      var i;
      if (
        e.hitArea &&
        (e.worldTransform.applyInverse(t, Zu), !e.hitArea.contains(Zu.x, Zu.y))
      )
        return !0;
      if (e._mask) {
        const s = e._mask.isMaskData ? e._mask.maskObject : e._mask;
        if (s && !((i = s.containsPoint) != null && i.call(s, t))) return !0;
      }
      return !1;
    }
    hitTestFn(e, t) {
      return e.eventMode === "passive"
        ? !1
        : e.hitArea
        ? !0
        : e.containsPoint
        ? e.containsPoint(t)
        : !1;
    }
    notifyTarget(e, t) {
      var n, a;
      t = t ?? e.type;
      const i = `on${t}`;
      (a = (n = e.currentTarget)[i]) == null || a.call(n, e);
      const s =
        e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET
          ? `${t}capture`
          : t;
      this.notifyListeners(e, s),
        e.eventPhase === e.AT_TARGET && this.notifyListeners(e, t);
    }
    mapPointerDown(e) {
      if (!(e instanceof ri)) {
        console.warn(
          "EventBoundary cannot map a non-pointer event as a pointer event"
        );
        return;
      }
      const t = this.createPointerEvent(e);
      if ((this.dispatchEvent(t, "pointerdown"), t.pointerType === "touch"))
        this.dispatchEvent(t, "touchstart");
      else if (t.pointerType === "mouse" || t.pointerType === "pen") {
        const s = t.button === 2;
        this.dispatchEvent(t, s ? "rightdown" : "mousedown");
      }
      const i = this.trackingData(e.pointerId);
      (i.pressTargetsByButton[e.button] = t.composedPath()), this.freeEvent(t);
    }
    mapPointerMove(e) {
      var l, h;
      if (!(e instanceof ri)) {
        console.warn(
          "EventBoundary cannot map a non-pointer event as a pointer event"
        );
        return;
      }
      (this._allInteractiveElements.length = 0),
        (this._hitElements.length = 0),
        (this._isPointerMoveEvent = !0);
      const t = this.createPointerEvent(e);
      this._isPointerMoveEvent = !1;
      const i = t.pointerType === "mouse" || t.pointerType === "pen",
        s = this.trackingData(e.pointerId),
        n = this.findMountedTarget(s.overTargets);
      if (
        ((l = s.overTargets) == null ? void 0 : l.length) > 0 &&
        n !== t.target
      ) {
        const c = e.type === "mousemove" ? "mouseout" : "pointerout",
          u = this.createPointerEvent(e, c, n);
        if (
          (this.dispatchEvent(u, "pointerout"),
          i && this.dispatchEvent(u, "mouseout"),
          !t.composedPath().includes(n))
        ) {
          const d = this.createPointerEvent(e, "pointerleave", n);
          for (
            d.eventPhase = d.AT_TARGET;
            d.target && !t.composedPath().includes(d.target);

          )
            (d.currentTarget = d.target),
              this.notifyTarget(d),
              i && this.notifyTarget(d, "mouseleave"),
              (d.target = d.target.parent);
          this.freeEvent(d);
        }
        this.freeEvent(u);
      }
      if (n !== t.target) {
        const c = e.type === "mousemove" ? "mouseover" : "pointerover",
          u = this.clonePointerEvent(t, c);
        this.dispatchEvent(u, "pointerover"),
          i && this.dispatchEvent(u, "mouseover");
        let d = n == null ? void 0 : n.parent;
        for (; d && d !== this.rootTarget.parent && d !== t.target; )
          d = d.parent;
        if (!d || d === this.rootTarget.parent) {
          const f = this.clonePointerEvent(t, "pointerenter");
          for (
            f.eventPhase = f.AT_TARGET;
            f.target && f.target !== n && f.target !== this.rootTarget.parent;

          )
            (f.currentTarget = f.target),
              this.notifyTarget(f),
              i && this.notifyTarget(f, "mouseenter"),
              (f.target = f.target.parent);
          this.freeEvent(f);
        }
        this.freeEvent(u);
      }
      const a = [],
        o = this.enableGlobalMoveEvents ?? !0;
      this.moveOnAll
        ? a.push("pointermove")
        : this.dispatchEvent(t, "pointermove"),
        o && a.push("globalpointermove"),
        t.pointerType === "touch" &&
          (this.moveOnAll
            ? a.splice(1, 0, "touchmove")
            : this.dispatchEvent(t, "touchmove"),
          o && a.push("globaltouchmove")),
        i &&
          (this.moveOnAll
            ? a.splice(1, 0, "mousemove")
            : this.dispatchEvent(t, "mousemove"),
          o && a.push("globalmousemove"),
          (this.cursor = (h = t.target) == null ? void 0 : h.cursor)),
        a.length > 0 && this.all(t, a),
        (this._allInteractiveElements.length = 0),
        (this._hitElements.length = 0),
        (s.overTargets = t.composedPath()),
        this.freeEvent(t);
    }
    mapPointerOver(e) {
      var a;
      if (!(e instanceof ri)) {
        console.warn(
          "EventBoundary cannot map a non-pointer event as a pointer event"
        );
        return;
      }
      const t = this.trackingData(e.pointerId),
        i = this.createPointerEvent(e),
        s = i.pointerType === "mouse" || i.pointerType === "pen";
      this.dispatchEvent(i, "pointerover"),
        s && this.dispatchEvent(i, "mouseover"),
        i.pointerType === "mouse" &&
          (this.cursor = (a = i.target) == null ? void 0 : a.cursor);
      const n = this.clonePointerEvent(i, "pointerenter");
      for (
        n.eventPhase = n.AT_TARGET;
        n.target && n.target !== this.rootTarget.parent;

      )
        (n.currentTarget = n.target),
          this.notifyTarget(n),
          s && this.notifyTarget(n, "mouseenter"),
          (n.target = n.target.parent);
      (t.overTargets = i.composedPath()), this.freeEvent(i), this.freeEvent(n);
    }
    mapPointerOut(e) {
      if (!(e instanceof ri)) {
        console.warn(
          "EventBoundary cannot map a non-pointer event as a pointer event"
        );
        return;
      }
      const t = this.trackingData(e.pointerId);
      if (t.overTargets) {
        const i = e.pointerType === "mouse" || e.pointerType === "pen",
          s = this.findMountedTarget(t.overTargets),
          n = this.createPointerEvent(e, "pointerout", s);
        this.dispatchEvent(n), i && this.dispatchEvent(n, "mouseout");
        const a = this.createPointerEvent(e, "pointerleave", s);
        for (
          a.eventPhase = a.AT_TARGET;
          a.target && a.target !== this.rootTarget.parent;

        )
          (a.currentTarget = a.target),
            this.notifyTarget(a),
            i && this.notifyTarget(a, "mouseleave"),
            (a.target = a.target.parent);
        (t.overTargets = null), this.freeEvent(n), this.freeEvent(a);
      }
      this.cursor = null;
    }
    mapPointerUp(e) {
      if (!(e instanceof ri)) {
        console.warn(
          "EventBoundary cannot map a non-pointer event as a pointer event"
        );
        return;
      }
      const t = performance.now(),
        i = this.createPointerEvent(e);
      if ((this.dispatchEvent(i, "pointerup"), i.pointerType === "touch"))
        this.dispatchEvent(i, "touchend");
      else if (i.pointerType === "mouse" || i.pointerType === "pen") {
        const o = i.button === 2;
        this.dispatchEvent(i, o ? "rightup" : "mouseup");
      }
      const s = this.trackingData(e.pointerId),
        n = this.findMountedTarget(s.pressTargetsByButton[e.button]);
      let a = n;
      if (n && !i.composedPath().includes(n)) {
        let o = n;
        for (; o && !i.composedPath().includes(o); ) {
          if (
            ((i.currentTarget = o),
            this.notifyTarget(i, "pointerupoutside"),
            i.pointerType === "touch")
          )
            this.notifyTarget(i, "touchendoutside");
          else if (i.pointerType === "mouse" || i.pointerType === "pen") {
            const l = i.button === 2;
            this.notifyTarget(i, l ? "rightupoutside" : "mouseupoutside");
          }
          o = o.parent;
        }
        delete s.pressTargetsByButton[e.button], (a = o);
      }
      if (a) {
        const o = this.clonePointerEvent(i, "click");
        (o.target = a),
          (o.path = null),
          s.clicksByButton[e.button] ||
            (s.clicksByButton[e.button] = {
              clickCount: 0,
              target: o.target,
              timeStamp: t,
            });
        const l = s.clicksByButton[e.button];
        if (
          (l.target === o.target && t - l.timeStamp < 200
            ? ++l.clickCount
            : (l.clickCount = 1),
          (l.target = o.target),
          (l.timeStamp = t),
          (o.detail = l.clickCount),
          o.pointerType === "mouse")
        ) {
          const h = o.button === 2;
          this.dispatchEvent(o, h ? "rightclick" : "click");
        } else o.pointerType === "touch" && this.dispatchEvent(o, "tap");
        this.dispatchEvent(o, "pointertap"), this.freeEvent(o);
      }
      this.freeEvent(i);
    }
    mapPointerUpOutside(e) {
      if (!(e instanceof ri)) {
        console.warn(
          "EventBoundary cannot map a non-pointer event as a pointer event"
        );
        return;
      }
      const t = this.trackingData(e.pointerId),
        i = this.findMountedTarget(t.pressTargetsByButton[e.button]),
        s = this.createPointerEvent(e);
      if (i) {
        let n = i;
        for (; n; )
          (s.currentTarget = n),
            this.notifyTarget(s, "pointerupoutside"),
            s.pointerType === "touch"
              ? this.notifyTarget(s, "touchendoutside")
              : (s.pointerType === "mouse" || s.pointerType === "pen") &&
                this.notifyTarget(
                  s,
                  s.button === 2 ? "rightupoutside" : "mouseupoutside"
                ),
            (n = n.parent);
        delete t.pressTargetsByButton[e.button];
      }
      this.freeEvent(s);
    }
    mapWheel(e) {
      if (!(e instanceof Ca)) {
        console.warn(
          "EventBoundary cannot map a non-wheel event as a wheel event"
        );
        return;
      }
      const t = this.createWheelEvent(e);
      this.dispatchEvent(t), this.freeEvent(t);
    }
    findMountedTarget(e) {
      if (!e) return null;
      let t = e[0];
      for (let i = 1; i < e.length && e[i].parent === t; i++) t = e[i];
      return t;
    }
    createPointerEvent(e, t, i) {
      const s = this.allocateEvent(ri);
      return (
        this.copyPointerData(e, s),
        this.copyMouseData(e, s),
        this.copyData(e, s),
        (s.nativeEvent = e.nativeEvent),
        (s.originalEvent = e),
        (s.target =
          i ?? this.hitTest(s.global.x, s.global.y) ?? this._hitElements[0]),
        typeof t == "string" && (s.type = t),
        s
      );
    }
    createWheelEvent(e) {
      const t = this.allocateEvent(Ca);
      return (
        this.copyWheelData(e, t),
        this.copyMouseData(e, t),
        this.copyData(e, t),
        (t.nativeEvent = e.nativeEvent),
        (t.originalEvent = e),
        (t.target = this.hitTest(t.global.x, t.global.y)),
        t
      );
    }
    clonePointerEvent(e, t) {
      const i = this.allocateEvent(ri);
      return (
        (i.nativeEvent = e.nativeEvent),
        (i.originalEvent = e.originalEvent),
        this.copyPointerData(e, i),
        this.copyMouseData(e, i),
        this.copyData(e, i),
        (i.target = e.target),
        (i.path = e.composedPath().slice()),
        (i.type = t ?? i.type),
        i
      );
    }
    copyWheelData(e, t) {
      (t.deltaMode = e.deltaMode),
        (t.deltaX = e.deltaX),
        (t.deltaY = e.deltaY),
        (t.deltaZ = e.deltaZ);
    }
    copyPointerData(e, t) {
      e instanceof ri &&
        t instanceof ri &&
        ((t.pointerId = e.pointerId),
        (t.width = e.width),
        (t.height = e.height),
        (t.isPrimary = e.isPrimary),
        (t.pointerType = e.pointerType),
        (t.pressure = e.pressure),
        (t.tangentialPressure = e.tangentialPressure),
        (t.tiltX = e.tiltX),
        (t.tiltY = e.tiltY),
        (t.twist = e.twist));
    }
    copyMouseData(e, t) {
      e instanceof Zh &&
        t instanceof Zh &&
        ((t.altKey = e.altKey),
        (t.button = e.button),
        (t.buttons = e.buttons),
        t.client.copyFrom(e.client),
        (t.ctrlKey = e.ctrlKey),
        (t.metaKey = e.metaKey),
        t.movement.copyFrom(e.movement),
        t.screen.copyFrom(e.screen),
        (t.shiftKey = e.shiftKey),
        t.global.copyFrom(e.global));
    }
    copyData(e, t) {
      (t.isTrusted = e.isTrusted),
        (t.srcElement = e.srcElement),
        (t.timeStamp = performance.now()),
        (t.type = e.type),
        (t.detail = e.detail),
        (t.view = e.view),
        (t.which = e.which),
        t.layer.copyFrom(e.layer),
        t.page.copyFrom(e.page);
    }
    trackingData(e) {
      return (
        this.mappingState.trackingData[e] ||
          (this.mappingState.trackingData[e] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null,
          }),
        this.mappingState.trackingData[e]
      );
    }
    allocateEvent(e) {
      this.eventPool.has(e) || this.eventPool.set(e, []);
      const t = this.eventPool.get(e).pop() || new e(this);
      return (
        (t.eventPhase = t.NONE),
        (t.currentTarget = null),
        (t.path = null),
        (t.target = null),
        t
      );
    }
    freeEvent(e) {
      if (e.manager !== this)
        throw new Error(
          "It is illegal to free an event not managed by this EventBoundary!"
        );
      const t = e.constructor;
      this.eventPool.has(t) || this.eventPool.set(t, []),
        this.eventPool.get(t).push(e);
    }
    notifyListeners(e, t) {
      const i = e.currentTarget._events[t];
      if (i && e.currentTarget.isInteractive())
        if ("fn" in i)
          i.once && e.currentTarget.removeListener(t, i.fn, void 0, !0),
            i.fn.call(i.context, e);
        else
          for (
            let s = 0, n = i.length;
            s < n && !e.propagationImmediatelyStopped;
            s++
          )
            i[s].once && e.currentTarget.removeListener(t, i[s].fn, void 0, !0),
              i[s].fn.call(i[s].context, e);
    }
  }
  const n8 = 1,
    a8 = {
      touchstart: "pointerdown",
      touchend: "pointerup",
      touchendoutside: "pointerupoutside",
      touchmove: "pointermove",
      touchcancel: "pointercancel",
    },
    Tf = class Ef {
      constructor(e) {
        (this.supportsTouchEvents = "ontouchstart" in globalThis),
          (this.supportsPointerEvents = !!globalThis.PointerEvent),
          (this.domElement = null),
          (this.resolution = 1),
          (this.renderer = e),
          (this.rootBoundary = new s8(null)),
          Ns.init(this),
          (this.autoPreventDefault = !0),
          (this.eventsAdded = !1),
          (this.rootPointerEvent = new ri(null)),
          (this.rootWheelEvent = new Ca(null)),
          (this.cursorStyles = { default: "inherit", pointer: "pointer" }),
          (this.features = new Proxy(
            { ...Ef.defaultEventFeatures },
            {
              set: (t, i, s) => (
                i === "globalMove" &&
                  (this.rootBoundary.enableGlobalMoveEvents = s),
                (t[i] = s),
                !0
              ),
            }
          )),
          (this.onPointerDown = this.onPointerDown.bind(this)),
          (this.onPointerMove = this.onPointerMove.bind(this)),
          (this.onPointerUp = this.onPointerUp.bind(this)),
          (this.onPointerOverOut = this.onPointerOverOut.bind(this)),
          (this.onWheel = this.onWheel.bind(this));
      }
      static get defaultEventMode() {
        return this._defaultEventMode;
      }
      init(e) {
        const { view: t, resolution: i } = this.renderer;
        this.setTargetElement(t),
          (this.resolution = i),
          (Ef._defaultEventMode = e.eventMode ?? "auto"),
          Object.assign(this.features, e.eventFeatures ?? {}),
          (this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove);
      }
      resolutionChange(e) {
        this.resolution = e;
      }
      destroy() {
        this.setTargetElement(null), (this.renderer = null);
      }
      setCursor(e) {
        e = e || "default";
        let t = !0;
        if (
          (globalThis.OffscreenCanvas &&
            this.domElement instanceof OffscreenCanvas &&
            (t = !1),
          this.currentCursor === e)
        )
          return;
        this.currentCursor = e;
        const i = this.cursorStyles[e];
        if (i)
          switch (typeof i) {
            case "string":
              t && (this.domElement.style.cursor = i);
              break;
            case "function":
              i(e);
              break;
            case "object":
              t && Object.assign(this.domElement.style, i);
              break;
          }
        else
          t &&
            typeof e == "string" &&
            !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) &&
            (this.domElement.style.cursor = e);
      }
      get pointer() {
        return this.rootPointerEvent;
      }
      onPointerDown(e) {
        if (!this.features.click) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const t = this.normalizeToPointerData(e);
        this.autoPreventDefault &&
          t[0].isNormalized &&
          (e.cancelable || !("cancelable" in e)) &&
          e.preventDefault();
        for (let i = 0, s = t.length; i < s; i++) {
          const n = t[i],
            a = this.bootstrapEvent(this.rootPointerEvent, n);
          this.rootBoundary.mapEvent(a);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      onPointerMove(e) {
        if (!this.features.move) return;
        (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered),
          Ns.pointerMoved();
        const t = this.normalizeToPointerData(e);
        for (let i = 0, s = t.length; i < s; i++) {
          const n = this.bootstrapEvent(this.rootPointerEvent, t[i]);
          this.rootBoundary.mapEvent(n);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      onPointerUp(e) {
        if (!this.features.click) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        let t = e.target;
        e.composedPath &&
          e.composedPath().length > 0 &&
          (t = e.composedPath()[0]);
        const i = t !== this.domElement ? "outside" : "",
          s = this.normalizeToPointerData(e);
        for (let n = 0, a = s.length; n < a; n++) {
          const o = this.bootstrapEvent(this.rootPointerEvent, s[n]);
          (o.type += i), this.rootBoundary.mapEvent(o);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      onPointerOverOut(e) {
        if (!this.features.click) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const t = this.normalizeToPointerData(e);
        for (let i = 0, s = t.length; i < s; i++) {
          const n = this.bootstrapEvent(this.rootPointerEvent, t[i]);
          this.rootBoundary.mapEvent(n);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      onWheel(e) {
        if (!this.features.wheel) return;
        const t = this.normalizeWheelEvent(e);
        (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered),
          this.rootBoundary.mapEvent(t);
      }
      setTargetElement(e) {
        this.removeEvents(),
          (this.domElement = e),
          (Ns.domElement = e),
          this.addEvents();
      }
      addEvents() {
        if (this.eventsAdded || !this.domElement) return;
        Ns.addTickerListener();
        const e = this.domElement.style;
        e &&
          (globalThis.navigator.msPointerEnabled
            ? ((e.msContentZooming = "none"), (e.msTouchAction = "none"))
            : this.supportsPointerEvents && (e.touchAction = "none")),
          this.supportsPointerEvents
            ? (globalThis.document.addEventListener(
                "pointermove",
                this.onPointerMove,
                !0
              ),
              this.domElement.addEventListener(
                "pointerdown",
                this.onPointerDown,
                !0
              ),
              this.domElement.addEventListener(
                "pointerleave",
                this.onPointerOverOut,
                !0
              ),
              this.domElement.addEventListener(
                "pointerover",
                this.onPointerOverOut,
                !0
              ),
              globalThis.addEventListener("pointerup", this.onPointerUp, !0))
            : (globalThis.document.addEventListener(
                "mousemove",
                this.onPointerMove,
                !0
              ),
              this.domElement.addEventListener(
                "mousedown",
                this.onPointerDown,
                !0
              ),
              this.domElement.addEventListener(
                "mouseout",
                this.onPointerOverOut,
                !0
              ),
              this.domElement.addEventListener(
                "mouseover",
                this.onPointerOverOut,
                !0
              ),
              globalThis.addEventListener("mouseup", this.onPointerUp, !0),
              this.supportsTouchEvents &&
                (this.domElement.addEventListener(
                  "touchstart",
                  this.onPointerDown,
                  !0
                ),
                this.domElement.addEventListener(
                  "touchend",
                  this.onPointerUp,
                  !0
                ),
                this.domElement.addEventListener(
                  "touchmove",
                  this.onPointerMove,
                  !0
                ))),
          this.domElement.addEventListener("wheel", this.onWheel, {
            passive: !0,
            capture: !0,
          }),
          (this.eventsAdded = !0);
      }
      removeEvents() {
        if (!this.eventsAdded || !this.domElement) return;
        Ns.removeTickerListener();
        const e = this.domElement.style;
        globalThis.navigator.msPointerEnabled
          ? ((e.msContentZooming = ""), (e.msTouchAction = ""))
          : this.supportsPointerEvents && (e.touchAction = ""),
          this.supportsPointerEvents
            ? (globalThis.document.removeEventListener(
                "pointermove",
                this.onPointerMove,
                !0
              ),
              this.domElement.removeEventListener(
                "pointerdown",
                this.onPointerDown,
                !0
              ),
              this.domElement.removeEventListener(
                "pointerleave",
                this.onPointerOverOut,
                !0
              ),
              this.domElement.removeEventListener(
                "pointerover",
                this.onPointerOverOut,
                !0
              ),
              globalThis.removeEventListener("pointerup", this.onPointerUp, !0))
            : (globalThis.document.removeEventListener(
                "mousemove",
                this.onPointerMove,
                !0
              ),
              this.domElement.removeEventListener(
                "mousedown",
                this.onPointerDown,
                !0
              ),
              this.domElement.removeEventListener(
                "mouseout",
                this.onPointerOverOut,
                !0
              ),
              this.domElement.removeEventListener(
                "mouseover",
                this.onPointerOverOut,
                !0
              ),
              globalThis.removeEventListener("mouseup", this.onPointerUp, !0),
              this.supportsTouchEvents &&
                (this.domElement.removeEventListener(
                  "touchstart",
                  this.onPointerDown,
                  !0
                ),
                this.domElement.removeEventListener(
                  "touchend",
                  this.onPointerUp,
                  !0
                ),
                this.domElement.removeEventListener(
                  "touchmove",
                  this.onPointerMove,
                  !0
                ))),
          this.domElement.removeEventListener("wheel", this.onWheel, !0),
          (this.domElement = null),
          (this.eventsAdded = !1);
      }
      mapPositionToPoint(e, t, i) {
        const s = this.domElement.isConnected
            ? this.domElement.getBoundingClientRect()
            : {
                x: 0,
                y: 0,
                width: this.domElement.width,
                height: this.domElement.height,
                left: 0,
                top: 0,
              },
          n = 1 / this.resolution;
        (e.x = (t - s.left) * (this.domElement.width / s.width) * n),
          (e.y = (i - s.top) * (this.domElement.height / s.height) * n);
      }
      normalizeToPointerData(e) {
        const t = [];
        if (this.supportsTouchEvents && e instanceof TouchEvent)
          for (let i = 0, s = e.changedTouches.length; i < s; i++) {
            const n = e.changedTouches[i];
            typeof n.button > "u" && (n.button = 0),
              typeof n.buttons > "u" && (n.buttons = 1),
              typeof n.isPrimary > "u" &&
                (n.isPrimary =
                  e.touches.length === 1 && e.type === "touchstart"),
              typeof n.width > "u" && (n.width = n.radiusX || 1),
              typeof n.height > "u" && (n.height = n.radiusY || 1),
              typeof n.tiltX > "u" && (n.tiltX = 0),
              typeof n.tiltY > "u" && (n.tiltY = 0),
              typeof n.pointerType > "u" && (n.pointerType = "touch"),
              typeof n.pointerId > "u" && (n.pointerId = n.identifier || 0),
              typeof n.pressure > "u" && (n.pressure = n.force || 0.5),
              typeof n.twist > "u" && (n.twist = 0),
              typeof n.tangentialPressure > "u" && (n.tangentialPressure = 0),
              typeof n.layerX > "u" && (n.layerX = n.offsetX = n.clientX),
              typeof n.layerY > "u" && (n.layerY = n.offsetY = n.clientY),
              (n.isNormalized = !0),
              (n.type = e.type),
              t.push(n);
          }
        else if (
          !globalThis.MouseEvent ||
          (e instanceof MouseEvent &&
            (!this.supportsPointerEvents ||
              !(e instanceof globalThis.PointerEvent)))
        ) {
          const i = e;
          typeof i.isPrimary > "u" && (i.isPrimary = !0),
            typeof i.width > "u" && (i.width = 1),
            typeof i.height > "u" && (i.height = 1),
            typeof i.tiltX > "u" && (i.tiltX = 0),
            typeof i.tiltY > "u" && (i.tiltY = 0),
            typeof i.pointerType > "u" && (i.pointerType = "mouse"),
            typeof i.pointerId > "u" && (i.pointerId = n8),
            typeof i.pressure > "u" && (i.pressure = 0.5),
            typeof i.twist > "u" && (i.twist = 0),
            typeof i.tangentialPressure > "u" && (i.tangentialPressure = 0),
            (i.isNormalized = !0),
            t.push(i);
        } else t.push(e);
        return t;
      }
      normalizeWheelEvent(e) {
        const t = this.rootWheelEvent;
        return (
          this.transferMouseData(t, e),
          (t.deltaX = e.deltaX),
          (t.deltaY = e.deltaY),
          (t.deltaZ = e.deltaZ),
          (t.deltaMode = e.deltaMode),
          this.mapPositionToPoint(t.screen, e.clientX, e.clientY),
          t.global.copyFrom(t.screen),
          t.offset.copyFrom(t.screen),
          (t.nativeEvent = e),
          (t.type = e.type),
          t
        );
      }
      bootstrapEvent(e, t) {
        return (
          (e.originalEvent = null),
          (e.nativeEvent = t),
          (e.pointerId = t.pointerId),
          (e.width = t.width),
          (e.height = t.height),
          (e.isPrimary = t.isPrimary),
          (e.pointerType = t.pointerType),
          (e.pressure = t.pressure),
          (e.tangentialPressure = t.tangentialPressure),
          (e.tiltX = t.tiltX),
          (e.tiltY = t.tiltY),
          (e.twist = t.twist),
          this.transferMouseData(e, t),
          this.mapPositionToPoint(e.screen, t.clientX, t.clientY),
          e.global.copyFrom(e.screen),
          e.offset.copyFrom(e.screen),
          (e.isTrusted = t.isTrusted),
          e.type === "pointerleave" && (e.type = "pointerout"),
          e.type.startsWith("mouse") &&
            (e.type = e.type.replace("mouse", "pointer")),
          e.type.startsWith("touch") && (e.type = a8[e.type] || e.type),
          e
        );
      }
      transferMouseData(e, t) {
        (e.isTrusted = t.isTrusted),
          (e.srcElement = t.srcElement),
          (e.timeStamp = performance.now()),
          (e.type = t.type),
          (e.altKey = t.altKey),
          (e.button = t.button),
          (e.buttons = t.buttons),
          (e.client.x = t.clientX),
          (e.client.y = t.clientY),
          (e.ctrlKey = t.ctrlKey),
          (e.metaKey = t.metaKey),
          (e.movement.x = t.movementX),
          (e.movement.y = t.movementY),
          (e.page.x = t.pageX),
          (e.page.y = t.pageY),
          (e.relatedTarget = null),
          (e.shiftKey = t.shiftKey);
      }
    };
  (Tf.extension = {
    name: "events",
    type: [me.RendererSystem, me.CanvasRendererSystem],
  }),
    (Tf.defaultEventFeatures = {
      move: !0,
      globalMove: !0,
      click: !0,
      wheel: !0,
    });
  let Sf = Tf;
  Ce.add(Sf);
  function Nv(r) {
    return r === "dynamic" || r === "static";
  }
  const o8 = {
    onclick: null,
    onmousedown: null,
    onmouseenter: null,
    onmouseleave: null,
    onmousemove: null,
    onglobalmousemove: null,
    onmouseout: null,
    onmouseover: null,
    onmouseup: null,
    onmouseupoutside: null,
    onpointercancel: null,
    onpointerdown: null,
    onpointerenter: null,
    onpointerleave: null,
    onpointermove: null,
    onglobalpointermove: null,
    onpointerout: null,
    onpointerover: null,
    onpointertap: null,
    onpointerup: null,
    onpointerupoutside: null,
    onrightclick: null,
    onrightdown: null,
    onrightup: null,
    onrightupoutside: null,
    ontap: null,
    ontouchcancel: null,
    ontouchend: null,
    ontouchendoutside: null,
    ontouchmove: null,
    onglobaltouchmove: null,
    ontouchstart: null,
    onwheel: null,
    _internalInteractive: void 0,
    get interactive() {
      return this._internalInteractive ?? Nv(Sf.defaultEventMode);
    },
    set interactive(r) {
      We(
        "7.2.0",
        "Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead."
      ),
        (this._internalInteractive = r),
        (this.eventMode = r ? "static" : "auto");
    },
    _internalEventMode: void 0,
    get eventMode() {
      return this._internalEventMode ?? Sf.defaultEventMode;
    },
    set eventMode(r) {
      (this._internalInteractive = Nv(r)), (this._internalEventMode = r);
    },
    isInteractive() {
      return this.eventMode === "static" || this.eventMode === "dynamic";
    },
    interactiveChildren: !0,
    hitArea: null,
    addEventListener(r, e, t) {
      const i =
          (typeof t == "boolean" && t) || (typeof t == "object" && t.capture),
        s = typeof t == "object" ? t.signal : void 0,
        n = typeof t == "object" ? t.once === !0 : !1,
        a = typeof e == "function" ? void 0 : e;
      r = i ? `${r}capture` : r;
      const o = typeof e == "function" ? e : e.handleEvent,
        l = this;
      s &&
        s.addEventListener("abort", () => {
          l.off(r, o, a);
        }),
        n ? l.once(r, o, a) : l.on(r, o, a);
    },
    removeEventListener(r, e, t) {
      const i =
          (typeof t == "boolean" && t) || (typeof t == "object" && t.capture),
        s = typeof e == "function" ? void 0 : e;
      (r = i ? `${r}capture` : r),
        (e = typeof e == "function" ? e : e.handleEvent),
        this.off(r, e, s);
    },
    dispatchEvent(r) {
      if (!(r instanceof bl))
        throw new Error(
          "DisplayObject cannot propagate events outside of the Federated Events API"
        );
      return (
        (r.defaultPrevented = !1),
        (r.path = null),
        (r.target = this),
        r.manager.dispatchEvent(r),
        !r.defaultPrevented
      );
    },
  };
  At.mixin(o8);
  const l8 = {
    accessible: !1,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    _accessibleActive: !1,
    _accessibleDiv: null,
    accessibleType: "button",
    accessiblePointerEvents: "auto",
    accessibleChildren: !0,
    renderId: -1,
  };
  At.mixin(l8);
  const h8 = 9,
    Ql = 100,
    c8 = 0,
    u8 = 0,
    Uv = 2,
    Vv = 1,
    d8 = -1e3,
    f8 = -1e3,
    p8 = 2;
  class b_ {
    constructor(e) {
      (this.debug = !1),
        (this._isActive = !1),
        (this._isMobileAccessibility = !1),
        (this.pool = []),
        (this.renderId = 0),
        (this.children = []),
        (this.androidUpdateCount = 0),
        (this.androidUpdateFrequency = 500),
        (this._hookDiv = null),
        (cs.tablet || cs.phone) && this.createTouchHook();
      const t = document.createElement("div");
      (t.style.width = `${Ql}px`),
        (t.style.height = `${Ql}px`),
        (t.style.position = "absolute"),
        (t.style.top = `${c8}px`),
        (t.style.left = `${u8}px`),
        (t.style.zIndex = Uv.toString()),
        (this.div = t),
        (this.renderer = e),
        (this._onKeyDown = this._onKeyDown.bind(this)),
        (this._onMouseMove = this._onMouseMove.bind(this)),
        globalThis.addEventListener("keydown", this._onKeyDown, !1);
    }
    get isActive() {
      return this._isActive;
    }
    get isMobileAccessibility() {
      return this._isMobileAccessibility;
    }
    createTouchHook() {
      const e = document.createElement("button");
      (e.style.width = `${Vv}px`),
        (e.style.height = `${Vv}px`),
        (e.style.position = "absolute"),
        (e.style.top = `${d8}px`),
        (e.style.left = `${f8}px`),
        (e.style.zIndex = p8.toString()),
        (e.style.backgroundColor = "#FF0000"),
        (e.title = "select to enable accessibility for this content"),
        e.addEventListener("focus", () => {
          (this._isMobileAccessibility = !0),
            this.activate(),
            this.destroyTouchHook();
        }),
        document.body.appendChild(e),
        (this._hookDiv = e);
    }
    destroyTouchHook() {
      this._hookDiv &&
        (document.body.removeChild(this._hookDiv), (this._hookDiv = null));
    }
    activate() {
      var e;
      this._isActive ||
        ((this._isActive = !0),
        globalThis.document.addEventListener(
          "mousemove",
          this._onMouseMove,
          !0
        ),
        globalThis.removeEventListener("keydown", this._onKeyDown, !1),
        this.renderer.on("postrender", this.update, this),
        (e = this.renderer.view.parentNode) == null || e.appendChild(this.div));
    }
    deactivate() {
      var e;
      !this._isActive ||
        this._isMobileAccessibility ||
        ((this._isActive = !1),
        globalThis.document.removeEventListener(
          "mousemove",
          this._onMouseMove,
          !0
        ),
        globalThis.addEventListener("keydown", this._onKeyDown, !1),
        this.renderer.off("postrender", this.update),
        (e = this.div.parentNode) == null || e.removeChild(this.div));
    }
    updateAccessibleObjects(e) {
      if (!e.visible || !e.accessibleChildren) return;
      e.accessible &&
        e.isInteractive() &&
        (e._accessibleActive || this.addChild(e), (e.renderId = this.renderId));
      const t = e.children;
      if (t)
        for (let i = 0; i < t.length; i++) this.updateAccessibleObjects(t[i]);
    }
    update() {
      const e = performance.now();
      if (
        (cs.android.device && e < this.androidUpdateCount) ||
        ((this.androidUpdateCount = e + this.androidUpdateFrequency),
        !this.renderer.renderingToScreen)
      )
        return;
      this.renderer.lastObjectRendered &&
        this.updateAccessibleObjects(this.renderer.lastObjectRendered);
      const {
          x: t,
          y: i,
          width: s,
          height: n,
        } = this.renderer.view.getBoundingClientRect(),
        { width: a, height: o, resolution: l } = this.renderer,
        h = (s / a) * l,
        c = (n / o) * l;
      let u = this.div;
      (u.style.left = `${t}px`),
        (u.style.top = `${i}px`),
        (u.style.width = `${a}px`),
        (u.style.height = `${o}px`);
      for (let d = 0; d < this.children.length; d++) {
        const f = this.children[d];
        if (f.renderId !== this.renderId)
          (f._accessibleActive = !1),
            Sa(this.children, d, 1),
            this.div.removeChild(f._accessibleDiv),
            this.pool.push(f._accessibleDiv),
            (f._accessibleDiv = null),
            d--;
        else {
          u = f._accessibleDiv;
          let p = f.hitArea;
          const m = f.worldTransform;
          f.hitArea
            ? ((u.style.left = `${(m.tx + p.x * m.a) * h}px`),
              (u.style.top = `${(m.ty + p.y * m.d) * c}px`),
              (u.style.width = `${p.width * m.a * h}px`),
              (u.style.height = `${p.height * m.d * c}px`))
            : ((p = f.getBounds()),
              this.capHitArea(p),
              (u.style.left = `${p.x * h}px`),
              (u.style.top = `${p.y * c}px`),
              (u.style.width = `${p.width * h}px`),
              (u.style.height = `${p.height * c}px`),
              u.title !== f.accessibleTitle &&
                f.accessibleTitle !== null &&
                (u.title = f.accessibleTitle),
              u.getAttribute("aria-label") !== f.accessibleHint &&
                f.accessibleHint !== null &&
                u.setAttribute("aria-label", f.accessibleHint)),
            (f.accessibleTitle !== u.title || f.tabIndex !== u.tabIndex) &&
              ((u.title = f.accessibleTitle),
              (u.tabIndex = f.tabIndex),
              this.debug && this.updateDebugHTML(u));
        }
      }
      this.renderId++;
    }
    updateDebugHTML(e) {
      e.innerHTML = `type: ${e.type}</br> title : ${e.title}</br> tabIndex: ${e.tabIndex}`;
    }
    capHitArea(e) {
      e.x < 0 && ((e.width += e.x), (e.x = 0)),
        e.y < 0 && ((e.height += e.y), (e.y = 0));
      const { width: t, height: i } = this.renderer;
      e.x + e.width > t && (e.width = t - e.x),
        e.y + e.height > i && (e.height = i - e.y);
    }
    addChild(e) {
      let t = this.pool.pop();
      t ||
        ((t = document.createElement("button")),
        (t.style.width = `${Ql}px`),
        (t.style.height = `${Ql}px`),
        (t.style.backgroundColor = this.debug
          ? "rgba(255,255,255,0.5)"
          : "transparent"),
        (t.style.position = "absolute"),
        (t.style.zIndex = Uv.toString()),
        (t.style.borderStyle = "none"),
        navigator.userAgent.toLowerCase().includes("chrome")
          ? t.setAttribute("aria-live", "off")
          : t.setAttribute("aria-live", "polite"),
        navigator.userAgent.match(/rv:.*Gecko\//)
          ? t.setAttribute("aria-relevant", "additions")
          : t.setAttribute("aria-relevant", "text"),
        t.addEventListener("click", this._onClick.bind(this)),
        t.addEventListener("focus", this._onFocus.bind(this)),
        t.addEventListener("focusout", this._onFocusOut.bind(this))),
        (t.style.pointerEvents = e.accessiblePointerEvents),
        (t.type = e.accessibleType),
        e.accessibleTitle && e.accessibleTitle !== null
          ? (t.title = e.accessibleTitle)
          : (!e.accessibleHint || e.accessibleHint === null) &&
            (t.title = `displayObject ${e.tabIndex}`),
        e.accessibleHint &&
          e.accessibleHint !== null &&
          t.setAttribute("aria-label", e.accessibleHint),
        this.debug && this.updateDebugHTML(t),
        (e._accessibleActive = !0),
        (e._accessibleDiv = t),
        (t.displayObject = e),
        this.children.push(e),
        this.div.appendChild(e._accessibleDiv),
        (e._accessibleDiv.tabIndex = e.tabIndex);
    }
    _dispatchEvent(e, t) {
      const { displayObject: i } = e.target,
        s = this.renderer.events.rootBoundary,
        n = Object.assign(new bl(s), { target: i });
      (s.rootTarget = this.renderer.lastObjectRendered),
        t.forEach((a) => s.dispatchEvent(n, a));
    }
    _onClick(e) {
      this._dispatchEvent(e, ["click", "pointertap", "tap"]);
    }
    _onFocus(e) {
      e.target.getAttribute("aria-live") ||
        e.target.setAttribute("aria-live", "assertive"),
        this._dispatchEvent(e, ["mouseover"]);
    }
    _onFocusOut(e) {
      e.target.getAttribute("aria-live") ||
        e.target.setAttribute("aria-live", "polite"),
        this._dispatchEvent(e, ["mouseout"]);
    }
    _onKeyDown(e) {
      e.keyCode === h8 && this.activate();
    }
    _onMouseMove(e) {
      (e.movementX === 0 && e.movementY === 0) || this.deactivate();
    }
    destroy() {
      this.destroyTouchHook(),
        (this.div = null),
        globalThis.document.removeEventListener(
          "mousemove",
          this._onMouseMove,
          !0
        ),
        globalThis.removeEventListener("keydown", this._onKeyDown),
        (this.pool = null),
        (this.children = null),
        (this.renderer = null);
    }
  }
  b_.extension = {
    name: "accessibility",
    type: [me.RendererPlugin, me.CanvasRendererPlugin],
  };
  Ce.add(b_);
  const x_ = class Af {
    constructor(e) {
      (this.stage = new jr()),
        (e = Object.assign({ forceCanvas: !1 }, e)),
        (this.renderer = E4(e)),
        Af._plugins.forEach((t) => {
          t.init.call(this, e);
        });
    }
    render() {
      this.renderer.render(this.stage);
    }
    get view() {
      var e;
      return (e = this.renderer) == null ? void 0 : e.view;
    }
    get screen() {
      var e;
      return (e = this.renderer) == null ? void 0 : e.screen;
    }
    destroy(e, t) {
      const i = Af._plugins.slice(0);
      i.reverse(),
        i.forEach((s) => {
          s.destroy.call(this);
        }),
        this.stage.destroy(t),
        (this.stage = null),
        this.renderer.destroy(e),
        (this.renderer = null);
    }
  };
  x_._plugins = [];
  let __ = x_;
  Ce.handleByList(me.Application, __._plugins);
  class w_ {
    static init(e) {
      Object.defineProperty(this, "resizeTo", {
        set(t) {
          globalThis.removeEventListener("resize", this.queueResize),
            (this._resizeTo = t),
            t &&
              (globalThis.addEventListener("resize", this.queueResize),
              this.resize());
        },
        get() {
          return this._resizeTo;
        },
      }),
        (this.queueResize = () => {
          this._resizeTo &&
            (this.cancelResize(),
            (this._resizeId = requestAnimationFrame(() => this.resize())));
        }),
        (this.cancelResize = () => {
          this._resizeId &&
            (cancelAnimationFrame(this._resizeId), (this._resizeId = null));
        }),
        (this.resize = () => {
          if (!this._resizeTo) return;
          this.cancelResize();
          let t, i;
          if (this._resizeTo === globalThis.window)
            (t = globalThis.innerWidth), (i = globalThis.innerHeight);
          else {
            const { clientWidth: s, clientHeight: n } = this._resizeTo;
            (t = s), (i = n);
          }
          this.renderer.resize(t, i), this.render();
        }),
        (this._resizeId = null),
        (this._resizeTo = null),
        (this.resizeTo = e.resizeTo || null);
    }
    static destroy() {
      globalThis.removeEventListener("resize", this.queueResize),
        this.cancelResize(),
        (this.cancelResize = null),
        (this.queueResize = null),
        (this.resizeTo = null),
        (this.resize = null);
    }
  }
  w_.extension = me.Application;
  Ce.add(w_);
  const $v = {
    loader: me.LoadParser,
    resolver: me.ResolveParser,
    cache: me.CacheParser,
    detection: me.DetectionParser,
  };
  Ce.handle(
    me.Asset,
    (r) => {
      const e = r.ref;
      Object.entries($v)
        .filter(([t]) => !!e[t])
        .forEach(([t, i]) =>
          Ce.add(Object.assign(e[t], { extension: e[t].extension ?? i }))
        );
    },
    (r) => {
      const e = r.ref;
      Object.keys($v)
        .filter((t) => !!e[t])
        .forEach((t) => Ce.remove(e[t]));
    }
  );
  class m8 {
    constructor(e, t = !1) {
      (this._loader = e),
        (this._assetList = []),
        (this._isLoading = !1),
        (this._maxConcurrent = 1),
        (this.verbose = t);
    }
    add(e) {
      e.forEach((t) => {
        this._assetList.push(t);
      }),
        this.verbose &&
          console.log("[BackgroundLoader] assets: ", this._assetList),
        this._isActive && !this._isLoading && this._next();
    }
    async _next() {
      if (this._assetList.length && this._isActive) {
        this._isLoading = !0;
        const e = [],
          t = Math.min(this._assetList.length, this._maxConcurrent);
        for (let i = 0; i < t; i++) e.push(this._assetList.pop());
        await this._loader.load(e), (this._isLoading = !1), this._next();
      }
    }
    get active() {
      return this._isActive;
    }
    set active(e) {
      this._isActive !== e &&
        ((this._isActive = e), e && !this._isLoading && this._next());
    }
  }
  function ro(r, e) {
    if (Array.isArray(e)) {
      for (const t of e) if (r.startsWith(`data:${t}`)) return !0;
      return !1;
    }
    return r.startsWith(`data:${e}`);
  }
  function xr(r, e) {
    const t = r.split("?")[0],
      i = Pt.extname(t).toLowerCase();
    return Array.isArray(e) ? e.includes(i) : i === e;
  }
  const si = (r, e, t = !1) => (
      Array.isArray(r) || (r = [r]),
      e ? r.map((i) => (typeof i == "string" || t ? e(i) : i)) : r
    ),
    Cf = (r, e) => {
      const t = e.split("?")[1];
      return t && (r += `?${t}`), r;
    };
  function T_(r, e, t, i, s) {
    const n = e[t];
    for (let a = 0; a < n.length; a++) {
      const o = n[a];
      t < e.length - 1
        ? T_(r.replace(i[t], o), e, t + 1, i, s)
        : s.push(r.replace(i[t], o));
    }
  }
  function g8(r) {
    const e = /\{(.*?)\}/g,
      t = r.match(e),
      i = [];
    if (t) {
      const s = [];
      t.forEach((n) => {
        const a = n.substring(1, n.length - 1).split(",");
        s.push(a);
      }),
        T_(r, s, 0, t, i);
    } else i.push(r);
    return i;
  }
  const Jh = (r) => !Array.isArray(r);
  class v8 {
    constructor() {
      (this._parsers = []),
        (this._cache = new Map()),
        (this._cacheMap = new Map());
    }
    reset() {
      this._cacheMap.clear(), this._cache.clear();
    }
    has(e) {
      return this._cache.has(e);
    }
    get(e) {
      const t = this._cache.get(e);
      return (
        t || console.warn(`[Assets] Asset id ${e} was not found in the Cache`),
        t
      );
    }
    set(e, t) {
      const i = si(e);
      let s;
      for (let o = 0; o < this.parsers.length; o++) {
        const l = this.parsers[o];
        if (l.test(t)) {
          s = l.getCacheableAssets(i, t);
          break;
        }
      }
      s ||
        ((s = {}),
        i.forEach((o) => {
          s[o] = t;
        }));
      const n = Object.keys(s),
        a = { cacheKeys: n, keys: i };
      if (
        (i.forEach((o) => {
          this._cacheMap.set(o, a);
        }),
        n.forEach((o) => {
          this._cache.has(o) &&
            this._cache.get(o) !== t &&
            console.warn("[Cache] already has key:", o),
            this._cache.set(o, s[o]);
        }),
        t instanceof ze)
      ) {
        const o = t;
        i.forEach((l) => {
          o.baseTexture !== ze.EMPTY.baseTexture &&
            Le.addToCache(o.baseTexture, l),
            ze.addToCache(o, l);
        });
      }
    }
    remove(e) {
      if (!this._cacheMap.has(e)) {
        console.warn(`[Assets] Asset id ${e} was not found in the Cache`);
        return;
      }
      const t = this._cacheMap.get(e);
      t.cacheKeys.forEach((i) => {
        this._cache.delete(i);
      }),
        t.keys.forEach((i) => {
          this._cacheMap.delete(i);
        });
    }
    get parsers() {
      return this._parsers;
    }
  }
  const vn = new v8();
  class y8 {
    constructor() {
      (this._parsers = []),
        (this._parsersValidated = !1),
        (this.parsers = new Proxy(this._parsers, {
          set: (e, t, i) => ((this._parsersValidated = !1), (e[t] = i), !0),
        })),
        (this.promiseCache = {});
    }
    reset() {
      (this._parsersValidated = !1), (this.promiseCache = {});
    }
    _getLoadPromiseAndParser(e, t) {
      const i = { promise: null, parser: null };
      return (
        (i.promise = (async () => {
          var a, o;
          let s = null,
            n = null;
          if (
            (t.loadParser &&
              ((n = this._parserHash[t.loadParser]),
              n ||
                console.warn(
                  `[Assets] specified load parser "${t.loadParser}" not found while loading ${e}`
                )),
            !n)
          ) {
            for (let l = 0; l < this.parsers.length; l++) {
              const h = this.parsers[l];
              if (h.load && (a = h.test) != null && a.call(h, e, t, this)) {
                n = h;
                break;
              }
            }
            if (!n)
              return (
                console.warn(
                  `[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`
                ),
                null
              );
          }
          (s = await n.load(e, t, this)), (i.parser = n);
          for (let l = 0; l < this.parsers.length; l++) {
            const h = this.parsers[l];
            h.parse &&
              h.parse &&
              (await ((o = h.testParse) == null
                ? void 0
                : o.call(h, s, t, this))) &&
              ((s = (await h.parse(s, t, this)) || s), (i.parser = h));
          }
          return s;
        })()),
        i
      );
    }
    async load(e, t) {
      this._parsersValidated || this._validateParsers();
      let i = 0;
      const s = {},
        n = Jh(e),
        a = si(e, (h) => ({ alias: [h], src: h })),
        o = a.length,
        l = a.map(async (h) => {
          const c = Pt.toAbsolute(h.src);
          if (!s[h.src])
            try {
              this.promiseCache[c] ||
                (this.promiseCache[c] = this._getLoadPromiseAndParser(c, h)),
                (s[h.src] = await this.promiseCache[c].promise),
                t && t(++i / o);
            } catch (u) {
              throw (
                (delete this.promiseCache[c],
                delete s[h.src],
                new Error(`[Loader.load] Failed to load ${c}.
${u}`))
              );
            }
        });
      return await Promise.all(l), n ? s[a[0].src] : s;
    }
    async unload(e) {
      const t = si(e, (i) => ({ alias: [i], src: i })).map(async (i) => {
        var a, o;
        const s = Pt.toAbsolute(i.src),
          n = this.promiseCache[s];
        if (n) {
          const l = await n.promise;
          delete this.promiseCache[s],
            (o = (a = n.parser) == null ? void 0 : a.unload) == null ||
              o.call(a, l, i, this);
        }
      });
      await Promise.all(t);
    }
    _validateParsers() {
      (this._parsersValidated = !0),
        (this._parserHash = this._parsers
          .filter((e) => e.name)
          .reduce(
            (e, t) => (
              e[t.name] &&
                console.warn(`[Assets] loadParser name conflict "${t.name}"`),
              { ...e, [t.name]: t }
            ),
            {}
          ));
    }
  }
  var kr = ((r) => (
    (r[(r.Low = 0)] = "Low"),
    (r[(r.Normal = 1)] = "Normal"),
    (r[(r.High = 2)] = "High"),
    r
  ))(kr || {});
  const b8 = ".json",
    x8 = "application/json",
    _8 = {
      extension: { type: me.LoadParser, priority: kr.Low },
      name: "loadJson",
      test(r) {
        return ro(r, x8) || xr(r, b8);
      },
      async load(r) {
        return await (await we.ADAPTER.fetch(r)).json();
      },
    };
  Ce.add(_8);
  const w8 = ".txt",
    T8 = "text/plain",
    E8 = {
      name: "loadTxt",
      extension: { type: me.LoadParser, priority: kr.Low },
      test(r) {
        return ro(r, T8) || xr(r, w8);
      },
      async load(r) {
        return await (await we.ADAPTER.fetch(r)).text();
      },
    };
  Ce.add(E8);
  const S8 = [
      "normal",
      "bold",
      "100",
      "200",
      "300",
      "400",
      "500",
      "600",
      "700",
      "800",
      "900",
    ],
    A8 = [".ttf", ".otf", ".woff", ".woff2"],
    C8 = ["font/ttf", "font/otf", "font/woff", "font/woff2"],
    I8 = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
  function P8(r) {
    const e = Pt.extname(r),
      t = Pt.basename(r, e)
        .replace(/(-|_)/g, " ")
        .toLowerCase()
        .split(" ")
        .map((n) => n.charAt(0).toUpperCase() + n.slice(1));
    let i = t.length > 0;
    for (const n of t)
      if (!n.match(I8)) {
        i = !1;
        break;
      }
    let s = t.join(" ");
    return i || (s = `"${s.replace(/[\\"]/g, "\\$&")}"`), s;
  }
  const R8 = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
  function M8(r) {
    return R8.test(r) ? r : encodeURI(r);
  }
  const F8 = {
    extension: { type: me.LoadParser, priority: kr.Low },
    name: "loadWebFont",
    test(r) {
      return ro(r, C8) || xr(r, A8);
    },
    async load(r, e) {
      var i, s, n;
      const t = we.ADAPTER.getFontFaceSet();
      if (t) {
        const a = [],
          o = ((i = e.data) == null ? void 0 : i.family) ?? P8(r),
          l = ((n = (s = e.data) == null ? void 0 : s.weights) == null
            ? void 0
            : n.filter((c) => S8.includes(c))) ?? ["normal"],
          h = e.data ?? {};
        for (let c = 0; c < l.length; c++) {
          const u = l[c],
            d = new FontFace(o, `url(${M8(r)})`, { ...h, weight: u });
          await d.load(), t.add(d), a.push(d);
        }
        return a.length === 1 ? a[0] : a;
      }
      return (
        console.warn(
          "[loadWebFont] FontFace API is not supported. Skipping loading font"
        ),
        null
      );
    },
    unload(r) {
      (Array.isArray(r) ? r : [r]).forEach((e) =>
        we.ADAPTER.getFontFaceSet().delete(e)
      );
    },
  };
  Ce.add(F8);
  const B8 = `(function() {
  "use strict";
  const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
  async function checkImageBitmap() {
    try {
      if (typeof createImageBitmap != "function")
        return !1;
      const imageBlob = await (await fetch(WHITE_PNG)).blob(), imageBitmap = await createImageBitmap(imageBlob);
      return imageBitmap.width === 1 && imageBitmap.height === 1;
    } catch {
      return !1;
    }
  }
  checkImageBitmap().then((result) => {
    self.postMessage(result);
  });
})();
`;
  let Ia = null,
    If = class {
      constructor() {
        Ia ||
          (Ia = URL.createObjectURL(
            new Blob([B8], { type: "application/javascript" })
          )),
          (this.worker = new Worker(Ia));
      }
    };
  If.revokeObjectURL = function () {
    Ia && (URL.revokeObjectURL(Ia), (Ia = null));
  };
  const O8 = `(function() {
  "use strict";
  async function loadImageBitmap(url) {
    const response = await fetch(url);
    if (!response.ok)
      throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
    const imageBlob = await response.blob();
    return await createImageBitmap(imageBlob);
  }
  self.onmessage = async (event) => {
    try {
      const imageBitmap = await loadImageBitmap(event.data.data[0]);
      self.postMessage({
        data: imageBitmap,
        uuid: event.data.uuid,
        id: event.data.id
      }, [imageBitmap]);
    } catch (e) {
      self.postMessage({
        error: e,
        uuid: event.data.uuid,
        id: event.data.id
      });
    }
  };
})();
`;
  let Pa = null;
  class E_ {
    constructor() {
      Pa ||
        (Pa = URL.createObjectURL(
          new Blob([O8], { type: "application/javascript" })
        )),
        (this.worker = new Worker(Pa));
    }
  }
  E_.revokeObjectURL = function () {
    Pa && (URL.revokeObjectURL(Pa), (Pa = null));
  };
  let Gv = 0,
    Ju;
  class k8 {
    constructor() {
      (this._initialized = !1),
        (this._createdWorkers = 0),
        (this.workerPool = []),
        (this.queue = []),
        (this.resolveHash = {});
    }
    isImageBitmapSupported() {
      return this._isImageBitmapSupported !== void 0
        ? this._isImageBitmapSupported
        : ((this._isImageBitmapSupported = new Promise((e) => {
            const { worker: t } = new If();
            t.addEventListener("message", (i) => {
              t.terminate(), If.revokeObjectURL(), e(i.data);
            });
          })),
          this._isImageBitmapSupported);
    }
    loadImageBitmap(e) {
      return this._run("loadImageBitmap", [e]);
    }
    async _initWorkers() {
      this._initialized || (this._initialized = !0);
    }
    getWorker() {
      Ju === void 0 && (Ju = navigator.hardwareConcurrency || 4);
      let e = this.workerPool.pop();
      return (
        !e &&
          this._createdWorkers < Ju &&
          (this._createdWorkers++,
          (e = new E_().worker),
          e.addEventListener("message", (t) => {
            this.complete(t.data), this.returnWorker(t.target), this.next();
          })),
        e
      );
    }
    returnWorker(e) {
      this.workerPool.push(e);
    }
    complete(e) {
      e.error !== void 0
        ? this.resolveHash[e.uuid].reject(e.error)
        : this.resolveHash[e.uuid].resolve(e.data),
        (this.resolveHash[e.uuid] = null);
    }
    async _run(e, t) {
      await this._initWorkers();
      const i = new Promise((s, n) => {
        this.queue.push({ id: e, arguments: t, resolve: s, reject: n });
      });
      return this.next(), i;
    }
    next() {
      if (!this.queue.length) return;
      const e = this.getWorker();
      if (!e) return;
      const t = this.queue.pop(),
        i = t.id;
      (this.resolveHash[Gv] = { resolve: t.resolve, reject: t.reject }),
        e.postMessage({ data: t.arguments, uuid: Gv++, id: i });
    }
  }
  const Hv = new k8();
  function xl(r, e, t) {
    r.resource.internal = !0;
    const i = new ze(r),
      s = () => {
        delete e.promiseCache[t], vn.has(t) && vn.remove(t);
      };
    return (
      i.baseTexture.once("destroyed", () => {
        t in e.promiseCache &&
          (console.warn(
            "[Assets] A BaseTexture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the BaseTexture."
          ),
          s());
      }),
      i.once("destroyed", () => {
        r.destroyed ||
          (console.warn(
            "[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."
          ),
          s());
      }),
      i
    );
  }
  const D8 = [".jpeg", ".jpg", ".png", ".webp", ".avif"],
    L8 = ["image/jpeg", "image/png", "image/webp", "image/avif"];
  async function N8(r) {
    const e = await we.ADAPTER.fetch(r);
    if (!e.ok)
      throw new Error(
        `[loadImageBitmap] Failed to fetch ${r}: ${e.status} ${e.statusText}`
      );
    const t = await e.blob();
    return await createImageBitmap(t);
  }
  const Hc = {
    name: "loadTextures",
    extension: { type: me.LoadParser, priority: kr.High },
    config: {
      preferWorkers: !0,
      preferCreateImageBitmap: !0,
      crossOrigin: "anonymous",
    },
    test(r) {
      return ro(r, L8) || xr(r, D8);
    },
    async load(r, e, t) {
      var o;
      const i =
        globalThis.createImageBitmap && this.config.preferCreateImageBitmap;
      let s;
      i
        ? this.config.preferWorkers && (await Hv.isImageBitmapSupported())
          ? (s = await Hv.loadImageBitmap(r))
          : (s = await N8(r))
        : (s = await new Promise((l, h) => {
            const c = new Image();
            (c.crossOrigin = this.config.crossOrigin),
              (c.src = r),
              c.complete
                ? l(c)
                : ((c.onload = () => l(c)), (c.onerror = (u) => h(u)));
          }));
      const n = { ...e.data };
      n.resolution ?? (n.resolution = vs(r)),
        i &&
          ((o = n.resourceOptions) == null ? void 0 : o.ownsImageBitmap) ===
            void 0 &&
          ((n.resourceOptions = { ...n.resourceOptions }),
          (n.resourceOptions.ownsImageBitmap = !0));
      const a = new Le(s, n);
      return (a.resource.src = r), xl(a, t, r);
    },
    unload(r) {
      r.destroy(!0);
    },
  };
  Ce.add(Hc);
  const U8 = ".svg",
    V8 = "image/svg+xml",
    $8 = {
      extension: { type: me.LoadParser, priority: kr.High },
      name: "loadSVG",
      test(r) {
        return ro(r, V8) || xr(r, U8);
      },
      async testParse(r) {
        return vf.test(r);
      },
      async parse(r, e, t) {
        var n;
        const i = new vf(
          r,
          (n = e == null ? void 0 : e.data) == null ? void 0 : n.resourceOptions
        );
        await i.load();
        const s = new Le(i, {
          resolution: vs(r),
          ...(e == null ? void 0 : e.data),
        });
        return (s.resource.src = e.src), xl(s, t, e.src);
      },
      async load(r, e) {
        return (await we.ADAPTER.fetch(r)).text();
      },
      unload: Hc.unload,
    };
  Ce.add($8);
  const G8 = [".mp4", ".m4v", ".webm", ".ogv"],
    H8 = ["video/mp4", "video/webm", "video/ogg"],
    X8 = {
      name: "loadVideo",
      extension: { type: me.LoadParser, priority: kr.High },
      config: {
        defaultAutoPlay: !0,
        defaultUpdateFPS: 0,
        defaultLoop: !1,
        defaultMuted: !1,
        defaultPlaysinline: !0,
      },
      test(r) {
        return ro(r, H8) || xr(r, G8);
      },
      async load(r, e, t) {
        var a;
        let i;
        const s = await (await we.ADAPTER.fetch(r)).blob(),
          n = URL.createObjectURL(s);
        try {
          const o = {
              autoPlay: this.config.defaultAutoPlay,
              updateFPS: this.config.defaultUpdateFPS,
              loop: this.config.defaultLoop,
              muted: this.config.defaultMuted,
              playsinline: this.config.defaultPlaysinline,
              ...((a = e == null ? void 0 : e.data) == null
                ? void 0
                : a.resourceOptions),
              autoLoad: !0,
            },
            l = new g_(n, o);
          await l.load();
          const h = new Le(l, {
            alphaMode: await ZL(),
            resolution: vs(r),
            ...(e == null ? void 0 : e.data),
          });
          (h.resource.src = r),
            (i = xl(h, t, r)),
            i.baseTexture.once("destroyed", () => {
              URL.revokeObjectURL(n);
            });
        } catch (o) {
          throw (URL.revokeObjectURL(n), o);
        }
        return i;
      },
      unload(r) {
        r.destroy(!0);
      },
    };
  Ce.add(X8);
  class z8 {
    constructor() {
      (this._defaultBundleIdentifierOptions = {
        connector: "-",
        createBundleAssetId: (e, t) => `${e}${this._bundleIdConnector}${t}`,
        extractAssetIdFromBundle: (e, t) =>
          t.replace(`${e}${this._bundleIdConnector}`, ""),
      }),
        (this._bundleIdConnector =
          this._defaultBundleIdentifierOptions.connector),
        (this._createBundleAssetId =
          this._defaultBundleIdentifierOptions.createBundleAssetId),
        (this._extractAssetIdFromBundle =
          this._defaultBundleIdentifierOptions.extractAssetIdFromBundle),
        (this._assetMap = {}),
        (this._preferredOrder = []),
        (this._parsers = []),
        (this._resolverHash = {}),
        (this._bundles = {});
    }
    setBundleIdentifier(e) {
      if (
        ((this._bundleIdConnector = e.connector ?? this._bundleIdConnector),
        (this._createBundleAssetId =
          e.createBundleAssetId ?? this._createBundleAssetId),
        (this._extractAssetIdFromBundle =
          e.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle),
        this._extractAssetIdFromBundle(
          "foo",
          this._createBundleAssetId("foo", "bar")
        ) !== "bar")
      )
        throw new Error(
          "[Resolver] GenerateBundleAssetId are not working correctly"
        );
    }
    prefer(...e) {
      e.forEach((t) => {
        this._preferredOrder.push(t),
          t.priority || (t.priority = Object.keys(t.params));
      }),
        (this._resolverHash = {});
    }
    set basePath(e) {
      this._basePath = e;
    }
    get basePath() {
      return this._basePath;
    }
    set rootPath(e) {
      this._rootPath = e;
    }
    get rootPath() {
      return this._rootPath;
    }
    get parsers() {
      return this._parsers;
    }
    reset() {
      this.setBundleIdentifier(this._defaultBundleIdentifierOptions),
        (this._assetMap = {}),
        (this._preferredOrder = []),
        (this._resolverHash = {}),
        (this._rootPath = null),
        (this._basePath = null),
        (this._manifest = null),
        (this._bundles = {}),
        (this._defaultSearchParams = null);
    }
    setDefaultSearchParams(e) {
      if (typeof e == "string") this._defaultSearchParams = e;
      else {
        const t = e;
        this._defaultSearchParams = Object.keys(t)
          .map((i) => `${encodeURIComponent(i)}=${encodeURIComponent(t[i])}`)
          .join("&");
      }
    }
    getAlias(e) {
      const { alias: t, name: i, src: s, srcs: n } = e;
      return si(
        t || i || s || n,
        (a) =>
          typeof a == "string"
            ? a
            : Array.isArray(a)
            ? a.map(
                (o) =>
                  (o == null ? void 0 : o.src) ??
                  (o == null ? void 0 : o.srcs) ??
                  o
              )
            : (a != null && a.src) || (a != null && a.srcs)
            ? a.src ?? a.srcs
            : a,
        !0
      );
    }
    addManifest(e) {
      this._manifest &&
        console.warn(
          "[Resolver] Manifest already exists, this will be overwritten"
        ),
        (this._manifest = e),
        e.bundles.forEach((t) => {
          this.addBundle(t.name, t.assets);
        });
    }
    addBundle(e, t) {
      const i = [];
      Array.isArray(t)
        ? t.forEach((s) => {
            const n = s.src ?? s.srcs,
              a = s.alias ?? s.name;
            let o;
            if (typeof a == "string") {
              const l = this._createBundleAssetId(e, a);
              i.push(l), (o = [a, l]);
            } else {
              const l = a.map((h) => this._createBundleAssetId(e, h));
              i.push(...l), (o = [...a, ...l]);
            }
            this.add({ ...s, alias: o, src: n });
          })
        : Object.keys(t).forEach((s) => {
            const n = [s, this._createBundleAssetId(e, s)];
            if (typeof t[s] == "string") this.add({ alias: n, src: t[s] });
            else if (Array.isArray(t[s])) this.add({ alias: n, src: t[s] });
            else {
              const a = t[s],
                o = a.src ?? a.srcs;
              this.add({ ...a, alias: n, src: Array.isArray(o) ? o : [o] });
            }
            i.push(...n);
          }),
        (this._bundles[e] = i);
    }
    add(e, t, i, s, n) {
      const a = [];
      typeof e == "string" || (Array.isArray(e) && typeof e[0] == "string")
        ? (We(
            "7.2.0",
            `Assets.add now uses an object instead of individual parameters.
Please use Assets.add({ alias, src, data, format, loadParser }) instead.`
          ),
          a.push({ alias: e, src: t, data: i, format: s, loadParser: n }))
        : Array.isArray(e)
        ? a.push(...e)
        : a.push(e);
      let o;
      (o = (l) => {
        this.hasKey(l) &&
          console.warn(`[Resolver] already has key: ${l} overwriting`);
      }),
        si(a).forEach((l) => {
          const { src: h, srcs: c } = l;
          let { data: u, format: d, loadParser: f } = l;
          const p = si(h || c).map((g) =>
              typeof g == "string" ? g8(g) : Array.isArray(g) ? g : [g]
            ),
            m = this.getAlias(l);
          Array.isArray(m) ? m.forEach(o) : o(m);
          const v = [];
          p.forEach((g) => {
            g.forEach((x) => {
              let b = {};
              if (typeof x != "object") {
                b.src = x;
                for (let y = 0; y < this._parsers.length; y++) {
                  const _ = this._parsers[y];
                  if (_.test(x)) {
                    b = _.parse(x);
                    break;
                  }
                }
              } else
                (u = x.data ?? u),
                  (d = x.format ?? d),
                  (f = x.loadParser ?? f),
                  (b = { ...b, ...x });
              if (!m)
                throw new Error(
                  `[Resolver] alias is undefined for this asset: ${b.src}`
                );
              (b = this.buildResolvedAsset(b, {
                aliases: m,
                data: u,
                format: d,
                loadParser: f,
              })),
                v.push(b);
            });
          }),
            m.forEach((g) => {
              this._assetMap[g] = v;
            });
        });
    }
    resolveBundle(e) {
      const t = Jh(e);
      e = si(e);
      const i = {};
      return (
        e.forEach((s) => {
          const n = this._bundles[s];
          if (n) {
            const a = this.resolve(n),
              o = {};
            for (const l in a) {
              const h = a[l];
              o[this._extractAssetIdFromBundle(s, l)] = h;
            }
            i[s] = o;
          }
        }),
        t ? i[e[0]] : i
      );
    }
    resolveUrl(e) {
      const t = this.resolve(e);
      if (typeof e != "string") {
        const i = {};
        for (const s in t) i[s] = t[s].src;
        return i;
      }
      return t.src;
    }
    resolve(e) {
      const t = Jh(e);
      e = si(e);
      const i = {};
      return (
        e.forEach((s) => {
          if (!this._resolverHash[s])
            if (this._assetMap[s]) {
              let n = this._assetMap[s];
              const a = n[0],
                o = this._getPreferredOrder(n);
              o == null ||
                o.priority.forEach((l) => {
                  o.params[l].forEach((h) => {
                    const c = n.filter((u) => (u[l] ? u[l] === h : !1));
                    c.length && (n = c);
                  });
                }),
                (this._resolverHash[s] = n[0] ?? a);
            } else
              this._resolverHash[s] = this.buildResolvedAsset(
                { alias: [s], src: s },
                {}
              );
          i[s] = this._resolverHash[s];
        }),
        t ? i[e[0]] : i
      );
    }
    hasKey(e) {
      return !!this._assetMap[e];
    }
    hasBundle(e) {
      return !!this._bundles[e];
    }
    _getPreferredOrder(e) {
      for (let t = 0; t < e.length; t++) {
        const i = e[0],
          s = this._preferredOrder.find((n) =>
            n.params.format.includes(i.format)
          );
        if (s) return s;
      }
      return this._preferredOrder[0];
    }
    _appendDefaultSearchParams(e) {
      if (!this._defaultSearchParams) return e;
      const t = /\?/.test(e) ? "&" : "?";
      return `${e}${t}${this._defaultSearchParams}`;
    }
    buildResolvedAsset(e, t) {
      const { aliases: i, data: s, loadParser: n, format: a } = t;
      return (
        (this._basePath || this._rootPath) &&
          (e.src = Pt.toAbsolute(e.src, this._basePath, this._rootPath)),
        (e.alias = i ?? e.alias ?? [e.src]),
        (e.src = this._appendDefaultSearchParams(e.src)),
        (e.data = { ...(s || {}), ...e.data }),
        (e.loadParser = n ?? e.loadParser),
        (e.format = a ?? e.format ?? Pt.extname(e.src).slice(1)),
        (e.srcs = e.src),
        (e.name = e.alias),
        e
      );
    }
  }
  class W8 {
    constructor() {
      (this._detections = []),
        (this._initialized = !1),
        (this.resolver = new z8()),
        (this.loader = new y8()),
        (this.cache = vn),
        (this._backgroundLoader = new m8(this.loader)),
        (this._backgroundLoader.active = !0),
        this.reset();
    }
    async init(e = {}) {
      var n, a;
      if (this._initialized) {
        console.warn(
          "[Assets]AssetManager already initialized, did you load before calling this Assets.init()?"
        );
        return;
      }
      if (
        ((this._initialized = !0),
        e.defaultSearchParams &&
          this.resolver.setDefaultSearchParams(e.defaultSearchParams),
        e.basePath && (this.resolver.basePath = e.basePath),
        e.bundleIdentifier &&
          this.resolver.setBundleIdentifier(e.bundleIdentifier),
        e.manifest)
      ) {
        let o = e.manifest;
        typeof o == "string" && (o = await this.load(o)),
          this.resolver.addManifest(o);
      }
      const t =
          ((n = e.texturePreference) == null ? void 0 : n.resolution) ?? 1,
        i = typeof t == "number" ? [t] : t,
        s = await this._detectFormats({
          preferredFormats:
            (a = e.texturePreference) == null ? void 0 : a.format,
          skipDetections: e.skipDetections,
          detections: this._detections,
        });
      this.resolver.prefer({ params: { format: s, resolution: i } }),
        e.preferences && this.setPreferences(e.preferences);
    }
    add(e, t, i, s, n) {
      this.resolver.add(e, t, i, s, n);
    }
    async load(e, t) {
      this._initialized || (await this.init());
      const i = Jh(e),
        s = si(e).map((o) => {
          if (typeof o != "string") {
            const l = this.resolver.getAlias(o);
            return (
              l.some((h) => !this.resolver.hasKey(h)) && this.add(o),
              Array.isArray(l) ? l[0] : l
            );
          }
          return this.resolver.hasKey(o) || this.add({ alias: o, src: o }), o;
        }),
        n = this.resolver.resolve(s),
        a = await this._mapLoadToResolve(n, t);
      return i ? a[s[0]] : a;
    }
    addBundle(e, t) {
      this.resolver.addBundle(e, t);
    }
    async loadBundle(e, t) {
      this._initialized || (await this.init());
      let i = !1;
      typeof e == "string" && ((i = !0), (e = [e]));
      const s = this.resolver.resolveBundle(e),
        n = {},
        a = Object.keys(s);
      let o = 0,
        l = 0;
      const h = () => {
          t == null || t(++o / l);
        },
        c = a.map((u) => {
          const d = s[u];
          return (
            (l += Object.keys(d).length),
            this._mapLoadToResolve(d, h).then((f) => {
              n[u] = f;
            })
          );
        });
      return await Promise.all(c), i ? n[e[0]] : n;
    }
    async backgroundLoad(e) {
      this._initialized || (await this.init()),
        typeof e == "string" && (e = [e]);
      const t = this.resolver.resolve(e);
      this._backgroundLoader.add(Object.values(t));
    }
    async backgroundLoadBundle(e) {
      this._initialized || (await this.init()),
        typeof e == "string" && (e = [e]);
      const t = this.resolver.resolveBundle(e);
      Object.values(t).forEach((i) => {
        this._backgroundLoader.add(Object.values(i));
      });
    }
    reset() {
      this.resolver.reset(),
        this.loader.reset(),
        this.cache.reset(),
        (this._initialized = !1);
    }
    get(e) {
      if (typeof e == "string") return vn.get(e);
      const t = {};
      for (let i = 0; i < e.length; i++) t[i] = vn.get(e[i]);
      return t;
    }
    async _mapLoadToResolve(e, t) {
      const i = Object.values(e),
        s = Object.keys(e);
      this._backgroundLoader.active = !1;
      const n = await this.loader.load(i, t);
      this._backgroundLoader.active = !0;
      const a = {};
      return (
        i.forEach((o, l) => {
          const h = n[o.src],
            c = [o.src];
          o.alias && c.push(...o.alias), (a[s[l]] = h), vn.set(c, h);
        }),
        a
      );
    }
    async unload(e) {
      this._initialized || (await this.init());
      const t = si(e).map((s) => (typeof s != "string" ? s.src : s)),
        i = this.resolver.resolve(t);
      await this._unloadFromResolved(i);
    }
    async unloadBundle(e) {
      this._initialized || (await this.init()), (e = si(e));
      const t = this.resolver.resolveBundle(e),
        i = Object.keys(t).map((s) => this._unloadFromResolved(t[s]));
      await Promise.all(i);
    }
    async _unloadFromResolved(e) {
      const t = Object.values(e);
      t.forEach((i) => {
        vn.remove(i.src);
      }),
        await this.loader.unload(t);
    }
    async _detectFormats(e) {
      let t = [];
      e.preferredFormats &&
        (t = Array.isArray(e.preferredFormats)
          ? e.preferredFormats
          : [e.preferredFormats]);
      for (const i of e.detections)
        e.skipDetections || (await i.test())
          ? (t = await i.add(t))
          : e.skipDetections || (t = await i.remove(t));
      return (t = t.filter((i, s) => t.indexOf(i) === s)), t;
    }
    get detections() {
      return this._detections;
    }
    get preferWorkers() {
      return Hc.config.preferWorkers;
    }
    set preferWorkers(e) {
      We(
        "7.2.0",
        "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead."
      ),
        this.setPreferences({ preferWorkers: e });
    }
    setPreferences(e) {
      this.loader.parsers.forEach((t) => {
        t.config &&
          Object.keys(t.config)
            .filter((i) => i in e)
            .forEach((i) => {
              t.config[i] = e[i];
            });
      });
    }
  }
  const oi = new W8();
  Ce.handleByList(me.LoadParser, oi.loader.parsers)
    .handleByList(me.ResolveParser, oi.resolver.parsers)
    .handleByList(me.CacheParser, oi.cache.parsers)
    .handleByList(me.DetectionParser, oi.detections);
  const Y8 = {
    extension: me.CacheParser,
    test: (r) => Array.isArray(r) && r.every((e) => e instanceof ze),
    getCacheableAssets: (r, e) => {
      const t = {};
      return (
        r.forEach((i) => {
          e.forEach((s, n) => {
            t[i + (n === 0 ? "" : n + 1)] = s;
          });
        }),
        t
      );
    },
  };
  Ce.add(Y8);
  async function S_(r) {
    if ("Image" in globalThis)
      return new Promise((e) => {
        const t = new Image();
        (t.onload = () => {
          e(!0);
        }),
          (t.onerror = () => {
            e(!1);
          }),
          (t.src = r);
      });
    if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
      try {
        const e = await (await fetch(r)).blob();
        await createImageBitmap(e);
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  }
  const j8 = {
    extension: { type: me.DetectionParser, priority: 1 },
    test: async () =>
      S_(
        "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
      ),
    add: async (r) => [...r, "avif"],
    remove: async (r) => r.filter((e) => e !== "avif"),
  };
  Ce.add(j8);
  const q8 = {
    extension: { type: me.DetectionParser, priority: 0 },
    test: async () =>
      S_(
        "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
      ),
    add: async (r) => [...r, "webp"],
    remove: async (r) => r.filter((e) => e !== "webp"),
  };
  Ce.add(q8);
  const Xv = ["png", "jpg", "jpeg"],
    K8 = {
      extension: { type: me.DetectionParser, priority: -1 },
      test: () => Promise.resolve(!0),
      add: async (r) => [...r, ...Xv],
      remove: async (r) => r.filter((e) => !Xv.includes(e)),
    };
  Ce.add(K8);
  const Z8 =
    "WorkerGlobalScope" in globalThis &&
    globalThis instanceof globalThis.WorkerGlobalScope;
  function am(r) {
    return Z8 ? !1 : document.createElement("video").canPlayType(r) !== "";
  }
  const J8 = {
    extension: { type: me.DetectionParser, priority: 0 },
    test: async () => am("video/webm"),
    add: async (r) => [...r, "webm"],
    remove: async (r) => r.filter((e) => e !== "webm"),
  };
  Ce.add(J8);
  const Q8 = {
    extension: { type: me.DetectionParser, priority: 0 },
    test: async () => am("video/mp4"),
    add: async (r) => [...r, "mp4", "m4v"],
    remove: async (r) => r.filter((e) => e !== "mp4" && e !== "m4v"),
  };
  Ce.add(Q8);
  const e6 = {
    extension: { type: me.DetectionParser, priority: 0 },
    test: async () => am("video/ogg"),
    add: async (r) => [...r, "ogv"],
    remove: async (r) => r.filter((e) => e !== "ogv"),
  };
  Ce.add(e6);
  const t6 = {
    extension: me.ResolveParser,
    test: Hc.test,
    parse: (r) => {
      var e;
      return {
        resolution: parseFloat(
          ((e = we.RETINA_PREFIX.exec(r)) == null ? void 0 : e[1]) ?? "1"
        ),
        format: Pt.extname(r).slice(1),
        src: r,
      };
    },
  };
  Ce.add(t6);
  var Yt = ((r) => (
    (r[(r.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776)] =
      "COMPRESSED_RGB_S3TC_DXT1_EXT"),
    (r[(r.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777)] =
      "COMPRESSED_RGBA_S3TC_DXT1_EXT"),
    (r[(r.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778)] =
      "COMPRESSED_RGBA_S3TC_DXT3_EXT"),
    (r[(r.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779)] =
      "COMPRESSED_RGBA_S3TC_DXT5_EXT"),
    (r[(r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917)] =
      "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"),
    (r[(r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918)] =
      "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"),
    (r[(r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919)] =
      "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"),
    (r[(r.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916)] =
      "COMPRESSED_SRGB_S3TC_DXT1_EXT"),
    (r[(r.COMPRESSED_R11_EAC = 37488)] = "COMPRESSED_R11_EAC"),
    (r[(r.COMPRESSED_SIGNED_R11_EAC = 37489)] = "COMPRESSED_SIGNED_R11_EAC"),
    (r[(r.COMPRESSED_RG11_EAC = 37490)] = "COMPRESSED_RG11_EAC"),
    (r[(r.COMPRESSED_SIGNED_RG11_EAC = 37491)] = "COMPRESSED_SIGNED_RG11_EAC"),
    (r[(r.COMPRESSED_RGB8_ETC2 = 37492)] = "COMPRESSED_RGB8_ETC2"),
    (r[(r.COMPRESSED_RGBA8_ETC2_EAC = 37496)] = "COMPRESSED_RGBA8_ETC2_EAC"),
    (r[(r.COMPRESSED_SRGB8_ETC2 = 37493)] = "COMPRESSED_SRGB8_ETC2"),
    (r[(r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497)] =
      "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"),
    (r[(r.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494)] =
      "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"),
    (r[(r.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495)] =
      "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"),
    (r[(r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840)] =
      "COMPRESSED_RGB_PVRTC_4BPPV1_IMG"),
    (r[(r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842)] =
      "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"),
    (r[(r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841)] =
      "COMPRESSED_RGB_PVRTC_2BPPV1_IMG"),
    (r[(r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843)] =
      "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"),
    (r[(r.COMPRESSED_RGB_ETC1_WEBGL = 36196)] = "COMPRESSED_RGB_ETC1_WEBGL"),
    (r[(r.COMPRESSED_RGB_ATC_WEBGL = 35986)] = "COMPRESSED_RGB_ATC_WEBGL"),
    (r[(r.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35987)] =
      "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"),
    (r[(r.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798)] =
      "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"),
    (r[(r.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808)] =
      "COMPRESSED_RGBA_ASTC_4x4_KHR"),
    (r[(r.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492)] =
      "COMPRESSED_RGBA_BPTC_UNORM_EXT"),
    (r[(r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493)] =
      "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT"),
    (r[(r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494)] =
      "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT"),
    (r[(r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495)] =
      "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT"),
    r
  ))(Yt || {});
  const Qh = {
    33776: 0.5,
    33777: 0.5,
    33778: 1,
    33779: 1,
    35916: 0.5,
    35917: 0.5,
    35918: 1,
    35919: 1,
    37488: 0.5,
    37489: 0.5,
    37490: 1,
    37491: 1,
    37492: 0.5,
    37496: 1,
    37493: 0.5,
    37497: 1,
    37494: 0.5,
    37495: 0.5,
    35840: 0.5,
    35842: 0.5,
    35841: 0.25,
    35843: 0.25,
    36196: 0.5,
    35986: 0.5,
    35987: 1,
    34798: 1,
    37808: 1,
    36492: 1,
    36493: 1,
    36494: 1,
    36495: 1,
  };
  let Ai, na;
  function zv() {
    na = {
      bptc: Ai.getExtension("EXT_texture_compression_bptc"),
      astc: Ai.getExtension("WEBGL_compressed_texture_astc"),
      etc: Ai.getExtension("WEBGL_compressed_texture_etc"),
      s3tc: Ai.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: Ai.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      pvrtc:
        Ai.getExtension("WEBGL_compressed_texture_pvrtc") ||
        Ai.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      etc1: Ai.getExtension("WEBGL_compressed_texture_etc1"),
      atc: Ai.getExtension("WEBGL_compressed_texture_atc"),
    };
  }
  const r6 = {
    extension: { type: me.DetectionParser, priority: 2 },
    test: async () => {
      const r = we.ADAPTER.createCanvas().getContext("webgl");
      return r
        ? ((Ai = r), !0)
        : (console.warn("WebGL not available for compressed textures."), !1);
    },
    add: async (r) => {
      na || zv();
      const e = [];
      for (const t in na) na[t] && e.push(t);
      return [...e, ...r];
    },
    remove: async (r) => (na || zv(), r.filter((e) => !(e in na))),
  };
  Ce.add(r6);
  class i6 extends Nc {
    constructor(e, t = { width: 1, height: 1, autoLoad: !0 }) {
      let i, s;
      typeof e == "string"
        ? ((i = e), (s = new Uint8Array()))
        : ((i = null), (s = e)),
        super(s, t),
        (this.origin = i),
        (this.buffer = s ? new sf(s) : null),
        (this._load = null),
        (this.loaded = !1),
        this.origin !== null && t.autoLoad !== !1 && this.load(),
        this.origin === null &&
          this.buffer &&
          ((this._load = Promise.resolve(this)),
          (this.loaded = !0),
          this.onBlobLoaded(this.buffer.rawBinaryData));
    }
    onBlobLoaded(e) {}
    load() {
      return this._load
        ? this._load
        : ((this._load = fetch(this.origin)
            .then((e) => e.blob())
            .then((e) => e.arrayBuffer())
            .then(
              (e) => (
                (this.data = new Uint32Array(e)),
                (this.buffer = new sf(e)),
                (this.loaded = !0),
                this.onBlobLoaded(e),
                this.update(),
                this
              )
            )),
          this._load);
    }
  }
  class An extends i6 {
    constructor(e, t) {
      super(e, t),
        (this.format = t.format),
        (this.levels = t.levels || 1),
        (this._width = t.width),
        (this._height = t.height),
        (this._extension = An._formatToExtension(this.format)),
        (t.levelBuffers || this.buffer) &&
          (this._levelBuffers =
            t.levelBuffers ||
            An._createLevelBuffers(
              e instanceof Uint8Array ? e : this.buffer.uint8View,
              this.format,
              this.levels,
              4,
              4,
              this.width,
              this.height
            ));
    }
    upload(e, t, i) {
      const s = e.gl;
      if (!e.context.extensions[this._extension])
        throw new Error(
          `${this._extension} textures are not supported on the current machine`
        );
      if (!this._levelBuffers) return !1;
      s.pixelStorei(s.UNPACK_ALIGNMENT, 4);
      for (let n = 0, a = this.levels; n < a; n++) {
        const {
          levelID: o,
          levelWidth: l,
          levelHeight: h,
          levelBuffer: c,
        } = this._levelBuffers[n];
        s.compressedTexImage2D(s.TEXTURE_2D, o, this.format, l, h, 0, c);
      }
      return !0;
    }
    onBlobLoaded() {
      this._levelBuffers = An._createLevelBuffers(
        this.buffer.uint8View,
        this.format,
        this.levels,
        4,
        4,
        this.width,
        this.height
      );
    }
    static _formatToExtension(e) {
      if (e >= 33776 && e <= 33779) return "s3tc";
      if (e >= 35916 && e <= 35919) return "s3tc_sRGB";
      if (e >= 37488 && e <= 37497) return "etc";
      if (e >= 35840 && e <= 35843) return "pvrtc";
      if (e === 36196) return "etc1";
      if (e === 35986 || e === 35987 || e === 34798) return "atc";
      if (e >= 36492 && e <= 36495) return "bptc";
      if (e === 37808) return "astc";
      throw new Error(`Invalid (compressed) texture format given: ${e}`);
    }
    static _createLevelBuffers(e, t, i, s, n, a, o) {
      const l = new Array(i);
      let h = e.byteOffset,
        c = a,
        u = o,
        d = (c + s - 1) & ~(s - 1),
        f = (u + n - 1) & ~(n - 1),
        p = d * f * Qh[t];
      for (let m = 0; m < i; m++)
        (l[m] = {
          levelID: m,
          levelWidth: i > 1 ? c : d,
          levelHeight: i > 1 ? u : f,
          levelBuffer: new Uint8Array(e.buffer, h, p),
        }),
          (h += p),
          (c = c >> 1 || 1),
          (u = u >> 1 || 1),
          (d = (c + s - 1) & ~(s - 1)),
          (f = (u + n - 1) & ~(n - 1)),
          (p = d * f * Qh[t]);
      return l;
    }
  }
  const Qu = 4,
    eh = 124,
    s6 = 32,
    Wv = 20,
    n6 = 542327876,
    th = {
      SIZE: 1,
      FLAGS: 2,
      HEIGHT: 3,
      WIDTH: 4,
      MIPMAP_COUNT: 7,
      PIXEL_FORMAT: 19,
    },
    a6 = {
      SIZE: 0,
      FLAGS: 1,
      FOURCC: 2,
      RGB_BITCOUNT: 3,
      R_BIT_MASK: 4,
      G_BIT_MASK: 5,
      B_BIT_MASK: 6,
      A_BIT_MASK: 7,
    },
    rh = {
      DXGI_FORMAT: 0,
      RESOURCE_DIMENSION: 1,
      MISC_FLAG: 2,
      ARRAY_SIZE: 3,
      MISC_FLAGS2: 4,
    },
    o6 = 1,
    l6 = 2,
    h6 = 4,
    c6 = 64,
    u6 = 512,
    d6 = 131072,
    f6 = 827611204,
    p6 = 861165636,
    m6 = 894720068,
    g6 = 808540228,
    v6 = 4,
    y6 = {
      [f6]: Yt.COMPRESSED_RGBA_S3TC_DXT1_EXT,
      [p6]: Yt.COMPRESSED_RGBA_S3TC_DXT3_EXT,
      [m6]: Yt.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    },
    b6 = {
      70: Yt.COMPRESSED_RGBA_S3TC_DXT1_EXT,
      71: Yt.COMPRESSED_RGBA_S3TC_DXT1_EXT,
      73: Yt.COMPRESSED_RGBA_S3TC_DXT3_EXT,
      74: Yt.COMPRESSED_RGBA_S3TC_DXT3_EXT,
      76: Yt.COMPRESSED_RGBA_S3TC_DXT5_EXT,
      77: Yt.COMPRESSED_RGBA_S3TC_DXT5_EXT,
      72: Yt.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
      75: Yt.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
      78: Yt.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
      96: Yt.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
      95: Yt.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
      98: Yt.COMPRESSED_RGBA_BPTC_UNORM_EXT,
      99: Yt.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT,
    };
  function x6(r) {
    const e = new Uint32Array(r);
    if (e[0] !== n6) throw new Error("Invalid DDS file magic word");
    const t = new Uint32Array(r, 0, eh / Uint32Array.BYTES_PER_ELEMENT),
      i = t[th.HEIGHT],
      s = t[th.WIDTH],
      n = t[th.MIPMAP_COUNT],
      a = new Uint32Array(
        r,
        th.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT,
        s6 / Uint32Array.BYTES_PER_ELEMENT
      ),
      o = a[o6];
    if (o & h6) {
      const l = a[a6.FOURCC];
      if (l !== g6) {
        const x = y6[l],
          b = Qu + eh,
          y = new Uint8Array(r, b);
        return [new An(y, { format: x, width: s, height: i, levels: n })];
      }
      const h = Qu + eh,
        c = new Uint32Array(e.buffer, h, Wv / Uint32Array.BYTES_PER_ELEMENT),
        u = c[rh.DXGI_FORMAT],
        d = c[rh.RESOURCE_DIMENSION],
        f = c[rh.MISC_FLAG],
        p = c[rh.ARRAY_SIZE],
        m = b6[u];
      if (m === void 0)
        throw new Error(
          `DDSParser cannot parse texture data with DXGI format ${u}`
        );
      if (f === v6)
        throw new Error("DDSParser does not support cubemap textures");
      if (d === 6)
        throw new Error("DDSParser does not supported 3D texture data");
      const v = new Array(),
        g = Qu + eh + Wv;
      if (p === 1) v.push(new Uint8Array(r, g));
      else {
        const x = Qh[m];
        let b = 0,
          y = s,
          _ = i;
        for (let E = 0; E < n; E++) {
          const A = Math.max(1, (y + 3) & -4),
            C = Math.max(1, (_ + 3) & -4),
            F = A * C * x;
          (b += F), (y = y >>> 1), (_ = _ >>> 1);
        }
        let w = g;
        for (let E = 0; E < p; E++) v.push(new Uint8Array(r, w, b)), (w += b);
      }
      return v.map(
        (x) => new An(x, { format: m, width: s, height: i, levels: n })
      );
    }
    throw o & c6
      ? new Error("DDSParser does not support uncompressed texture data.")
      : o & u6
      ? new Error("DDSParser does not supported YUV uncompressed texture data.")
      : o & d6
      ? new Error(
          "DDSParser does not support single-channel (lumninance) texture data!"
        )
      : o & l6
      ? new Error(
          "DDSParser does not support single-channel (alpha) texture data!"
        )
      : new Error(
          "DDSParser failed to load a texture file due to an unknown reason!"
        );
  }
  const Yv = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10],
    _6 = 67305985,
    Jr = {
      FILE_IDENTIFIER: 0,
      ENDIANNESS: 12,
      GL_TYPE: 16,
      GL_TYPE_SIZE: 20,
      GL_FORMAT: 24,
      GL_INTERNAL_FORMAT: 28,
      GL_BASE_INTERNAL_FORMAT: 32,
      PIXEL_WIDTH: 36,
      PIXEL_HEIGHT: 40,
      PIXEL_DEPTH: 44,
      NUMBER_OF_ARRAY_ELEMENTS: 48,
      NUMBER_OF_FACES: 52,
      NUMBER_OF_MIPMAP_LEVELS: 56,
      BYTES_OF_KEY_VALUE_DATA: 60,
    },
    Pf = 64,
    jv = {
      [Ae.UNSIGNED_BYTE]: 1,
      [Ae.UNSIGNED_SHORT]: 2,
      [Ae.INT]: 4,
      [Ae.UNSIGNED_INT]: 4,
      [Ae.FLOAT]: 4,
      [Ae.HALF_FLOAT]: 8,
    },
    w6 = {
      [le.RGBA]: 4,
      [le.RGB]: 3,
      [le.RG]: 2,
      [le.RED]: 1,
      [le.LUMINANCE]: 1,
      [le.LUMINANCE_ALPHA]: 2,
      [le.ALPHA]: 1,
    },
    T6 = {
      [Ae.UNSIGNED_SHORT_4_4_4_4]: 2,
      [Ae.UNSIGNED_SHORT_5_5_5_1]: 2,
      [Ae.UNSIGNED_SHORT_5_6_5]: 2,
    };
  function E6(r, e, t = !1) {
    const i = new DataView(e);
    if (!S6(r, i)) return null;
    const s = i.getUint32(Jr.ENDIANNESS, !0) === _6,
      n = i.getUint32(Jr.GL_TYPE, s),
      a = i.getUint32(Jr.GL_FORMAT, s),
      o = i.getUint32(Jr.GL_INTERNAL_FORMAT, s),
      l = i.getUint32(Jr.PIXEL_WIDTH, s),
      h = i.getUint32(Jr.PIXEL_HEIGHT, s) || 1,
      c = i.getUint32(Jr.PIXEL_DEPTH, s) || 1,
      u = i.getUint32(Jr.NUMBER_OF_ARRAY_ELEMENTS, s) || 1,
      d = i.getUint32(Jr.NUMBER_OF_FACES, s),
      f = i.getUint32(Jr.NUMBER_OF_MIPMAP_LEVELS, s),
      p = i.getUint32(Jr.BYTES_OF_KEY_VALUE_DATA, s);
    if (h === 0 || c !== 1) throw new Error("Only 2D textures are supported");
    if (d !== 1)
      throw new Error("CubeTextures are not supported by KTXLoader yet!");
    if (u !== 1) throw new Error("WebGL does not support array textures");
    const m = 4,
      v = 4,
      g = (l + 3) & -4,
      x = (h + 3) & -4,
      b = new Array(u);
    let y = l * h;
    n === 0 && (y = g * x);
    let _;
    if (
      (n !== 0 ? (jv[n] ? (_ = jv[n] * w6[a]) : (_ = T6[n])) : (_ = Qh[o]),
      _ === void 0)
    )
      throw new Error(
        "Unable to resolve the pixel format stored in the *.ktx file!"
      );
    const w = t ? C6(i, p, s) : null;
    let E = y * _,
      A = l,
      C = h,
      F = g,
      B = x,
      R = Pf + p;
    for (let I = 0; I < f; I++) {
      const P = i.getUint32(R, s);
      let M = R + 4;
      for (let L = 0; L < u; L++) {
        let U = b[L];
        U || (U = b[L] = new Array(f)),
          (U[I] = {
            levelID: I,
            levelWidth: f > 1 || n !== 0 ? A : F,
            levelHeight: f > 1 || n !== 0 ? C : B,
            levelBuffer: new Uint8Array(e, M, E),
          }),
          (M += E);
      }
      (R += P + 4),
        (R = R % 4 !== 0 ? R + 4 - (R % 4) : R),
        (A = A >> 1 || 1),
        (C = C >> 1 || 1),
        (F = (A + m - 1) & ~(m - 1)),
        (B = (C + v - 1) & ~(v - 1)),
        (E = F * B * _);
    }
    return n !== 0
      ? {
          uncompressed: b.map((I) => {
            let P = I[0].levelBuffer,
              M = !1;
            return (
              n === Ae.FLOAT
                ? (P = new Float32Array(
                    I[0].levelBuffer.buffer,
                    I[0].levelBuffer.byteOffset,
                    I[0].levelBuffer.byteLength / 4
                  ))
                : n === Ae.UNSIGNED_INT
                ? ((M = !0),
                  (P = new Uint32Array(
                    I[0].levelBuffer.buffer,
                    I[0].levelBuffer.byteOffset,
                    I[0].levelBuffer.byteLength / 4
                  )))
                : n === Ae.INT &&
                  ((M = !0),
                  (P = new Int32Array(
                    I[0].levelBuffer.buffer,
                    I[0].levelBuffer.byteOffset,
                    I[0].levelBuffer.byteLength / 4
                  ))),
              {
                resource: new Nc(P, {
                  width: I[0].levelWidth,
                  height: I[0].levelHeight,
                }),
                type: n,
                format: M ? A6(a) : a,
              }
            );
          }),
          kvData: w,
        }
      : {
          compressed: b.map(
            (I) =>
              new An(null, {
                format: o,
                width: l,
                height: h,
                levels: f,
                levelBuffers: I,
              })
          ),
          kvData: w,
        };
  }
  function S6(r, e) {
    for (let t = 0; t < Yv.length; t++)
      if (e.getUint8(t) !== Yv[t])
        return console.error(`${r} is not a valid *.ktx file!`), !1;
    return !0;
  }
  function A6(r) {
    switch (r) {
      case le.RGBA:
        return le.RGBA_INTEGER;
      case le.RGB:
        return le.RGB_INTEGER;
      case le.RG:
        return le.RG_INTEGER;
      case le.RED:
        return le.RED_INTEGER;
      default:
        return r;
    }
  }
  function C6(r, e, t) {
    const i = new Map();
    let s = 0;
    for (; s < e; ) {
      const n = r.getUint32(Pf + s, t),
        a = Pf + s + 4,
        o = 3 - ((n + 3) % 4);
      if (n === 0 || n > e - s) {
        console.error("KTXLoader: keyAndValueByteSize out of bounds");
        break;
      }
      let l = 0;
      for (; l < n && r.getUint8(a + l) !== 0; l++);
      if (l === -1) {
        console.error(
          "KTXLoader: Failed to find null byte terminating kvData key"
        );
        break;
      }
      const h = new TextDecoder().decode(new Uint8Array(r.buffer, a, l)),
        c = new DataView(r.buffer, a + l + 1, n - l - 1);
      i.set(h, c), (s += 4 + n + o);
    }
    return i;
  }
  const I6 = {
    extension: { type: me.LoadParser, priority: kr.High },
    name: "loadDDS",
    test(r) {
      return xr(r, ".dds");
    },
    async load(r, e, t) {
      const i = await (await we.ADAPTER.fetch(r)).arrayBuffer(),
        s = x6(i).map((n) => {
          const a = new Le(n, {
            mipmap: Yr.OFF,
            alphaMode: sr.NO_PREMULTIPLIED_ALPHA,
            resolution: vs(r),
            ...e.data,
          });
          return xl(a, t, r);
        });
      return s.length === 1 ? s[0] : s;
    },
    unload(r) {
      Array.isArray(r) ? r.forEach((e) => e.destroy(!0)) : r.destroy(!0);
    },
  };
  Ce.add(I6);
  const P6 = {
    extension: { type: me.LoadParser, priority: kr.High },
    name: "loadKTX",
    test(r) {
      return xr(r, ".ktx");
    },
    async load(r, e, t) {
      const i = await (await we.ADAPTER.fetch(r)).arrayBuffer(),
        { compressed: s, uncompressed: n, kvData: a } = E6(r, i),
        o = s ?? n,
        l = {
          mipmap: Yr.OFF,
          alphaMode: sr.NO_PREMULTIPLIED_ALPHA,
          resolution: vs(r),
          ...e.data,
        },
        h = o.map((c) => {
          o === n && Object.assign(l, { type: c.type, format: c.format });
          const u = c.resource ?? c,
            d = new Le(u, l);
          return (d.ktxKeyValueData = a), xl(d, t, r);
        });
      return h.length === 1 ? h[0] : h;
    },
    unload(r) {
      Array.isArray(r) ? r.forEach((e) => e.destroy(!0)) : r.destroy(!0);
    },
  };
  Ce.add(P6);
  const R6 = [
      "s3tc",
      "s3tc_sRGB",
      "etc",
      "etc1",
      "pvrtc",
      "atc",
      "astc",
      "bptc",
    ],
    M6 = {
      extension: me.ResolveParser,
      test: (r) => {
        const e = Pt.extname(r).slice(1);
        return ["basis", "ktx", "dds"].includes(e);
      },
      parse: (r) => {
        var i, s;
        const e = r.split("."),
          t = e.pop();
        if (["ktx", "dds"].includes(t)) {
          const n = e.pop();
          if (R6.includes(n))
            return {
              resolution: parseFloat(
                ((i = we.RETINA_PREFIX.exec(r)) == null ? void 0 : i[1]) ?? "1"
              ),
              format: n,
              src: r,
            };
        }
        return {
          resolution: parseFloat(
            ((s = we.RETINA_PREFIX.exec(r)) == null ? void 0 : s[1]) ?? "1"
          ),
          format: t,
          src: r,
        };
      },
    };
  Ce.add(M6);
  const ih = new $e(),
    F6 = 4,
    A_ = class wo {
      constructor(e) {
        (this.renderer = e), (this._rendererPremultipliedAlpha = !1);
      }
      contextChange() {
        var t;
        const e =
          (t = this.renderer) == null ? void 0 : t.gl.getContextAttributes();
        this._rendererPremultipliedAlpha = !!(
          e &&
          e.alpha &&
          e.premultipliedAlpha
        );
      }
      async image(e, t, i, s) {
        const n = new Image();
        return (n.src = await this.base64(e, t, i, s)), n;
      }
      async base64(e, t, i, s) {
        const n = this.canvas(e, s);
        if (n.toBlob !== void 0)
          return new Promise((a, o) => {
            n.toBlob(
              (l) => {
                if (!l) {
                  o(new Error("ICanvas.toBlob failed!"));
                  return;
                }
                const h = new FileReader();
                (h.onload = () => a(h.result)),
                  (h.onerror = o),
                  h.readAsDataURL(l);
              },
              t,
              i
            );
          });
        if (n.toDataURL !== void 0) return n.toDataURL(t, i);
        if (n.convertToBlob !== void 0) {
          const a = await n.convertToBlob({ type: t, quality: i });
          return new Promise((o, l) => {
            const h = new FileReader();
            (h.onload = () => o(h.result)), (h.onerror = l), h.readAsDataURL(a);
          });
        }
        throw new Error(
          "Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented"
        );
      }
      canvas(e, t) {
        const {
          pixels: i,
          width: s,
          height: n,
          flipY: a,
          premultipliedAlpha: o,
        } = this._rawPixels(e, t);
        a && wo._flipY(i, s, n), o && wo._unpremultiplyAlpha(i);
        const l = new fN(s, n, 1),
          h = new ImageData(new Uint8ClampedArray(i.buffer), s, n);
        return l.context.putImageData(h, 0, 0), l.canvas;
      }
      pixels(e, t) {
        const {
          pixels: i,
          width: s,
          height: n,
          flipY: a,
          premultipliedAlpha: o,
        } = this._rawPixels(e, t);
        return a && wo._flipY(i, s, n), o && wo._unpremultiplyAlpha(i), i;
      }
      _rawPixels(e, t) {
        const i = this.renderer;
        if (!i) throw new Error("The Extract has already been destroyed");
        let s,
          n = !1,
          a = !1,
          o,
          l = !1;
        e &&
          (e instanceof Gn
            ? (o = e)
            : ((o = i.generateTexture(e, {
                region: t,
                resolution: i.resolution,
                multisample: i.multisample,
              })),
              (l = !0),
              t && ((ih.width = t.width), (ih.height = t.height), (t = ih))));
        const h = i.gl;
        if (o) {
          if (
            ((s = o.baseTexture.resolution),
            (t = t ?? o.frame),
            (n = !1),
            (a =
              o.baseTexture.alphaMode > 0 && o.baseTexture.format === le.RGBA),
            !l)
          ) {
            i.renderTexture.bind(o);
            const f = o.framebuffer.glFramebuffers[i.CONTEXT_UID];
            f.blitFramebuffer && i.framebuffer.bind(f.blitFramebuffer);
          }
        } else
          (s = i.resolution),
            t || ((t = ih), (t.width = i.width / s), (t.height = i.height / s)),
            (n = !0),
            (a = this._rendererPremultipliedAlpha),
            i.renderTexture.bind();
        const c = Math.max(Math.round(t.width * s), 1),
          u = Math.max(Math.round(t.height * s), 1),
          d = new Uint8Array(F6 * c * u);
        return (
          h.readPixels(
            Math.round(t.x * s),
            Math.round(t.y * s),
            c,
            u,
            h.RGBA,
            h.UNSIGNED_BYTE,
            d
          ),
          l && (o == null || o.destroy(!0)),
          { pixels: d, width: c, height: u, flipY: n, premultipliedAlpha: a }
        );
      }
      destroy() {
        this.renderer = null;
      }
      static _flipY(e, t, i) {
        const s = t << 2,
          n = i >> 1,
          a = new Uint8Array(s);
        for (let o = 0; o < n; o++) {
          const l = o * s,
            h = (i - o - 1) * s;
          a.set(e.subarray(l, l + s)), e.copyWithin(l, h, h + s), e.set(a, h);
        }
      }
      static _unpremultiplyAlpha(e) {
        e instanceof Uint8ClampedArray && (e = new Uint8Array(e.buffer));
        const t = e.length;
        for (let i = 0; i < t; i += 4) {
          const s = e[i + 3];
          if (s !== 0) {
            const n = 255.001 / s;
            (e[i] = e[i] * n + 0.5),
              (e[i + 1] = e[i + 1] * n + 0.5),
              (e[i + 2] = e[i + 2] * n + 0.5);
          }
        }
      }
    };
  A_.extension = { name: "extract", type: me.RendererSystem };
  let B6 = A_;
  Ce.add(B6);
  const ec = {
    build(r) {
      const e = r.points;
      let t, i, s, n, a, o;
      if (r.type === Zt.CIRC) {
        const p = r.shape;
        (t = p.x), (i = p.y), (a = o = p.radius), (s = n = 0);
      } else if (r.type === Zt.ELIP) {
        const p = r.shape;
        (t = p.x), (i = p.y), (a = p.width), (o = p.height), (s = n = 0);
      } else {
        const p = r.shape,
          m = p.width / 2,
          v = p.height / 2;
        (t = p.x + m),
          (i = p.y + v),
          (a = o = Math.max(0, Math.min(p.radius, Math.min(m, v)))),
          (s = m - a),
          (n = v - o);
      }
      if (!(a >= 0 && o >= 0 && s >= 0 && n >= 0)) {
        e.length = 0;
        return;
      }
      const l = Math.ceil(2.3 * Math.sqrt(a + o)),
        h = l * 8 + (s ? 4 : 0) + (n ? 4 : 0);
      if (((e.length = h), h === 0)) return;
      if (l === 0) {
        (e.length = 8),
          (e[0] = e[6] = t + s),
          (e[1] = e[3] = i + n),
          (e[2] = e[4] = t - s),
          (e[5] = e[7] = i - n);
        return;
      }
      let c = 0,
        u = l * 4 + (s ? 2 : 0) + 2,
        d = u,
        f = h;
      {
        const p = s + a,
          m = n,
          v = t + p,
          g = t - p,
          x = i + m;
        if (((e[c++] = v), (e[c++] = x), (e[--u] = x), (e[--u] = g), n)) {
          const b = i - m;
          (e[d++] = g), (e[d++] = b), (e[--f] = b), (e[--f] = v);
        }
      }
      for (let p = 1; p < l; p++) {
        const m = (Math.PI / 2) * (p / l),
          v = s + Math.cos(m) * a,
          g = n + Math.sin(m) * o,
          x = t + v,
          b = t - v,
          y = i + g,
          _ = i - g;
        (e[c++] = x),
          (e[c++] = y),
          (e[--u] = y),
          (e[--u] = b),
          (e[d++] = b),
          (e[d++] = _),
          (e[--f] = _),
          (e[--f] = x);
      }
      {
        const p = s,
          m = n + o,
          v = t + p,
          g = t - p,
          x = i + m,
          b = i - m;
        (e[c++] = v),
          (e[c++] = x),
          (e[--f] = b),
          (e[--f] = v),
          s && ((e[c++] = g), (e[c++] = x), (e[--f] = b), (e[--f] = g));
      }
    },
    triangulate(r, e) {
      const t = r.points,
        i = e.points,
        s = e.indices;
      if (t.length === 0) return;
      let n = i.length / 2;
      const a = n;
      let o, l;
      if (r.type !== Zt.RREC) {
        const c = r.shape;
        (o = c.x), (l = c.y);
      } else {
        const c = r.shape;
        (o = c.x + c.width / 2), (l = c.y + c.height / 2);
      }
      const h = r.matrix;
      i.push(
        r.matrix ? h.a * o + h.c * l + h.tx : o,
        r.matrix ? h.b * o + h.d * l + h.ty : l
      ),
        n++,
        i.push(t[0], t[1]);
      for (let c = 2; c < t.length; c += 2)
        i.push(t[c], t[c + 1]), s.push(n++, a, n);
      s.push(a + 1, a, n);
    },
  };
  function qv(r, e = !1) {
    const t = r.length;
    if (t < 6) return;
    let i = 0;
    for (let s = 0, n = r[t - 2], a = r[t - 1]; s < t; s += 2) {
      const o = r[s],
        l = r[s + 1];
      (i += (o - n) * (l + a)), (n = o), (a = l);
    }
    if ((!e && i > 0) || (e && i <= 0)) {
      const s = t / 2;
      for (let n = s + (s % 2); n < t; n += 2) {
        const a = t - n - 2,
          o = t - n - 1,
          l = n,
          h = n + 1;
        ([r[a], r[l]] = [r[l], r[a]]), ([r[o], r[h]] = [r[h], r[o]]);
      }
    }
  }
  const C_ = {
      build(r) {
        r.points = r.shape.points.slice();
      },
      triangulate(r, e) {
        let t = r.points;
        const i = r.holes,
          s = e.points,
          n = e.indices;
        if (t.length >= 6) {
          qv(t, !1);
          const a = [];
          for (let h = 0; h < i.length; h++) {
            const c = i[h];
            qv(c.points, !0), a.push(t.length / 2), (t = t.concat(c.points));
          }
          const o = yk(t, a, 2);
          if (!o) return;
          const l = s.length / 2;
          for (let h = 0; h < o.length; h += 3)
            n.push(o[h] + l), n.push(o[h + 1] + l), n.push(o[h + 2] + l);
          for (let h = 0; h < t.length; h++) s.push(t[h]);
        }
      },
    },
    O6 = {
      build(r) {
        const e = r.shape,
          t = e.x,
          i = e.y,
          s = e.width,
          n = e.height,
          a = r.points;
        (a.length = 0),
          s >= 0 && n >= 0 && a.push(t, i, t + s, i, t + s, i + n, t, i + n);
      },
      triangulate(r, e) {
        const t = r.points,
          i = e.points;
        if (t.length === 0) return;
        const s = i.length / 2;
        i.push(t[0], t[1], t[2], t[3], t[6], t[7], t[4], t[5]),
          e.indices.push(s, s + 1, s + 2, s + 1, s + 2, s + 3);
      },
    },
    k6 = {
      build(r) {
        ec.build(r);
      },
      triangulate(r, e) {
        ec.triangulate(r, e);
      },
    };
  var Nr = ((r) => (
      (r.MITER = "miter"), (r.BEVEL = "bevel"), (r.ROUND = "round"), r
    ))(Nr || {}),
    Hs = ((r) => (
      (r.BUTT = "butt"), (r.ROUND = "round"), (r.SQUARE = "square"), r
    ))(Hs || {});
  const Ga = {
    adaptive: !0,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048,
    epsilon: 1e-4,
    _segmentsCount(r, e = 20) {
      if (!this.adaptive || !r || isNaN(r)) return e;
      let t = Math.ceil(r / this.maxLength);
      return (
        t < this.minSegments
          ? (t = this.minSegments)
          : t > this.maxSegments && (t = this.maxSegments),
        t
      );
    },
  };
  class Kv {
    static curveTo(e, t, i, s, n, a) {
      const o = a[a.length - 2],
        l = a[a.length - 1] - t,
        h = o - e,
        c = s - t,
        u = i - e,
        d = Math.abs(l * u - h * c);
      if (d < 1e-8 || n === 0)
        return (
          (a[a.length - 2] !== e || a[a.length - 1] !== t) && a.push(e, t), null
        );
      const f = l * l + h * h,
        p = c * c + u * u,
        m = l * c + h * u,
        v = (n * Math.sqrt(f)) / d,
        g = (n * Math.sqrt(p)) / d,
        x = (v * m) / f,
        b = (g * m) / p,
        y = v * u + g * h,
        _ = v * c + g * l,
        w = h * (g + x),
        E = l * (g + x),
        A = u * (v + b),
        C = c * (v + b),
        F = Math.atan2(E - _, w - y),
        B = Math.atan2(C - _, A - y);
      return {
        cx: y + e,
        cy: _ + t,
        radius: n,
        startAngle: F,
        endAngle: B,
        anticlockwise: h * c > u * l,
      };
    }
    static arc(e, t, i, s, n, a, o, l, h) {
      const c = o - a,
        u = Ga._segmentsCount(
          Math.abs(c) * n,
          Math.ceil(Math.abs(c) / zh) * 40
        ),
        d = c / (u * 2),
        f = d * 2,
        p = Math.cos(d),
        m = Math.sin(d),
        v = u - 1,
        g = (v % 1) / v;
      for (let x = 0; x <= v; ++x) {
        const b = x + g * x,
          y = d + a + f * b,
          _ = Math.cos(y),
          w = -Math.sin(y);
        h.push((p * _ + m * w) * n + i, (p * -w + m * _) * n + s);
      }
    }
  }
  class D6 {
    constructor() {
      this.reset();
    }
    begin(e, t, i) {
      this.reset(), (this.style = e), (this.start = t), (this.attribStart = i);
    }
    end(e, t) {
      (this.attribSize = t - this.attribStart), (this.size = e - this.start);
    }
    reset() {
      (this.style = null),
        (this.size = 0),
        (this.start = 0),
        (this.attribStart = 0),
        (this.attribSize = 0);
    }
  }
  class om {
    static curveLength(e, t, i, s, n, a, o, l) {
      let h = 0,
        c = 0,
        u = 0,
        d = 0,
        f = 0,
        p = 0,
        m = 0,
        v = 0,
        g = 0,
        x = 0,
        b = 0,
        y = e,
        _ = t;
      for (let w = 1; w <= 10; ++w)
        (c = w / 10),
          (u = c * c),
          (d = u * c),
          (f = 1 - c),
          (p = f * f),
          (m = p * f),
          (v = m * e + 3 * p * c * i + 3 * f * u * n + d * o),
          (g = m * t + 3 * p * c * s + 3 * f * u * a + d * l),
          (x = y - v),
          (b = _ - g),
          (y = v),
          (_ = g),
          (h += Math.sqrt(x * x + b * b));
      return h;
    }
    static curveTo(e, t, i, s, n, a, o) {
      const l = o[o.length - 2],
        h = o[o.length - 1];
      o.length -= 2;
      const c = Ga._segmentsCount(om.curveLength(l, h, e, t, i, s, n, a));
      let u = 0,
        d = 0,
        f = 0,
        p = 0,
        m = 0;
      o.push(l, h);
      for (let v = 1, g = 0; v <= c; ++v)
        (g = v / c),
          (u = 1 - g),
          (d = u * u),
          (f = d * u),
          (p = g * g),
          (m = p * g),
          o.push(
            f * l + 3 * d * g * e + 3 * u * p * i + m * n,
            f * h + 3 * d * g * t + 3 * u * p * s + m * a
          );
    }
  }
  function Zv(r, e, t, i, s, n, a, o) {
    const l = r - t * s,
      h = e - i * s,
      c = r + t * n,
      u = e + i * n;
    let d, f;
    a ? ((d = i), (f = -t)) : ((d = -i), (f = t));
    const p = l + d,
      m = h + f,
      v = c + d,
      g = u + f;
    return o.push(p, m, v, g), 2;
  }
  function ln(r, e, t, i, s, n, a, o) {
    const l = t - r,
      h = i - e;
    let c = Math.atan2(l, h),
      u = Math.atan2(s - r, n - e);
    o && c < u ? (c += Math.PI * 2) : !o && c > u && (u += Math.PI * 2);
    let d = c;
    const f = u - c,
      p = Math.abs(f),
      m = Math.sqrt(l * l + h * h),
      v = (((15 * p * Math.sqrt(m)) / Math.PI) >> 0) + 1,
      g = f / v;
    if (((d += g), o)) {
      a.push(r, e, t, i);
      for (let x = 1, b = d; x < v; x++, b += g)
        a.push(r, e, r + Math.sin(b) * m, e + Math.cos(b) * m);
      a.push(r, e, s, n);
    } else {
      a.push(t, i, r, e);
      for (let x = 1, b = d; x < v; x++, b += g)
        a.push(r + Math.sin(b) * m, e + Math.cos(b) * m, r, e);
      a.push(s, n, r, e);
    }
    return v * 2;
  }
  function L6(r, e) {
    const t = r.shape;
    let i = r.points || t.points.slice();
    const s = e.closePointEps;
    if (i.length === 0) return;
    const n = r.lineStyle,
      a = new Je(i[0], i[1]),
      o = new Je(i[i.length - 2], i[i.length - 1]),
      l = t.type !== Zt.POLY || t.closeStroke,
      h = Math.abs(a.x - o.x) < s && Math.abs(a.y - o.y) < s;
    if (l) {
      (i = i.slice()),
        h && (i.pop(), i.pop(), o.set(i[i.length - 2], i[i.length - 1]));
      const U = (a.x + o.x) * 0.5,
        V = (o.y + a.y) * 0.5;
      i.unshift(U, V), i.push(U, V);
    }
    const c = e.points,
      u = i.length / 2;
    let d = i.length;
    const f = c.length / 2,
      p = n.width / 2,
      m = p * p,
      v = n.miterLimit * n.miterLimit;
    let g = i[0],
      x = i[1],
      b = i[2],
      y = i[3],
      _ = 0,
      w = 0,
      E = -(x - y),
      A = g - b,
      C = 0,
      F = 0,
      B = Math.sqrt(E * E + A * A);
    (E /= B), (A /= B), (E *= p), (A *= p);
    const R = n.alignment,
      I = (1 - R) * 2,
      P = R * 2;
    l ||
      (n.cap === Hs.ROUND
        ? (d +=
            ln(
              g - E * (I - P) * 0.5,
              x - A * (I - P) * 0.5,
              g - E * I,
              x - A * I,
              g + E * P,
              x + A * P,
              c,
              !0
            ) + 2)
        : n.cap === Hs.SQUARE && (d += Zv(g, x, E, A, I, P, !0, c))),
      c.push(g - E * I, x - A * I, g + E * P, x + A * P);
    for (let U = 1; U < u - 1; ++U) {
      (g = i[(U - 1) * 2]),
        (x = i[(U - 1) * 2 + 1]),
        (b = i[U * 2]),
        (y = i[U * 2 + 1]),
        (_ = i[(U + 1) * 2]),
        (w = i[(U + 1) * 2 + 1]),
        (E = -(x - y)),
        (A = g - b),
        (B = Math.sqrt(E * E + A * A)),
        (E /= B),
        (A /= B),
        (E *= p),
        (A *= p),
        (C = -(y - w)),
        (F = b - _),
        (B = Math.sqrt(C * C + F * F)),
        (C /= B),
        (F /= B),
        (C *= p),
        (F *= p);
      const V = b - g,
        z = x - y,
        N = b - _,
        O = w - y,
        H = V * N + z * O,
        G = z * N - O * V,
        q = G < 0;
      if (Math.abs(G) < 0.001 * Math.abs(H)) {
        c.push(b - E * I, y - A * I, b + E * P, y + A * P),
          H >= 0 &&
            (n.join === Nr.ROUND
              ? (d +=
                  ln(b, y, b - E * I, y - A * I, b - C * I, y - F * I, c, !1) +
                  4)
              : (d += 2),
            c.push(b - C * P, y - F * P, b + C * I, y + F * I));
        continue;
      }
      const K = (-E + g) * (-A + y) - (-E + b) * (-A + x),
        ue = (-C + _) * (-F + y) - (-C + b) * (-F + w),
        ie = (V * ue - N * K) / G,
        ee = (O * K - z * ue) / G,
        ve = (ie - b) * (ie - b) + (ee - y) * (ee - y),
        ye = b + (ie - b) * I,
        _e = y + (ee - y) * I,
        ke = b - (ie - b) * P,
        k = y - (ee - y) * P,
        D = Math.min(V * V + z * z, N * N + O * O),
        W = q ? I : P,
        te = D + W * W * m,
        J = ve <= te;
      let Q = n.join;
      if ((Q === Nr.MITER && ve / m > v && (Q = Nr.BEVEL), J))
        switch (Q) {
          case Nr.MITER: {
            c.push(ye, _e, ke, k);
            break;
          }
          case Nr.BEVEL: {
            q
              ? c.push(
                  ye,
                  _e,
                  b + E * P,
                  y + A * P,
                  ye,
                  _e,
                  b + C * P,
                  y + F * P
                )
              : c.push(
                  b - E * I,
                  y - A * I,
                  ke,
                  k,
                  b - C * I,
                  y - F * I,
                  ke,
                  k
                ),
              (d += 2);
            break;
          }
          case Nr.ROUND: {
            q
              ? (c.push(ye, _e, b + E * P, y + A * P),
                (d +=
                  ln(b, y, b + E * P, y + A * P, b + C * P, y + F * P, c, !0) +
                  4),
                c.push(ye, _e, b + C * P, y + F * P))
              : (c.push(b - E * I, y - A * I, ke, k),
                (d +=
                  ln(b, y, b - E * I, y - A * I, b - C * I, y - F * I, c, !1) +
                  4),
                c.push(b - C * I, y - F * I, ke, k));
            break;
          }
        }
      else {
        switch ((c.push(b - E * I, y - A * I, b + E * P, y + A * P), Q)) {
          case Nr.MITER: {
            q ? c.push(ke, k, ke, k) : c.push(ye, _e, ye, _e), (d += 2);
            break;
          }
          case Nr.ROUND: {
            q
              ? (d +=
                  ln(b, y, b + E * P, y + A * P, b + C * P, y + F * P, c, !0) +
                  2)
              : (d +=
                  ln(b, y, b - E * I, y - A * I, b - C * I, y - F * I, c, !1) +
                  2);
            break;
          }
        }
        c.push(b - C * I, y - F * I, b + C * P, y + F * P), (d += 2);
      }
    }
    (g = i[(u - 2) * 2]),
      (x = i[(u - 2) * 2 + 1]),
      (b = i[(u - 1) * 2]),
      (y = i[(u - 1) * 2 + 1]),
      (E = -(x - y)),
      (A = g - b),
      (B = Math.sqrt(E * E + A * A)),
      (E /= B),
      (A /= B),
      (E *= p),
      (A *= p),
      c.push(b - E * I, y - A * I, b + E * P, y + A * P),
      l ||
        (n.cap === Hs.ROUND
          ? (d +=
              ln(
                b - E * (I - P) * 0.5,
                y - A * (I - P) * 0.5,
                b - E * I,
                y - A * I,
                b + E * P,
                y + A * P,
                c,
                !1
              ) + 2)
          : n.cap === Hs.SQUARE && (d += Zv(b, y, E, A, I, P, !1, c)));
    const M = e.indices,
      L = Ga.epsilon * Ga.epsilon;
    for (let U = f; U < d + f - 2; ++U)
      (g = c[U * 2]),
        (x = c[U * 2 + 1]),
        (b = c[(U + 1) * 2]),
        (y = c[(U + 1) * 2 + 1]),
        (_ = c[(U + 2) * 2]),
        (w = c[(U + 2) * 2 + 1]),
        !(Math.abs(g * (y - w) + b * (w - x) + _ * (x - y)) < L) &&
          M.push(U, U + 1, U + 2);
  }
  function N6(r, e) {
    let t = 0;
    const i = r.shape,
      s = r.points || i.points,
      n = i.type !== Zt.POLY || i.closeStroke;
    if (s.length === 0) return;
    const a = e.points,
      o = e.indices,
      l = s.length / 2,
      h = a.length / 2;
    let c = h;
    for (a.push(s[0], s[1]), t = 1; t < l; t++)
      a.push(s[t * 2], s[t * 2 + 1]), o.push(c, c + 1), c++;
    n && o.push(c, h);
  }
  function Jv(r, e) {
    r.lineStyle.native ? N6(r, e) : L6(r, e);
  }
  class lm {
    static curveLength(e, t, i, s, n, a) {
      const o = e - 2 * i + n,
        l = t - 2 * s + a,
        h = 2 * i - 2 * e,
        c = 2 * s - 2 * t,
        u = 4 * (o * o + l * l),
        d = 4 * (o * h + l * c),
        f = h * h + c * c,
        p = 2 * Math.sqrt(u + d + f),
        m = Math.sqrt(u),
        v = 2 * u * m,
        g = 2 * Math.sqrt(f),
        x = d / m;
      return (
        (v * p +
          m * d * (p - g) +
          (4 * f * u - d * d) * Math.log((2 * m + x + p) / (x + g))) /
        (4 * v)
      );
    }
    static curveTo(e, t, i, s, n) {
      const a = n[n.length - 2],
        o = n[n.length - 1],
        l = Ga._segmentsCount(lm.curveLength(a, o, e, t, i, s));
      let h = 0,
        c = 0;
      for (let u = 1; u <= l; ++u) {
        const d = u / l;
        (h = a + (e - a) * d),
          (c = o + (t - o) * d),
          n.push(h + (e + (i - e) * d - h) * d, c + (t + (s - t) * d - c) * d);
      }
    }
  }
  const ed = {
      [Zt.POLY]: C_,
      [Zt.CIRC]: ec,
      [Zt.ELIP]: ec,
      [Zt.RECT]: O6,
      [Zt.RREC]: k6,
    },
    Qv = [],
    sh = [];
  class tc {
    constructor(e, t = null, i = null, s = null) {
      (this.points = []),
        (this.holes = []),
        (this.shape = e),
        (this.lineStyle = i),
        (this.fillStyle = t),
        (this.matrix = s),
        (this.type = e.type);
    }
    clone() {
      return new tc(this.shape, this.fillStyle, this.lineStyle, this.matrix);
    }
    destroy() {
      (this.shape = null),
        (this.holes.length = 0),
        (this.holes = null),
        (this.points.length = 0),
        (this.points = null),
        (this.lineStyle = null),
        (this.fillStyle = null);
    }
  }
  const Jn = new Je(),
    I_ = class P_ extends B1 {
      constructor() {
        super(),
          (this.closePointEps = 1e-4),
          (this.boundsPadding = 0),
          (this.uvsFloat32 = null),
          (this.indicesUint16 = null),
          (this.batchable = !1),
          (this.points = []),
          (this.colors = []),
          (this.uvs = []),
          (this.indices = []),
          (this.textureIds = []),
          (this.graphicsData = []),
          (this.drawCalls = []),
          (this.batchDirty = -1),
          (this.batches = []),
          (this.dirty = 0),
          (this.cacheDirty = -1),
          (this.clearDirty = 0),
          (this.shapeIndex = 0),
          (this._bounds = new Kh()),
          (this.boundsDirty = -1);
      }
      get bounds() {
        return (
          this.updateBatches(),
          this.boundsDirty !== this.dirty &&
            ((this.boundsDirty = this.dirty), this.calculateBounds()),
          this._bounds
        );
      }
      invalidate() {
        (this.boundsDirty = -1),
          this.dirty++,
          this.batchDirty++,
          (this.shapeIndex = 0),
          (this.points.length = 0),
          (this.colors.length = 0),
          (this.uvs.length = 0),
          (this.indices.length = 0),
          (this.textureIds.length = 0);
        for (let e = 0; e < this.drawCalls.length; e++)
          this.drawCalls[e].texArray.clear(), sh.push(this.drawCalls[e]);
        this.drawCalls.length = 0;
        for (let e = 0; e < this.batches.length; e++) {
          const t = this.batches[e];
          t.reset(), Qv.push(t);
        }
        this.batches.length = 0;
      }
      clear() {
        return (
          this.graphicsData.length > 0 &&
            (this.invalidate(),
            this.clearDirty++,
            (this.graphicsData.length = 0)),
          this
        );
      }
      drawShape(e, t = null, i = null, s = null) {
        const n = new tc(e, t, i, s);
        return this.graphicsData.push(n), this.dirty++, this;
      }
      drawHole(e, t = null) {
        if (!this.graphicsData.length) return null;
        const i = new tc(e, null, null, t),
          s = this.graphicsData[this.graphicsData.length - 1];
        return (i.lineStyle = s.lineStyle), s.holes.push(i), this.dirty++, this;
      }
      destroy() {
        super.destroy();
        for (let e = 0; e < this.graphicsData.length; ++e)
          this.graphicsData[e].destroy();
        (this.points.length = 0),
          (this.points = null),
          (this.colors.length = 0),
          (this.colors = null),
          (this.uvs.length = 0),
          (this.uvs = null),
          (this.indices.length = 0),
          (this.indices = null),
          this.indexBuffer.destroy(),
          (this.indexBuffer = null),
          (this.graphicsData.length = 0),
          (this.graphicsData = null),
          (this.drawCalls.length = 0),
          (this.drawCalls = null),
          (this.batches.length = 0),
          (this.batches = null),
          (this._bounds = null);
      }
      containsPoint(e) {
        const t = this.graphicsData;
        for (let i = 0; i < t.length; ++i) {
          const s = t[i];
          if (
            s.fillStyle.visible &&
            s.shape &&
            (s.matrix ? s.matrix.applyInverse(e, Jn) : Jn.copyFrom(e),
            s.shape.contains(Jn.x, Jn.y))
          ) {
            let n = !1;
            if (s.holes) {
              for (let a = 0; a < s.holes.length; a++)
                if (s.holes[a].shape.contains(Jn.x, Jn.y)) {
                  n = !0;
                  break;
                }
            }
            if (!n) return !0;
          }
        }
        return !1;
      }
      updateBatches() {
        if (!this.graphicsData.length) {
          this.batchable = !0;
          return;
        }
        if (!this.validateBatching()) return;
        this.cacheDirty = this.dirty;
        const e = this.uvs,
          t = this.graphicsData;
        let i = null,
          s = null;
        this.batches.length > 0 &&
          ((i = this.batches[this.batches.length - 1]), (s = i.style));
        for (let l = this.shapeIndex; l < t.length; l++) {
          this.shapeIndex++;
          const h = t[l],
            c = h.fillStyle,
            u = h.lineStyle;
          ed[h.type].build(h),
            h.matrix && this.transformPoints(h.points, h.matrix),
            (c.visible || u.visible) && this.processHoles(h.holes);
          for (let d = 0; d < 2; d++) {
            const f = d === 0 ? c : u;
            if (!f.visible) continue;
            const p = f.texture.baseTexture,
              m = this.indices.length,
              v = this.points.length / 2;
            (p.wrapMode = ci.REPEAT),
              d === 0 ? this.processFill(h) : this.processLine(h);
            const g = this.points.length / 2 - v;
            g !== 0 &&
              (i && !this._compareStyles(s, f) && (i.end(m, v), (i = null)),
              i ||
                ((i = Qv.pop() || new D6()),
                i.begin(f, m, v),
                this.batches.push(i),
                (s = f)),
              this.addUvs(this.points, e, f.texture, v, g, f.matrix));
          }
        }
        const n = this.indices.length,
          a = this.points.length / 2;
        if ((i && i.end(n, a), this.batches.length === 0)) {
          this.batchable = !0;
          return;
        }
        const o = a > 65535;
        this.indicesUint16 &&
        this.indices.length === this.indicesUint16.length &&
        o === this.indicesUint16.BYTES_PER_ELEMENT > 2
          ? this.indicesUint16.set(this.indices)
          : (this.indicesUint16 = o
              ? new Uint32Array(this.indices)
              : new Uint16Array(this.indices)),
          (this.batchable = this.isBatchable()),
          this.batchable ? this.packBatches() : this.buildDrawCalls();
      }
      _compareStyles(e, t) {
        return !(
          !e ||
          !t ||
          e.texture.baseTexture !== t.texture.baseTexture ||
          e.color + e.alpha !== t.color + t.alpha ||
          !!e.native != !!t.native
        );
      }
      validateBatching() {
        if (this.dirty === this.cacheDirty || !this.graphicsData.length)
          return !1;
        for (let e = 0, t = this.graphicsData.length; e < t; e++) {
          const i = this.graphicsData[e],
            s = i.fillStyle,
            n = i.lineStyle;
          if (
            (s && !s.texture.baseTexture.valid) ||
            (n && !n.texture.baseTexture.valid)
          )
            return !1;
        }
        return !0;
      }
      packBatches() {
        this.batchDirty++, (this.uvsFloat32 = new Float32Array(this.uvs));
        const e = this.batches;
        for (let t = 0, i = e.length; t < i; t++) {
          const s = e[t];
          for (let n = 0; n < s.size; n++) {
            const a = s.start + n;
            this.indicesUint16[a] = this.indicesUint16[a] - s.attribStart;
          }
        }
      }
      isBatchable() {
        if (this.points.length > 65535 * 2) return !1;
        const e = this.batches;
        for (let t = 0; t < e.length; t++) if (e[t].style.native) return !1;
        return this.points.length < P_.BATCHABLE_SIZE * 2;
      }
      buildDrawCalls() {
        let e = ++Le._globalBatch;
        for (let u = 0; u < this.drawCalls.length; u++)
          this.drawCalls[u].texArray.clear(), sh.push(this.drawCalls[u]);
        this.drawCalls.length = 0;
        const t = this.colors,
          i = this.textureIds;
        let s = sh.pop();
        s || ((s = new of()), (s.texArray = new uf())),
          (s.texArray.count = 0),
          (s.start = 0),
          (s.size = 0),
          (s.type = Di.TRIANGLES);
        let n = 0,
          a = null,
          o = 0,
          l = !1,
          h = Di.TRIANGLES,
          c = 0;
        this.drawCalls.push(s);
        for (let u = 0; u < this.batches.length; u++) {
          const d = this.batches[u],
            f = 8,
            p = d.style,
            m = p.texture.baseTexture;
          l !== !!p.native &&
            ((l = !!p.native),
            (h = l ? Di.LINES : Di.TRIANGLES),
            (a = null),
            (n = f),
            e++),
            a !== m &&
              ((a = m),
              m._batchEnabled !== e &&
                (n === f &&
                  (e++,
                  (n = 0),
                  s.size > 0 &&
                    ((s = sh.pop()),
                    s || ((s = new of()), (s.texArray = new uf())),
                    this.drawCalls.push(s)),
                  (s.start = c),
                  (s.size = 0),
                  (s.texArray.count = 0),
                  (s.type = h)),
                (m.touched = 1),
                (m._batchEnabled = e),
                (m._batchLocation = n),
                (m.wrapMode = ci.REPEAT),
                (s.texArray.elements[s.texArray.count++] = m),
                n++)),
            (s.size += d.size),
            (c += d.size),
            (o = m._batchLocation),
            this.addColors(t, p.color, p.alpha, d.attribSize, d.attribStart),
            this.addTextureIds(i, o, d.attribSize, d.attribStart);
        }
        (Le._globalBatch = e), this.packAttributes();
      }
      packAttributes() {
        const e = this.points,
          t = this.uvs,
          i = this.colors,
          s = this.textureIds,
          n = new ArrayBuffer(e.length * 3 * 4),
          a = new Float32Array(n),
          o = new Uint32Array(n);
        let l = 0;
        for (let h = 0; h < e.length / 2; h++)
          (a[l++] = e[h * 2]),
            (a[l++] = e[h * 2 + 1]),
            (a[l++] = t[h * 2]),
            (a[l++] = t[h * 2 + 1]),
            (o[l++] = i[h]),
            (a[l++] = s[h]);
        this._buffer.update(n), this._indexBuffer.update(this.indicesUint16);
      }
      processFill(e) {
        e.holes.length
          ? C_.triangulate(e, this)
          : ed[e.type].triangulate(e, this);
      }
      processLine(e) {
        Jv(e, this);
        for (let t = 0; t < e.holes.length; t++) Jv(e.holes[t], this);
      }
      processHoles(e) {
        for (let t = 0; t < e.length; t++) {
          const i = e[t];
          ed[i.type].build(i),
            i.matrix && this.transformPoints(i.points, i.matrix);
        }
      }
      calculateBounds() {
        const e = this._bounds;
        e.clear(),
          e.addVertexData(this.points, 0, this.points.length),
          e.pad(this.boundsPadding, this.boundsPadding);
      }
      transformPoints(e, t) {
        for (let i = 0; i < e.length / 2; i++) {
          const s = e[i * 2],
            n = e[i * 2 + 1];
          (e[i * 2] = t.a * s + t.c * n + t.tx),
            (e[i * 2 + 1] = t.b * s + t.d * n + t.ty);
        }
      }
      addColors(e, t, i, s, n = 0) {
        const a = lt.shared.setValue(t).toLittleEndianNumber(),
          o = lt.shared.setValue(a).toPremultiplied(i);
        e.length = Math.max(e.length, n + s);
        for (let l = 0; l < s; l++) e[n + l] = o;
      }
      addTextureIds(e, t, i, s = 0) {
        e.length = Math.max(e.length, s + i);
        for (let n = 0; n < i; n++) e[s + n] = t;
      }
      addUvs(e, t, i, s, n, a = null) {
        let o = 0;
        const l = t.length,
          h = i.frame;
        for (; o < n; ) {
          let u = e[(s + o) * 2],
            d = e[(s + o) * 2 + 1];
          if (a) {
            const f = a.a * u + a.c * d + a.tx;
            (d = a.b * u + a.d * d + a.ty), (u = f);
          }
          o++, t.push(u / h.width, d / h.height);
        }
        const c = i.baseTexture;
        (h.width < c.width || h.height < c.height) &&
          this.adjustUvs(t, i, l, n);
      }
      adjustUvs(e, t, i, s) {
        const n = t.baseTexture,
          a = 1e-6,
          o = i + s * 2,
          l = t.frame,
          h = l.width / n.width,
          c = l.height / n.height;
        let u = l.x / l.width,
          d = l.y / l.height,
          f = Math.floor(e[i] + a),
          p = Math.floor(e[i + 1] + a);
        for (let m = i + 2; m < o; m += 2)
          (f = Math.min(f, Math.floor(e[m] + a))),
            (p = Math.min(p, Math.floor(e[m + 1] + a)));
        (u -= f), (d -= p);
        for (let m = i; m < o; m += 2)
          (e[m] = (e[m] + u) * h), (e[m + 1] = (e[m + 1] + d) * c);
      }
    };
  I_.BATCHABLE_SIZE = 100;
  let U6 = I_;
  class Xc {
    constructor() {
      (this.color = 16777215),
        (this.alpha = 1),
        (this.texture = ze.WHITE),
        (this.matrix = null),
        (this.visible = !1),
        this.reset();
    }
    clone() {
      const e = new Xc();
      return (
        (e.color = this.color),
        (e.alpha = this.alpha),
        (e.texture = this.texture),
        (e.matrix = this.matrix),
        (e.visible = this.visible),
        e
      );
    }
    reset() {
      (this.color = 16777215),
        (this.alpha = 1),
        (this.texture = ze.WHITE),
        (this.matrix = null),
        (this.visible = !1);
    }
    destroy() {
      (this.texture = null), (this.matrix = null);
    }
  }
  class hm extends Xc {
    constructor() {
      super(...arguments),
        (this.width = 0),
        (this.alignment = 0.5),
        (this.native = !1),
        (this.cap = Hs.BUTT),
        (this.join = Nr.MITER),
        (this.miterLimit = 10);
    }
    clone() {
      const e = new hm();
      return (
        (e.color = this.color),
        (e.alpha = this.alpha),
        (e.texture = this.texture),
        (e.matrix = this.matrix),
        (e.visible = this.visible),
        (e.width = this.width),
        (e.alignment = this.alignment),
        (e.native = this.native),
        (e.cap = this.cap),
        (e.join = this.join),
        (e.miterLimit = this.miterLimit),
        e
      );
    }
    reset() {
      super.reset(),
        (this.color = 0),
        (this.alignment = 0.5),
        (this.width = 0),
        (this.native = !1),
        (this.cap = Hs.BUTT),
        (this.join = Nr.MITER),
        (this.miterLimit = 10);
    }
  }
  const td = {},
    Rf = class wh extends jr {
      constructor(e = null) {
        super(),
          (this.shader = null),
          (this.pluginName = "batch"),
          (this.currentPath = null),
          (this.batches = []),
          (this.batchTint = -1),
          (this.batchDirty = -1),
          (this.vertexData = null),
          (this._fillStyle = new Xc()),
          (this._lineStyle = new hm()),
          (this._matrix = null),
          (this._holeMode = !1),
          (this.state = ji.for2d()),
          (this._geometry = e || new U6()),
          this._geometry.refCount++,
          (this._transformID = -1),
          (this._tintColor = new lt(16777215)),
          (this.blendMode = Be.NORMAL);
      }
      get geometry() {
        return this._geometry;
      }
      clone() {
        return this.finishPoly(), new wh(this._geometry);
      }
      set blendMode(e) {
        this.state.blendMode = e;
      }
      get blendMode() {
        return this.state.blendMode;
      }
      get tint() {
        return this._tintColor.value;
      }
      set tint(e) {
        this._tintColor.setValue(e);
      }
      get fill() {
        return this._fillStyle;
      }
      get line() {
        return this._lineStyle;
      }
      lineStyle(e = null, t = 0, i, s = 0.5, n = !1) {
        return (
          typeof e == "number" &&
            (e = { width: e, color: t, alpha: i, alignment: s, native: n }),
          this.lineTextureStyle(e)
        );
      }
      lineTextureStyle(e) {
        const t = {
          width: 0,
          texture: ze.WHITE,
          color: e != null && e.texture ? 16777215 : 0,
          matrix: null,
          alignment: 0.5,
          native: !1,
          cap: Hs.BUTT,
          join: Nr.MITER,
          miterLimit: 10,
        };
        (e = Object.assign(t, e)),
          this.normalizeColor(e),
          this.currentPath && this.startPoly();
        const i = e.width > 0 && e.alpha > 0;
        return (
          i
            ? (e.matrix && ((e.matrix = e.matrix.clone()), e.matrix.invert()),
              Object.assign(this._lineStyle, { visible: i }, e))
            : this._lineStyle.reset(),
          this
        );
      }
      startPoly() {
        if (this.currentPath) {
          const e = this.currentPath.points,
            t = this.currentPath.points.length;
          t > 2 &&
            (this.drawShape(this.currentPath),
            (this.currentPath = new Sn()),
            (this.currentPath.closeStroke = !1),
            this.currentPath.points.push(e[t - 2], e[t - 1]));
        } else
          (this.currentPath = new Sn()), (this.currentPath.closeStroke = !1);
      }
      finishPoly() {
        this.currentPath &&
          (this.currentPath.points.length > 2
            ? (this.drawShape(this.currentPath), (this.currentPath = null))
            : (this.currentPath.points.length = 0));
      }
      moveTo(e, t) {
        return (
          this.startPoly(),
          (this.currentPath.points[0] = e),
          (this.currentPath.points[1] = t),
          this
        );
      }
      lineTo(e, t) {
        this.currentPath || this.moveTo(0, 0);
        const i = this.currentPath.points,
          s = i[i.length - 2],
          n = i[i.length - 1];
        return (s !== e || n !== t) && i.push(e, t), this;
      }
      _initCurve(e = 0, t = 0) {
        this.currentPath
          ? this.currentPath.points.length === 0 &&
            (this.currentPath.points = [e, t])
          : this.moveTo(e, t);
      }
      quadraticCurveTo(e, t, i, s) {
        this._initCurve();
        const n = this.currentPath.points;
        return (
          n.length === 0 && this.moveTo(0, 0), lm.curveTo(e, t, i, s, n), this
        );
      }
      bezierCurveTo(e, t, i, s, n, a) {
        return (
          this._initCurve(),
          om.curveTo(e, t, i, s, n, a, this.currentPath.points),
          this
        );
      }
      arcTo(e, t, i, s, n) {
        this._initCurve(e, t);
        const a = this.currentPath.points,
          o = Kv.curveTo(e, t, i, s, n, a);
        if (o) {
          const {
            cx: l,
            cy: h,
            radius: c,
            startAngle: u,
            endAngle: d,
            anticlockwise: f,
          } = o;
          this.arc(l, h, c, u, d, f);
        }
        return this;
      }
      arc(e, t, i, s, n, a = !1) {
        if (s === n) return this;
        if ((!a && n <= s ? (n += zh) : a && s <= n && (s += zh), n - s === 0))
          return this;
        const o = e + Math.cos(s) * i,
          l = t + Math.sin(s) * i,
          h = this._geometry.closePointEps;
        let c = this.currentPath ? this.currentPath.points : null;
        if (c) {
          const u = Math.abs(c[c.length - 2] - o),
            d = Math.abs(c[c.length - 1] - l);
          (u < h && d < h) || c.push(o, l);
        } else this.moveTo(o, l), (c = this.currentPath.points);
        return Kv.arc(o, l, e, t, i, s, n, a, c), this;
      }
      beginFill(e = 0, t) {
        return this.beginTextureFill({ texture: ze.WHITE, color: e, alpha: t });
      }
      normalizeColor(e) {
        const t = lt.shared.setValue(e.color ?? 0);
        (e.color = t.toNumber()), e.alpha ?? (e.alpha = t.alpha);
      }
      beginTextureFill(e) {
        const t = { texture: ze.WHITE, color: 16777215, matrix: null };
        (e = Object.assign(t, e)),
          this.normalizeColor(e),
          this.currentPath && this.startPoly();
        const i = e.alpha > 0;
        return (
          i
            ? (e.matrix && ((e.matrix = e.matrix.clone()), e.matrix.invert()),
              Object.assign(this._fillStyle, { visible: i }, e))
            : this._fillStyle.reset(),
          this
        );
      }
      endFill() {
        return this.finishPoly(), this._fillStyle.reset(), this;
      }
      drawRect(e, t, i, s) {
        return this.drawShape(new $e(e, t, i, s));
      }
      drawRoundedRect(e, t, i, s, n) {
        return this.drawShape(new $c(e, t, i, s, n));
      }
      drawCircle(e, t, i) {
        return this.drawShape(new Uc(e, t, i));
      }
      drawEllipse(e, t, i, s) {
        return this.drawShape(new Vc(e, t, i, s));
      }
      drawPolygon(...e) {
        let t,
          i = !0;
        const s = e[0];
        s.points
          ? ((i = s.closeStroke), (t = s.points))
          : Array.isArray(e[0])
          ? (t = e[0])
          : (t = e);
        const n = new Sn(t);
        return (n.closeStroke = i), this.drawShape(n), this;
      }
      drawShape(e) {
        return (
          this._holeMode
            ? this._geometry.drawHole(e, this._matrix)
            : this._geometry.drawShape(
                e,
                this._fillStyle.clone(),
                this._lineStyle.clone(),
                this._matrix
              ),
          this
        );
      }
      clear() {
        return (
          this._geometry.clear(),
          this._lineStyle.reset(),
          this._fillStyle.reset(),
          this._boundsID++,
          (this._matrix = null),
          (this._holeMode = !1),
          (this.currentPath = null),
          this
        );
      }
      isFastRect() {
        const e = this._geometry.graphicsData;
        return (
          e.length === 1 &&
          e[0].shape.type === Zt.RECT &&
          !e[0].matrix &&
          !e[0].holes.length &&
          !(e[0].lineStyle.visible && e[0].lineStyle.width)
        );
      }
      _render(e) {
        this.finishPoly();
        const t = this._geometry;
        t.updateBatches(),
          t.batchable
            ? (this.batchDirty !== t.batchDirty && this._populateBatches(),
              this._renderBatched(e))
            : (e.batch.flush(), this._renderDirect(e));
      }
      _populateBatches() {
        const e = this._geometry,
          t = this.blendMode,
          i = e.batches.length;
        (this.batchTint = -1),
          (this._transformID = -1),
          (this.batchDirty = e.batchDirty),
          (this.batches.length = i),
          (this.vertexData = new Float32Array(e.points));
        for (let s = 0; s < i; s++) {
          const n = e.batches[s],
            a = n.style.color,
            o = new Float32Array(
              this.vertexData.buffer,
              n.attribStart * 4 * 2,
              n.attribSize * 2
            ),
            l = new Float32Array(
              e.uvsFloat32.buffer,
              n.attribStart * 4 * 2,
              n.attribSize * 2
            ),
            h = new Uint16Array(e.indicesUint16.buffer, n.start * 2, n.size),
            c = {
              vertexData: o,
              blendMode: t,
              indices: h,
              uvs: l,
              _batchRGB: lt.shared.setValue(a).toRgbArray(),
              _tintRGB: a,
              _texture: n.style.texture,
              alpha: n.style.alpha,
              worldAlpha: 1,
            };
          this.batches[s] = c;
        }
      }
      _renderBatched(e) {
        if (this.batches.length) {
          e.batch.setObjectRenderer(e.plugins[this.pluginName]),
            this.calculateVertices(),
            this.calculateTints();
          for (let t = 0, i = this.batches.length; t < i; t++) {
            const s = this.batches[t];
            (s.worldAlpha = this.worldAlpha * s.alpha),
              e.plugins[this.pluginName].render(s);
          }
        }
      }
      _renderDirect(e) {
        const t = this._resolveDirectShader(e),
          i = this._geometry,
          s = this.worldAlpha,
          n = t.uniforms,
          a = i.drawCalls;
        (n.translationMatrix = this.transform.worldTransform),
          lt.shared.setValue(this._tintColor).premultiply(s).toArray(n.tint),
          e.shader.bind(t),
          e.geometry.bind(i, t),
          e.state.set(this.state);
        for (let o = 0, l = a.length; o < l; o++)
          this._renderDrawCallDirect(e, i.drawCalls[o]);
      }
      _renderDrawCallDirect(e, t) {
        const { texArray: i, type: s, size: n, start: a } = t,
          o = i.count;
        for (let l = 0; l < o; l++) e.texture.bind(i.elements[l], l);
        e.geometry.draw(s, n, a);
      }
      _resolveDirectShader(e) {
        let t = this.shader;
        const i = this.pluginName;
        if (!t) {
          if (!td[i]) {
            const { maxTextures: s } = e.plugins[i],
              n = new Int32Array(s);
            for (let l = 0; l < s; l++) n[l] = l;
            const a = {
                tint: new Float32Array([1, 1, 1, 1]),
                translationMatrix: new vt(),
                default: di.from({ uSamplers: n }, !0),
              },
              o = e.plugins[i]._shader.program;
            td[i] = new fi(o, a);
          }
          t = td[i];
        }
        return t;
      }
      _calculateBounds() {
        this.finishPoly();
        const e = this._geometry;
        if (!e.graphicsData.length) return;
        const { minX: t, minY: i, maxX: s, maxY: n } = e.bounds;
        this._bounds.addFrame(this.transform, t, i, s, n);
      }
      containsPoint(e) {
        return (
          this.worldTransform.applyInverse(e, wh._TEMP_POINT),
          this._geometry.containsPoint(wh._TEMP_POINT)
        );
      }
      calculateTints() {
        if (this.batchTint !== this.tint) {
          this.batchTint = this._tintColor.toNumber();
          for (let e = 0; e < this.batches.length; e++) {
            const t = this.batches[e];
            t._tintRGB = lt.shared
              .setValue(this._tintColor)
              .multiply(t._batchRGB)
              .toLittleEndianNumber();
          }
        }
      }
      calculateVertices() {
        const e = this.transform._worldID;
        if (this._transformID === e) return;
        this._transformID = e;
        const t = this.transform.worldTransform,
          i = t.a,
          s = t.b,
          n = t.c,
          a = t.d,
          o = t.tx,
          l = t.ty,
          h = this._geometry.points,
          c = this.vertexData;
        let u = 0;
        for (let d = 0; d < h.length; d += 2) {
          const f = h[d],
            p = h[d + 1];
          (c[u++] = i * f + n * p + o), (c[u++] = a * p + s * f + l);
        }
      }
      closePath() {
        const e = this.currentPath;
        return e && ((e.closeStroke = !0), this.finishPoly()), this;
      }
      setMatrix(e) {
        return (this._matrix = e), this;
      }
      beginHole() {
        return this.finishPoly(), (this._holeMode = !0), this;
      }
      endHole() {
        return this.finishPoly(), (this._holeMode = !1), this;
      }
      destroy(e) {
        this._geometry.refCount--,
          this._geometry.refCount === 0 && this._geometry.dispose(),
          (this._matrix = null),
          (this.currentPath = null),
          this._lineStyle.destroy(),
          (this._lineStyle = null),
          this._fillStyle.destroy(),
          (this._fillStyle = null),
          (this._geometry = null),
          (this.shader = null),
          (this.vertexData = null),
          (this.batches.length = 0),
          (this.batches = null),
          super.destroy(e);
      }
    };
  (Rf.curves = Ga), (Rf._TEMP_POINT = new Je());
  let zc = Rf;
  class V6 {
    constructor(e, t) {
      (this.uvBuffer = e),
        (this.uvMatrix = t),
        (this.data = null),
        (this._bufferUpdateId = -1),
        (this._textureUpdateId = -1),
        (this._updateID = 0);
    }
    update(e) {
      if (
        !e &&
        this._bufferUpdateId === this.uvBuffer._updateID &&
        this._textureUpdateId === this.uvMatrix._updateID
      )
        return;
      (this._bufferUpdateId = this.uvBuffer._updateID),
        (this._textureUpdateId = this.uvMatrix._updateID);
      const t = this.uvBuffer.data;
      (!this.data || this.data.length !== t.length) &&
        (this.data = new Float32Array(t.length)),
        this.uvMatrix.multiplyUvs(t, this.data),
        this._updateID++;
    }
  }
  const rd = new Je(),
    ey = new Sn(),
    R_ = class M_ extends jr {
      constructor(e, t, i, s = Di.TRIANGLES) {
        super(),
          (this.geometry = e),
          (this.shader = t),
          (this.state = i || ji.for2d()),
          (this.drawMode = s),
          (this.start = 0),
          (this.size = 0),
          (this.uvs = null),
          (this.indices = null),
          (this.vertexData = new Float32Array(1)),
          (this.vertexDirty = -1),
          (this._transformID = -1),
          (this._roundPixels = we.ROUND_PIXELS),
          (this.batchUvs = null);
      }
      get geometry() {
        return this._geometry;
      }
      set geometry(e) {
        this._geometry !== e &&
          (this._geometry &&
            (this._geometry.refCount--,
            this._geometry.refCount === 0 && this._geometry.dispose()),
          (this._geometry = e),
          this._geometry && this._geometry.refCount++,
          (this.vertexDirty = -1));
      }
      get uvBuffer() {
        return this.geometry.buffers[1];
      }
      get verticesBuffer() {
        return this.geometry.buffers[0];
      }
      set material(e) {
        this.shader = e;
      }
      get material() {
        return this.shader;
      }
      set blendMode(e) {
        this.state.blendMode = e;
      }
      get blendMode() {
        return this.state.blendMode;
      }
      set roundPixels(e) {
        this._roundPixels !== e && (this._transformID = -1),
          (this._roundPixels = e);
      }
      get roundPixels() {
        return this._roundPixels;
      }
      get tint() {
        return "tint" in this.shader ? this.shader.tint : null;
      }
      set tint(e) {
        this.shader.tint = e;
      }
      get tintValue() {
        return this.shader.tintValue;
      }
      get texture() {
        return "texture" in this.shader ? this.shader.texture : null;
      }
      set texture(e) {
        this.shader.texture = e;
      }
      _render(e) {
        const t = this.geometry.buffers[0].data;
        this.shader.batchable &&
        this.drawMode === Di.TRIANGLES &&
        t.length < M_.BATCHABLE_SIZE * 2
          ? this._renderToBatch(e)
          : this._renderDefault(e);
      }
      _renderDefault(e) {
        const t = this.shader;
        (t.alpha = this.worldAlpha),
          t.update && t.update(),
          e.batch.flush(),
          (t.uniforms.translationMatrix = this.transform.worldTransform.toArray(
            !0
          )),
          e.shader.bind(t),
          e.state.set(this.state),
          e.geometry.bind(this.geometry, t),
          e.geometry.draw(
            this.drawMode,
            this.size,
            this.start,
            this.geometry.instanceCount
          );
      }
      _renderToBatch(e) {
        const t = this.geometry,
          i = this.shader;
        i.uvMatrix && (i.uvMatrix.update(), this.calculateUvs()),
          this.calculateVertices(),
          (this.indices = t.indexBuffer.data),
          (this._tintRGB = i._tintRGB),
          (this._texture = i.texture);
        const s = this.material.pluginName;
        e.batch.setObjectRenderer(e.plugins[s]), e.plugins[s].render(this);
      }
      calculateVertices() {
        const e = this.geometry.buffers[0],
          t = e.data,
          i = e._updateID;
        if (
          i === this.vertexDirty &&
          this._transformID === this.transform._worldID
        )
          return;
        (this._transformID = this.transform._worldID),
          this.vertexData.length !== t.length &&
            (this.vertexData = new Float32Array(t.length));
        const s = this.transform.worldTransform,
          n = s.a,
          a = s.b,
          o = s.c,
          l = s.d,
          h = s.tx,
          c = s.ty,
          u = this.vertexData;
        for (let d = 0; d < u.length / 2; d++) {
          const f = t[d * 2],
            p = t[d * 2 + 1];
          (u[d * 2] = n * f + o * p + h), (u[d * 2 + 1] = a * f + l * p + c);
        }
        if (this._roundPixels) {
          const d = we.RESOLUTION;
          for (let f = 0; f < u.length; ++f) u[f] = Math.round(u[f] * d) / d;
        }
        this.vertexDirty = i;
      }
      calculateUvs() {
        const e = this.geometry.buffers[1],
          t = this.shader;
        t.uvMatrix.isSimple
          ? (this.uvs = e.data)
          : (this.batchUvs || (this.batchUvs = new V6(e, t.uvMatrix)),
            this.batchUvs.update(),
            (this.uvs = this.batchUvs.data));
      }
      _calculateBounds() {
        this.calculateVertices(),
          this._bounds.addVertexData(
            this.vertexData,
            0,
            this.vertexData.length
          );
      }
      containsPoint(e) {
        if (!this.getBounds().contains(e.x, e.y)) return !1;
        this.worldTransform.applyInverse(e, rd);
        const t = this.geometry.getBuffer("aVertexPosition").data,
          i = ey.points,
          s = this.geometry.getIndex().data,
          n = s.length,
          a = this.drawMode === 4 ? 3 : 1;
        for (let o = 0; o + 2 < n; o += a) {
          const l = s[o] * 2,
            h = s[o + 1] * 2,
            c = s[o + 2] * 2;
          if (
            ((i[0] = t[l]),
            (i[1] = t[l + 1]),
            (i[2] = t[h]),
            (i[3] = t[h + 1]),
            (i[4] = t[c]),
            (i[5] = t[c + 1]),
            ey.contains(rd.x, rd.y))
          )
            return !0;
        }
        return !1;
      }
      destroy(e) {
        super.destroy(e),
          this._cachedTexture &&
            (this._cachedTexture.destroy(), (this._cachedTexture = null)),
          (this.geometry = null),
          (this.shader = null),
          (this.state = null),
          (this.uvs = null),
          (this.indices = null),
          (this.vertexData = null);
      }
    };
  R_.BATCHABLE_SIZE = 100;
  let rc = R_;
  class F_ extends Yi {
    constructor(e, t, i) {
      super();
      const s = new gt(e),
        n = new gt(t, !0),
        a = new gt(i, !0, !0);
      this.addAttribute("aVertexPosition", s, 2, !1, Ae.FLOAT)
        .addAttribute("aTextureCoord", n, 2, !1, Ae.FLOAT)
        .addIndex(a),
        (this._updateId = -1);
    }
    get vertexDirtyId() {
      return this.buffers[0]._updateID;
    }
  }
  var $6 = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`,
    G6 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`;
  class Mf extends fi {
    constructor(e, t) {
      const i = {
        uSampler: e,
        alpha: 1,
        uTextureMatrix: vt.IDENTITY,
        uColor: new Float32Array([1, 1, 1, 1]),
      };
      (t = Object.assign({ tint: 16777215, alpha: 1, pluginName: "batch" }, t)),
        t.uniforms && Object.assign(i, t.uniforms),
        super(t.program || Li.from(G6, $6), i),
        (this._colorDirty = !1),
        (this.uvMatrix = new sm(e)),
        (this.batchable = t.program === void 0),
        (this.pluginName = t.pluginName),
        (this._tintColor = new lt(t.tint)),
        (this._tintRGB = this._tintColor.toLittleEndianNumber()),
        (this._colorDirty = !0),
        (this.alpha = t.alpha);
    }
    get texture() {
      return this.uniforms.uSampler;
    }
    set texture(e) {
      this.uniforms.uSampler !== e &&
        (!this.uniforms.uSampler.baseTexture.alphaMode !=
          !e.baseTexture.alphaMode && (this._colorDirty = !0),
        (this.uniforms.uSampler = e),
        (this.uvMatrix.texture = e));
    }
    set alpha(e) {
      e !== this._alpha && ((this._alpha = e), (this._colorDirty = !0));
    }
    get alpha() {
      return this._alpha;
    }
    set tint(e) {
      e !== this.tint &&
        (this._tintColor.setValue(e),
        (this._tintRGB = this._tintColor.toLittleEndianNumber()),
        (this._colorDirty = !0));
    }
    get tint() {
      return this._tintColor.value;
    }
    get tintValue() {
      return this._tintColor.toNumber();
    }
    update() {
      if (this._colorDirty) {
        this._colorDirty = !1;
        const e = this.texture.baseTexture.alphaMode;
        lt.shared
          .setValue(this._tintColor)
          .premultiply(this._alpha, e)
          .toArray(this.uniforms.uColor);
      }
      this.uvMatrix.update() &&
        (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
    }
  }
  class ty {
    constructor(e, t, i) {
      (this.geometry = new Yi()),
        (this.indexBuffer = null),
        (this.size = i),
        (this.dynamicProperties = []),
        (this.staticProperties = []);
      for (let s = 0; s < e.length; ++s) {
        let n = e[s];
        (n = {
          attributeName: n.attributeName,
          size: n.size,
          uploadFunction: n.uploadFunction,
          type: n.type || Ae.FLOAT,
          offset: n.offset,
        }),
          t[s] ? this.dynamicProperties.push(n) : this.staticProperties.push(n);
      }
      (this.staticStride = 0),
        (this.staticBuffer = null),
        (this.staticData = null),
        (this.staticDataUint32 = null),
        (this.dynamicStride = 0),
        (this.dynamicBuffer = null),
        (this.dynamicData = null),
        (this.dynamicDataUint32 = null),
        (this._updateID = 0),
        this.initBuffers();
    }
    initBuffers() {
      const e = this.geometry;
      let t = 0;
      (this.indexBuffer = new gt(uN(this.size), !0, !0)),
        e.addIndex(this.indexBuffer),
        (this.dynamicStride = 0);
      for (let a = 0; a < this.dynamicProperties.length; ++a) {
        const o = this.dynamicProperties[a];
        (o.offset = t), (t += o.size), (this.dynamicStride += o.size);
      }
      const i = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
      (this.dynamicData = new Float32Array(i)),
        (this.dynamicDataUint32 = new Uint32Array(i)),
        (this.dynamicBuffer = new gt(this.dynamicData, !1, !1));
      let s = 0;
      this.staticStride = 0;
      for (let a = 0; a < this.staticProperties.length; ++a) {
        const o = this.staticProperties[a];
        (o.offset = s), (s += o.size), (this.staticStride += o.size);
      }
      const n = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
      (this.staticData = new Float32Array(n)),
        (this.staticDataUint32 = new Uint32Array(n)),
        (this.staticBuffer = new gt(this.staticData, !0, !1));
      for (let a = 0; a < this.dynamicProperties.length; ++a) {
        const o = this.dynamicProperties[a];
        e.addAttribute(
          o.attributeName,
          this.dynamicBuffer,
          0,
          o.type === Ae.UNSIGNED_BYTE,
          o.type,
          this.dynamicStride * 4,
          o.offset * 4
        );
      }
      for (let a = 0; a < this.staticProperties.length; ++a) {
        const o = this.staticProperties[a];
        e.addAttribute(
          o.attributeName,
          this.staticBuffer,
          0,
          o.type === Ae.UNSIGNED_BYTE,
          o.type,
          this.staticStride * 4,
          o.offset * 4
        );
      }
    }
    uploadDynamic(e, t, i) {
      for (let s = 0; s < this.dynamicProperties.length; s++) {
        const n = this.dynamicProperties[s];
        n.uploadFunction(
          e,
          t,
          i,
          n.type === Ae.UNSIGNED_BYTE
            ? this.dynamicDataUint32
            : this.dynamicData,
          this.dynamicStride,
          n.offset
        );
      }
      this.dynamicBuffer._updateID++;
    }
    uploadStatic(e, t, i) {
      for (let s = 0; s < this.staticProperties.length; s++) {
        const n = this.staticProperties[s];
        n.uploadFunction(
          e,
          t,
          i,
          n.type === Ae.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData,
          this.staticStride,
          n.offset
        );
      }
      this.staticBuffer._updateID++;
    }
    destroy() {
      (this.indexBuffer = null),
        (this.dynamicProperties = null),
        (this.dynamicBuffer = null),
        (this.dynamicData = null),
        (this.dynamicDataUint32 = null),
        (this.staticProperties = null),
        (this.staticBuffer = null),
        (this.staticData = null),
        (this.staticDataUint32 = null),
        this.geometry.destroy();
    }
  }
  var H6 = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`,
    X6 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`;
  class B_ extends Gc {
    constructor(e) {
      super(e),
        (this.shader = null),
        (this.properties = null),
        (this.tempMatrix = new vt()),
        (this.properties = [
          {
            attributeName: "aVertexPosition",
            size: 2,
            uploadFunction: this.uploadVertices,
            offset: 0,
          },
          {
            attributeName: "aPositionCoord",
            size: 2,
            uploadFunction: this.uploadPosition,
            offset: 0,
          },
          {
            attributeName: "aRotation",
            size: 1,
            uploadFunction: this.uploadRotation,
            offset: 0,
          },
          {
            attributeName: "aTextureCoord",
            size: 2,
            uploadFunction: this.uploadUvs,
            offset: 0,
          },
          {
            attributeName: "aColor",
            size: 1,
            type: Ae.UNSIGNED_BYTE,
            uploadFunction: this.uploadTint,
            offset: 0,
          },
        ]),
        (this.shader = fi.from(X6, H6, {})),
        (this.state = ji.for2d());
    }
    render(e) {
      const t = e.children,
        i = e._maxSize,
        s = e._batchSize,
        n = this.renderer;
      let a = t.length;
      if (a === 0) return;
      a > i && !e.autoResize && (a = i);
      let o = e._buffers;
      o || (o = e._buffers = this.generateBuffers(e));
      const l = t[0]._texture.baseTexture,
        h = l.alphaMode > 0;
      (this.state.blendMode = R1(e.blendMode, h)), n.state.set(this.state);
      const c = n.gl,
        u = e.worldTransform.copyTo(this.tempMatrix);
      u.prepend(n.globalUniforms.uniforms.projectionMatrix),
        (this.shader.uniforms.translationMatrix = u.toArray(!0)),
        (this.shader.uniforms.uColor = lt.shared
          .setValue(e.tintRgb)
          .premultiply(e.worldAlpha, h)
          .toArray(this.shader.uniforms.uColor)),
        (this.shader.uniforms.uSampler = l),
        this.renderer.shader.bind(this.shader);
      let d = !1;
      for (let f = 0, p = 0; f < a; f += s, p += 1) {
        let m = a - f;
        m > s && (m = s),
          p >= o.length && o.push(this._generateOneMoreBuffer(e));
        const v = o[p];
        v.uploadDynamic(t, f, m);
        const g = e._bufferUpdateIDs[p] || 0;
        (d = d || v._updateID < g),
          d && ((v._updateID = e._updateID), v.uploadStatic(t, f, m)),
          n.geometry.bind(v.geometry),
          c.drawElements(c.TRIANGLES, m * 6, c.UNSIGNED_SHORT, 0);
      }
    }
    generateBuffers(e) {
      const t = [],
        i = e._maxSize,
        s = e._batchSize,
        n = e._properties;
      for (let a = 0; a < i; a += s) t.push(new ty(this.properties, n, s));
      return t;
    }
    _generateOneMoreBuffer(e) {
      const t = e._batchSize,
        i = e._properties;
      return new ty(this.properties, i, t);
    }
    uploadVertices(e, t, i, s, n, a) {
      let o = 0,
        l = 0,
        h = 0,
        c = 0;
      for (let u = 0; u < i; ++u) {
        const d = e[t + u],
          f = d._texture,
          p = d.scale.x,
          m = d.scale.y,
          v = f.trim,
          g = f.orig;
        v
          ? ((l = v.x - d.anchor.x * g.width),
            (o = l + v.width),
            (c = v.y - d.anchor.y * g.height),
            (h = c + v.height))
          : ((o = g.width * (1 - d.anchor.x)),
            (l = g.width * -d.anchor.x),
            (h = g.height * (1 - d.anchor.y)),
            (c = g.height * -d.anchor.y)),
          (s[a] = l * p),
          (s[a + 1] = c * m),
          (s[a + n] = o * p),
          (s[a + n + 1] = c * m),
          (s[a + n * 2] = o * p),
          (s[a + n * 2 + 1] = h * m),
          (s[a + n * 3] = l * p),
          (s[a + n * 3 + 1] = h * m),
          (a += n * 4);
      }
    }
    uploadPosition(e, t, i, s, n, a) {
      for (let o = 0; o < i; o++) {
        const l = e[t + o].position;
        (s[a] = l.x),
          (s[a + 1] = l.y),
          (s[a + n] = l.x),
          (s[a + n + 1] = l.y),
          (s[a + n * 2] = l.x),
          (s[a + n * 2 + 1] = l.y),
          (s[a + n * 3] = l.x),
          (s[a + n * 3 + 1] = l.y),
          (a += n * 4);
      }
    }
    uploadRotation(e, t, i, s, n, a) {
      for (let o = 0; o < i; o++) {
        const l = e[t + o].rotation;
        (s[a] = l),
          (s[a + n] = l),
          (s[a + n * 2] = l),
          (s[a + n * 3] = l),
          (a += n * 4);
      }
    }
    uploadUvs(e, t, i, s, n, a) {
      for (let o = 0; o < i; ++o) {
        const l = e[t + o]._texture._uvs;
        l
          ? ((s[a] = l.x0),
            (s[a + 1] = l.y0),
            (s[a + n] = l.x1),
            (s[a + n + 1] = l.y1),
            (s[a + n * 2] = l.x2),
            (s[a + n * 2 + 1] = l.y2),
            (s[a + n * 3] = l.x3),
            (s[a + n * 3 + 1] = l.y3),
            (a += n * 4))
          : ((s[a] = 0),
            (s[a + 1] = 0),
            (s[a + n] = 0),
            (s[a + n + 1] = 0),
            (s[a + n * 2] = 0),
            (s[a + n * 2 + 1] = 0),
            (s[a + n * 3] = 0),
            (s[a + n * 3 + 1] = 0),
            (a += n * 4));
      }
    }
    uploadTint(e, t, i, s, n, a) {
      for (let o = 0; o < i; ++o) {
        const l = e[t + o],
          h = lt.shared
            .setValue(l._tintRGB)
            .toPremultiplied(l.alpha, l.texture.baseTexture.alphaMode > 0);
        (s[a] = h),
          (s[a + n] = h),
          (s[a + n * 2] = h),
          (s[a + n * 3] = h),
          (a += n * 4);
      }
    }
    destroy() {
      super.destroy(),
        this.shader && (this.shader.destroy(), (this.shader = null)),
        (this.tempMatrix = null);
    }
  }
  B_.extension = { name: "particle", type: me.RendererPlugin };
  Ce.add(B_);
  var Wc = ((r) => (
    (r[(r.LINEAR_VERTICAL = 0)] = "LINEAR_VERTICAL"),
    (r[(r.LINEAR_HORIZONTAL = 1)] = "LINEAR_HORIZONTAL"),
    r
  ))(Wc || {});
  const nh = { willReadFrequently: !0 },
    Ci = class Ie {
      static get experimentalLetterSpacingSupported() {
        let e = Ie._experimentalLetterSpacingSupported;
        if (e !== void 0) {
          const t = we.ADAPTER.getCanvasRenderingContext2D().prototype;
          e = Ie._experimentalLetterSpacingSupported =
            "letterSpacing" in t || "textLetterSpacing" in t;
        }
        return e;
      }
      constructor(e, t, i, s, n, a, o, l, h) {
        (this.text = e),
          (this.style = t),
          (this.width = i),
          (this.height = s),
          (this.lines = n),
          (this.lineWidths = a),
          (this.lineHeight = o),
          (this.maxLineWidth = l),
          (this.fontProperties = h);
      }
      static measureText(e, t, i, s = Ie._canvas) {
        i = i ?? t.wordWrap;
        const n = t.toFontString(),
          a = Ie.measureFont(n);
        a.fontSize === 0 &&
          ((a.fontSize = t.fontSize), (a.ascent = t.fontSize));
        const o = s.getContext("2d", nh);
        o.font = n;
        const l = (i ? Ie.wordWrap(e, t, s) : e).split(/(?:\r\n|\r|\n)/),
          h = new Array(l.length);
        let c = 0;
        for (let p = 0; p < l.length; p++) {
          const m = Ie._measureText(l[p], t.letterSpacing, o);
          (h[p] = m), (c = Math.max(c, m));
        }
        let u = c + t.strokeThickness;
        t.dropShadow && (u += t.dropShadowDistance);
        const d = t.lineHeight || a.fontSize + t.strokeThickness;
        let f =
          Math.max(d, a.fontSize + t.strokeThickness * 2) +
          t.leading +
          (l.length - 1) * (d + t.leading);
        return (
          t.dropShadow && (f += t.dropShadowDistance),
          new Ie(e, t, u, f, l, h, d + t.leading, c, a)
        );
      }
      static _measureText(e, t, i) {
        let s = !1;
        Ie.experimentalLetterSpacingSupported &&
          (Ie.experimentalLetterSpacing
            ? ((i.letterSpacing = `${t}px`),
              (i.textLetterSpacing = `${t}px`),
              (s = !0))
            : ((i.letterSpacing = "0px"), (i.textLetterSpacing = "0px")));
        let n = i.measureText(e).width;
        return (
          n > 0 &&
            (s ? (n -= t) : (n += (Ie.graphemeSegmenter(e).length - 1) * t)),
          n
        );
      }
      static wordWrap(e, t, i = Ie._canvas) {
        const s = i.getContext("2d", nh);
        let n = 0,
          a = "",
          o = "";
        const l = Object.create(null),
          { letterSpacing: h, whiteSpace: c } = t,
          u = Ie.collapseSpaces(c),
          d = Ie.collapseNewlines(c);
        let f = !u;
        const p = t.wordWrapWidth + h,
          m = Ie.tokenize(e);
        for (let v = 0; v < m.length; v++) {
          let g = m[v];
          if (Ie.isNewline(g)) {
            if (!d) {
              (o += Ie.addLine(a)), (f = !u), (a = ""), (n = 0);
              continue;
            }
            g = " ";
          }
          if (u) {
            const b = Ie.isBreakingSpace(g),
              y = Ie.isBreakingSpace(a[a.length - 1]);
            if (b && y) continue;
          }
          const x = Ie.getFromCache(g, h, l, s);
          if (x > p)
            if (
              (a !== "" && ((o += Ie.addLine(a)), (a = ""), (n = 0)),
              Ie.canBreakWords(g, t.breakWords))
            ) {
              const b = Ie.wordWrapSplit(g);
              for (let y = 0; y < b.length; y++) {
                let _ = b[y],
                  w = _,
                  E = 1;
                for (; b[y + E]; ) {
                  const C = b[y + E];
                  if (!Ie.canBreakChars(w, C, g, y, t.breakWords)) _ += C;
                  else break;
                  (w = C), E++;
                }
                y += E - 1;
                const A = Ie.getFromCache(_, h, l, s);
                A + n > p &&
                  ((o += Ie.addLine(a)), (f = !1), (a = ""), (n = 0)),
                  (a += _),
                  (n += A);
              }
            } else {
              a.length > 0 && ((o += Ie.addLine(a)), (a = ""), (n = 0));
              const b = v === m.length - 1;
              (o += Ie.addLine(g, !b)), (f = !1), (a = ""), (n = 0);
            }
          else
            x + n > p && ((f = !1), (o += Ie.addLine(a)), (a = ""), (n = 0)),
              (a.length > 0 || !Ie.isBreakingSpace(g) || f) &&
                ((a += g), (n += x));
        }
        return (o += Ie.addLine(a, !1)), o;
      }
      static addLine(e, t = !0) {
        return (
          (e = Ie.trimRight(e)),
          (e = t
            ? `${e}
`
            : e),
          e
        );
      }
      static getFromCache(e, t, i, s) {
        let n = i[e];
        return (
          typeof n != "number" &&
            ((n = Ie._measureText(e, t, s) + t), (i[e] = n)),
          n
        );
      }
      static collapseSpaces(e) {
        return e === "normal" || e === "pre-line";
      }
      static collapseNewlines(e) {
        return e === "normal";
      }
      static trimRight(e) {
        if (typeof e != "string") return "";
        for (let t = e.length - 1; t >= 0; t--) {
          const i = e[t];
          if (!Ie.isBreakingSpace(i)) break;
          e = e.slice(0, -1);
        }
        return e;
      }
      static isNewline(e) {
        return typeof e != "string"
          ? !1
          : Ie._newlines.includes(e.charCodeAt(0));
      }
      static isBreakingSpace(e, t) {
        return typeof e != "string"
          ? !1
          : Ie._breakingSpaces.includes(e.charCodeAt(0));
      }
      static tokenize(e) {
        const t = [];
        let i = "";
        if (typeof e != "string") return t;
        for (let s = 0; s < e.length; s++) {
          const n = e[s],
            a = e[s + 1];
          if (Ie.isBreakingSpace(n, a) || Ie.isNewline(n)) {
            i !== "" && (t.push(i), (i = "")), t.push(n);
            continue;
          }
          i += n;
        }
        return i !== "" && t.push(i), t;
      }
      static canBreakWords(e, t) {
        return t;
      }
      static canBreakChars(e, t, i, s, n) {
        return !0;
      }
      static wordWrapSplit(e) {
        return Ie.graphemeSegmenter(e);
      }
      static measureFont(e) {
        if (Ie._fonts[e]) return Ie._fonts[e];
        const t = { ascent: 0, descent: 0, fontSize: 0 },
          i = Ie._canvas,
          s = Ie._context;
        s.font = e;
        const n = Ie.METRICS_STRING + Ie.BASELINE_SYMBOL,
          a = Math.ceil(s.measureText(n).width);
        let o = Math.ceil(s.measureText(Ie.BASELINE_SYMBOL).width);
        const l = Math.ceil(Ie.HEIGHT_MULTIPLIER * o);
        if (((o = (o * Ie.BASELINE_MULTIPLIER) | 0), a === 0 || l === 0))
          return (Ie._fonts[e] = t), t;
        (i.width = a),
          (i.height = l),
          (s.fillStyle = "#f00"),
          s.fillRect(0, 0, a, l),
          (s.font = e),
          (s.textBaseline = "alphabetic"),
          (s.fillStyle = "#000"),
          s.fillText(n, 0, o);
        const h = s.getImageData(0, 0, a, l).data,
          c = h.length,
          u = a * 4;
        let d = 0,
          f = 0,
          p = !1;
        for (d = 0; d < o; ++d) {
          for (let m = 0; m < u; m += 4)
            if (h[f + m] !== 255) {
              p = !0;
              break;
            }
          if (!p) f += u;
          else break;
        }
        for (t.ascent = o - d, f = c - u, p = !1, d = l; d > o; --d) {
          for (let m = 0; m < u; m += 4)
            if (h[f + m] !== 255) {
              p = !0;
              break;
            }
          if (!p) f -= u;
          else break;
        }
        return (
          (t.descent = d - o),
          (t.fontSize = t.ascent + t.descent),
          (Ie._fonts[e] = t),
          t
        );
      }
      static clearMetrics(e = "") {
        e ? delete Ie._fonts[e] : (Ie._fonts = {});
      }
      static get _canvas() {
        var e;
        if (!Ie.__canvas) {
          let t;
          try {
            const i = new OffscreenCanvas(0, 0);
            if ((e = i.getContext("2d", nh)) != null && e.measureText)
              return (Ie.__canvas = i), i;
            t = we.ADAPTER.createCanvas();
          } catch {
            t = we.ADAPTER.createCanvas();
          }
          (t.width = t.height = 10), (Ie.__canvas = t);
        }
        return Ie.__canvas;
      }
      static get _context() {
        return (
          Ie.__context || (Ie.__context = Ie._canvas.getContext("2d", nh)),
          Ie.__context
        );
      }
    };
  (Ci.METRICS_STRING = "|ÉqÅ"),
    (Ci.BASELINE_SYMBOL = "M"),
    (Ci.BASELINE_MULTIPLIER = 1.4),
    (Ci.HEIGHT_MULTIPLIER = 2),
    (Ci.graphemeSegmenter = (() => {
      if (typeof (Intl == null ? void 0 : Intl.Segmenter) == "function") {
        const r = new Intl.Segmenter();
        return (e) => [...r.segment(e)].map((t) => t.segment);
      }
      return (r) => [...r];
    })()),
    (Ci.experimentalLetterSpacing = !1),
    (Ci._fonts = {}),
    (Ci._newlines = [10, 13]),
    (Ci._breakingSpaces = [
      9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287,
      12288,
    ]);
  let Ds = Ci;
  const z6 = [
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui",
    ],
    O_ = class To {
      constructor(e) {
        (this.styleID = 0), this.reset(), sd(this, e, e);
      }
      clone() {
        const e = {};
        return sd(e, this, To.defaultStyle), new To(e);
      }
      reset() {
        sd(this, To.defaultStyle, To.defaultStyle);
      }
      get align() {
        return this._align;
      }
      set align(e) {
        this._align !== e && ((this._align = e), this.styleID++);
      }
      get breakWords() {
        return this._breakWords;
      }
      set breakWords(e) {
        this._breakWords !== e && ((this._breakWords = e), this.styleID++);
      }
      get dropShadow() {
        return this._dropShadow;
      }
      set dropShadow(e) {
        this._dropShadow !== e && ((this._dropShadow = e), this.styleID++);
      }
      get dropShadowAlpha() {
        return this._dropShadowAlpha;
      }
      set dropShadowAlpha(e) {
        this._dropShadowAlpha !== e &&
          ((this._dropShadowAlpha = e), this.styleID++);
      }
      get dropShadowAngle() {
        return this._dropShadowAngle;
      }
      set dropShadowAngle(e) {
        this._dropShadowAngle !== e &&
          ((this._dropShadowAngle = e), this.styleID++);
      }
      get dropShadowBlur() {
        return this._dropShadowBlur;
      }
      set dropShadowBlur(e) {
        this._dropShadowBlur !== e &&
          ((this._dropShadowBlur = e), this.styleID++);
      }
      get dropShadowColor() {
        return this._dropShadowColor;
      }
      set dropShadowColor(e) {
        const t = id(e);
        this._dropShadowColor !== t &&
          ((this._dropShadowColor = t), this.styleID++);
      }
      get dropShadowDistance() {
        return this._dropShadowDistance;
      }
      set dropShadowDistance(e) {
        this._dropShadowDistance !== e &&
          ((this._dropShadowDistance = e), this.styleID++);
      }
      get fill() {
        return this._fill;
      }
      set fill(e) {
        const t = id(e);
        this._fill !== t && ((this._fill = t), this.styleID++);
      }
      get fillGradientType() {
        return this._fillGradientType;
      }
      set fillGradientType(e) {
        this._fillGradientType !== e &&
          ((this._fillGradientType = e), this.styleID++);
      }
      get fillGradientStops() {
        return this._fillGradientStops;
      }
      set fillGradientStops(e) {
        W6(this._fillGradientStops, e) ||
          ((this._fillGradientStops = e), this.styleID++);
      }
      get fontFamily() {
        return this._fontFamily;
      }
      set fontFamily(e) {
        this.fontFamily !== e && ((this._fontFamily = e), this.styleID++);
      }
      get fontSize() {
        return this._fontSize;
      }
      set fontSize(e) {
        this._fontSize !== e && ((this._fontSize = e), this.styleID++);
      }
      get fontStyle() {
        return this._fontStyle;
      }
      set fontStyle(e) {
        this._fontStyle !== e && ((this._fontStyle = e), this.styleID++);
      }
      get fontVariant() {
        return this._fontVariant;
      }
      set fontVariant(e) {
        this._fontVariant !== e && ((this._fontVariant = e), this.styleID++);
      }
      get fontWeight() {
        return this._fontWeight;
      }
      set fontWeight(e) {
        this._fontWeight !== e && ((this._fontWeight = e), this.styleID++);
      }
      get letterSpacing() {
        return this._letterSpacing;
      }
      set letterSpacing(e) {
        this._letterSpacing !== e &&
          ((this._letterSpacing = e), this.styleID++);
      }
      get lineHeight() {
        return this._lineHeight;
      }
      set lineHeight(e) {
        this._lineHeight !== e && ((this._lineHeight = e), this.styleID++);
      }
      get leading() {
        return this._leading;
      }
      set leading(e) {
        this._leading !== e && ((this._leading = e), this.styleID++);
      }
      get lineJoin() {
        return this._lineJoin;
      }
      set lineJoin(e) {
        this._lineJoin !== e && ((this._lineJoin = e), this.styleID++);
      }
      get miterLimit() {
        return this._miterLimit;
      }
      set miterLimit(e) {
        this._miterLimit !== e && ((this._miterLimit = e), this.styleID++);
      }
      get padding() {
        return this._padding;
      }
      set padding(e) {
        this._padding !== e && ((this._padding = e), this.styleID++);
      }
      get stroke() {
        return this._stroke;
      }
      set stroke(e) {
        const t = id(e);
        this._stroke !== t && ((this._stroke = t), this.styleID++);
      }
      get strokeThickness() {
        return this._strokeThickness;
      }
      set strokeThickness(e) {
        this._strokeThickness !== e &&
          ((this._strokeThickness = e), this.styleID++);
      }
      get textBaseline() {
        return this._textBaseline;
      }
      set textBaseline(e) {
        this._textBaseline !== e && ((this._textBaseline = e), this.styleID++);
      }
      get trim() {
        return this._trim;
      }
      set trim(e) {
        this._trim !== e && ((this._trim = e), this.styleID++);
      }
      get whiteSpace() {
        return this._whiteSpace;
      }
      set whiteSpace(e) {
        this._whiteSpace !== e && ((this._whiteSpace = e), this.styleID++);
      }
      get wordWrap() {
        return this._wordWrap;
      }
      set wordWrap(e) {
        this._wordWrap !== e && ((this._wordWrap = e), this.styleID++);
      }
      get wordWrapWidth() {
        return this._wordWrapWidth;
      }
      set wordWrapWidth(e) {
        this._wordWrapWidth !== e &&
          ((this._wordWrapWidth = e), this.styleID++);
      }
      toFontString() {
        const e =
          typeof this.fontSize == "number"
            ? `${this.fontSize}px`
            : this.fontSize;
        let t = this.fontFamily;
        Array.isArray(this.fontFamily) || (t = this.fontFamily.split(","));
        for (let i = t.length - 1; i >= 0; i--) {
          let s = t[i].trim();
          !/([\"\'])[^\'\"]+\1/.test(s) && !z6.includes(s) && (s = `"${s}"`),
            (t[i] = s);
        }
        return `${this.fontStyle} ${this.fontVariant} ${
          this.fontWeight
        } ${e} ${t.join(",")}`;
      }
    };
  O_.defaultStyle = {
    align: "left",
    breakWords: !1,
    dropShadow: !1,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fillGradientType: Wc.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: "miter",
    miterLimit: 10,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    textBaseline: "alphabetic",
    trim: !1,
    whiteSpace: "pre",
    wordWrap: !1,
    wordWrapWidth: 100,
  };
  let js = O_;
  function id(r) {
    const e = lt.shared,
      t = (i) => {
        const s = e.setValue(i);
        return s.alpha === 1 ? s.toHex() : s.toRgbaString();
      };
    return Array.isArray(r) ? r.map(t) : t(r);
  }
  function W6(r, e) {
    if (!Array.isArray(r) || !Array.isArray(e) || r.length !== e.length)
      return !1;
    for (let t = 0; t < r.length; ++t) if (r[t] !== e[t]) return !1;
    return !0;
  }
  function sd(r, e, t) {
    for (const i in t)
      Array.isArray(e[i]) ? (r[i] = e[i].slice()) : (r[i] = e[i]);
  }
  const Y6 = { texture: !0, children: !1, baseTexture: !0 },
    k_ = class Ff extends to {
      constructor(e, t, i) {
        let s = !1;
        i || ((i = we.ADAPTER.createCanvas()), (s = !0)),
          (i.width = 3),
          (i.height = 3);
        const n = ze.from(i);
        (n.orig = new $e()),
          (n.trim = new $e()),
          super(n),
          (this._ownCanvas = s),
          (this.canvas = i),
          (this.context = i.getContext("2d", { willReadFrequently: !0 })),
          (this._resolution = Ff.defaultResolution ?? we.RESOLUTION),
          (this._autoResolution = Ff.defaultAutoResolution),
          (this._text = null),
          (this._style = null),
          (this._styleListener = null),
          (this._font = ""),
          (this.text = e),
          (this.style = t),
          (this.localStyleID = -1);
      }
      static get experimentalLetterSpacing() {
        return Ds.experimentalLetterSpacing;
      }
      static set experimentalLetterSpacing(e) {
        We(
          "7.1.0",
          "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing"
        ),
          (Ds.experimentalLetterSpacing = e);
      }
      updateText(e) {
        const t = this._style;
        if (
          (this.localStyleID !== t.styleID &&
            ((this.dirty = !0), (this.localStyleID = t.styleID)),
          !this.dirty && e)
        )
          return;
        this._font = this._style.toFontString();
        const i = this.context,
          s = Ds.measureText(
            this._text || " ",
            this._style,
            this._style.wordWrap,
            this.canvas
          ),
          n = s.width,
          a = s.height,
          o = s.lines,
          l = s.lineHeight,
          h = s.lineWidths,
          c = s.maxLineWidth,
          u = s.fontProperties;
        (this.canvas.width = Math.ceil(
          Math.ceil(Math.max(1, n) + t.padding * 2) * this._resolution
        )),
          (this.canvas.height = Math.ceil(
            Math.ceil(Math.max(1, a) + t.padding * 2) * this._resolution
          )),
          i.scale(this._resolution, this._resolution),
          i.clearRect(0, 0, this.canvas.width, this.canvas.height),
          (i.font = this._font),
          (i.lineWidth = t.strokeThickness),
          (i.textBaseline = t.textBaseline),
          (i.lineJoin = t.lineJoin),
          (i.miterLimit = t.miterLimit);
        let d, f;
        const p = t.dropShadow ? 2 : 1;
        for (let m = 0; m < p; ++m) {
          const v = t.dropShadow && m === 0,
            g = v ? Math.ceil(Math.max(1, a) + t.padding * 2) : 0,
            x = g * this._resolution;
          if (v) {
            (i.fillStyle = "black"), (i.strokeStyle = "black");
            const y = t.dropShadowColor,
              _ = t.dropShadowBlur * this._resolution,
              w = t.dropShadowDistance * this._resolution;
            (i.shadowColor = lt.shared
              .setValue(y)
              .setAlpha(t.dropShadowAlpha)
              .toRgbaString()),
              (i.shadowBlur = _),
              (i.shadowOffsetX = Math.cos(t.dropShadowAngle) * w),
              (i.shadowOffsetY = Math.sin(t.dropShadowAngle) * w + x);
          } else
            (i.fillStyle = this._generateFillStyle(t, o, s)),
              (i.strokeStyle = t.stroke),
              (i.shadowColor = "black"),
              (i.shadowBlur = 0),
              (i.shadowOffsetX = 0),
              (i.shadowOffsetY = 0);
          let b = (l - u.fontSize) / 2;
          l - u.fontSize < 0 && (b = 0);
          for (let y = 0; y < o.length; y++)
            (d = t.strokeThickness / 2),
              (f = t.strokeThickness / 2 + y * l + u.ascent + b),
              t.align === "right"
                ? (d += c - h[y])
                : t.align === "center" && (d += (c - h[y]) / 2),
              t.stroke &&
                t.strokeThickness &&
                this.drawLetterSpacing(
                  o[y],
                  d + t.padding,
                  f + t.padding - g,
                  !0
                ),
              t.fill &&
                this.drawLetterSpacing(o[y], d + t.padding, f + t.padding - g);
        }
        this.updateTexture();
      }
      drawLetterSpacing(e, t, i, s = !1) {
        const n = this._style.letterSpacing;
        let a = !1;
        if (
          (Ds.experimentalLetterSpacingSupported &&
            (Ds.experimentalLetterSpacing
              ? ((this.context.letterSpacing = `${n}px`),
                (this.context.textLetterSpacing = `${n}px`),
                (a = !0))
              : ((this.context.letterSpacing = "0px"),
                (this.context.textLetterSpacing = "0px"))),
          n === 0 || a)
        ) {
          s ? this.context.strokeText(e, t, i) : this.context.fillText(e, t, i);
          return;
        }
        let o = t;
        const l = Ds.graphemeSegmenter(e);
        let h = this.context.measureText(e).width,
          c = 0;
        for (let u = 0; u < l.length; ++u) {
          const d = l[u];
          s ? this.context.strokeText(d, o, i) : this.context.fillText(d, o, i);
          let f = "";
          for (let p = u + 1; p < l.length; ++p) f += l[p];
          (c = this.context.measureText(f).width), (o += h - c + n), (h = c);
        }
      }
      updateTexture() {
        const e = this.canvas;
        if (this._style.trim) {
          const a = mN(e);
          a.data &&
            ((e.width = a.width),
            (e.height = a.height),
            this.context.putImageData(a.data, 0, 0));
        }
        const t = this._texture,
          i = this._style,
          s = i.trim ? 0 : i.padding,
          n = t.baseTexture;
        (t.trim.width = t._frame.width = e.width / this._resolution),
          (t.trim.height = t._frame.height = e.height / this._resolution),
          (t.trim.x = -s),
          (t.trim.y = -s),
          (t.orig.width = t._frame.width - s * 2),
          (t.orig.height = t._frame.height - s * 2),
          this._onTextureUpdate(),
          n.setRealSize(e.width, e.height, this._resolution),
          t.updateUvs(),
          (this.dirty = !1);
      }
      _render(e) {
        this._autoResolution &&
          this._resolution !== e.resolution &&
          ((this._resolution = e.resolution), (this.dirty = !0)),
          this.updateText(!0),
          super._render(e);
      }
      updateTransform() {
        this.updateText(!0), super.updateTransform();
      }
      getBounds(e, t) {
        return (
          this.updateText(!0),
          this._textureID === -1 && (e = !1),
          super.getBounds(e, t)
        );
      }
      getLocalBounds(e) {
        return this.updateText(!0), super.getLocalBounds.call(this, e);
      }
      _calculateBounds() {
        this.calculateVertices(), this._bounds.addQuad(this.vertexData);
      }
      _generateFillStyle(e, t, i) {
        const s = e.fill;
        if (Array.isArray(s)) {
          if (s.length === 1) return s[0];
        } else return s;
        let n;
        const a = e.dropShadow ? e.dropShadowDistance : 0,
          o = e.padding || 0,
          l = this.canvas.width / this._resolution - a - o * 2,
          h = this.canvas.height / this._resolution - a - o * 2,
          c = s.slice(),
          u = e.fillGradientStops.slice();
        if (!u.length) {
          const d = c.length + 1;
          for (let f = 1; f < d; ++f) u.push(f / d);
        }
        if (
          (c.unshift(s[0]),
          u.unshift(0),
          c.push(s[s.length - 1]),
          u.push(1),
          e.fillGradientType === Wc.LINEAR_VERTICAL)
        ) {
          n = this.context.createLinearGradient(l / 2, o, l / 2, h + o);
          const d = i.fontProperties.fontSize + e.strokeThickness;
          for (let f = 0; f < t.length; f++) {
            const p = i.lineHeight * (f - 1) + d,
              m = i.lineHeight * f;
            let v = m;
            f > 0 && p > m && (v = (m + p) / 2);
            const g = m + d,
              x = i.lineHeight * (f + 1);
            let b = g;
            f + 1 < t.length && x < g && (b = (g + x) / 2);
            const y = (b - v) / h;
            for (let _ = 0; _ < c.length; _++) {
              let w = 0;
              typeof u[_] == "number" ? (w = u[_]) : (w = _ / c.length);
              let E = Math.min(1, Math.max(0, v / h + w * y));
              (E = Number(E.toFixed(5))), n.addColorStop(E, c[_]);
            }
          }
        } else {
          n = this.context.createLinearGradient(o, h / 2, l + o, h / 2);
          const d = c.length + 1;
          let f = 1;
          for (let p = 0; p < c.length; p++) {
            let m;
            typeof u[p] == "number" ? (m = u[p]) : (m = f / d),
              n.addColorStop(m, c[p]),
              f++;
          }
        }
        return n;
      }
      destroy(e) {
        typeof e == "boolean" && (e = { children: e }),
          (e = Object.assign({}, Y6, e)),
          super.destroy(e),
          this._ownCanvas && (this.canvas.height = this.canvas.width = 0),
          (this.context = null),
          (this.canvas = null),
          (this._style = null);
      }
      get width() {
        return (
          this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width
        );
      }
      set width(e) {
        this.updateText(!0);
        const t = Gs(this.scale.x) || 1;
        (this.scale.x = (t * e) / this._texture.orig.width), (this._width = e);
      }
      get height() {
        return (
          this.updateText(!0),
          Math.abs(this.scale.y) * this._texture.orig.height
        );
      }
      set height(e) {
        this.updateText(!0);
        const t = Gs(this.scale.y) || 1;
        (this.scale.y = (t * e) / this._texture.orig.height),
          (this._height = e);
      }
      get style() {
        return this._style;
      }
      set style(e) {
        (e = e || {}),
          e instanceof js ? (this._style = e) : (this._style = new js(e)),
          (this.localStyleID = -1),
          (this.dirty = !0);
      }
      get text() {
        return this._text;
      }
      set text(e) {
        (e = String(e ?? "")),
          this._text !== e && ((this._text = e), (this.dirty = !0));
      }
      get resolution() {
        return this._resolution;
      }
      set resolution(e) {
        (this._autoResolution = !1),
          this._resolution !== e && ((this._resolution = e), (this.dirty = !0));
      }
    };
  k_.defaultAutoResolution = !0;
  let D_ = k_;
  class j6 {
    constructor(e) {
      (this.maxItemsPerFrame = e), (this.itemsLeft = 0);
    }
    beginFrame() {
      this.itemsLeft = this.maxItemsPerFrame;
    }
    allowedToUpload() {
      return this.itemsLeft-- > 0;
    }
  }
  function q6(r, e) {
    var i;
    let t = !1;
    if ((i = r == null ? void 0 : r._textures) != null && i.length) {
      for (let s = 0; s < r._textures.length; s++)
        if (r._textures[s] instanceof ze) {
          const n = r._textures[s].baseTexture;
          e.includes(n) || (e.push(n), (t = !0));
        }
    }
    return t;
  }
  function K6(r, e) {
    if (r.baseTexture instanceof Le) {
      const t = r.baseTexture;
      return e.includes(t) || e.push(t), !0;
    }
    return !1;
  }
  function Z6(r, e) {
    if (r._texture && r._texture instanceof ze) {
      const t = r._texture.baseTexture;
      return e.includes(t) || e.push(t), !0;
    }
    return !1;
  }
  function J6(r, e) {
    return e instanceof D_ ? (e.updateText(!0), !0) : !1;
  }
  function Q6(r, e) {
    if (e instanceof js) {
      const t = e.toFontString();
      return Ds.measureFont(t), !0;
    }
    return !1;
  }
  function e5(r, e) {
    if (r instanceof D_) {
      e.includes(r.style) || e.push(r.style), e.includes(r) || e.push(r);
      const t = r._texture.baseTexture;
      return e.includes(t) || e.push(t), !0;
    }
    return !1;
  }
  function t5(r, e) {
    return r instanceof js ? (e.includes(r) || e.push(r), !0) : !1;
  }
  const L_ = class N_ {
    constructor(e) {
      (this.limiter = new j6(N_.uploadsPerFrame)),
        (this.renderer = e),
        (this.uploadHookHelper = null),
        (this.queue = []),
        (this.addHooks = []),
        (this.uploadHooks = []),
        (this.completes = []),
        (this.ticking = !1),
        (this.delayedTick = () => {
          this.queue && this.prepareItems();
        }),
        this.registerFindHook(e5),
        this.registerFindHook(t5),
        this.registerFindHook(q6),
        this.registerFindHook(K6),
        this.registerFindHook(Z6),
        this.registerUploadHook(J6),
        this.registerUploadHook(Q6);
    }
    upload(e) {
      return new Promise((t) => {
        e && this.add(e),
          this.queue.length
            ? (this.completes.push(t),
              this.ticking ||
                ((this.ticking = !0),
                nr.system.addOnce(this.tick, this, Ln.UTILITY)))
            : t();
      });
    }
    tick() {
      setTimeout(this.delayedTick, 0);
    }
    prepareItems() {
      for (
        this.limiter.beginFrame();
        this.queue.length && this.limiter.allowedToUpload();

      ) {
        const e = this.queue[0];
        let t = !1;
        if (e && !e._destroyed) {
          for (let i = 0, s = this.uploadHooks.length; i < s; i++)
            if (this.uploadHooks[i](this.uploadHookHelper, e)) {
              this.queue.shift(), (t = !0);
              break;
            }
        }
        t || this.queue.shift();
      }
      if (this.queue.length) nr.system.addOnce(this.tick, this, Ln.UTILITY);
      else {
        this.ticking = !1;
        const e = this.completes.slice(0);
        this.completes.length = 0;
        for (let t = 0, i = e.length; t < i; t++) e[t]();
      }
    }
    registerFindHook(e) {
      return e && this.addHooks.push(e), this;
    }
    registerUploadHook(e) {
      return e && this.uploadHooks.push(e), this;
    }
    add(e) {
      for (
        let t = 0, i = this.addHooks.length;
        t < i && !this.addHooks[t](e, this.queue);
        t++
      );
      if (e instanceof jr)
        for (let t = e.children.length - 1; t >= 0; t--)
          this.add(e.children[t]);
      return this;
    }
    destroy() {
      this.ticking && nr.system.remove(this.tick, this),
        (this.ticking = !1),
        (this.addHooks = null),
        (this.uploadHooks = null),
        (this.renderer = null),
        (this.completes = null),
        (this.queue = null),
        (this.limiter = null),
        (this.uploadHookHelper = null);
    }
  };
  L_.uploadsPerFrame = 4;
  let Bf = L_;
  Object.defineProperties(we, {
    UPLOADS_PER_FRAME: {
      get() {
        return Bf.uploadsPerFrame;
      },
      set(r) {
        We(
          "7.1.0",
          "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame"
        ),
          (Bf.uploadsPerFrame = r);
      },
    },
  });
  function U_(r, e) {
    return e instanceof Le
      ? (e._glTextures[r.CONTEXT_UID] || r.texture.bind(e), !0)
      : !1;
  }
  function r5(r, e) {
    if (!(e instanceof zc)) return !1;
    const { geometry: t } = e;
    e.finishPoly(), t.updateBatches();
    const { batches: i } = t;
    for (let s = 0; s < i.length; s++) {
      const { texture: n } = i[s].style;
      n && U_(r, n.baseTexture);
    }
    return t.batchable || r.geometry.bind(t, e._resolveDirectShader(r)), !0;
  }
  function i5(r, e) {
    return r instanceof zc ? (e.push(r), !0) : !1;
  }
  class V_ extends Bf {
    constructor(e) {
      super(e),
        (this.uploadHookHelper = this.renderer),
        this.registerFindHook(i5),
        this.registerUploadHook(U_),
        this.registerUploadHook(r5);
    }
  }
  V_.extension = { name: "prepare", type: me.RendererSystem };
  Ce.add(V_);
  var s5 = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`,
    n5 = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`,
    a5 = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`,
    ry = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`,
    o5 = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`;
  const ah = new vt();
  class $_ extends Gc {
    constructor(e) {
      super(e),
        e.runners.contextChange.add(this),
        (this.quad = new X1()),
        (this.state = ji.for2d());
    }
    contextChange() {
      const e = this.renderer,
        t = { globals: e.globalUniforms };
      (this.simpleShader = fi.from(ry, o5, t)),
        (this.shader =
          e.context.webGLVersion > 1 ? fi.from(n5, s5, t) : fi.from(ry, a5, t));
    }
    render(e) {
      const t = this.renderer,
        i = this.quad;
      let s = i.vertices;
      (s[0] = s[6] = e._width * -e.anchor.x),
        (s[1] = s[3] = e._height * -e.anchor.y),
        (s[2] = s[4] = e._width * (1 - e.anchor.x)),
        (s[5] = s[7] = e._height * (1 - e.anchor.y));
      const n = e.uvRespectAnchor ? e.anchor.x : 0,
        a = e.uvRespectAnchor ? e.anchor.y : 0;
      (s = i.uvs),
        (s[0] = s[6] = -n),
        (s[1] = s[3] = -a),
        (s[2] = s[4] = 1 - n),
        (s[5] = s[7] = 1 - a),
        i.invalidate();
      const o = e._texture,
        l = o.baseTexture,
        h = l.alphaMode > 0,
        c = e.tileTransform.localTransform,
        u = e.uvMatrix;
      let d =
        l.isPowerOfTwo &&
        o.frame.width === l.width &&
        o.frame.height === l.height;
      d &&
        (l._glTextures[t.CONTEXT_UID]
          ? (d = l.wrapMode !== ci.CLAMP)
          : l.wrapMode === ci.CLAMP && (l.wrapMode = ci.REPEAT));
      const f = d ? this.simpleShader : this.shader,
        p = o.width,
        m = o.height,
        v = e._width,
        g = e._height;
      ah.set(
        (c.a * p) / v,
        (c.b * p) / g,
        (c.c * m) / v,
        (c.d * m) / g,
        c.tx / v,
        c.ty / g
      ),
        ah.invert(),
        d
          ? ah.prepend(u.mapCoord)
          : ((f.uniforms.uMapCoord = u.mapCoord.toArray(!0)),
            (f.uniforms.uClampFrame = u.uClampFrame),
            (f.uniforms.uClampOffset = u.uClampOffset)),
        (f.uniforms.uTransform = ah.toArray(!0)),
        (f.uniforms.uColor = lt.shared
          .setValue(e.tint)
          .premultiply(e.worldAlpha, h)
          .toArray(f.uniforms.uColor)),
        (f.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0)),
        (f.uniforms.uSampler = o),
        t.shader.bind(f),
        t.geometry.bind(i),
        (this.state.blendMode = R1(e.blendMode, h)),
        t.state.set(this.state),
        t.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
    }
  }
  $_.extension = { name: "tilingSprite", type: me.RendererPlugin };
  Ce.add($_);
  const G_ = class Eo {
    constructor(e, t, i) {
      (this.linkedSheets = []),
        (e instanceof Le || e instanceof ze) &&
          (e = { texture: e, data: t, resolutionFilename: i });
      const {
        texture: s,
        data: n,
        resolutionFilename: a = null,
        cachePrefix: o = "",
      } = e;
      (this.cachePrefix = o),
        (this._texture = s instanceof ze ? s : null),
        (this.baseTexture = s instanceof Le ? s : this._texture.baseTexture),
        (this.textures = {}),
        (this.animations = {}),
        (this.data = n);
      const l = this.baseTexture.resource;
      (this.resolution = this._updateResolution(a || (l ? l.url : null))),
        (this._frames = this.data.frames),
        (this._frameKeys = Object.keys(this._frames)),
        (this._batchIndex = 0),
        (this._callback = null);
    }
    _updateResolution(e = null) {
      const { scale: t } = this.data.meta;
      let i = vs(e, null);
      return (
        i === null && (i = typeof t == "number" ? t : parseFloat(t ?? "1")),
        i !== 1 && this.baseTexture.setResolution(i),
        i
      );
    }
    parse() {
      return new Promise((e) => {
        (this._callback = e),
          (this._batchIndex = 0),
          this._frameKeys.length <= Eo.BATCH_SIZE
            ? (this._processFrames(0),
              this._processAnimations(),
              this._parseComplete())
            : this._nextBatch();
      });
    }
    _processFrames(e) {
      let t = e;
      const i = Eo.BATCH_SIZE;
      for (; t - e < i && t < this._frameKeys.length; ) {
        const s = this._frameKeys[t],
          n = this._frames[s],
          a = n.frame;
        if (a) {
          let o = null,
            l = null;
          const h = n.trimmed !== !1 && n.sourceSize ? n.sourceSize : n.frame,
            c = new $e(
              0,
              0,
              Math.floor(h.w) / this.resolution,
              Math.floor(h.h) / this.resolution
            );
          n.rotated
            ? (o = new $e(
                Math.floor(a.x) / this.resolution,
                Math.floor(a.y) / this.resolution,
                Math.floor(a.h) / this.resolution,
                Math.floor(a.w) / this.resolution
              ))
            : (o = new $e(
                Math.floor(a.x) / this.resolution,
                Math.floor(a.y) / this.resolution,
                Math.floor(a.w) / this.resolution,
                Math.floor(a.h) / this.resolution
              )),
            n.trimmed !== !1 &&
              n.spriteSourceSize &&
              (l = new $e(
                Math.floor(n.spriteSourceSize.x) / this.resolution,
                Math.floor(n.spriteSourceSize.y) / this.resolution,
                Math.floor(a.w) / this.resolution,
                Math.floor(a.h) / this.resolution
              )),
            (this.textures[s] = new ze(
              this.baseTexture,
              o,
              c,
              l,
              n.rotated ? 2 : 0,
              n.anchor,
              n.borders
            )),
            ze.addToCache(this.textures[s], this.cachePrefix + s.toString());
        }
        t++;
      }
    }
    _processAnimations() {
      const e = this.data.animations || {};
      for (const t in e) {
        this.animations[t] = [];
        for (let i = 0; i < e[t].length; i++) {
          const s = e[t][i];
          this.animations[t].push(this.textures[s]);
        }
      }
    }
    _parseComplete() {
      const e = this._callback;
      (this._callback = null),
        (this._batchIndex = 0),
        e.call(this, this.textures);
    }
    _nextBatch() {
      this._processFrames(this._batchIndex * Eo.BATCH_SIZE),
        this._batchIndex++,
        setTimeout(() => {
          this._batchIndex * Eo.BATCH_SIZE < this._frameKeys.length
            ? this._nextBatch()
            : (this._processAnimations(), this._parseComplete());
        }, 0);
    }
    destroy(e = !1) {
      var t;
      for (const i in this.textures) this.textures[i].destroy();
      (this._frames = null),
        (this._frameKeys = null),
        (this.data = null),
        (this.textures = null),
        e &&
          ((t = this._texture) == null || t.destroy(),
          this.baseTexture.destroy()),
        (this._texture = null),
        (this.baseTexture = null),
        (this.linkedSheets = []);
    }
  };
  G_.BATCH_SIZE = 1e3;
  let iy = G_;
  const l5 = [
    "jpg",
    "png",
    "jpeg",
    "avif",
    "webp",
    "s3tc",
    "s3tc_sRGB",
    "etc",
    "etc1",
    "pvrtc",
    "atc",
    "astc",
    "bptc",
  ];
  function H_(r, e, t) {
    const i = {};
    if (
      (r.forEach((s) => {
        i[s] = e;
      }),
      Object.keys(e.textures).forEach((s) => {
        i[`${e.cachePrefix}${s}`] = e.textures[s];
      }),
      !t)
    ) {
      const s = Pt.dirname(r[0]);
      e.linkedSheets.forEach((n, a) => {
        Object.assign(
          i,
          H_([`${s}/${e.data.meta.related_multi_packs[a]}`], n, !0)
        );
      });
    }
    return i;
  }
  const h5 = {
    extension: me.Asset,
    cache: {
      test: (r) => r instanceof iy,
      getCacheableAssets: (r, e) => H_(r, e, !1),
    },
    resolver: {
      test: (r) => {
        const e = r.split("?")[0].split("."),
          t = e.pop(),
          i = e.pop();
        return t === "json" && l5.includes(i);
      },
      parse: (r) => {
        var t;
        const e = r.split(".");
        return {
          resolution: parseFloat(
            ((t = we.RETINA_PREFIX.exec(r)) == null ? void 0 : t[1]) ?? "1"
          ),
          format: e[e.length - 2],
          src: r,
        };
      },
    },
    loader: {
      name: "spritesheetLoader",
      extension: { type: me.LoadParser, priority: kr.Normal },
      async testParse(r, e) {
        return Pt.extname(e.src).toLowerCase() === ".json" && !!r.frames;
      },
      async parse(r, e, t) {
        var c, u;
        const {
          texture: i,
          imageFilename: s,
          cachePrefix: n,
        } = (e == null ? void 0 : e.data) ?? {};
        let a = Pt.dirname(e.src);
        a && a.lastIndexOf("/") !== a.length - 1 && (a += "/");
        let o;
        if (i && i.baseTexture) o = i;
        else {
          const d = Cf(a + (s ?? r.meta.image), e.src);
          o = (await t.load([d]))[d];
        }
        const l = new iy({
          texture: o.baseTexture,
          data: r,
          resolutionFilename: e.src,
          cachePrefix: n,
        });
        await l.parse();
        const h =
          (c = r == null ? void 0 : r.meta) == null
            ? void 0
            : c.related_multi_packs;
        if (Array.isArray(h)) {
          const d = [];
          for (const p of h) {
            if (typeof p != "string") continue;
            let m = a + p;
            ((u = e.data) != null && u.ignoreMultiPack) ||
              ((m = Cf(m, e.src)),
              d.push(t.load({ src: m, data: { ignoreMultiPack: !0 } })));
          }
          const f = await Promise.all(d);
          (l.linkedSheets = f),
            f.forEach((p) => {
              p.linkedSheets = [l].concat(
                l.linkedSheets.filter((m) => m !== p)
              );
            });
        }
        return l;
      },
      unload(r) {
        r.destroy(!0);
      },
    },
  };
  Ce.add(h5);
  class ic {
    constructor() {
      (this.info = []),
        (this.common = []),
        (this.page = []),
        (this.char = []),
        (this.kerning = []),
        (this.distanceField = []);
    }
  }
  class Th {
    static test(e) {
      return typeof e == "string" && e.startsWith("info face=");
    }
    static parse(e) {
      const t = e.match(/^[a-z]+\s+.+$/gm),
        i = {
          info: [],
          common: [],
          page: [],
          char: [],
          chars: [],
          kerning: [],
          kernings: [],
          distanceField: [],
        };
      for (const n in t) {
        const a = t[n].match(/^[a-z]+/gm)[0],
          o = t[n].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
          l = {};
        for (const h in o) {
          const c = o[h].split("="),
            u = c[0],
            d = c[1].replace(/"/gm, ""),
            f = parseFloat(d),
            p = isNaN(f) ? d : f;
          l[u] = p;
        }
        i[a].push(l);
      }
      const s = new ic();
      return (
        i.info.forEach((n) =>
          s.info.push({ face: n.face, size: parseInt(n.size, 10) })
        ),
        i.common.forEach((n) =>
          s.common.push({ lineHeight: parseInt(n.lineHeight, 10) })
        ),
        i.page.forEach((n) =>
          s.page.push({ id: parseInt(n.id, 10), file: n.file })
        ),
        i.char.forEach((n) =>
          s.char.push({
            id: parseInt(n.id, 10),
            page: parseInt(n.page, 10),
            x: parseInt(n.x, 10),
            y: parseInt(n.y, 10),
            width: parseInt(n.width, 10),
            height: parseInt(n.height, 10),
            xoffset: parseInt(n.xoffset, 10),
            yoffset: parseInt(n.yoffset, 10),
            xadvance: parseInt(n.xadvance, 10),
          })
        ),
        i.kerning.forEach((n) =>
          s.kerning.push({
            first: parseInt(n.first, 10),
            second: parseInt(n.second, 10),
            amount: parseInt(n.amount, 10),
          })
        ),
        i.distanceField.forEach((n) =>
          s.distanceField.push({
            distanceRange: parseInt(n.distanceRange, 10),
            fieldType: n.fieldType,
          })
        ),
        s
      );
    }
  }
  class Of {
    static test(e) {
      const t = e;
      return (
        typeof e != "string" &&
        "getElementsByTagName" in e &&
        t.getElementsByTagName("page").length &&
        t.getElementsByTagName("info")[0].getAttribute("face") !== null
      );
    }
    static parse(e) {
      const t = new ic(),
        i = e.getElementsByTagName("info"),
        s = e.getElementsByTagName("common"),
        n = e.getElementsByTagName("page"),
        a = e.getElementsByTagName("char"),
        o = e.getElementsByTagName("kerning"),
        l = e.getElementsByTagName("distanceField");
      for (let h = 0; h < i.length; h++)
        t.info.push({
          face: i[h].getAttribute("face"),
          size: parseInt(i[h].getAttribute("size"), 10),
        });
      for (let h = 0; h < s.length; h++)
        t.common.push({
          lineHeight: parseInt(s[h].getAttribute("lineHeight"), 10),
        });
      for (let h = 0; h < n.length; h++)
        t.page.push({
          id: parseInt(n[h].getAttribute("id"), 10) || 0,
          file: n[h].getAttribute("file"),
        });
      for (let h = 0; h < a.length; h++) {
        const c = a[h];
        t.char.push({
          id: parseInt(c.getAttribute("id"), 10),
          page: parseInt(c.getAttribute("page"), 10) || 0,
          x: parseInt(c.getAttribute("x"), 10),
          y: parseInt(c.getAttribute("y"), 10),
          width: parseInt(c.getAttribute("width"), 10),
          height: parseInt(c.getAttribute("height"), 10),
          xoffset: parseInt(c.getAttribute("xoffset"), 10),
          yoffset: parseInt(c.getAttribute("yoffset"), 10),
          xadvance: parseInt(c.getAttribute("xadvance"), 10),
        });
      }
      for (let h = 0; h < o.length; h++)
        t.kerning.push({
          first: parseInt(o[h].getAttribute("first"), 10),
          second: parseInt(o[h].getAttribute("second"), 10),
          amount: parseInt(o[h].getAttribute("amount"), 10),
        });
      for (let h = 0; h < l.length; h++)
        t.distanceField.push({
          fieldType: l[h].getAttribute("fieldType"),
          distanceRange: parseInt(l[h].getAttribute("distanceRange"), 10),
        });
      return t;
    }
  }
  class kf {
    static test(e) {
      return typeof e == "string" && e.includes("<font>")
        ? Of.test(we.ADAPTER.parseXML(e))
        : !1;
    }
    static parse(e) {
      return Of.parse(we.ADAPTER.parseXML(e));
    }
  }
  const nd = [Th, Of, kf];
  function c5(r) {
    for (let e = 0; e < nd.length; e++) if (nd[e].test(r)) return nd[e];
    return null;
  }
  function u5(r, e, t, i, s, n) {
    const a = t.fill;
    if (Array.isArray(a)) {
      if (a.length === 1) return a[0];
    } else return a;
    let o;
    const l = t.dropShadow ? t.dropShadowDistance : 0,
      h = t.padding || 0,
      c = r.width / i - l - h * 2,
      u = r.height / i - l - h * 2,
      d = a.slice(),
      f = t.fillGradientStops.slice();
    if (!f.length) {
      const p = d.length + 1;
      for (let m = 1; m < p; ++m) f.push(m / p);
    }
    if (
      (d.unshift(a[0]),
      f.unshift(0),
      d.push(a[a.length - 1]),
      f.push(1),
      t.fillGradientType === Wc.LINEAR_VERTICAL)
    ) {
      o = e.createLinearGradient(c / 2, h, c / 2, u + h);
      let p = 0;
      const m = (n.fontProperties.fontSize + t.strokeThickness) / u;
      for (let v = 0; v < s.length; v++) {
        const g = n.lineHeight * v;
        for (let x = 0; x < d.length; x++) {
          let b = 0;
          typeof f[x] == "number" ? (b = f[x]) : (b = x / d.length);
          const y = g / u + b * m;
          let _ = Math.max(p, y);
          (_ = Math.min(_, 1)), o.addColorStop(_, d[x]), (p = _);
        }
      }
    } else {
      o = e.createLinearGradient(h, u / 2, c + h, u / 2);
      const p = d.length + 1;
      let m = 1;
      for (let v = 0; v < d.length; v++) {
        let g;
        typeof f[v] == "number" ? (g = f[v]) : (g = m / p),
          o.addColorStop(g, d[v]),
          m++;
      }
    }
    return o;
  }
  function d5(r, e, t, i, s, n, a) {
    const o = t.text,
      l = t.fontProperties;
    e.translate(i, s), e.scale(n, n);
    const h = a.strokeThickness / 2,
      c = -(a.strokeThickness / 2);
    if (
      ((e.font = a.toFontString()),
      (e.lineWidth = a.strokeThickness),
      (e.textBaseline = a.textBaseline),
      (e.lineJoin = a.lineJoin),
      (e.miterLimit = a.miterLimit),
      (e.fillStyle = u5(r, e, a, n, [o], t)),
      (e.strokeStyle = a.stroke),
      a.dropShadow)
    ) {
      const u = a.dropShadowColor,
        d = a.dropShadowBlur * n,
        f = a.dropShadowDistance * n;
      (e.shadowColor = lt.shared
        .setValue(u)
        .setAlpha(a.dropShadowAlpha)
        .toRgbaString()),
        (e.shadowBlur = d),
        (e.shadowOffsetX = Math.cos(a.dropShadowAngle) * f),
        (e.shadowOffsetY = Math.sin(a.dropShadowAngle) * f);
    } else
      (e.shadowColor = "black"),
        (e.shadowBlur = 0),
        (e.shadowOffsetX = 0),
        (e.shadowOffsetY = 0);
    a.stroke &&
      a.strokeThickness &&
      e.strokeText(o, h, c + t.lineHeight - l.descent),
      a.fill && e.fillText(o, h, c + t.lineHeight - l.descent),
      e.setTransform(1, 0, 0, 1, 0, 0),
      (e.fillStyle = "rgba(0, 0, 0, 0)");
  }
  function Eh(r) {
    return r.codePointAt ? r.codePointAt(0) : r.charCodeAt(0);
  }
  function X_(r) {
    return Array.from ? Array.from(r) : r.split("");
  }
  function f5(r) {
    typeof r == "string" && (r = [r]);
    const e = [];
    for (let t = 0, i = r.length; t < i; t++) {
      const s = r[t];
      if (Array.isArray(s)) {
        if (s.length !== 2)
          throw new Error(
            `[BitmapFont]: Invalid character range length, expecting 2 got ${s.length}.`
          );
        const n = s[0].charCodeAt(0),
          a = s[1].charCodeAt(0);
        if (a < n) throw new Error("[BitmapFont]: Invalid character range.");
        for (let o = n, l = a; o <= l; o++) e.push(String.fromCharCode(o));
      } else e.push(...X_(s));
    }
    if (e.length === 0)
      throw new Error("[BitmapFont]: Empty set when resolving characters.");
    return e;
  }
  const Ps = class Ii {
    constructor(e, t, i) {
      var c;
      const [s] = e.info,
        [n] = e.common,
        [a] = e.page,
        [o] = e.distanceField,
        l = vs(a.file),
        h = {};
      (this._ownsTextures = i),
        (this.font = s.face),
        (this.size = s.size),
        (this.lineHeight = n.lineHeight / l),
        (this.chars = {}),
        (this.pageTextures = h);
      for (let u = 0; u < e.page.length; u++) {
        const { id: d, file: f } = e.page[u];
        (h[d] = t instanceof Array ? t[u] : t[f]),
          o != null &&
            o.fieldType &&
            o.fieldType !== "none" &&
            ((h[d].baseTexture.alphaMode = sr.NO_PREMULTIPLIED_ALPHA),
            (h[d].baseTexture.mipmap = Yr.OFF));
      }
      for (let u = 0; u < e.char.length; u++) {
        const { id: d, page: f } = e.char[u];
        let {
          x: p,
          y: m,
          width: v,
          height: g,
          xoffset: x,
          yoffset: b,
          xadvance: y,
        } = e.char[u];
        (p /= l), (m /= l), (v /= l), (g /= l), (x /= l), (b /= l), (y /= l);
        const _ = new $e(p + h[f].frame.x / l, m + h[f].frame.y / l, v, g);
        this.chars[d] = {
          xOffset: x,
          yOffset: b,
          xAdvance: y,
          kerning: {},
          texture: new ze(h[f].baseTexture, _),
          page: f,
        };
      }
      for (let u = 0; u < e.kerning.length; u++) {
        let { first: d, second: f, amount: p } = e.kerning[u];
        (d /= l),
          (f /= l),
          (p /= l),
          this.chars[f] && (this.chars[f].kerning[d] = p);
      }
      (this.distanceFieldRange = o == null ? void 0 : o.distanceRange),
        (this.distanceFieldType =
          ((c = o == null ? void 0 : o.fieldType) == null
            ? void 0
            : c.toLowerCase()) ?? "none");
    }
    destroy() {
      for (const e in this.chars)
        this.chars[e].texture.destroy(), (this.chars[e].texture = null);
      for (const e in this.pageTextures)
        this._ownsTextures && this.pageTextures[e].destroy(!0),
          (this.pageTextures[e] = null);
      (this.chars = null), (this.pageTextures = null);
    }
    static install(e, t, i) {
      let s;
      if (e instanceof ic) s = e;
      else {
        const a = c5(e);
        if (!a) throw new Error("Unrecognized data format for font.");
        s = a.parse(e);
      }
      t instanceof ze && (t = [t]);
      const n = new Ii(s, t, i);
      return (Ii.available[n.font] = n), n;
    }
    static uninstall(e) {
      const t = Ii.available[e];
      if (!t) throw new Error(`No font found named '${e}'`);
      t.destroy(), delete Ii.available[e];
    }
    static from(e, t, i) {
      if (!e) throw new Error("[BitmapFont] Property `name` is required.");
      const {
          chars: s,
          padding: n,
          resolution: a,
          textureWidth: o,
          textureHeight: l,
          ...h
        } = Object.assign({}, Ii.defaultOptions, i),
        c = f5(s),
        u = t instanceof js ? t : new js(t),
        d = o,
        f = new ic();
      (f.info[0] = { face: u.fontFamily, size: u.fontSize }),
        (f.common[0] = { lineHeight: u.fontSize });
      let p = 0,
        m = 0,
        v,
        g,
        x,
        b = 0;
      const y = [];
      for (let w = 0; w < c.length; w++) {
        v ||
          ((v = we.ADAPTER.createCanvas()),
          (v.width = o),
          (v.height = l),
          (g = v.getContext("2d")),
          (x = new Le(v, { resolution: a, ...h })),
          y.push(new ze(x)),
          f.page.push({ id: y.length - 1, file: "" }));
        const E = c[w],
          A = Ds.measureText(E, u, !1, v),
          C = A.width,
          F = Math.ceil(A.height),
          B = Math.ceil((u.fontStyle === "italic" ? 2 : 1) * C);
        if (m >= l - F * a) {
          if (m === 0)
            throw new Error(
              `[BitmapFont] textureHeight ${l}px is too small (fontFamily: '${u.fontFamily}', fontSize: ${u.fontSize}px, char: '${E}')`
            );
          --w, (v = null), (g = null), (x = null), (m = 0), (p = 0), (b = 0);
          continue;
        }
        if (((b = Math.max(F + A.fontProperties.descent, b)), B * a + p >= d)) {
          if (p === 0)
            throw new Error(
              `[BitmapFont] textureWidth ${o}px is too small (fontFamily: '${u.fontFamily}', fontSize: ${u.fontSize}px, char: '${E}')`
            );
          --w, (m += b * a), (m = Math.ceil(m)), (p = 0), (b = 0);
          continue;
        }
        d5(v, g, A, p, m, a, u);
        const R = Eh(A.text);
        f.char.push({
          id: R,
          page: y.length - 1,
          x: p / a,
          y: m / a,
          width: B,
          height: F,
          xoffset: 0,
          yoffset: 0,
          xadvance:
            C -
            (u.dropShadow ? u.dropShadowDistance : 0) -
            (u.stroke ? u.strokeThickness : 0),
        }),
          (p += (B + 2 * n) * a),
          (p = Math.ceil(p));
      }
      if (!(i != null && i.skipKerning))
        for (let w = 0, E = c.length; w < E; w++) {
          const A = c[w];
          for (let C = 0; C < E; C++) {
            const F = c[C],
              B = g.measureText(A).width,
              R = g.measureText(F).width,
              I = g.measureText(A + F).width - (B + R);
            I && f.kerning.push({ first: Eh(A), second: Eh(F), amount: I });
          }
        }
      const _ = new Ii(f, y, !0);
      return (
        Ii.available[e] !== void 0 && Ii.uninstall(e), (Ii.available[e] = _), _
      );
    }
  };
  (Ps.ALPHA = [["a", "z"], ["A", "Z"], " "]),
    (Ps.NUMERIC = [["0", "9"]]),
    (Ps.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "]),
    (Ps.ASCII = [[" ", "~"]]),
    (Ps.defaultOptions = {
      resolution: 1,
      textureWidth: 512,
      textureHeight: 512,
      padding: 4,
      chars: Ps.ALPHANUMERIC,
    }),
    (Ps.available = {});
  let Rs = Ps;
  var p5 = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // Gamma correction for coverage-like alpha\r
  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r
  float gamma = mix(1.0, 1.0 / 2.2, luma);\r
  float coverage = pow(uColor.a * alpha, gamma);  \r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, coverage);\r
}\r
`,
    m5 = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`;
  const sy = [],
    ny = [],
    ay = [],
    g5 = class z_ extends jr {
      constructor(e, t = {}) {
        super();
        const {
          align: i,
          tint: s,
          maxWidth: n,
          letterSpacing: a,
          fontName: o,
          fontSize: l,
        } = Object.assign({}, z_.styleDefaults, t);
        if (!Rs.available[o]) throw new Error(`Missing BitmapFont "${o}"`);
        (this._activePagesMeshData = []),
          (this._textWidth = 0),
          (this._textHeight = 0),
          (this._align = i),
          (this._tintColor = new lt(s)),
          (this._font = void 0),
          (this._fontName = o),
          (this._fontSize = l),
          (this.text = e),
          (this._maxWidth = n),
          (this._maxLineHeight = 0),
          (this._letterSpacing = a),
          (this._anchor = new us(
            () => {
              this.dirty = !0;
            },
            this,
            0,
            0
          )),
          (this._roundPixels = we.ROUND_PIXELS),
          (this.dirty = !0),
          (this._resolution = we.RESOLUTION),
          (this._autoResolution = !0),
          (this._textureCache = {});
      }
      updateText() {
        var B;
        const e = Rs.available[this._fontName],
          t = this.fontSize,
          i = t / e.size,
          s = new Je(),
          n = [],
          a = [],
          o = [],
          l =
            this._text.replace(
              /(?:\r\n|\r)/g,
              `
`
            ) || " ",
          h = X_(l),
          c = (this._maxWidth * e.size) / t,
          u = e.distanceFieldType === "none" ? sy : ny;
        let d = null,
          f = 0,
          p = 0,
          m = 0,
          v = -1,
          g = 0,
          x = 0,
          b = 0,
          y = 0;
        for (let R = 0; R < h.length; R++) {
          const I = h[R],
            P = Eh(I);
          if (
            (/(?:\s)/.test(I) && ((v = R), (g = f), y++),
            I === "\r" ||
              I ===
                `
`)
          ) {
            a.push(f),
              o.push(-1),
              (p = Math.max(p, f)),
              ++m,
              ++x,
              (s.x = 0),
              (s.y += e.lineHeight),
              (d = null),
              (y = 0);
            continue;
          }
          const M = e.chars[P];
          if (!M) continue;
          d && M.kerning[d] && (s.x += M.kerning[d]);
          const L = ay.pop() || {
            texture: ze.EMPTY,
            line: 0,
            charCode: 0,
            prevSpaces: 0,
            position: new Je(),
          };
          (L.texture = M.texture),
            (L.line = m),
            (L.charCode = P),
            (L.position.x = Math.round(
              s.x + M.xOffset + this._letterSpacing / 2
            )),
            (L.position.y = Math.round(s.y + M.yOffset)),
            (L.prevSpaces = y),
            n.push(L),
            (f =
              L.position.x +
              Math.max(M.xAdvance - M.xOffset, M.texture.orig.width)),
            (s.x += M.xAdvance + this._letterSpacing),
            (b = Math.max(b, M.yOffset + M.texture.height)),
            (d = P),
            v !== -1 &&
              c > 0 &&
              s.x > c &&
              (++x,
              Sa(n, 1 + v - x, 1 + R - v),
              (R = v),
              (v = -1),
              a.push(g),
              o.push(n.length > 0 ? n[n.length - 1].prevSpaces : 0),
              (p = Math.max(p, g)),
              m++,
              (s.x = 0),
              (s.y += e.lineHeight),
              (d = null),
              (y = 0));
        }
        const _ = h[h.length - 1];
        _ !== "\r" &&
          _ !==
            `
` &&
          (/(?:\s)/.test(_) && (f = g),
          a.push(f),
          (p = Math.max(p, f)),
          o.push(-1));
        const w = [];
        for (let R = 0; R <= m; R++) {
          let I = 0;
          this._align === "right"
            ? (I = p - a[R])
            : this._align === "center"
            ? (I = (p - a[R]) / 2)
            : this._align === "justify" &&
              (I = o[R] < 0 ? 0 : (p - a[R]) / o[R]),
            w.push(I);
        }
        const E = n.length,
          A = {},
          C = [],
          F = this._activePagesMeshData;
        u.push(...F);
        for (let R = 0; R < E; R++) {
          const I = n[R].texture,
            P = I.baseTexture.uid;
          if (!A[P]) {
            let M = u.pop();
            if (!M) {
              const U = new F_();
              let V, z;
              e.distanceFieldType === "none"
                ? ((V = new Mf(ze.EMPTY)), (z = Be.NORMAL))
                : ((V = new Mf(ze.EMPTY, {
                    program: Li.from(m5, p5),
                    uniforms: { uFWidth: 0 },
                  })),
                  (z = Be.NORMAL_NPM));
              const N = new rc(U, V);
              (N.blendMode = z),
                (M = {
                  index: 0,
                  indexCount: 0,
                  vertexCount: 0,
                  uvsCount: 0,
                  total: 0,
                  mesh: N,
                  vertices: null,
                  uvs: null,
                  indices: null,
                });
            }
            (M.index = 0),
              (M.indexCount = 0),
              (M.vertexCount = 0),
              (M.uvsCount = 0),
              (M.total = 0);
            const { _textureCache: L } = this;
            (L[P] = L[P] || new ze(I.baseTexture)),
              (M.mesh.texture = L[P]),
              (M.mesh.tint = this._tintColor.value),
              C.push(M),
              (A[P] = M);
          }
          A[P].total++;
        }
        for (let R = 0; R < F.length; R++)
          C.includes(F[R]) || this.removeChild(F[R].mesh);
        for (let R = 0; R < C.length; R++)
          C[R].mesh.parent !== this && this.addChild(C[R].mesh);
        this._activePagesMeshData = C;
        for (const R in A) {
          const I = A[R],
            P = I.total;
          if (
            !(((B = I.indices) == null ? void 0 : B.length) > 6 * P) ||
            I.vertices.length < rc.BATCHABLE_SIZE * 2
          )
            (I.vertices = new Float32Array(4 * 2 * P)),
              (I.uvs = new Float32Array(4 * 2 * P)),
              (I.indices = new Uint16Array(6 * P));
          else {
            const M = I.total,
              L = I.vertices;
            for (let U = M * 4 * 2; U < L.length; U++) L[U] = 0;
          }
          I.mesh.size = 6 * P;
        }
        for (let R = 0; R < E; R++) {
          const I = n[R];
          let P =
            I.position.x +
            w[I.line] * (this._align === "justify" ? I.prevSpaces : 1);
          this._roundPixels && (P = Math.round(P));
          const M = P * i,
            L = I.position.y * i,
            U = I.texture,
            V = A[U.baseTexture.uid],
            z = U.frame,
            N = U._uvs,
            O = V.index++;
          (V.indices[O * 6 + 0] = 0 + O * 4),
            (V.indices[O * 6 + 1] = 1 + O * 4),
            (V.indices[O * 6 + 2] = 2 + O * 4),
            (V.indices[O * 6 + 3] = 0 + O * 4),
            (V.indices[O * 6 + 4] = 2 + O * 4),
            (V.indices[O * 6 + 5] = 3 + O * 4),
            (V.vertices[O * 8 + 0] = M),
            (V.vertices[O * 8 + 1] = L),
            (V.vertices[O * 8 + 2] = M + z.width * i),
            (V.vertices[O * 8 + 3] = L),
            (V.vertices[O * 8 + 4] = M + z.width * i),
            (V.vertices[O * 8 + 5] = L + z.height * i),
            (V.vertices[O * 8 + 6] = M),
            (V.vertices[O * 8 + 7] = L + z.height * i),
            (V.uvs[O * 8 + 0] = N.x0),
            (V.uvs[O * 8 + 1] = N.y0),
            (V.uvs[O * 8 + 2] = N.x1),
            (V.uvs[O * 8 + 3] = N.y1),
            (V.uvs[O * 8 + 4] = N.x2),
            (V.uvs[O * 8 + 5] = N.y2),
            (V.uvs[O * 8 + 6] = N.x3),
            (V.uvs[O * 8 + 7] = N.y3);
        }
        (this._textWidth = p * i),
          (this._textHeight = (s.y + e.lineHeight) * i);
        for (const R in A) {
          const I = A[R];
          if (this.anchor.x !== 0 || this.anchor.y !== 0) {
            let U = 0;
            const V = this._textWidth * this.anchor.x,
              z = this._textHeight * this.anchor.y;
            for (let N = 0; N < I.total; N++)
              (I.vertices[U++] -= V),
                (I.vertices[U++] -= z),
                (I.vertices[U++] -= V),
                (I.vertices[U++] -= z),
                (I.vertices[U++] -= V),
                (I.vertices[U++] -= z),
                (I.vertices[U++] -= V),
                (I.vertices[U++] -= z);
          }
          this._maxLineHeight = b * i;
          const P = I.mesh.geometry.getBuffer("aVertexPosition"),
            M = I.mesh.geometry.getBuffer("aTextureCoord"),
            L = I.mesh.geometry.getIndex();
          (P.data = I.vertices),
            (M.data = I.uvs),
            (L.data = I.indices),
            P.update(),
            M.update(),
            L.update();
        }
        for (let R = 0; R < n.length; R++) ay.push(n[R]);
        (this._font = e), (this.dirty = !1);
      }
      updateTransform() {
        this.validate(), this.containerUpdateTransform();
      }
      _render(e) {
        this._autoResolution &&
          this._resolution !== e.resolution &&
          ((this._resolution = e.resolution), (this.dirty = !0));
        const {
          distanceFieldRange: t,
          distanceFieldType: i,
          size: s,
        } = Rs.available[this._fontName];
        if (i !== "none") {
          const { a: n, b: a, c: o, d: l } = this.worldTransform,
            h = Math.sqrt(n * n + a * a),
            c = Math.sqrt(o * o + l * l),
            u = (Math.abs(h) + Math.abs(c)) / 2,
            d = this.fontSize / s,
            f = e._view.resolution;
          for (const p of this._activePagesMeshData)
            p.mesh.shader.uniforms.uFWidth = u * t * d * f;
        }
        super._render(e);
      }
      getLocalBounds() {
        return this.validate(), super.getLocalBounds();
      }
      validate() {
        const e = Rs.available[this._fontName];
        if (!e) throw new Error(`Missing BitmapFont "${this._fontName}"`);
        this._font !== e && (this.dirty = !0), this.dirty && this.updateText();
      }
      get tint() {
        return this._tintColor.value;
      }
      set tint(e) {
        if (this.tint !== e) {
          this._tintColor.setValue(e);
          for (let t = 0; t < this._activePagesMeshData.length; t++)
            this._activePagesMeshData[t].mesh.tint = e;
        }
      }
      get align() {
        return this._align;
      }
      set align(e) {
        this._align !== e && ((this._align = e), (this.dirty = !0));
      }
      get fontName() {
        return this._fontName;
      }
      set fontName(e) {
        if (!Rs.available[e]) throw new Error(`Missing BitmapFont "${e}"`);
        this._fontName !== e && ((this._fontName = e), (this.dirty = !0));
      }
      get fontSize() {
        return this._fontSize ?? Rs.available[this._fontName].size;
      }
      set fontSize(e) {
        this._fontSize !== e && ((this._fontSize = e), (this.dirty = !0));
      }
      get anchor() {
        return this._anchor;
      }
      set anchor(e) {
        typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
      }
      get text() {
        return this._text;
      }
      set text(e) {
        (e = String(e ?? "")),
          this._text !== e && ((this._text = e), (this.dirty = !0));
      }
      get maxWidth() {
        return this._maxWidth;
      }
      set maxWidth(e) {
        this._maxWidth !== e && ((this._maxWidth = e), (this.dirty = !0));
      }
      get maxLineHeight() {
        return this.validate(), this._maxLineHeight;
      }
      get textWidth() {
        return this.validate(), this._textWidth;
      }
      get letterSpacing() {
        return this._letterSpacing;
      }
      set letterSpacing(e) {
        this._letterSpacing !== e &&
          ((this._letterSpacing = e), (this.dirty = !0));
      }
      get roundPixels() {
        return this._roundPixels;
      }
      set roundPixels(e) {
        e !== this._roundPixels && ((this._roundPixels = e), (this.dirty = !0));
      }
      get textHeight() {
        return this.validate(), this._textHeight;
      }
      get resolution() {
        return this._resolution;
      }
      set resolution(e) {
        (this._autoResolution = !1),
          this._resolution !== e && ((this._resolution = e), (this.dirty = !0));
      }
      destroy(e) {
        const { _textureCache: t } = this,
          i =
            Rs.available[this._fontName].distanceFieldType === "none" ? sy : ny;
        i.push(...this._activePagesMeshData);
        for (const s of this._activePagesMeshData) this.removeChild(s.mesh);
        (this._activePagesMeshData = []),
          i
            .filter((s) => t[s.mesh.texture.baseTexture.uid])
            .forEach((s) => {
              s.mesh.texture = ze.EMPTY;
            });
        for (const s in t) t[s].destroy(), delete t[s];
        (this._font = null),
          (this._tintColor = null),
          (this._textureCache = null),
          super.destroy(e);
      }
    };
  g5.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0,
  };
  const v5 = [".xml", ".fnt"],
    y5 = {
      extension: { type: me.LoadParser, priority: kr.Normal },
      name: "loadBitmapFont",
      test(r) {
        return v5.includes(Pt.extname(r).toLowerCase());
      },
      async testParse(r) {
        return Th.test(r) || kf.test(r);
      },
      async parse(r, e, t) {
        const i = Th.test(r) ? Th.parse(r) : kf.parse(r),
          { src: s } = e,
          { page: n } = i,
          a = [];
        for (let h = 0; h < n.length; ++h) {
          const c = n[h].file;
          let u = Pt.join(Pt.dirname(s), c);
          (u = Cf(u, s)), a.push(u);
        }
        const o = await t.load(a),
          l = a.map((h) => o[h]);
        return Rs.install(i, l, !0);
      },
      async load(r, e) {
        return (await we.ADAPTER.fetch(r)).text();
      },
      unload(r) {
        r.destroy();
      },
    };
  Ce.add(y5);
  const Df = class aa extends js {
    constructor() {
      super(...arguments),
        (this._fonts = []),
        (this._overrides = []),
        (this._stylesheet = ""),
        (this.fontsDirty = !1);
    }
    static from(e) {
      return new aa(
        Object.keys(aa.defaultOptions).reduce(
          (t, i) => ({ ...t, [i]: e[i] }),
          {}
        )
      );
    }
    cleanFonts() {
      this._fonts.length > 0 &&
        (this._fonts.forEach((e) => {
          URL.revokeObjectURL(e.src),
            e.refs--,
            e.refs === 0 &&
              (e.fontFace && document.fonts.delete(e.fontFace),
              delete aa.availableFonts[e.originalUrl]);
        }),
        (this.fontFamily = "Arial"),
        (this._fonts.length = 0),
        this.styleID++,
        (this.fontsDirty = !0));
    }
    loadFont(e, t = {}) {
      const { availableFonts: i } = aa;
      if (i[e]) {
        const s = i[e];
        return (
          this._fonts.push(s),
          s.refs++,
          this.styleID++,
          (this.fontsDirty = !0),
          Promise.resolve()
        );
      }
      return we.ADAPTER.fetch(e)
        .then((s) => s.blob())
        .then(
          async (s) =>
            new Promise((n, a) => {
              const o = URL.createObjectURL(s),
                l = new FileReader();
              (l.onload = () => n([o, l.result])),
                (l.onerror = a),
                l.readAsDataURL(s);
            })
        )
        .then(async ([s, n]) => {
          const a = Object.assign(
            {
              family: Pt.basename(e, Pt.extname(e)),
              weight: "normal",
              style: "normal",
              display: "auto",
              src: s,
              dataSrc: n,
              refs: 1,
              originalUrl: e,
              fontFace: null,
            },
            t
          );
          (i[e] = a), this._fonts.push(a), this.styleID++;
          const o = new FontFace(a.family, `url(${a.src})`, {
            weight: a.weight,
            style: a.style,
            display: a.display,
          });
          (a.fontFace = o),
            await o.load(),
            document.fonts.add(o),
            await document.fonts.ready,
            this.styleID++,
            (this.fontsDirty = !0);
        });
    }
    addOverride(...e) {
      const t = e.filter((i) => !this._overrides.includes(i));
      t.length > 0 && (this._overrides.push(...t), this.styleID++);
    }
    removeOverride(...e) {
      const t = e.filter((i) => this._overrides.includes(i));
      t.length > 0 &&
        ((this._overrides = this._overrides.filter((i) => !t.includes(i))),
        this.styleID++);
    }
    toCSS(e) {
      return [
        `transform: scale(${e})`,
        "transform-origin: top left",
        "display: inline-block",
        `color: ${this.normalizeColor(this.fill)}`,
        `font-size: ${this.fontSize}px`,
        `font-family: ${this.fontFamily}`,
        `font-weight: ${this.fontWeight}`,
        `font-style: ${this.fontStyle}`,
        `font-variant: ${this.fontVariant}`,
        `letter-spacing: ${this.letterSpacing}px`,
        `text-align: ${this.align}`,
        `padding: ${this.padding}px`,
        `white-space: ${this.whiteSpace}`,
        ...(this.lineHeight ? [`line-height: ${this.lineHeight}px`] : []),
        ...(this.wordWrap
          ? [
              `word-wrap: ${this.breakWords ? "break-all" : "break-word"}`,
              `max-width: ${this.wordWrapWidth}px`,
            ]
          : []),
        ...(this.strokeThickness
          ? [
              `-webkit-text-stroke-width: ${this.strokeThickness}px`,
              `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`,
              `text-stroke-width: ${this.strokeThickness}px`,
              `text-stroke-color: ${this.normalizeColor(this.stroke)}`,
              "paint-order: stroke",
            ]
          : []),
        ...(this.dropShadow ? [this.dropShadowToCSS()] : []),
        ...this._overrides,
      ].join(";");
    }
    toGlobalCSS() {
      return this._fonts.reduce(
        (e, t) => `${e}
            @font-face {
                font-family: "${t.family}";
                src: url('${t.dataSrc}');
                font-weight: ${t.weight};
                font-style: ${t.style};
                font-display: ${t.display};
            }`,
        this._stylesheet
      );
    }
    get stylesheet() {
      return this._stylesheet;
    }
    set stylesheet(e) {
      this._stylesheet !== e && ((this._stylesheet = e), this.styleID++);
    }
    normalizeColor(e) {
      return Array.isArray(e) && (e = hN(e)), typeof e == "number" ? lN(e) : e;
    }
    dropShadowToCSS() {
      let e = this.normalizeColor(this.dropShadowColor);
      const t = this.dropShadowAlpha,
        i = Math.round(
          Math.cos(this.dropShadowAngle) * this.dropShadowDistance
        ),
        s = Math.round(
          Math.sin(this.dropShadowAngle) * this.dropShadowDistance
        );
      e.startsWith("#") &&
        t < 1 &&
        (e += ((t * 255) | 0).toString(16).padStart(2, "0"));
      const n = `${i}px ${s}px`;
      return this.dropShadowBlur > 0
        ? `text-shadow: ${n} ${this.dropShadowBlur}px ${e}`
        : `text-shadow: ${n} ${e}`;
    }
    reset() {
      Object.assign(this, aa.defaultOptions);
    }
    onBeforeDraw() {
      const { fontsDirty: e } = this;
      return (
        (this.fontsDirty = !1),
        this.isSafari && this._fonts.length > 0 && e
          ? new Promise((t) => setTimeout(t, 100))
          : Promise.resolve()
      );
    }
    get isSafari() {
      const { userAgent: e } = we.ADAPTER.getNavigator();
      return /^((?!chrome|android).)*safari/i.test(e);
    }
    set fillGradientStops(e) {
      console.warn(
        "[HTMLTextStyle] fillGradientStops is not supported by HTMLText"
      );
    }
    get fillGradientStops() {
      return super.fillGradientStops;
    }
    set fillGradientType(e) {
      console.warn(
        "[HTMLTextStyle] fillGradientType is not supported by HTMLText"
      );
    }
    get fillGradientType() {
      return super.fillGradientType;
    }
    set miterLimit(e) {
      console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText");
    }
    get miterLimit() {
      return super.miterLimit;
    }
    set trim(e) {
      console.warn("[HTMLTextStyle] trim is not supported by HTMLText");
    }
    get trim() {
      return super.trim;
    }
    set textBaseline(e) {
      console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText");
    }
    get textBaseline() {
      return super.textBaseline;
    }
    set leading(e) {
      console.warn("[HTMLTextStyle] leading is not supported by HTMLText");
    }
    get leading() {
      return super.leading;
    }
    set lineJoin(e) {
      console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText");
    }
    get lineJoin() {
      return super.lineJoin;
    }
  };
  (Df.availableFonts = {}),
    (Df.defaultOptions = {
      align: "left",
      breakWords: !1,
      dropShadow: !1,
      dropShadowAlpha: 1,
      dropShadowAngle: Math.PI / 6,
      dropShadowBlur: 0,
      dropShadowColor: "black",
      dropShadowDistance: 5,
      fill: "black",
      fontFamily: "Arial",
      fontSize: 26,
      fontStyle: "normal",
      fontVariant: "normal",
      fontWeight: "normal",
      letterSpacing: 0,
      lineHeight: 0,
      padding: 0,
      stroke: "black",
      strokeThickness: 0,
      whiteSpace: "normal",
      wordWrap: !1,
      wordWrapWidth: 100,
    });
  let ad = Df;
  const oh = class oa extends to {
    constructor(e = "", t = {}) {
      super(ze.EMPTY),
        (this._text = null),
        (this._style = null),
        (this._autoResolution = !0),
        (this.localStyleID = -1),
        (this.dirty = !1),
        (this._updateID = 0),
        (this.ownsStyle = !1);
      const i = new Image(),
        s = ze.from(i, {
          scaleMode: we.SCALE_MODE,
          resourceOptions: { autoLoad: !1 },
        });
      (s.orig = new $e()), (s.trim = new $e()), (this.texture = s);
      const n = "http://www.w3.org/2000/svg",
        a = "http://www.w3.org/1999/xhtml",
        o = document.createElementNS(n, "svg"),
        l = document.createElementNS(n, "foreignObject"),
        h = document.createElementNS(a, "div"),
        c = document.createElementNS(a, "style");
      l.setAttribute("width", "10000"),
        l.setAttribute("height", "10000"),
        (l.style.overflow = "hidden"),
        o.appendChild(l),
        (this.maxWidth = oa.defaultMaxWidth),
        (this.maxHeight = oa.defaultMaxHeight),
        (this._domElement = h),
        (this._styleElement = c),
        (this._svgRoot = o),
        (this._foreignObject = l),
        this._foreignObject.appendChild(c),
        this._foreignObject.appendChild(h),
        (this._image = i),
        (this._loadImage = new Image()),
        (this._autoResolution = oa.defaultAutoResolution),
        (this._resolution = oa.defaultResolution ?? we.RESOLUTION),
        (this.text = e),
        (this.style = t);
    }
    measureText(e) {
      var c, u;
      const {
        text: t,
        style: i,
        resolution: s,
      } = Object.assign(
        { text: this._text, style: this._style, resolution: this._resolution },
        e
      );
      Object.assign(this._domElement, { innerHTML: t, style: i.toCSS(s) }),
        (this._styleElement.textContent = i.toGlobalCSS()),
        document.body.appendChild(this._svgRoot);
      const n = this._domElement.getBoundingClientRect();
      this._svgRoot.remove();
      const { width: a, height: o } = n;
      (a > this.maxWidth || o > this.maxHeight) &&
        console.warn(
          "[HTMLText] Large expanse of text, increase HTMLText.maxWidth or HTMLText.maxHeight property."
        );
      const l = Math.min(this.maxWidth, Math.ceil(a)),
        h = Math.min(this.maxHeight, Math.ceil(o));
      return (
        this._svgRoot.setAttribute("width", l.toString()),
        this._svgRoot.setAttribute("height", h.toString()),
        t !== this._text && (this._domElement.innerHTML = this._text),
        i !== this._style &&
          (Object.assign(this._domElement, {
            style: (c = this._style) == null ? void 0 : c.toCSS(s),
          }),
          (this._styleElement.textContent =
            (u = this._style) == null ? void 0 : u.toGlobalCSS())),
        { width: l + i.padding * 2, height: h + i.padding * 2 }
      );
    }
    async updateText(e = !0) {
      const { style: t, _image: i, _loadImage: s } = this;
      if (
        (this.localStyleID !== t.styleID &&
          ((this.dirty = !0), (this.localStyleID = t.styleID)),
        !this.dirty && e)
      )
        return;
      const { width: n, height: a } = this.measureText();
      (i.width = s.width = Math.ceil(Math.max(1, n))),
        (i.height = s.height = Math.ceil(Math.max(1, a))),
        this._updateID++;
      const o = this._updateID;
      await new Promise((l) => {
        s.onload = async () => {
          if (o < this._updateID) {
            l();
            return;
          }
          await t.onBeforeDraw(),
            (i.src = s.src),
            (s.onload = null),
            (s.src = ""),
            this.updateTexture(),
            l();
        };
        const h = new XMLSerializer().serializeToString(this._svgRoot);
        s.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(h)}`;
      });
    }
    get source() {
      return this._image;
    }
    updateTexture() {
      const { style: e, texture: t, _image: i, resolution: s } = this,
        { padding: n } = e,
        { baseTexture: a } = t;
      (t.trim.width = t._frame.width = i.width / s),
        (t.trim.height = t._frame.height = i.height / s),
        (t.trim.x = -n),
        (t.trim.y = -n),
        (t.orig.width = t._frame.width - n * 2),
        (t.orig.height = t._frame.height - n * 2),
        this._onTextureUpdate(),
        a.setRealSize(i.width, i.height, s),
        (this.dirty = !1);
    }
    _render(e) {
      this._autoResolution &&
        this._resolution !== e.resolution &&
        ((this._resolution = e.resolution), (this.dirty = !0)),
        this.updateText(!0),
        super._render(e);
    }
    _renderCanvas(e) {
      this._autoResolution &&
        this._resolution !== e.resolution &&
        ((this._resolution = e.resolution), (this.dirty = !0)),
        this.updateText(!0),
        super._renderCanvas(e);
    }
    getLocalBounds(e) {
      return this.updateText(!0), super.getLocalBounds(e);
    }
    _calculateBounds() {
      this.updateText(!0),
        this.calculateVertices(),
        this._bounds.addQuad(this.vertexData);
    }
    _onStyleChange() {
      this.dirty = !0;
    }
    destroy(e) {
      var i, s, n, a, o;
      typeof e == "boolean" && (e = { children: e }),
        (e = Object.assign({}, oa.defaultDestroyOptions, e)),
        super.destroy(e);
      const t = null;
      this.ownsStyle && ((i = this._style) == null || i.cleanFonts()),
        (this._style = t),
        (s = this._svgRoot) == null || s.remove(),
        (this._svgRoot = t),
        (n = this._domElement) == null || n.remove(),
        (this._domElement = t),
        (a = this._foreignObject) == null || a.remove(),
        (this._foreignObject = t),
        (o = this._styleElement) == null || o.remove(),
        (this._styleElement = t),
        (this._loadImage.src = ""),
        (this._loadImage.onload = null),
        (this._loadImage = t),
        (this._image.src = ""),
        (this._image = t);
    }
    get width() {
      return (
        this.updateText(!0),
        (Math.abs(this.scale.x) * this._image.width) / this.resolution
      );
    }
    set width(e) {
      this.updateText(!0);
      const t = Gs(this.scale.x) || 1;
      (this.scale.x = (t * e) / this._image.width / this.resolution),
        (this._width = e);
    }
    get height() {
      return (
        this.updateText(!0),
        (Math.abs(this.scale.y) * this._image.height) / this.resolution
      );
    }
    set height(e) {
      this.updateText(!0);
      const t = Gs(this.scale.y) || 1;
      (this.scale.y = (t * e) / this._image.height / this.resolution),
        (this._height = e);
    }
    get style() {
      return this._style;
    }
    set style(e) {
      this._style !== e &&
        ((e = e || {}),
        e instanceof ad
          ? ((this.ownsStyle = !1), (this._style = e))
          : e instanceof js
          ? (console.warn(
              "[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle"
            ),
            (this.ownsStyle = !0),
            (this._style = ad.from(e)))
          : ((this.ownsStyle = !0), (this._style = new ad(e))),
        (this.localStyleID = -1),
        (this.dirty = !0));
    }
    get text() {
      return this._text;
    }
    set text(e) {
      (e = String(e === "" || e === null || e === void 0 ? " " : e)),
        (e = this.sanitiseText(e)),
        this._text !== e && ((this._text = e), (this.dirty = !0));
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(e) {
      (this._autoResolution = !1),
        this._resolution !== e && ((this._resolution = e), (this.dirty = !0));
    }
    sanitiseText(e) {
      return e
        .replace(/<br>/gi, "<br/>")
        .replace(/<hr>/gi, "<hr/>")
        .replace(/&nbsp;/gi, "&#160;");
    }
  };
  (oh.defaultDestroyOptions = { texture: !0, children: !1, baseTexture: !0 }),
    (oh.defaultMaxWidth = 2024),
    (oh.defaultMaxHeight = 2024),
    (oh.defaultAutoResolution = !0);
  if (typeof window < "u" && window.PIXI) {
    let r = window.require;
    window.require = (e) => {
      if (r) return r(e);
      if (e.startsWith("@pixi/")) return window.PIXI;
    };
  }
  class W_ {
    constructor() {
      T(this, "entries", {});
      T(this, "size", 0);
    }
    add(e) {
      let t = this.entries[e];
      return (this.entries[e] = !0), t ? !1 : (this.size++, !0);
    }
    addAll(e) {
      let t = this.size;
      for (var i = 0, s = e.length; i < s; i++) this.add(e[i]);
      return t != this.size;
    }
    contains(e) {
      return this.entries[e];
    }
    clear() {
      (this.entries = {}), (this.size = 0);
    }
  }
  const Ar = class Ar {
    constructor(e = 0, t = 0, i = 0, s = 0) {
      T(this, "r");
      T(this, "g");
      T(this, "b");
      T(this, "a");
      (this.r = e), (this.g = t), (this.b = i), (this.a = s);
    }
    set(e, t, i, s) {
      return (
        (this.r = e), (this.g = t), (this.b = i), (this.a = s), this.clamp()
      );
    }
    setFromColor(e) {
      return (
        (this.r = e.r), (this.g = e.g), (this.b = e.b), (this.a = e.a), this
      );
    }
    setFromString(e) {
      return (
        (e = e.charAt(0) == "#" ? e.substr(1) : e),
        (this.r = parseInt(e.substr(0, 2), 16) / 255),
        (this.g = parseInt(e.substr(2, 2), 16) / 255),
        (this.b = parseInt(e.substr(4, 2), 16) / 255),
        (this.a = e.length != 8 ? 1 : parseInt(e.substr(6, 2), 16) / 255),
        this
      );
    }
    add(e, t, i, s) {
      return (
        (this.r += e), (this.g += t), (this.b += i), (this.a += s), this.clamp()
      );
    }
    clamp() {
      return (
        this.r < 0 ? (this.r = 0) : this.r > 1 && (this.r = 1),
        this.g < 0 ? (this.g = 0) : this.g > 1 && (this.g = 1),
        this.b < 0 ? (this.b = 0) : this.b > 1 && (this.b = 1),
        this.a < 0 ? (this.a = 0) : this.a > 1 && (this.a = 1),
        this
      );
    }
    static rgba8888ToColor(e, t) {
      (e.r = ((t & 4278190080) >>> 24) / 255),
        (e.g = ((t & 16711680) >>> 16) / 255),
        (e.b = ((t & 65280) >>> 8) / 255),
        (e.a = (t & 255) / 255);
    }
    static rgb888ToColor(e, t) {
      (e.r = ((t & 16711680) >>> 16) / 255),
        (e.g = ((t & 65280) >>> 8) / 255),
        (e.b = (t & 255) / 255);
    }
    toRgb888() {
      const e = (t) => ("0" + (t * 255).toString(16)).slice(-2);
      return +("0x" + e(this.r) + e(this.g) + e(this.b));
    }
    static fromString(e) {
      return new Ar().setFromString(e);
    }
  };
  T(Ar, "WHITE", new Ar(1, 1, 1, 1)),
    T(Ar, "RED", new Ar(1, 0, 0, 1)),
    T(Ar, "GREEN", new Ar(0, 1, 0, 1)),
    T(Ar, "BLUE", new Ar(0, 0, 1, 1)),
    T(Ar, "MAGENTA", new Ar(1, 0, 1, 1));
  let Ve = Ar;
  const Ot = class Ot {
    static clamp(e, t, i) {
      return e < t ? t : e > i ? i : e;
    }
    static cosDeg(e) {
      return Math.cos(e * Ot.degRad);
    }
    static sinDeg(e) {
      return Math.sin(e * Ot.degRad);
    }
    static atan2Deg(e, t) {
      return Math.atan2(e, t) * Ot.degRad;
    }
    static signum(e) {
      return e > 0 ? 1 : e < 0 ? -1 : 0;
    }
    static toInt(e) {
      return e > 0 ? Math.floor(e) : Math.ceil(e);
    }
    static cbrt(e) {
      let t = Math.pow(Math.abs(e), 0.3333333333333333);
      return e < 0 ? -t : t;
    }
    static randomTriangular(e, t) {
      return Ot.randomTriangularWith(e, t, (e + t) * 0.5);
    }
    static randomTriangularWith(e, t, i) {
      let s = Math.random(),
        n = t - e;
      return s <= (i - e) / n
        ? e + Math.sqrt(s * n * (i - e))
        : t - Math.sqrt((1 - s) * n * (t - i));
    }
    static isPowerOfTwo(e) {
      return e && (e & (e - 1)) === 0;
    }
  };
  T(Ot, "PI", 3.1415927),
    T(Ot, "PI2", Ot.PI * 2),
    T(Ot, "invPI2", 1 / Ot.PI2),
    T(Ot, "radiansToDegrees", 180 / Ot.PI),
    T(Ot, "radDeg", Ot.radiansToDegrees),
    T(Ot, "degreesToRadians", Ot.PI / 180),
    T(Ot, "degRad", Ot.degreesToRadians);
  let ae = Ot;
  const Ls = class Ls {
    static arrayCopy(e, t, i, s, n) {
      for (let a = t, o = s; a < t + n; a++, o++) i[o] = e[a];
    }
    static arrayFill(e, t, i, s) {
      for (let n = t; n < i; n++) e[n] = s;
    }
    static setArraySize(e, t, i = 0) {
      let s = e.length;
      if (s == t) return e;
      if (((e.length = t), s < t)) for (let n = s; n < t; n++) e[n] = i;
      return e;
    }
    static ensureArrayCapacity(e, t, i = 0) {
      return e.length >= t ? e : Ls.setArraySize(e, t, i);
    }
    static newArray(e, t) {
      let i = new Array(e);
      for (let s = 0; s < e; s++) i[s] = t;
      return i;
    }
    static newFloatArray(e) {
      if (Ls.SUPPORTS_TYPED_ARRAYS) return new Float32Array(e);
      {
        let t = new Array(e);
        for (let i = 0; i < t.length; i++) t[i] = 0;
        return t;
      }
    }
    static newShortArray(e) {
      if (Ls.SUPPORTS_TYPED_ARRAYS) return new Int16Array(e);
      {
        let t = new Array(e);
        for (let i = 0; i < t.length; i++) t[i] = 0;
        return t;
      }
    }
    static toFloatArray(e) {
      return Ls.SUPPORTS_TYPED_ARRAYS ? new Float32Array(e) : e;
    }
    static toSinglePrecision(e) {
      return Ls.SUPPORTS_TYPED_ARRAYS ? Math.fround(e) : e;
    }
    static webkit602BugfixHelper(e, t) {}
    static contains(e, t, i = !0) {
      for (var s = 0; s < e.length; s++) if (e[s] == t) return !0;
      return !1;
    }
    static enumValue(e, t) {
      return e[t[0].toUpperCase() + t.slice(1)];
    }
  };
  T(Ls, "SUPPORTS_TYPED_ARRAYS", typeof Float32Array < "u");
  let pe = Ls;
  class Lf {
    constructor(e) {
      T(this, "items", new Array());
      T(this, "instantiator");
      this.instantiator = e;
    }
    obtain() {
      return this.items.length > 0 ? this.items.pop() : this.instantiator();
    }
    free(e) {
      e.reset && e.reset(), this.items.push(e);
    }
    freeAll(e) {
      for (let t = 0; t < e.length; t++) this.free(e[t]);
    }
    clear() {
      this.items.length = 0;
    }
  }
  class sc {
    constructor(e = 0, t = 0) {
      T(this, "x");
      T(this, "y");
      (this.x = e), (this.y = t);
    }
    set(e, t) {
      return (this.x = e), (this.y = t), this;
    }
    length() {
      let e = this.x,
        t = this.y;
      return Math.sqrt(e * e + t * t);
    }
    normalize() {
      let e = this.length();
      return e != 0 && ((this.x /= e), (this.y /= e)), this;
    }
  }
  class Y_ {
    constructor(e) {
      T(this, "name");
      if (!e) throw new Error("name cannot be null.");
      this.name = e;
    }
  }
  const cc = class cc extends Y_ {
    constructor(t) {
      super(t);
      T(this, "id", cc.nextID++);
      T(this, "bones", null);
      T(this, "vertices", []);
      T(this, "worldVerticesLength", 0);
      T(this, "timelineAttachment", this);
    }
    computeWorldVertices(t, i, s, n, a, o) {
      s = a + (s >> 1) * o;
      let l = t.bone.skeleton,
        h = t.deform,
        c = this.vertices,
        u = this.bones;
      if (!u) {
        h.length > 0 && (c = h);
        let m = t.bone,
          v = m.worldX,
          g = m.worldY,
          x = m.a,
          b = m.b,
          y = m.c,
          _ = m.d;
        for (let w = i, E = a; E < s; w += 2, E += o) {
          let A = c[w],
            C = c[w + 1];
          (n[E] = A * x + C * b + v), (n[E + 1] = A * y + C * _ + g);
        }
        return;
      }
      let d = 0,
        f = 0;
      for (let m = 0; m < i; m += 2) {
        let v = u[d];
        (d += v + 1), (f += v);
      }
      let p = l.bones;
      if (h.length == 0)
        for (let m = a, v = f * 3; m < s; m += o) {
          let g = 0,
            x = 0,
            b = u[d++];
          for (b += d; d < b; d++, v += 3) {
            let y = p[u[d]],
              _ = c[v],
              w = c[v + 1],
              E = c[v + 2];
            (g += (_ * y.a + w * y.b + y.worldX) * E),
              (x += (_ * y.c + w * y.d + y.worldY) * E);
          }
          (n[m] = g), (n[m + 1] = x);
        }
      else {
        let m = h;
        for (let v = a, g = f * 3, x = f << 1; v < s; v += o) {
          let b = 0,
            y = 0,
            _ = u[d++];
          for (_ += d; d < _; d++, g += 3, x += 2) {
            let w = p[u[d]],
              E = c[g] + m[x],
              A = c[g + 1] + m[x + 1],
              C = c[g + 2];
            (b += (E * w.a + A * w.b + w.worldX) * C),
              (y += (E * w.c + A * w.d + w.worldY) * C);
          }
          (n[v] = b), (n[v + 1] = y);
        }
      }
    }
    copyTo(t) {
      this.bones
        ? ((t.bones = new Array(this.bones.length)),
          pe.arrayCopy(this.bones, 0, t.bones, 0, this.bones.length))
        : (t.bones = null),
        this.vertices &&
          ((t.vertices = pe.newFloatArray(this.vertices.length)),
          pe.arrayCopy(this.vertices, 0, t.vertices, 0, this.vertices.length)),
        (t.worldVerticesLength = this.worldVerticesLength),
        (t.timelineAttachment = this.timelineAttachment);
    }
  };
  T(cc, "nextID", 0);
  let gi = cc;
  const da = class da {
    constructor(e) {
      T(this, "id", da.nextID());
      T(this, "regions");
      T(this, "start", 0);
      T(this, "digits", 0);
      T(this, "setupIndex", 0);
      this.regions = new Array(e);
    }
    copy() {
      let e = new da(this.regions.length);
      return (
        pe.arrayCopy(this.regions, 0, e.regions, 0, this.regions.length),
        (e.start = this.start),
        (e.digits = this.digits),
        (e.setupIndex = this.setupIndex),
        e
      );
    }
    apply(e, t) {
      let i = e.sequenceIndex;
      i == -1 && (i = this.setupIndex),
        i >= this.regions.length && (i = this.regions.length - 1);
      let s = this.regions[i];
      t.region != s && ((t.region = s), t.updateRegion());
    }
    getPath(e, t) {
      let i = e,
        s = (this.start + t).toString();
      for (let n = this.digits - s.length; n > 0; n--) i += "0";
      return (i += s), i;
    }
    static nextID() {
      return da._nextID++;
    }
  };
  T(da, "_nextID", 0);
  let nc = da;
  var jt;
  (function (r) {
    (r[(r.hold = 0)] = "hold"),
      (r[(r.once = 1)] = "once"),
      (r[(r.loop = 2)] = "loop"),
      (r[(r.pingpong = 3)] = "pingpong"),
      (r[(r.onceReverse = 4)] = "onceReverse"),
      (r[(r.loopReverse = 5)] = "loopReverse"),
      (r[(r.pingpongReverse = 6)] = "pingpongReverse");
  })(jt || (jt = {}));
  const j_ = [
    jt.hold,
    jt.once,
    jt.loop,
    jt.pingpong,
    jt.onceReverse,
    jt.loopReverse,
    jt.pingpongReverse,
  ];
  class cm {
    constructor(e, t, i) {
      T(this, "name");
      T(this, "timelines", []);
      T(this, "timelineIds", new W_());
      T(this, "duration");
      if (!e) throw new Error("name cannot be null.");
      (this.name = e), this.setTimelines(t), (this.duration = i);
    }
    setTimelines(e) {
      if (!e) throw new Error("timelines cannot be null.");
      (this.timelines = e), this.timelineIds.clear();
      for (var t = 0; t < e.length; t++)
        this.timelineIds.addAll(e[t].getPropertyIds());
    }
    hasTimeline(e) {
      for (let t = 0; t < e.length; t++)
        if (this.timelineIds.contains(e[t])) return !0;
      return !1;
    }
    apply(e, t, i, s, n, a, o, l) {
      if (!e) throw new Error("skeleton cannot be null.");
      s &&
        this.duration != 0 &&
        ((i %= this.duration), t > 0 && (t %= this.duration));
      let h = this.timelines;
      for (let c = 0, u = h.length; c < u; c++) h[c].apply(e, t, i, n, a, o, l);
    }
  }
  var Z;
  (function (r) {
    (r[(r.setup = 0)] = "setup"),
      (r[(r.first = 1)] = "first"),
      (r[(r.replace = 2)] = "replace"),
      (r[(r.add = 3)] = "add");
  })(Z || (Z = {}));
  var dr;
  (function (r) {
    (r[(r.mixIn = 0)] = "mixIn"), (r[(r.mixOut = 1)] = "mixOut");
  })(dr || (dr = {}));
  const He = {
    rotate: 0,
    x: 1,
    y: 2,
    scaleX: 3,
    scaleY: 4,
    shearX: 5,
    shearY: 6,
    inherit: 7,
    rgb: 8,
    alpha: 9,
    rgb2: 10,
    attachment: 11,
    deform: 12,
    event: 13,
    drawOrder: 14,
    ikConstraint: 15,
    transformConstraint: 16,
    pathConstraintPosition: 17,
    pathConstraintSpacing: 18,
    pathConstraintMix: 19,
    physicsConstraintInertia: 20,
    physicsConstraintStrength: 21,
    physicsConstraintDamping: 22,
    physicsConstraintMass: 23,
    physicsConstraintWind: 24,
    physicsConstraintGravity: 25,
    physicsConstraintMix: 26,
    physicsConstraintReset: 27,
    sequence: 28,
  };
  class bt {
    constructor(e, t) {
      T(this, "propertyIds");
      T(this, "frames");
      (this.propertyIds = t),
        (this.frames = pe.newFloatArray(e * this.getFrameEntries()));
    }
    getPropertyIds() {
      return this.propertyIds;
    }
    getFrameEntries() {
      return 1;
    }
    getFrameCount() {
      return this.frames.length / this.getFrameEntries();
    }
    getDuration() {
      return this.frames[this.frames.length - this.getFrameEntries()];
    }
    static search1(e, t) {
      let i = e.length;
      for (let s = 1; s < i; s++) if (e[s] > t) return s - 1;
      return i - 1;
    }
    static search(e, t, i) {
      let s = e.length;
      for (let n = i; n < s; n += i) if (e[n] > t) return n - i;
      return s - i;
    }
  }
  class qi extends bt {
    constructor(t, i, s) {
      super(t, s);
      T(this, "curves");
      (this.curves = pe.newFloatArray(t + i * 18)), (this.curves[t - 1] = 1);
    }
    setLinear(t) {
      this.curves[t] = 0;
    }
    setStepped(t) {
      this.curves[t] = 1;
    }
    shrink(t) {
      let i = this.getFrameCount() + t * 18;
      if (this.curves.length > i) {
        let s = pe.newFloatArray(i);
        pe.arrayCopy(this.curves, 0, s, 0, i), (this.curves = s);
      }
    }
    setBezier(t, i, s, n, a, o, l, h, c, u, d) {
      let f = this.curves,
        p = this.getFrameCount() + t * 18;
      s == 0 && (f[i] = 2 + p);
      let m = (n - o * 2 + h) * 0.03,
        v = (a - l * 2 + c) * 0.03,
        g = ((o - h) * 3 - n + u) * 0.006,
        x = ((l - c) * 3 - a + d) * 0.006,
        b = m * 2 + g,
        y = v * 2 + x,
        _ = (o - n) * 0.3 + m + g * 0.16666667,
        w = (l - a) * 0.3 + v + x * 0.16666667,
        E = n + _,
        A = a + w;
      for (let C = p + 18; p < C; p += 2)
        (f[p] = E),
          (f[p + 1] = A),
          (_ += b),
          (w += y),
          (b += g),
          (y += x),
          (E += _),
          (A += w);
    }
    getBezierValue(t, i, s, n) {
      let a = this.curves;
      if (a[n] > t) {
        let c = this.frames[i],
          u = this.frames[i + s];
        return u + ((t - c) / (a[n] - c)) * (a[n + 1] - u);
      }
      let o = n + 18;
      for (n += 2; n < o; n += 2)
        if (a[n] >= t) {
          let c = a[n - 2],
            u = a[n - 1];
          return u + ((t - c) / (a[n] - c)) * (a[n + 1] - u);
        }
      i += this.getFrameEntries();
      let l = a[o - 2],
        h = a[o - 1];
      return h + ((t - l) / (this.frames[i] - l)) * (this.frames[i + s] - h);
    }
  }
  class xi extends qi {
    constructor(e, t, i) {
      super(e, t, [i]);
    }
    getFrameEntries() {
      return 2;
    }
    setFrame(e, t, i) {
      (e <<= 1), (this.frames[e] = t), (this.frames[e + 1] = i);
    }
    getCurveValue(e) {
      let t = this.frames,
        i = t.length - 2;
      for (let n = 2; n <= i; n += 2)
        if (t[n] > e) {
          i = n - 2;
          break;
        }
      let s = this.curves[i >> 1];
      switch (s) {
        case 0:
          let n = t[i],
            a = t[i + 1];
          return a + ((e - n) / (t[i + 2] - n)) * (t[i + 2 + 1] - a);
        case 1:
          return t[i + 1];
      }
      return this.getBezierValue(e, i, 1, s - 2);
    }
    getRelativeValue(e, t, i, s, n) {
      if (e < this.frames[0]) {
        switch (i) {
          case Z.setup:
            return n;
          case Z.first:
            return s + (n - s) * t;
        }
        return s;
      }
      let a = this.getCurveValue(e);
      switch (i) {
        case Z.setup:
          return n + a * t;
        case Z.first:
        case Z.replace:
          a += n - s;
      }
      return s + a * t;
    }
    getAbsoluteValue(e, t, i, s, n) {
      if (e < this.frames[0]) {
        switch (i) {
          case Z.setup:
            return n;
          case Z.first:
            return s + (n - s) * t;
        }
        return s;
      }
      let a = this.getCurveValue(e);
      return i == Z.setup ? n + (a - n) * t : s + (a - s) * t;
    }
    getAbsoluteValue2(e, t, i, s, n, a) {
      if (e < this.frames[0]) {
        switch (i) {
          case Z.setup:
            return n;
          case Z.first:
            return s + (n - s) * t;
        }
        return s;
      }
      return i == Z.setup ? n + (a - n) * t : s + (a - s) * t;
    }
    getScaleValue(e, t, i, s, n, a) {
      const o = this.frames;
      if (e < o[0]) {
        switch (i) {
          case Z.setup:
            return a;
          case Z.first:
            return n + (a - n) * t;
        }
        return n;
      }
      let l = this.getCurveValue(e) * a;
      if (t == 1) return i == Z.add ? n + l - a : l;
      if (s == dr.mixOut)
        switch (i) {
          case Z.setup:
            return a + (Math.abs(l) * ae.signum(a) - a) * t;
          case Z.first:
          case Z.replace:
            return n + (Math.abs(l) * ae.signum(n) - n) * t;
        }
      else {
        let h = 0;
        switch (i) {
          case Z.setup:
            return (h = Math.abs(a) * ae.signum(l)), h + (l - h) * t;
          case Z.first:
          case Z.replace:
            return (h = Math.abs(n) * ae.signum(l)), h + (l - h) * t;
        }
      }
      return n + (l - a) * t;
    }
  }
  class um extends qi {
    constructor(e, t, i, s) {
      super(e, t, [i, s]);
    }
    getFrameEntries() {
      return 3;
    }
    setFrame(e, t, i, s) {
      (e *= 3),
        (this.frames[e] = t),
        (this.frames[e + 1] = i),
        (this.frames[e + 2] = s);
    }
  }
  class ac extends xi {
    constructor(t, i, s) {
      super(t, i, He.rotate + "|" + s);
      T(this, "boneIndex", 0);
      this.boneIndex = s;
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.bones[this.boneIndex];
      h.active &&
        (h.rotation = this.getRelativeValue(
          s,
          a,
          o,
          h.rotation,
          h.data.rotation
        ));
    }
  }
  class q_ extends um {
    constructor(t, i, s) {
      super(t, i, He.x + "|" + s, He.y + "|" + s);
      T(this, "boneIndex", 0);
      this.boneIndex = s;
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.bones[this.boneIndex];
      if (!h.active) return;
      let c = this.frames;
      if (s < c[0]) {
        switch (o) {
          case Z.setup:
            (h.x = h.data.x), (h.y = h.data.y);
            return;
          case Z.first:
            (h.x += (h.data.x - h.x) * a), (h.y += (h.data.y - h.y) * a);
        }
        return;
      }
      let u = 0,
        d = 0,
        f = bt.search(c, s, 3),
        p = this.curves[f / 3];
      switch (p) {
        case 0:
          let m = c[f];
          (u = c[f + 1]), (d = c[f + 2]);
          let v = (s - m) / (c[f + 3] - m);
          (u += (c[f + 3 + 1] - u) * v), (d += (c[f + 3 + 2] - d) * v);
          break;
        case 1:
          (u = c[f + 1]), (d = c[f + 2]);
          break;
        default:
          (u = this.getBezierValue(s, f, 1, p - 2)),
            (d = this.getBezierValue(s, f, 2, p + 18 - 2));
      }
      switch (o) {
        case Z.setup:
          (h.x = h.data.x + u * a), (h.y = h.data.y + d * a);
          break;
        case Z.first:
        case Z.replace:
          (h.x += (h.data.x + u - h.x) * a), (h.y += (h.data.y + d - h.y) * a);
          break;
        case Z.add:
          (h.x += u * a), (h.y += d * a);
      }
    }
  }
  class K_ extends xi {
    constructor(t, i, s) {
      super(t, i, He.x + "|" + s);
      T(this, "boneIndex", 0);
      this.boneIndex = s;
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.bones[this.boneIndex];
      h.active && (h.x = this.getRelativeValue(s, a, o, h.x, h.data.x));
    }
  }
  class Z_ extends xi {
    constructor(t, i, s) {
      super(t, i, He.y + "|" + s);
      T(this, "boneIndex", 0);
      this.boneIndex = s;
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.bones[this.boneIndex];
      h.active && (h.y = this.getRelativeValue(s, a, o, h.y, h.data.y));
    }
  }
  class J_ extends um {
    constructor(t, i, s) {
      super(t, i, He.scaleX + "|" + s, He.scaleY + "|" + s);
      T(this, "boneIndex", 0);
      this.boneIndex = s;
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.bones[this.boneIndex];
      if (!h.active) return;
      let c = this.frames;
      if (s < c[0]) {
        switch (o) {
          case Z.setup:
            (h.scaleX = h.data.scaleX), (h.scaleY = h.data.scaleY);
            return;
          case Z.first:
            (h.scaleX += (h.data.scaleX - h.scaleX) * a),
              (h.scaleY += (h.data.scaleY - h.scaleY) * a);
        }
        return;
      }
      let u,
        d,
        f = bt.search(c, s, 3),
        p = this.curves[f / 3];
      switch (p) {
        case 0:
          let m = c[f];
          (u = c[f + 1]), (d = c[f + 2]);
          let v = (s - m) / (c[f + 3] - m);
          (u += (c[f + 3 + 1] - u) * v), (d += (c[f + 3 + 2] - d) * v);
          break;
        case 1:
          (u = c[f + 1]), (d = c[f + 2]);
          break;
        default:
          (u = this.getBezierValue(s, f, 1, p - 2)),
            (d = this.getBezierValue(s, f, 2, p + 18 - 2));
      }
      if (((u *= h.data.scaleX), (d *= h.data.scaleY), a == 1))
        o == Z.add
          ? ((h.scaleX += u - h.data.scaleX), (h.scaleY += d - h.data.scaleY))
          : ((h.scaleX = u), (h.scaleY = d));
      else {
        let m = 0,
          v = 0;
        if (l == dr.mixOut)
          switch (o) {
            case Z.setup:
              (m = h.data.scaleX),
                (v = h.data.scaleY),
                (h.scaleX = m + (Math.abs(u) * ae.signum(m) - m) * a),
                (h.scaleY = v + (Math.abs(d) * ae.signum(v) - v) * a);
              break;
            case Z.first:
            case Z.replace:
              (m = h.scaleX),
                (v = h.scaleY),
                (h.scaleX = m + (Math.abs(u) * ae.signum(m) - m) * a),
                (h.scaleY = v + (Math.abs(d) * ae.signum(v) - v) * a);
              break;
            case Z.add:
              (h.scaleX += (u - h.data.scaleX) * a),
                (h.scaleY += (d - h.data.scaleY) * a);
          }
        else
          switch (o) {
            case Z.setup:
              (m = Math.abs(h.data.scaleX) * ae.signum(u)),
                (v = Math.abs(h.data.scaleY) * ae.signum(d)),
                (h.scaleX = m + (u - m) * a),
                (h.scaleY = v + (d - v) * a);
              break;
            case Z.first:
            case Z.replace:
              (m = Math.abs(h.scaleX) * ae.signum(u)),
                (v = Math.abs(h.scaleY) * ae.signum(d)),
                (h.scaleX = m + (u - m) * a),
                (h.scaleY = v + (d - v) * a);
              break;
            case Z.add:
              (h.scaleX += (u - h.data.scaleX) * a),
                (h.scaleY += (d - h.data.scaleY) * a);
          }
      }
    }
  }
  class Q_ extends xi {
    constructor(t, i, s) {
      super(t, i, He.scaleX + "|" + s);
      T(this, "boneIndex", 0);
      this.boneIndex = s;
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.bones[this.boneIndex];
      h.active &&
        (h.scaleX = this.getScaleValue(s, a, o, l, h.scaleX, h.data.scaleX));
    }
  }
  class ew extends xi {
    constructor(t, i, s) {
      super(t, i, He.scaleY + "|" + s);
      T(this, "boneIndex", 0);
      this.boneIndex = s;
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.bones[this.boneIndex];
      h.active &&
        (h.scaleY = this.getScaleValue(s, a, o, l, h.scaleY, h.data.scaleY));
    }
  }
  class tw extends um {
    constructor(t, i, s) {
      super(t, i, He.shearX + "|" + s, He.shearY + "|" + s);
      T(this, "boneIndex", 0);
      this.boneIndex = s;
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.bones[this.boneIndex];
      if (!h.active) return;
      let c = this.frames;
      if (s < c[0]) {
        switch (o) {
          case Z.setup:
            (h.shearX = h.data.shearX), (h.shearY = h.data.shearY);
            return;
          case Z.first:
            (h.shearX += (h.data.shearX - h.shearX) * a),
              (h.shearY += (h.data.shearY - h.shearY) * a);
        }
        return;
      }
      let u = 0,
        d = 0,
        f = bt.search(c, s, 3),
        p = this.curves[f / 3];
      switch (p) {
        case 0:
          let m = c[f];
          (u = c[f + 1]), (d = c[f + 2]);
          let v = (s - m) / (c[f + 3] - m);
          (u += (c[f + 3 + 1] - u) * v), (d += (c[f + 3 + 2] - d) * v);
          break;
        case 1:
          (u = c[f + 1]), (d = c[f + 2]);
          break;
        default:
          (u = this.getBezierValue(s, f, 1, p - 2)),
            (d = this.getBezierValue(s, f, 2, p + 18 - 2));
      }
      switch (o) {
        case Z.setup:
          (h.shearX = h.data.shearX + u * a),
            (h.shearY = h.data.shearY + d * a);
          break;
        case Z.first:
        case Z.replace:
          (h.shearX += (h.data.shearX + u - h.shearX) * a),
            (h.shearY += (h.data.shearY + d - h.shearY) * a);
          break;
        case Z.add:
          (h.shearX += u * a), (h.shearY += d * a);
      }
    }
  }
  class rw extends xi {
    constructor(t, i, s) {
      super(t, i, He.shearX + "|" + s);
      T(this, "boneIndex", 0);
      this.boneIndex = s;
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.bones[this.boneIndex];
      h.active &&
        (h.shearX = this.getRelativeValue(s, a, o, h.shearX, h.data.shearX));
    }
  }
  class iw extends xi {
    constructor(t, i, s) {
      super(t, i, He.shearY + "|" + s);
      T(this, "boneIndex", 0);
      this.boneIndex = s;
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.bones[this.boneIndex];
      h.active &&
        (h.shearY = this.getRelativeValue(s, a, o, h.shearY, h.data.shearY));
    }
  }
  class sw extends bt {
    constructor(t, i) {
      super(t, [He.inherit + "|" + i]);
      T(this, "boneIndex", 0);
      this.boneIndex = i;
    }
    getFrameEntries() {
      return 2;
    }
    setFrame(t, i, s) {
      (t *= 2), (this.frames[t] = i), (this.frames[t + 1] = s);
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.bones[this.boneIndex];
      if (!h.active) return;
      if (l == dr.mixOut) {
        o == Z.setup && (h.inherit = h.data.inherit);
        return;
      }
      let c = this.frames;
      if (s < c[0]) {
        (o == Z.setup || o == Z.first) && (h.inherit = h.data.inherit);
        return;
      }
      h.inherit = this.frames[bt.search(c, s, 2) + 1];
    }
  }
  class nw extends qi {
    constructor(t, i, s) {
      super(t, i, [He.rgb + "|" + s, He.alpha + "|" + s]);
      T(this, "slotIndex", 0);
      this.slotIndex = s;
    }
    getFrameEntries() {
      return 5;
    }
    setFrame(t, i, s, n, a, o) {
      (t *= 5),
        (this.frames[t] = i),
        (this.frames[t + 1] = s),
        (this.frames[t + 2] = n),
        (this.frames[t + 3] = a),
        (this.frames[t + 4] = o);
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.slots[this.slotIndex];
      if (!h.bone.active) return;
      let c = this.frames,
        u = h.color;
      if (s < c[0]) {
        let x = h.data.color;
        switch (o) {
          case Z.setup:
            u.setFromColor(x);
            return;
          case Z.first:
            u.add(
              (x.r - u.r) * a,
              (x.g - u.g) * a,
              (x.b - u.b) * a,
              (x.a - u.a) * a
            );
        }
        return;
      }
      let d = 0,
        f = 0,
        p = 0,
        m = 0,
        v = bt.search(c, s, 5),
        g = this.curves[v / 5];
      switch (g) {
        case 0:
          let x = c[v];
          (d = c[v + 1]), (f = c[v + 2]), (p = c[v + 3]), (m = c[v + 4]);
          let b = (s - x) / (c[v + 5] - x);
          (d += (c[v + 5 + 1] - d) * b),
            (f += (c[v + 5 + 2] - f) * b),
            (p += (c[v + 5 + 3] - p) * b),
            (m += (c[v + 5 + 4] - m) * b);
          break;
        case 1:
          (d = c[v + 1]), (f = c[v + 2]), (p = c[v + 3]), (m = c[v + 4]);
          break;
        default:
          (d = this.getBezierValue(s, v, 1, g - 2)),
            (f = this.getBezierValue(s, v, 2, g + 18 - 2)),
            (p = this.getBezierValue(s, v, 3, g + 18 * 2 - 2)),
            (m = this.getBezierValue(s, v, 4, g + 18 * 3 - 2));
      }
      a == 1
        ? u.set(d, f, p, m)
        : (o == Z.setup && u.setFromColor(h.data.color),
          u.add((d - u.r) * a, (f - u.g) * a, (p - u.b) * a, (m - u.a) * a));
    }
  }
  class aw extends qi {
    constructor(t, i, s) {
      super(t, i, [He.rgb + "|" + s]);
      T(this, "slotIndex", 0);
      this.slotIndex = s;
    }
    getFrameEntries() {
      return 4;
    }
    setFrame(t, i, s, n, a) {
      (t <<= 2),
        (this.frames[t] = i),
        (this.frames[t + 1] = s),
        (this.frames[t + 2] = n),
        (this.frames[t + 3] = a);
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.slots[this.slotIndex];
      if (!h.bone.active) return;
      let c = this.frames,
        u = h.color;
      if (s < c[0]) {
        let g = h.data.color;
        switch (o) {
          case Z.setup:
            (u.r = g.r), (u.g = g.g), (u.b = g.b);
            return;
          case Z.first:
            (u.r += (g.r - u.r) * a),
              (u.g += (g.g - u.g) * a),
              (u.b += (g.b - u.b) * a);
        }
        return;
      }
      let d = 0,
        f = 0,
        p = 0,
        m = bt.search(c, s, 4),
        v = this.curves[m >> 2];
      switch (v) {
        case 0:
          let g = c[m];
          (d = c[m + 1]), (f = c[m + 2]), (p = c[m + 3]);
          let x = (s - g) / (c[m + 4] - g);
          (d += (c[m + 4 + 1] - d) * x),
            (f += (c[m + 4 + 2] - f) * x),
            (p += (c[m + 4 + 3] - p) * x);
          break;
        case 1:
          (d = c[m + 1]), (f = c[m + 2]), (p = c[m + 3]);
          break;
        default:
          (d = this.getBezierValue(s, m, 1, v - 2)),
            (f = this.getBezierValue(s, m, 2, v + 18 - 2)),
            (p = this.getBezierValue(s, m, 3, v + 18 * 2 - 2));
      }
      if (a == 1) (u.r = d), (u.g = f), (u.b = p);
      else {
        if (o == Z.setup) {
          let g = h.data.color;
          (u.r = g.r), (u.g = g.g), (u.b = g.b);
        }
        (u.r += (d - u.r) * a), (u.g += (f - u.g) * a), (u.b += (p - u.b) * a);
      }
    }
  }
  class ow extends xi {
    constructor(t, i, s) {
      super(t, i, He.alpha + "|" + s);
      T(this, "slotIndex", 0);
      this.slotIndex = s;
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.slots[this.slotIndex];
      if (!h.bone.active) return;
      let c = h.color;
      if (s < this.frames[0]) {
        let d = h.data.color;
        switch (o) {
          case Z.setup:
            c.a = d.a;
            return;
          case Z.first:
            c.a += (d.a - c.a) * a;
        }
        return;
      }
      let u = this.getCurveValue(s);
      a == 1
        ? (c.a = u)
        : (o == Z.setup && (c.a = h.data.color.a), (c.a += (u - c.a) * a));
    }
  }
  class lw extends qi {
    constructor(t, i, s) {
      super(t, i, [He.rgb + "|" + s, He.alpha + "|" + s, He.rgb2 + "|" + s]);
      T(this, "slotIndex", 0);
      this.slotIndex = s;
    }
    getFrameEntries() {
      return 8;
    }
    setFrame(t, i, s, n, a, o, l, h, c) {
      (t <<= 3),
        (this.frames[t] = i),
        (this.frames[t + 1] = s),
        (this.frames[t + 2] = n),
        (this.frames[t + 3] = a),
        (this.frames[t + 4] = o),
        (this.frames[t + 5] = l),
        (this.frames[t + 6] = h),
        (this.frames[t + 7] = c);
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.slots[this.slotIndex];
      if (!h.bone.active) return;
      let c = this.frames,
        u = h.color,
        d = h.darkColor;
      if (s < c[0]) {
        let w = h.data.color,
          E = h.data.darkColor;
        switch (o) {
          case Z.setup:
            u.setFromColor(w), (d.r = E.r), (d.g = E.g), (d.b = E.b);
            return;
          case Z.first:
            u.add(
              (w.r - u.r) * a,
              (w.g - u.g) * a,
              (w.b - u.b) * a,
              (w.a - u.a) * a
            ),
              (d.r += (E.r - d.r) * a),
              (d.g += (E.g - d.g) * a),
              (d.b += (E.b - d.b) * a);
        }
        return;
      }
      let f = 0,
        p = 0,
        m = 0,
        v = 0,
        g = 0,
        x = 0,
        b = 0,
        y = bt.search(c, s, 8),
        _ = this.curves[y >> 3];
      switch (_) {
        case 0:
          let w = c[y];
          (f = c[y + 1]),
            (p = c[y + 2]),
            (m = c[y + 3]),
            (v = c[y + 4]),
            (g = c[y + 5]),
            (x = c[y + 6]),
            (b = c[y + 7]);
          let E = (s - w) / (c[y + 8] - w);
          (f += (c[y + 8 + 1] - f) * E),
            (p += (c[y + 8 + 2] - p) * E),
            (m += (c[y + 8 + 3] - m) * E),
            (v += (c[y + 8 + 4] - v) * E),
            (g += (c[y + 8 + 5] - g) * E),
            (x += (c[y + 8 + 6] - x) * E),
            (b += (c[y + 8 + 7] - b) * E);
          break;
        case 1:
          (f = c[y + 1]),
            (p = c[y + 2]),
            (m = c[y + 3]),
            (v = c[y + 4]),
            (g = c[y + 5]),
            (x = c[y + 6]),
            (b = c[y + 7]);
          break;
        default:
          (f = this.getBezierValue(s, y, 1, _ - 2)),
            (p = this.getBezierValue(s, y, 2, _ + 18 - 2)),
            (m = this.getBezierValue(s, y, 3, _ + 18 * 2 - 2)),
            (v = this.getBezierValue(s, y, 4, _ + 18 * 3 - 2)),
            (g = this.getBezierValue(s, y, 5, _ + 18 * 4 - 2)),
            (x = this.getBezierValue(s, y, 6, _ + 18 * 5 - 2)),
            (b = this.getBezierValue(s, y, 7, _ + 18 * 6 - 2));
      }
      if (a == 1) u.set(f, p, m, v), (d.r = g), (d.g = x), (d.b = b);
      else {
        if (o == Z.setup) {
          u.setFromColor(h.data.color);
          let w = h.data.darkColor;
          (d.r = w.r), (d.g = w.g), (d.b = w.b);
        }
        u.add((f - u.r) * a, (p - u.g) * a, (m - u.b) * a, (v - u.a) * a),
          (d.r += (g - d.r) * a),
          (d.g += (x - d.g) * a),
          (d.b += (b - d.b) * a);
      }
    }
  }
  class hw extends qi {
    constructor(t, i, s) {
      super(t, i, [He.rgb + "|" + s, He.rgb2 + "|" + s]);
      T(this, "slotIndex", 0);
      this.slotIndex = s;
    }
    getFrameEntries() {
      return 7;
    }
    setFrame(t, i, s, n, a, o, l, h) {
      (t *= 7),
        (this.frames[t] = i),
        (this.frames[t + 1] = s),
        (this.frames[t + 2] = n),
        (this.frames[t + 3] = a),
        (this.frames[t + 4] = o),
        (this.frames[t + 5] = l),
        (this.frames[t + 6] = h);
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.slots[this.slotIndex];
      if (!h.bone.active) return;
      let c = this.frames,
        u = h.color,
        d = h.darkColor;
      if (s < c[0]) {
        let _ = h.data.color,
          w = h.data.darkColor;
        switch (o) {
          case Z.setup:
            (u.r = _.r),
              (u.g = _.g),
              (u.b = _.b),
              (d.r = w.r),
              (d.g = w.g),
              (d.b = w.b);
            return;
          case Z.first:
            (u.r += (_.r - u.r) * a),
              (u.g += (_.g - u.g) * a),
              (u.b += (_.b - u.b) * a),
              (d.r += (w.r - d.r) * a),
              (d.g += (w.g - d.g) * a),
              (d.b += (w.b - d.b) * a);
        }
        return;
      }
      let f = 0,
        p = 0,
        m = 0,
        v = 0,
        g = 0,
        x = 0,
        b = bt.search(c, s, 7),
        y = this.curves[b / 7];
      switch (y) {
        case 0:
          let _ = c[b];
          (f = c[b + 1]),
            (p = c[b + 2]),
            (m = c[b + 3]),
            (v = c[b + 4]),
            (g = c[b + 5]),
            (x = c[b + 6]);
          let w = (s - _) / (c[b + 7] - _);
          (f += (c[b + 7 + 1] - f) * w),
            (p += (c[b + 7 + 2] - p) * w),
            (m += (c[b + 7 + 3] - m) * w),
            (v += (c[b + 7 + 4] - v) * w),
            (g += (c[b + 7 + 5] - g) * w),
            (x += (c[b + 7 + 6] - x) * w);
          break;
        case 1:
          (f = c[b + 1]),
            (p = c[b + 2]),
            (m = c[b + 3]),
            (v = c[b + 4]),
            (g = c[b + 5]),
            (x = c[b + 6]);
          break;
        default:
          (f = this.getBezierValue(s, b, 1, y - 2)),
            (p = this.getBezierValue(s, b, 2, y + 18 - 2)),
            (m = this.getBezierValue(s, b, 3, y + 18 * 2 - 2)),
            (v = this.getBezierValue(s, b, 4, y + 18 * 3 - 2)),
            (g = this.getBezierValue(s, b, 5, y + 18 * 4 - 2)),
            (x = this.getBezierValue(s, b, 6, y + 18 * 5 - 2));
      }
      if (a == 1)
        (u.r = f), (u.g = p), (u.b = m), (d.r = v), (d.g = g), (d.b = x);
      else {
        if (o == Z.setup) {
          let _ = h.data.color,
            w = h.data.darkColor;
          (u.r = _.r),
            (u.g = _.g),
            (u.b = _.b),
            (d.r = w.r),
            (d.g = w.g),
            (d.b = w.b);
        }
        (u.r += (f - u.r) * a),
          (u.g += (p - u.g) * a),
          (u.b += (m - u.b) * a),
          (d.r += (v - d.r) * a),
          (d.g += (g - d.g) * a),
          (d.b += (x - d.b) * a);
      }
    }
  }
  class ua extends bt {
    constructor(t, i) {
      super(t, [He.attachment + "|" + i]);
      T(this, "slotIndex", 0);
      T(this, "attachmentNames");
      (this.slotIndex = i), (this.attachmentNames = new Array(t));
    }
    getFrameCount() {
      return this.frames.length;
    }
    setFrame(t, i, s) {
      (this.frames[t] = i), (this.attachmentNames[t] = s);
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.slots[this.slotIndex];
      if (h.bone.active) {
        if (l == dr.mixOut) {
          o == Z.setup && this.setAttachment(t, h, h.data.attachmentName);
          return;
        }
        if (s < this.frames[0]) {
          (o == Z.setup || o == Z.first) &&
            this.setAttachment(t, h, h.data.attachmentName);
          return;
        }
        this.setAttachment(
          t,
          h,
          this.attachmentNames[bt.search1(this.frames, s)]
        );
      }
    }
    setAttachment(t, i, s) {
      i.setAttachment(s ? t.getAttachment(this.slotIndex, s) : null);
    }
  }
  class cw extends qi {
    constructor(t, i, s, n) {
      super(t, i, [He.deform + "|" + s + "|" + n.id]);
      T(this, "slotIndex", 0);
      T(this, "attachment");
      T(this, "vertices");
      (this.slotIndex = s),
        (this.attachment = n),
        (this.vertices = new Array(t));
    }
    getFrameCount() {
      return this.frames.length;
    }
    setFrame(t, i, s) {
      (this.frames[t] = i), (this.vertices[t] = s);
    }
    setBezier(t, i, s, n, a, o, l, h, c, u, d) {
      let f = this.curves,
        p = this.getFrameCount() + t * 18;
      s == 0 && (f[i] = 2 + p);
      let m = (n - o * 2 + h) * 0.03,
        v = c * 0.03 - l * 0.06,
        g = ((o - h) * 3 - n + u) * 0.006,
        x = (l - c + 0.33333333) * 0.018,
        b = m * 2 + g,
        y = v * 2 + x,
        _ = (o - n) * 0.3 + m + g * 0.16666667,
        w = l * 0.3 + v + x * 0.16666667,
        E = n + _,
        A = w;
      for (let C = p + 18; p < C; p += 2)
        (f[p] = E),
          (f[p + 1] = A),
          (_ += b),
          (w += y),
          (b += g),
          (y += x),
          (E += _),
          (A += w);
    }
    getCurvePercent(t, i) {
      let s = this.curves,
        n = s[i];
      switch (n) {
        case 0:
          let h = this.frames[i];
          return (t - h) / (this.frames[i + this.getFrameEntries()] - h);
        case 1:
          return 0;
      }
      if (((n -= 2), s[n] > t)) {
        let h = this.frames[i];
        return (s[n + 1] * (t - h)) / (s[n] - h);
      }
      let a = n + 18;
      for (n += 2; n < a; n += 2)
        if (s[n] >= t) {
          let h = s[n - 2],
            c = s[n - 1];
          return c + ((t - h) / (s[n] - h)) * (s[n + 1] - c);
        }
      let o = s[a - 2],
        l = s[a - 1];
      return (
        l + ((1 - l) * (t - o)) / (this.frames[i + this.getFrameEntries()] - o)
      );
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.slots[this.slotIndex];
      if (!h.bone.active) return;
      let c = h.getAttachment();
      if (!c || !(c instanceof gi) || c.timelineAttachment != this.attachment)
        return;
      let u = h.deform;
      u.length == 0 && (o = Z.setup);
      let d = this.vertices,
        f = d[0].length,
        p = this.frames;
      if (s < p[0]) {
        switch (o) {
          case Z.setup:
            u.length = 0;
            return;
          case Z.first:
            if (a == 1) {
              u.length = 0;
              return;
            }
            u.length = f;
            let y = c;
            if (y.bones) {
              a = 1 - a;
              for (var m = 0; m < f; m++) u[m] *= a;
            } else {
              let _ = y.vertices;
              for (var m = 0; m < f; m++) u[m] += (_[m] - u[m]) * a;
            }
        }
        return;
      }
      if (((u.length = f), s >= p[p.length - 1])) {
        let y = d[p.length - 1];
        if (a == 1)
          if (o == Z.add) {
            let _ = c;
            if (_.bones) for (let w = 0; w < f; w++) u[w] += y[w];
            else {
              let w = _.vertices;
              for (let E = 0; E < f; E++) u[E] += y[E] - w[E];
            }
          } else pe.arrayCopy(y, 0, u, 0, f);
        else
          switch (o) {
            case Z.setup: {
              let w = c;
              if (w.bones) for (let E = 0; E < f; E++) u[E] = y[E] * a;
              else {
                let E = w.vertices;
                for (let A = 0; A < f; A++) {
                  let C = E[A];
                  u[A] = C + (y[A] - C) * a;
                }
              }
              break;
            }
            case Z.first:
            case Z.replace:
              for (let w = 0; w < f; w++) u[w] += (y[w] - u[w]) * a;
              break;
            case Z.add:
              let _ = c;
              if (_.bones) for (let w = 0; w < f; w++) u[w] += y[w] * a;
              else {
                let w = _.vertices;
                for (let E = 0; E < f; E++) u[E] += (y[E] - w[E]) * a;
              }
          }
        return;
      }
      let v = bt.search1(p, s),
        g = this.getCurvePercent(s, v),
        x = d[v],
        b = d[v + 1];
      if (a == 1)
        if (o == Z.add) {
          let y = c;
          if (y.bones)
            for (let _ = 0; _ < f; _++) {
              let w = x[_];
              u[_] += w + (b[_] - w) * g;
            }
          else {
            let _ = y.vertices;
            for (let w = 0; w < f; w++) {
              let E = x[w];
              u[w] += E + (b[w] - E) * g - _[w];
            }
          }
        } else
          for (let y = 0; y < f; y++) {
            let _ = x[y];
            u[y] = _ + (b[y] - _) * g;
          }
      else
        switch (o) {
          case Z.setup: {
            let _ = c;
            if (_.bones)
              for (let w = 0; w < f; w++) {
                let E = x[w];
                u[w] = (E + (b[w] - E) * g) * a;
              }
            else {
              let w = _.vertices;
              for (let E = 0; E < f; E++) {
                let A = x[E],
                  C = w[E];
                u[E] = C + (A + (b[E] - A) * g - C) * a;
              }
            }
            break;
          }
          case Z.first:
          case Z.replace:
            for (let _ = 0; _ < f; _++) {
              let w = x[_];
              u[_] += (w + (b[_] - w) * g - u[_]) * a;
            }
            break;
          case Z.add:
            let y = c;
            if (y.bones)
              for (let _ = 0; _ < f; _++) {
                let w = x[_];
                u[_] += (w + (b[_] - w) * g) * a;
              }
            else {
              let _ = y.vertices;
              for (let w = 0; w < f; w++) {
                let E = x[w];
                u[w] += (E + (b[w] - E) * g - _[w]) * a;
              }
            }
        }
    }
  }
  const uc = class uc extends bt {
    constructor(t) {
      super(t, uc.propertyIds);
      T(this, "events");
      this.events = new Array(t);
    }
    getFrameCount() {
      return this.frames.length;
    }
    setFrame(t, i) {
      (this.frames[t] = i.time), (this.events[t] = i);
    }
    apply(t, i, s, n, a, o, l) {
      if (!n) return;
      let h = this.frames,
        c = this.frames.length;
      if (i > s) this.apply(t, i, Number.MAX_VALUE, n, a, o, l), (i = -1);
      else if (i >= h[c - 1]) return;
      if (s < h[0]) return;
      let u = 0;
      if (i < h[0]) u = 0;
      else {
        u = bt.search1(h, i) + 1;
        let d = h[u];
        for (; u > 0 && h[u - 1] == d; ) u--;
      }
      for (; u < c && s >= h[u]; u++) n.push(this.events[u]);
    }
  };
  T(uc, "propertyIds", ["" + He.event]);
  let il = uc;
  const dc = class dc extends bt {
    constructor(t) {
      super(t, dc.propertyIds);
      T(this, "drawOrders");
      this.drawOrders = new Array(t);
    }
    getFrameCount() {
      return this.frames.length;
    }
    setFrame(t, i, s) {
      (this.frames[t] = i), (this.drawOrders[t] = s);
    }
    apply(t, i, s, n, a, o, l) {
      if (l == dr.mixOut) {
        o == Z.setup &&
          pe.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length);
        return;
      }
      if (s < this.frames[0]) {
        (o == Z.setup || o == Z.first) &&
          pe.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length);
        return;
      }
      let h = bt.search1(this.frames, s),
        c = this.drawOrders[h];
      if (!c) pe.arrayCopy(t.slots, 0, t.drawOrder, 0, t.slots.length);
      else {
        let u = t.drawOrder,
          d = t.slots;
        for (let f = 0, p = c.length; f < p; f++) u[f] = d[c[f]];
      }
    }
  };
  T(dc, "propertyIds", ["" + He.drawOrder]);
  let Cn = dc;
  class uw extends qi {
    constructor(t, i, s) {
      super(t, i, [He.ikConstraint + "|" + s]);
      T(this, "constraintIndex", 0);
      this.constraintIndex = s;
    }
    getFrameEntries() {
      return 6;
    }
    setFrame(t, i, s, n, a, o, l) {
      (t *= 6),
        (this.frames[t] = i),
        (this.frames[t + 1] = s),
        (this.frames[t + 2] = n),
        (this.frames[t + 3] = a),
        (this.frames[t + 4] = o ? 1 : 0),
        (this.frames[t + 5] = l ? 1 : 0);
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.ikConstraints[this.constraintIndex];
      if (!h.active) return;
      let c = this.frames;
      if (s < c[0]) {
        switch (o) {
          case Z.setup:
            (h.mix = h.data.mix),
              (h.softness = h.data.softness),
              (h.bendDirection = h.data.bendDirection),
              (h.compress = h.data.compress),
              (h.stretch = h.data.stretch);
            return;
          case Z.first:
            (h.mix += (h.data.mix - h.mix) * a),
              (h.softness += (h.data.softness - h.softness) * a),
              (h.bendDirection = h.data.bendDirection),
              (h.compress = h.data.compress),
              (h.stretch = h.data.stretch);
        }
        return;
      }
      let u = 0,
        d = 0,
        f = bt.search(c, s, 6),
        p = this.curves[f / 6];
      switch (p) {
        case 0:
          let m = c[f];
          (u = c[f + 1]), (d = c[f + 2]);
          let v = (s - m) / (c[f + 6] - m);
          (u += (c[f + 6 + 1] - u) * v), (d += (c[f + 6 + 2] - d) * v);
          break;
        case 1:
          (u = c[f + 1]), (d = c[f + 2]);
          break;
        default:
          (u = this.getBezierValue(s, f, 1, p - 2)),
            (d = this.getBezierValue(s, f, 2, p + 18 - 2));
      }
      o == Z.setup
        ? ((h.mix = h.data.mix + (u - h.data.mix) * a),
          (h.softness = h.data.softness + (d - h.data.softness) * a),
          l == dr.mixOut
            ? ((h.bendDirection = h.data.bendDirection),
              (h.compress = h.data.compress),
              (h.stretch = h.data.stretch))
            : ((h.bendDirection = c[f + 3]),
              (h.compress = c[f + 4] != 0),
              (h.stretch = c[f + 5] != 0)))
        : ((h.mix += (u - h.mix) * a),
          (h.softness += (d - h.softness) * a),
          l == dr.mixIn &&
            ((h.bendDirection = c[f + 3]),
            (h.compress = c[f + 4] != 0),
            (h.stretch = c[f + 5] != 0)));
    }
  }
  class dw extends qi {
    constructor(t, i, s) {
      super(t, i, [He.transformConstraint + "|" + s]);
      T(this, "constraintIndex", 0);
      this.constraintIndex = s;
    }
    getFrameEntries() {
      return 7;
    }
    setFrame(t, i, s, n, a, o, l, h) {
      let c = this.frames;
      (t *= 7),
        (c[t] = i),
        (c[t + 1] = s),
        (c[t + 2] = n),
        (c[t + 3] = a),
        (c[t + 4] = o),
        (c[t + 5] = l),
        (c[t + 6] = h);
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.transformConstraints[this.constraintIndex];
      if (!h.active) return;
      let c = this.frames;
      if (s < c[0]) {
        let b = h.data;
        switch (o) {
          case Z.setup:
            (h.mixRotate = b.mixRotate),
              (h.mixX = b.mixX),
              (h.mixY = b.mixY),
              (h.mixScaleX = b.mixScaleX),
              (h.mixScaleY = b.mixScaleY),
              (h.mixShearY = b.mixShearY);
            return;
          case Z.first:
            (h.mixRotate += (b.mixRotate - h.mixRotate) * a),
              (h.mixX += (b.mixX - h.mixX) * a),
              (h.mixY += (b.mixY - h.mixY) * a),
              (h.mixScaleX += (b.mixScaleX - h.mixScaleX) * a),
              (h.mixScaleY += (b.mixScaleY - h.mixScaleY) * a),
              (h.mixShearY += (b.mixShearY - h.mixShearY) * a);
        }
        return;
      }
      let u,
        d,
        f,
        p,
        m,
        v,
        g = bt.search(c, s, 7),
        x = this.curves[g / 7];
      switch (x) {
        case 0:
          let b = c[g];
          (u = c[g + 1]),
            (d = c[g + 2]),
            (f = c[g + 3]),
            (p = c[g + 4]),
            (m = c[g + 5]),
            (v = c[g + 6]);
          let y = (s - b) / (c[g + 7] - b);
          (u += (c[g + 7 + 1] - u) * y),
            (d += (c[g + 7 + 2] - d) * y),
            (f += (c[g + 7 + 3] - f) * y),
            (p += (c[g + 7 + 4] - p) * y),
            (m += (c[g + 7 + 5] - m) * y),
            (v += (c[g + 7 + 6] - v) * y);
          break;
        case 1:
          (u = c[g + 1]),
            (d = c[g + 2]),
            (f = c[g + 3]),
            (p = c[g + 4]),
            (m = c[g + 5]),
            (v = c[g + 6]);
          break;
        default:
          (u = this.getBezierValue(s, g, 1, x - 2)),
            (d = this.getBezierValue(s, g, 2, x + 18 - 2)),
            (f = this.getBezierValue(s, g, 3, x + 18 * 2 - 2)),
            (p = this.getBezierValue(s, g, 4, x + 18 * 3 - 2)),
            (m = this.getBezierValue(s, g, 5, x + 18 * 4 - 2)),
            (v = this.getBezierValue(s, g, 6, x + 18 * 5 - 2));
      }
      if (o == Z.setup) {
        let b = h.data;
        (h.mixRotate = b.mixRotate + (u - b.mixRotate) * a),
          (h.mixX = b.mixX + (d - b.mixX) * a),
          (h.mixY = b.mixY + (f - b.mixY) * a),
          (h.mixScaleX = b.mixScaleX + (p - b.mixScaleX) * a),
          (h.mixScaleY = b.mixScaleY + (m - b.mixScaleY) * a),
          (h.mixShearY = b.mixShearY + (v - b.mixShearY) * a);
      } else
        (h.mixRotate += (u - h.mixRotate) * a),
          (h.mixX += (d - h.mixX) * a),
          (h.mixY += (f - h.mixY) * a),
          (h.mixScaleX += (p - h.mixScaleX) * a),
          (h.mixScaleY += (m - h.mixScaleY) * a),
          (h.mixShearY += (v - h.mixShearY) * a);
    }
  }
  class fw extends xi {
    constructor(t, i, s) {
      super(t, i, He.pathConstraintPosition + "|" + s);
      T(this, "constraintIndex", 0);
      this.constraintIndex = s;
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.pathConstraints[this.constraintIndex];
      h.active &&
        (h.position = this.getAbsoluteValue(
          s,
          a,
          o,
          h.position,
          h.data.position
        ));
    }
  }
  class pw extends xi {
    constructor(t, i, s) {
      super(t, i, He.pathConstraintSpacing + "|" + s);
      T(this, "constraintIndex", 0);
      this.constraintIndex = s;
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.pathConstraints[this.constraintIndex];
      h.active &&
        (h.spacing = this.getAbsoluteValue(s, a, o, h.spacing, h.data.spacing));
    }
  }
  class mw extends qi {
    constructor(t, i, s) {
      super(t, i, [He.pathConstraintMix + "|" + s]);
      T(this, "constraintIndex", 0);
      this.constraintIndex = s;
    }
    getFrameEntries() {
      return 4;
    }
    setFrame(t, i, s, n, a) {
      let o = this.frames;
      (t <<= 2), (o[t] = i), (o[t + 1] = s), (o[t + 2] = n), (o[t + 3] = a);
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.pathConstraints[this.constraintIndex];
      if (!h.active) return;
      let c = this.frames;
      if (s < c[0]) {
        switch (o) {
          case Z.setup:
            (h.mixRotate = h.data.mixRotate),
              (h.mixX = h.data.mixX),
              (h.mixY = h.data.mixY);
            return;
          case Z.first:
            (h.mixRotate += (h.data.mixRotate - h.mixRotate) * a),
              (h.mixX += (h.data.mixX - h.mixX) * a),
              (h.mixY += (h.data.mixY - h.mixY) * a);
        }
        return;
      }
      let u,
        d,
        f,
        p = bt.search(c, s, 4),
        m = this.curves[p >> 2];
      switch (m) {
        case 0:
          let v = c[p];
          (u = c[p + 1]), (d = c[p + 2]), (f = c[p + 3]);
          let g = (s - v) / (c[p + 4] - v);
          (u += (c[p + 4 + 1] - u) * g),
            (d += (c[p + 4 + 2] - d) * g),
            (f += (c[p + 4 + 3] - f) * g);
          break;
        case 1:
          (u = c[p + 1]), (d = c[p + 2]), (f = c[p + 3]);
          break;
        default:
          (u = this.getBezierValue(s, p, 1, m - 2)),
            (d = this.getBezierValue(s, p, 2, m + 18 - 2)),
            (f = this.getBezierValue(s, p, 3, m + 18 * 2 - 2));
      }
      if (o == Z.setup) {
        let v = h.data;
        (h.mixRotate = v.mixRotate + (u - v.mixRotate) * a),
          (h.mixX = v.mixX + (d - v.mixX) * a),
          (h.mixY = v.mixY + (f - v.mixY) * a);
      } else
        (h.mixRotate += (u - h.mixRotate) * a),
          (h.mixX += (d - h.mixX) * a),
          (h.mixY += (f - h.mixY) * a);
    }
  }
  class Hn extends xi {
    constructor(t, i, s, n) {
      super(t, i, n + "|" + s);
      T(this, "constraintIndex", 0);
      this.constraintIndex = s;
    }
    apply(t, i, s, n, a, o, l) {
      let h;
      if (this.constraintIndex == -1) {
        const c = s >= this.frames[0] ? this.getCurveValue(s) : 0;
        for (const u of t.physicsConstraints)
          u.active &&
            this.global(u.data) &&
            this.set(
              u,
              this.getAbsoluteValue2(s, a, o, this.get(u), this.setup(u), c)
            );
      } else
        (h = t.physicsConstraints[this.constraintIndex]),
          h.active &&
            this.set(
              h,
              this.getAbsoluteValue(s, a, o, this.get(h), this.setup(h))
            );
    }
  }
  class gw extends Hn {
    constructor(e, t, i) {
      super(e, t, i, He.physicsConstraintInertia);
    }
    setup(e) {
      return e.data.inertia;
    }
    get(e) {
      return e.inertia;
    }
    set(e, t) {
      e.inertia = t;
    }
    global(e) {
      return e.inertiaGlobal;
    }
  }
  class vw extends Hn {
    constructor(e, t, i) {
      super(e, t, i, He.physicsConstraintStrength);
    }
    setup(e) {
      return e.data.strength;
    }
    get(e) {
      return e.strength;
    }
    set(e, t) {
      e.strength = t;
    }
    global(e) {
      return e.strengthGlobal;
    }
  }
  class yw extends Hn {
    constructor(e, t, i) {
      super(e, t, i, He.physicsConstraintDamping);
    }
    setup(e) {
      return e.data.damping;
    }
    get(e) {
      return e.damping;
    }
    set(e, t) {
      e.damping = t;
    }
    global(e) {
      return e.dampingGlobal;
    }
  }
  class bw extends Hn {
    constructor(e, t, i) {
      super(e, t, i, He.physicsConstraintMass);
    }
    setup(e) {
      return 1 / e.data.massInverse;
    }
    get(e) {
      return 1 / e.massInverse;
    }
    set(e, t) {
      e.massInverse = 1 / t;
    }
    global(e) {
      return e.massGlobal;
    }
  }
  class xw extends Hn {
    constructor(e, t, i) {
      super(e, t, i, He.physicsConstraintWind);
    }
    setup(e) {
      return e.data.wind;
    }
    get(e) {
      return e.wind;
    }
    set(e, t) {
      e.wind = t;
    }
    global(e) {
      return e.windGlobal;
    }
  }
  class _w extends Hn {
    constructor(e, t, i) {
      super(e, t, i, He.physicsConstraintGravity);
    }
    setup(e) {
      return e.data.gravity;
    }
    get(e) {
      return e.gravity;
    }
    set(e, t) {
      e.gravity = t;
    }
    global(e) {
      return e.gravityGlobal;
    }
  }
  class ww extends Hn {
    constructor(e, t, i) {
      super(e, t, i, He.physicsConstraintMix);
    }
    setup(e) {
      return e.data.mix;
    }
    get(e) {
      return e.mix;
    }
    set(e, t) {
      e.mix = t;
    }
    global(e) {
      return e.mixGlobal;
    }
  }
  const fc = class fc extends bt {
    constructor(t, i) {
      super(t, fc.propertyIds);
      T(this, "constraintIndex");
      this.constraintIndex = i;
    }
    getFrameCount() {
      return this.frames.length;
    }
    setFrame(t, i) {
      this.frames[t] = i;
    }
    apply(t, i, s, n, a, o, l) {
      let h;
      if (
        this.constraintIndex != -1 &&
        ((h = t.physicsConstraints[this.constraintIndex]), !h.active)
      )
        return;
      const c = this.frames;
      if (i > s) this.apply(t, i, Number.MAX_VALUE, [], a, o, l), (i = -1);
      else if (i >= c[c.length - 1]) return;
      if (!(s < c[0]) && (i < c[0] || s >= c[bt.search1(c, i) + 1]))
        if (h != null) h.reset();
        else for (const u of t.physicsConstraints) u.active && u.reset();
    }
  };
  T(fc, "propertyIds", [He.physicsConstraintReset.toString()]);
  let oc = fc;
  const Lr = class Lr extends bt {
    constructor(t, i, s) {
      super(t, [He.sequence + "|" + i + "|" + s.sequence.id]);
      T(this, "slotIndex");
      T(this, "attachment");
      (this.slotIndex = i), (this.attachment = s);
    }
    getFrameEntries() {
      return Lr.ENTRIES;
    }
    getSlotIndex() {
      return this.slotIndex;
    }
    getAttachment() {
      return this.attachment;
    }
    setFrame(t, i, s, n, a) {
      let o = this.frames;
      (t *= Lr.ENTRIES),
        (o[t] = i),
        (o[t + Lr.MODE] = s | (n << 4)),
        (o[t + Lr.DELAY] = a);
    }
    apply(t, i, s, n, a, o, l) {
      let h = t.slots[this.slotIndex];
      if (!h.bone.active) return;
      let c = h.attachment,
        u = this.attachment;
      if (c != u && (!(c instanceof gi) || c.timelineAttachment != u)) return;
      let d = this.frames;
      if (s < d[0]) {
        (o == Z.setup || o == Z.first) && (h.sequenceIndex = -1);
        return;
      }
      let f = bt.search(d, s, Lr.ENTRIES),
        p = d[f],
        m = d[f + Lr.MODE],
        v = d[f + Lr.DELAY];
      if (!this.attachment.sequence) return;
      let g = m >> 4,
        x = this.attachment.sequence.regions.length,
        b = j_[m & 15];
      if (b != jt.hold)
        switch (((g += ((s - p) / v + 1e-5) | 0), b)) {
          case jt.once:
            g = Math.min(x - 1, g);
            break;
          case jt.loop:
            g %= x;
            break;
          case jt.pingpong: {
            let y = (x << 1) - 2;
            (g = y == 0 ? 0 : g % y), g >= x && (g = y - g);
            break;
          }
          case jt.onceReverse:
            g = Math.max(x - 1 - g, 0);
            break;
          case jt.loopReverse:
            g = x - 1 - (g % x);
            break;
          case jt.pingpongReverse: {
            let y = (x << 1) - 2;
            (g = y == 0 ? 0 : (g + x - 1) % y), g >= x && (g = y - g);
          }
        }
      h.sequenceIndex = g;
    }
  };
  T(Lr, "ENTRIES", 3), T(Lr, "MODE", 1), T(Lr, "DELAY", 2);
  let lc = Lr;
  const fa = class fa {
    constructor(e) {
      T(this, "data");
      T(this, "tracks", new Array());
      T(this, "timeScale", 1);
      T(this, "unkeyedState", 0);
      T(this, "events", new Array());
      T(this, "listeners", new Array());
      T(this, "queue", new x5(this));
      T(this, "propertyIDs", new W_());
      T(this, "animationsChanged", !1);
      T(this, "trackEntryPool", new Lf(() => new b5()));
      this.data = e;
    }
    static emptyAnimation() {
      return fa._emptyAnimation;
    }
    update(e) {
      e *= this.timeScale;
      let t = this.tracks;
      for (let i = 0, s = t.length; i < s; i++) {
        let n = t[i];
        if (!n) continue;
        (n.animationLast = n.nextAnimationLast),
          (n.trackLast = n.nextTrackLast);
        let a = e * n.timeScale;
        if (n.delay > 0) {
          if (((n.delay -= a), n.delay > 0)) continue;
          (a = -n.delay), (n.delay = 0);
        }
        let o = n.next;
        if (o) {
          let l = n.trackLast - o.delay;
          if (l >= 0) {
            for (
              o.delay = 0,
                o.trackTime +=
                  n.timeScale == 0 ? 0 : (l / n.timeScale + e) * o.timeScale,
                n.trackTime += a,
                this.setCurrent(i, o, !0);
              o.mixingFrom;

            )
              (o.mixTime += e), (o = o.mixingFrom);
            continue;
          }
        } else if (n.trackLast >= n.trackEnd && !n.mixingFrom) {
          (t[i] = null), this.queue.end(n), this.clearNext(n);
          continue;
        }
        if (n.mixingFrom && this.updateMixingFrom(n, e)) {
          let l = n.mixingFrom;
          for (n.mixingFrom = null, l && (l.mixingTo = null); l; )
            this.queue.end(l), (l = l.mixingFrom);
        }
        n.trackTime += a;
      }
      this.queue.drain();
    }
    updateMixingFrom(e, t) {
      let i = e.mixingFrom;
      if (!i) return !0;
      let s = this.updateMixingFrom(i, t);
      return (
        (i.animationLast = i.nextAnimationLast),
        (i.trackLast = i.nextTrackLast),
        e.mixTime > 0 && e.mixTime >= e.mixDuration
          ? ((i.totalAlpha == 0 || e.mixDuration == 0) &&
              ((e.mixingFrom = i.mixingFrom),
              i.mixingFrom && (i.mixingFrom.mixingTo = e),
              (e.interruptAlpha = i.interruptAlpha),
              this.queue.end(i)),
            s)
          : ((i.trackTime += t * i.timeScale), (e.mixTime += t), !1)
      );
    }
    apply(e) {
      if (!e) throw new Error("skeleton cannot be null.");
      this.animationsChanged && this._animationsChanged();
      let t = this.events,
        i = this.tracks,
        s = !1;
      for (let d = 0, f = i.length; d < f; d++) {
        let p = i[d];
        if (!p || p.delay > 0) continue;
        s = !0;
        let m = d == 0 ? Z.first : p.mixBlend,
          v = p.alpha;
        p.mixingFrom
          ? (v *= this.applyMixingFrom(p, e, m))
          : p.trackTime >= p.trackEnd && !p.next && (v = 0);
        let g = v >= p.alphaAttachmentThreshold,
          x = p.animationLast,
          b = p.getAnimationTime(),
          y = b,
          _ = t;
        p.reverse && ((y = p.animation.duration - y), (_ = null));
        let w = p.animation.timelines,
          E = w.length;
        if ((d == 0 && v == 1) || m == Z.add) {
          d == 0 && (g = !0);
          for (let A = 0; A < E; A++) {
            var n = w[A];
            n instanceof ua
              ? this.applyAttachmentTimeline(n, e, y, m, g)
              : n.apply(e, x, y, _, v, m, dr.mixIn);
          }
        } else {
          let A = p.timelineMode,
            C = p.shortestRotation,
            F = !C && p.timelinesRotation.length != E << 1;
          F && (p.timelinesRotation.length = E << 1);
          for (let B = 0; B < E; B++) {
            let R = w[B],
              I = A[B] == od ? m : Z.setup;
            !C && R instanceof ac
              ? this.applyRotateTimeline(
                  R,
                  e,
                  y,
                  v,
                  I,
                  p.timelinesRotation,
                  B << 1,
                  F
                )
              : R instanceof ua
              ? this.applyAttachmentTimeline(R, e, y, m, g)
              : R.apply(e, x, y, _, v, I, dr.mixIn);
          }
        }
        this.queueEvents(p, b),
          (t.length = 0),
          (p.nextAnimationLast = b),
          (p.nextTrackLast = p.trackTime);
      }
      for (
        var a = this.unkeyedState + hy, o = e.slots, l = 0, h = e.slots.length;
        l < h;
        l++
      ) {
        var c = o[l];
        if (c.attachmentState == a) {
          var u = c.data.attachmentName;
          c.setAttachment(u ? e.getAttachment(c.data.index, u) : null);
        }
      }
      return (this.unkeyedState += 2), this.queue.drain(), s;
    }
    applyMixingFrom(e, t, i) {
      let s = e.mixingFrom;
      s.mixingFrom && this.applyMixingFrom(s, t, i);
      let n = 0;
      e.mixDuration == 0
        ? ((n = 1), i == Z.first && (i = Z.setup))
        : ((n = e.mixTime / e.mixDuration),
          n > 1 && (n = 1),
          i != Z.first && (i = s.mixBlend));
      let a = n < s.mixAttachmentThreshold,
        o = n < s.mixDrawOrderThreshold,
        l = s.animation.timelines,
        h = l.length,
        c = s.alpha * e.interruptAlpha,
        u = c * (1 - n),
        d = s.animationLast,
        f = s.getAnimationTime(),
        p = f,
        m = null;
      if (
        (s.reverse
          ? (p = s.animation.duration - p)
          : n < s.eventThreshold && (m = this.events),
        i == Z.add)
      )
        for (let v = 0; v < h; v++) l[v].apply(t, d, p, m, u, i, dr.mixOut);
      else {
        let v = s.timelineMode,
          g = s.timelineHoldMix,
          x = s.shortestRotation,
          b = !x && s.timelinesRotation.length != h << 1;
        b && (s.timelinesRotation.length = h << 1), (s.totalAlpha = 0);
        for (let y = 0; y < h; y++) {
          let _ = l[y],
            w = dr.mixOut,
            E,
            A = 0;
          switch (v[y]) {
            case od:
              if (!o && _ instanceof Cn) continue;
              (E = i), (A = u);
              break;
            case oy:
              (E = Z.setup), (A = u);
              break;
            case ly:
              (E = i), (A = c);
              break;
            case ld:
              (E = Z.setup), (A = c);
              break;
            default:
              E = Z.setup;
              let C = g[y];
              A = c * Math.max(0, 1 - C.mixTime / C.mixDuration);
              break;
          }
          (s.totalAlpha += A),
            !x && _ instanceof ac
              ? this.applyRotateTimeline(
                  _,
                  t,
                  p,
                  A,
                  E,
                  s.timelinesRotation,
                  y << 1,
                  b
                )
              : _ instanceof ua
              ? this.applyAttachmentTimeline(
                  _,
                  t,
                  p,
                  E,
                  a && A >= s.alphaAttachmentThreshold
                )
              : (o && _ instanceof Cn && E == Z.setup && (w = dr.mixIn),
                _.apply(t, d, p, m, A, E, w));
        }
      }
      return (
        e.mixDuration > 0 && this.queueEvents(s, f),
        (this.events.length = 0),
        (s.nextAnimationLast = f),
        (s.nextTrackLast = s.trackTime),
        n
      );
    }
    applyAttachmentTimeline(e, t, i, s, n) {
      var a = t.slots[e.slotIndex];
      a.bone.active &&
        (i < e.frames[0]
          ? (s == Z.setup || s == Z.first) &&
            this.setAttachment(t, a, a.data.attachmentName, n)
          : this.setAttachment(
              t,
              a,
              e.attachmentNames[bt.search1(e.frames, i)],
              n
            ),
        a.attachmentState <= this.unkeyedState &&
          (a.attachmentState = this.unkeyedState + hy));
    }
    setAttachment(e, t, i, s) {
      t.setAttachment(i ? e.getAttachment(t.data.index, i) : null),
        s && (t.attachmentState = this.unkeyedState + w5);
    }
    applyRotateTimeline(e, t, i, s, n, a, o, l) {
      if ((l && (a[o] = 0), s == 1)) {
        e.apply(t, 0, i, null, 1, n, dr.mixIn);
        return;
      }
      let h = t.bones[e.boneIndex];
      if (!h.active) return;
      let c = e.frames,
        u = 0,
        d = 0;
      if (i < c[0])
        switch (n) {
          case Z.setup:
            h.rotation = h.data.rotation;
          default:
            return;
          case Z.first:
            (u = h.rotation), (d = h.data.rotation);
        }
      else
        (u = n == Z.setup ? h.data.rotation : h.rotation),
          (d = h.data.rotation + e.getCurveValue(i));
      let f = 0,
        p = d - u;
      if (((p -= Math.ceil(p / 360 - 0.5) * 360), p == 0)) f = a[o];
      else {
        let m = 0,
          v = 0;
        l ? ((m = 0), (v = p)) : ((m = a[o]), (v = a[o + 1]));
        let g = m - (m % 360);
        f = p + g;
        let x = p >= 0,
          b = m >= 0;
        Math.abs(v) <= 90 &&
          ae.signum(v) != ae.signum(p) &&
          (Math.abs(m - g) > 180
            ? ((f += 360 * ae.signum(m)), (b = x))
            : g != 0
            ? (f -= 360 * ae.signum(m))
            : (b = x)),
          b != x && (f += 360 * ae.signum(m)),
          (a[o] = f);
      }
      (a[o + 1] = p), (h.rotation = u + f * s);
    }
    queueEvents(e, t) {
      let i = e.animationStart,
        s = e.animationEnd,
        n = s - i,
        a = e.trackLast % n,
        o = this.events,
        l = 0,
        h = o.length;
      for (; l < h; l++) {
        let u = o[l];
        if (u.time < a) break;
        u.time > s || this.queue.event(e, u);
      }
      let c = !1;
      if (e.loop)
        if (n == 0) c = !0;
        else {
          const u = Math.floor(e.trackTime / n);
          c = u > 0 && u > Math.floor(e.trackLast / n);
        }
      else c = t >= s && e.animationLast < s;
      for (c && this.queue.complete(e); l < h; l++) {
        let u = o[l];
        u.time < i || this.queue.event(e, u);
      }
    }
    clearTracks() {
      let e = this.queue.drainDisabled;
      this.queue.drainDisabled = !0;
      for (let t = 0, i = this.tracks.length; t < i; t++) this.clearTrack(t);
      (this.tracks.length = 0),
        (this.queue.drainDisabled = e),
        this.queue.drain();
    }
    clearTrack(e) {
      if (e >= this.tracks.length) return;
      let t = this.tracks[e];
      if (!t) return;
      this.queue.end(t), this.clearNext(t);
      let i = t;
      for (;;) {
        let s = i.mixingFrom;
        if (!s) break;
        this.queue.end(s), (i.mixingFrom = null), (i.mixingTo = null), (i = s);
      }
      (this.tracks[t.trackIndex] = null), this.queue.drain();
    }
    setCurrent(e, t, i) {
      let s = this.expandToIndex(e);
      (this.tracks[e] = t),
        (t.previous = null),
        s &&
          (i && this.queue.interrupt(s),
          (t.mixingFrom = s),
          (s.mixingTo = t),
          (t.mixTime = 0),
          s.mixingFrom &&
            s.mixDuration > 0 &&
            (t.interruptAlpha *= Math.min(1, s.mixTime / s.mixDuration)),
          (s.timelinesRotation.length = 0)),
        this.queue.start(t);
    }
    setAnimation(e, t, i = !1) {
      let s = this.data.skeletonData.findAnimation(t);
      if (!s) throw new Error("Animation not found: " + t);
      return this.setAnimationWith(e, s, i);
    }
    setAnimationWith(e, t, i = !1) {
      if (!t) throw new Error("animation cannot be null.");
      let s = !0,
        n = this.expandToIndex(e);
      n &&
        (n.nextTrackLast == -1
          ? ((this.tracks[e] = n.mixingFrom),
            this.queue.interrupt(n),
            this.queue.end(n),
            this.clearNext(n),
            (n = n.mixingFrom),
            (s = !1))
          : this.clearNext(n));
      let a = this.trackEntry(e, t, i, n);
      return this.setCurrent(e, a, s), this.queue.drain(), a;
    }
    addAnimation(e, t, i = !1, s = 0) {
      let n = this.data.skeletonData.findAnimation(t);
      if (!n) throw new Error("Animation not found: " + t);
      return this.addAnimationWith(e, n, i, s);
    }
    addAnimationWith(e, t, i = !1, s = 0) {
      if (!t) throw new Error("animation cannot be null.");
      let n = this.expandToIndex(e);
      if (n) for (; n.next; ) n = n.next;
      let a = this.trackEntry(e, t, i, n);
      return (
        n
          ? ((n.next = a),
            (a.previous = n),
            s <= 0 && (s += n.getTrackComplete() - a.mixDuration))
          : (this.setCurrent(e, a, !0), this.queue.drain()),
        (a.delay = s),
        a
      );
    }
    setEmptyAnimation(e, t = 0) {
      let i = this.setAnimationWith(e, fa.emptyAnimation(), !1);
      return (i.mixDuration = t), (i.trackEnd = t), i;
    }
    addEmptyAnimation(e, t = 0, i = 0) {
      let s = this.addAnimationWith(e, fa.emptyAnimation(), !1, i);
      return (
        i <= 0 && (s.delay += s.mixDuration - t),
        (s.mixDuration = t),
        (s.trackEnd = t),
        s
      );
    }
    setEmptyAnimations(e = 0) {
      let t = this.queue.drainDisabled;
      this.queue.drainDisabled = !0;
      for (let i = 0, s = this.tracks.length; i < s; i++) {
        let n = this.tracks[i];
        n && this.setEmptyAnimation(n.trackIndex, e);
      }
      (this.queue.drainDisabled = t), this.queue.drain();
    }
    expandToIndex(e) {
      return e < this.tracks.length
        ? this.tracks[e]
        : (pe.ensureArrayCapacity(this.tracks, e + 1, null),
          (this.tracks.length = e + 1),
          null);
    }
    trackEntry(e, t, i, s) {
      let n = this.trackEntryPool.obtain();
      return (
        n.reset(),
        (n.trackIndex = e),
        (n.animation = t),
        (n.loop = i),
        (n.holdPrevious = !1),
        (n.reverse = !1),
        (n.shortestRotation = !1),
        (n.eventThreshold = 0),
        (n.alphaAttachmentThreshold = 0),
        (n.mixAttachmentThreshold = 0),
        (n.mixDrawOrderThreshold = 0),
        (n.animationStart = 0),
        (n.animationEnd = t.duration),
        (n.animationLast = -1),
        (n.nextAnimationLast = -1),
        (n.delay = 0),
        (n.trackTime = 0),
        (n.trackLast = -1),
        (n.nextTrackLast = -1),
        (n.trackEnd = Number.MAX_VALUE),
        (n.timeScale = 1),
        (n.alpha = 1),
        (n.mixTime = 0),
        (n.mixDuration = s ? this.data.getMix(s.animation, t) : 0),
        (n.interruptAlpha = 1),
        (n.totalAlpha = 0),
        (n.mixBlend = Z.replace),
        n
      );
    }
    clearNext(e) {
      let t = e.next;
      for (; t; ) this.queue.dispose(t), (t = t.next);
      e.next = null;
    }
    _animationsChanged() {
      (this.animationsChanged = !1), this.propertyIDs.clear();
      let e = this.tracks;
      for (let t = 0, i = e.length; t < i; t++) {
        let s = e[t];
        if (s) {
          for (; s.mixingFrom; ) s = s.mixingFrom;
          do
            (!s.mixingTo || s.mixBlend != Z.add) && this.computeHold(s),
              (s = s.mixingTo);
          while (s);
        }
      }
    }
    computeHold(e) {
      let t = e.mixingTo,
        i = e.animation.timelines,
        s = e.animation.timelines.length,
        n = e.timelineMode;
      n.length = s;
      let a = e.timelineHoldMix;
      a.length = 0;
      let o = this.propertyIDs;
      if (t && t.holdPrevious) {
        for (let l = 0; l < s; l++)
          n[l] = o.addAll(i[l].getPropertyIds()) ? ld : ly;
        return;
      }
      e: for (let l = 0; l < s; l++) {
        let h = i[l],
          c = h.getPropertyIds();
        if (!o.addAll(c)) n[l] = od;
        else if (
          !t ||
          h instanceof ua ||
          h instanceof Cn ||
          h instanceof il ||
          !t.animation.hasTimeline(c)
        )
          n[l] = oy;
        else {
          for (let u = t.mixingTo; u; u = u.mixingTo)
            if (!u.animation.hasTimeline(c)) {
              if (e.mixDuration > 0) {
                (n[l] = _5), (a[l] = u);
                continue e;
              }
              break;
            }
          n[l] = ld;
        }
      }
    }
    getCurrent(e) {
      return e >= this.tracks.length ? null : this.tracks[e];
    }
    addListener(e) {
      if (!e) throw new Error("listener cannot be null.");
      this.listeners.push(e);
    }
    removeListener(e) {
      let t = this.listeners.indexOf(e);
      t >= 0 && this.listeners.splice(t, 1);
    }
    clearListeners() {
      this.listeners.length = 0;
    }
    clearListenerNotifications() {
      this.queue.clear();
    }
  };
  T(fa, "_emptyAnimation", new cm("<empty>", [], 0));
  let Nf = fa;
  class b5 {
    constructor() {
      T(this, "animation", null);
      T(this, "previous", null);
      T(this, "next", null);
      T(this, "mixingFrom", null);
      T(this, "mixingTo", null);
      T(this, "listener", null);
      T(this, "trackIndex", 0);
      T(this, "loop", !1);
      T(this, "holdPrevious", !1);
      T(this, "reverse", !1);
      T(this, "shortestRotation", !1);
      T(this, "eventThreshold", 0);
      T(this, "mixAttachmentThreshold", 0);
      T(this, "alphaAttachmentThreshold", 0);
      T(this, "mixDrawOrderThreshold", 0);
      T(this, "animationStart", 0);
      T(this, "animationEnd", 0);
      T(this, "animationLast", 0);
      T(this, "nextAnimationLast", 0);
      T(this, "delay", 0);
      T(this, "trackTime", 0);
      T(this, "trackLast", 0);
      T(this, "nextTrackLast", 0);
      T(this, "trackEnd", 0);
      T(this, "timeScale", 0);
      T(this, "alpha", 0);
      T(this, "mixTime", 0);
      T(this, "_mixDuration", 0);
      T(this, "interruptAlpha", 0);
      T(this, "totalAlpha", 0);
      T(this, "mixBlend", Z.replace);
      T(this, "timelineMode", new Array());
      T(this, "timelineHoldMix", new Array());
      T(this, "timelinesRotation", new Array());
    }
    get mixDuration() {
      return this._mixDuration;
    }
    set mixDuration(e) {
      this._mixDuration = e;
    }
    setMixDurationWithDelay(e, t) {
      (this._mixDuration = e),
        this.previous != null &&
          t <= 0 &&
          (t += this.previous.getTrackComplete() - e),
        (this.delay = t);
    }
    reset() {
      (this.next = null),
        (this.previous = null),
        (this.mixingFrom = null),
        (this.mixingTo = null),
        (this.animation = null),
        (this.listener = null),
        (this.timelineMode.length = 0),
        (this.timelineHoldMix.length = 0),
        (this.timelinesRotation.length = 0);
    }
    getAnimationTime() {
      if (this.loop) {
        let e = this.animationEnd - this.animationStart;
        return e == 0
          ? this.animationStart
          : (this.trackTime % e) + this.animationStart;
      }
      return Math.min(this.trackTime + this.animationStart, this.animationEnd);
    }
    setAnimationLast(e) {
      (this.animationLast = e), (this.nextAnimationLast = e);
    }
    isComplete() {
      return this.trackTime >= this.animationEnd - this.animationStart;
    }
    resetRotationDirections() {
      this.timelinesRotation.length = 0;
    }
    getTrackComplete() {
      let e = this.animationEnd - this.animationStart;
      if (e != 0) {
        if (this.loop) return e * (1 + ((this.trackTime / e) | 0));
        if (this.trackTime < e) return e;
      }
      return this.trackTime;
    }
    wasApplied() {
      return this.nextTrackLast != -1;
    }
    isNextReady() {
      return this.next != null && this.nextTrackLast - this.next.delay >= 0;
    }
  }
  class x5 {
    constructor(e) {
      T(this, "objects", []);
      T(this, "drainDisabled", !1);
      T(this, "animState");
      this.animState = e;
    }
    start(e) {
      this.objects.push(pr.start),
        this.objects.push(e),
        (this.animState.animationsChanged = !0);
    }
    interrupt(e) {
      this.objects.push(pr.interrupt), this.objects.push(e);
    }
    end(e) {
      this.objects.push(pr.end),
        this.objects.push(e),
        (this.animState.animationsChanged = !0);
    }
    dispose(e) {
      this.objects.push(pr.dispose), this.objects.push(e);
    }
    complete(e) {
      this.objects.push(pr.complete), this.objects.push(e);
    }
    event(e, t) {
      this.objects.push(pr.event), this.objects.push(e), this.objects.push(t);
    }
    drain() {
      if (this.drainDisabled) return;
      this.drainDisabled = !0;
      let e = this.objects,
        t = this.animState.listeners;
      for (let i = 0; i < e.length; i += 2) {
        let s = e[i],
          n = e[i + 1];
        switch (s) {
          case pr.start:
            n.listener && n.listener.start && n.listener.start(n);
            for (let o = 0; o < t.length; o++) {
              let l = t[o];
              l.start && l.start(n);
            }
            break;
          case pr.interrupt:
            n.listener && n.listener.interrupt && n.listener.interrupt(n);
            for (let o = 0; o < t.length; o++) {
              let l = t[o];
              l.interrupt && l.interrupt(n);
            }
            break;
          case pr.end:
            n.listener && n.listener.end && n.listener.end(n);
            for (let o = 0; o < t.length; o++) {
              let l = t[o];
              l.end && l.end(n);
            }
          case pr.dispose:
            n.listener && n.listener.dispose && n.listener.dispose(n);
            for (let o = 0; o < t.length; o++) {
              let l = t[o];
              l.dispose && l.dispose(n);
            }
            this.animState.trackEntryPool.free(n);
            break;
          case pr.complete:
            n.listener && n.listener.complete && n.listener.complete(n);
            for (let o = 0; o < t.length; o++) {
              let l = t[o];
              l.complete && l.complete(n);
            }
            break;
          case pr.event:
            let a = e[i++ + 2];
            n.listener && n.listener.event && n.listener.event(n, a);
            for (let o = 0; o < t.length; o++) {
              let l = t[o];
              l.event && l.event(n, a);
            }
            break;
        }
      }
      this.clear(), (this.drainDisabled = !1);
    }
    clear() {
      this.objects.length = 0;
    }
  }
  var pr;
  (function (r) {
    (r[(r.start = 0)] = "start"),
      (r[(r.interrupt = 1)] = "interrupt"),
      (r[(r.end = 2)] = "end"),
      (r[(r.dispose = 3)] = "dispose"),
      (r[(r.complete = 4)] = "complete"),
      (r[(r.event = 5)] = "event");
  })(pr || (pr = {}));
  const od = 0,
    oy = 1,
    ly = 2,
    ld = 3,
    _5 = 4,
    hy = 1,
    w5 = 2;
  class T5 {
    constructor(e) {
      T(this, "skeletonData");
      T(this, "animationToMixTime", {});
      T(this, "defaultMix", 0);
      if (!e) throw new Error("skeletonData cannot be null.");
      this.skeletonData = e;
    }
    setMix(e, t, i) {
      let s = this.skeletonData.findAnimation(e);
      if (!s) throw new Error("Animation not found: " + e);
      let n = this.skeletonData.findAnimation(t);
      if (!n) throw new Error("Animation not found: " + t);
      this.setMixWith(s, n, i);
    }
    setMixWith(e, t, i) {
      if (!e) throw new Error("from cannot be null.");
      if (!t) throw new Error("to cannot be null.");
      let s = e.name + "." + t.name;
      this.animationToMixTime[s] = i;
    }
    getMix(e, t) {
      let i = e.name + "." + t.name,
        s = this.animationToMixTime[i];
      return s === void 0 ? this.defaultMix : s;
    }
  }
  class dm extends gi {
    constructor(t) {
      super(t);
      T(this, "color", new Ve(1, 1, 1, 1));
    }
    copy() {
      let t = new dm(this.name);
      return this.copyTo(t), t.color.setFromColor(this.color), t;
    }
  }
  class _l extends gi {
    constructor(t) {
      super(t);
      T(this, "endSlot", null);
      T(this, "color", new Ve(0.2275, 0.2275, 0.8078, 1));
    }
    copy() {
      let t = new _l(this.name);
      return (
        this.copyTo(t),
        (t.endSlot = this.endSlot),
        t.color.setFromColor(this.color),
        t
      );
    }
  }
  class E5 {
    constructor(e) {
      T(this, "_image");
      this._image = e;
    }
    getImage() {
      return this._image;
    }
  }
  var Ht;
  (function (r) {
    (r[(r.Nearest = 9728)] = "Nearest"),
      (r[(r.Linear = 9729)] = "Linear"),
      (r[(r.MipMap = 9987)] = "MipMap"),
      (r[(r.MipMapNearestNearest = 9984)] = "MipMapNearestNearest"),
      (r[(r.MipMapLinearNearest = 9985)] = "MipMapLinearNearest"),
      (r[(r.MipMapNearestLinear = 9986)] = "MipMapNearestLinear"),
      (r[(r.MipMapLinearLinear = 9987)] = "MipMapLinearLinear");
  })(Ht || (Ht = {}));
  var ps;
  (function (r) {
    (r[(r.MirroredRepeat = 33648)] = "MirroredRepeat"),
      (r[(r.ClampToEdge = 33071)] = "ClampToEdge"),
      (r[(r.Repeat = 10497)] = "Repeat");
  })(ps || (ps = {}));
  class S5 {
    constructor() {
      T(this, "texture");
      T(this, "u", 0);
      T(this, "v", 0);
      T(this, "u2", 0);
      T(this, "v2", 0);
      T(this, "width", 0);
      T(this, "height", 0);
      T(this, "degrees", 0);
      T(this, "offsetX", 0);
      T(this, "offsetY", 0);
      T(this, "originalWidth", 0);
      T(this, "originalHeight", 0);
    }
  }
  class A5 {
    constructor(e) {
      T(this, "pages", new Array());
      T(this, "regions", new Array());
      let t = new C5(e),
        i = new Array(4),
        s = {};
      (s.size = (c) => {
        (c.width = parseInt(i[1])), (c.height = parseInt(i[2]));
      }),
        (s.format = () => {}),
        (s.filter = (c) => {
          (c.minFilter = pe.enumValue(Ht, i[1])),
            (c.magFilter = pe.enumValue(Ht, i[2]));
        }),
        (s.repeat = (c) => {
          i[1].indexOf("x") != -1 && (c.uWrap = ps.Repeat),
            i[1].indexOf("y") != -1 && (c.vWrap = ps.Repeat);
        }),
        (s.pma = (c) => {
          c.pma = i[1] == "true";
        });
      var n = {};
      (n.xy = (c) => {
        (c.x = parseInt(i[1])), (c.y = parseInt(i[2]));
      }),
        (n.size = (c) => {
          (c.width = parseInt(i[1])), (c.height = parseInt(i[2]));
        }),
        (n.bounds = (c) => {
          (c.x = parseInt(i[1])),
            (c.y = parseInt(i[2])),
            (c.width = parseInt(i[3])),
            (c.height = parseInt(i[4]));
        }),
        (n.offset = (c) => {
          (c.offsetX = parseInt(i[1])), (c.offsetY = parseInt(i[2]));
        }),
        (n.orig = (c) => {
          (c.originalWidth = parseInt(i[1])),
            (c.originalHeight = parseInt(i[2]));
        }),
        (n.offsets = (c) => {
          (c.offsetX = parseInt(i[1])),
            (c.offsetY = parseInt(i[2])),
            (c.originalWidth = parseInt(i[3])),
            (c.originalHeight = parseInt(i[4]));
        }),
        (n.rotate = (c) => {
          let u = i[1];
          u == "true"
            ? (c.degrees = 90)
            : u != "false" && (c.degrees = parseInt(u));
        }),
        (n.index = (c) => {
          c.index = parseInt(i[1]);
        });
      let a = t.readLine();
      for (; a && a.trim().length == 0; ) a = t.readLine();
      for (; !(!a || a.trim().length == 0 || t.readEntry(i, a) == 0); )
        a = t.readLine();
      let o = null,
        l = null,
        h = null;
      for (; a !== null; )
        if (a.trim().length == 0) (o = null), (a = t.readLine());
        else if (o) {
          let c = new Tw(o, a);
          for (;;) {
            let u = t.readEntry(i, (a = t.readLine()));
            if (u == 0) break;
            let d = n[i[0]];
            if (d) d(c);
            else {
              l || (l = []), h || (h = []), l.push(i[0]);
              let f = [];
              for (let p = 0; p < u; p++) f.push(parseInt(i[p + 1]));
              h.push(f);
            }
          }
          c.originalWidth == 0 &&
            c.originalHeight == 0 &&
            ((c.originalWidth = c.width), (c.originalHeight = c.height)),
            l &&
              l.length > 0 &&
              h &&
              h.length > 0 &&
              ((c.names = l), (c.values = h), (l = null), (h = null)),
            (c.u = c.x / o.width),
            (c.v = c.y / o.height),
            c.degrees == 90
              ? ((c.u2 = (c.x + c.height) / o.width),
                (c.v2 = (c.y + c.width) / o.height))
              : ((c.u2 = (c.x + c.width) / o.width),
                (c.v2 = (c.y + c.height) / o.height)),
            this.regions.push(c);
        } else {
          for (
            o = new I5(a.trim());
            t.readEntry(i, (a = t.readLine())) != 0;

          ) {
            let c = s[i[0]];
            c && c(o);
          }
          this.pages.push(o);
        }
    }
    findRegion(e) {
      for (let t = 0; t < this.regions.length; t++)
        if (this.regions[t].name == e) return this.regions[t];
      return null;
    }
    setTextures(e, t = "") {
      for (let i of this.pages) i.setTexture(e.get(t + i.name));
    }
    dispose() {
      var e;
      for (let t = 0; t < this.pages.length; t++)
        (e = this.pages[t].texture) == null || e.dispose();
    }
  }
  class C5 {
    constructor(e) {
      T(this, "lines");
      T(this, "index", 0);
      this.lines = e.split(/\r\n|\r|\n/);
    }
    readLine() {
      return this.index >= this.lines.length ? null : this.lines[this.index++];
    }
    readEntry(e, t) {
      if (!t || ((t = t.trim()), t.length == 0)) return 0;
      let i = t.indexOf(":");
      if (i == -1) return 0;
      e[0] = t.substr(0, i).trim();
      for (let s = 1, n = i + 1; ; s++) {
        let a = t.indexOf(",", n);
        if (a == -1) return (e[s] = t.substr(n).trim()), s;
        if (((e[s] = t.substr(n, a - n).trim()), (n = a + 1), s == 4)) return 4;
      }
    }
  }
  class I5 {
    constructor(e) {
      T(this, "name");
      T(this, "minFilter", Ht.Nearest);
      T(this, "magFilter", Ht.Nearest);
      T(this, "uWrap", ps.ClampToEdge);
      T(this, "vWrap", ps.ClampToEdge);
      T(this, "texture", null);
      T(this, "width", 0);
      T(this, "height", 0);
      T(this, "pma", !1);
      T(this, "regions", new Array());
      this.name = e;
    }
    setTexture(e) {
      (this.texture = e),
        e.setFilters(this.minFilter, this.magFilter),
        e.setWraps(this.uWrap, this.vWrap);
      for (let t of this.regions) t.texture = e;
    }
  }
  class Tw extends S5 {
    constructor(t, i) {
      super();
      T(this, "page");
      T(this, "name");
      T(this, "x", 0);
      T(this, "y", 0);
      T(this, "offsetX", 0);
      T(this, "offsetY", 0);
      T(this, "originalWidth", 0);
      T(this, "originalHeight", 0);
      T(this, "index", 0);
      T(this, "degrees", 0);
      T(this, "names", null);
      T(this, "values", null);
      (this.page = t), (this.name = i), t.regions.push(this);
    }
  }
  class Nn extends gi {
    constructor(t, i) {
      super(t);
      T(this, "region", null);
      T(this, "path");
      T(this, "regionUVs", []);
      T(this, "uvs", []);
      T(this, "triangles", []);
      T(this, "color", new Ve(1, 1, 1, 1));
      T(this, "width", 0);
      T(this, "height", 0);
      T(this, "hullLength", 0);
      T(this, "edges", []);
      T(this, "parentMesh", null);
      T(this, "sequence", null);
      T(this, "tempColor", new Ve(0, 0, 0, 0));
      this.path = i;
    }
    updateRegion() {
      if (!this.region) throw new Error("Region not set.");
      let t = this.regionUVs;
      (!this.uvs || this.uvs.length != t.length) &&
        (this.uvs = pe.newFloatArray(t.length));
      let i = this.uvs,
        s = this.uvs.length,
        n = this.region.u,
        a = this.region.v,
        o = 0,
        l = 0;
      if (this.region instanceof Tw) {
        let h = this.region,
          c = h.page,
          u = c.width,
          d = c.height;
        switch (h.degrees) {
          case 90:
            (n -= (h.originalHeight - h.offsetY - h.height) / u),
              (a -= (h.originalWidth - h.offsetX - h.width) / d),
              (o = h.originalHeight / u),
              (l = h.originalWidth / d);
            for (let f = 0; f < s; f += 2)
              (i[f] = n + t[f + 1] * o), (i[f + 1] = a + (1 - t[f]) * l);
            return;
          case 180:
            (n -= (h.originalWidth - h.offsetX - h.width) / u),
              (a -= h.offsetY / d),
              (o = h.originalWidth / u),
              (l = h.originalHeight / d);
            for (let f = 0; f < s; f += 2)
              (i[f] = n + (1 - t[f]) * o), (i[f + 1] = a + (1 - t[f + 1]) * l);
            return;
          case 270:
            (n -= h.offsetY / u),
              (a -= h.offsetX / d),
              (o = h.originalHeight / u),
              (l = h.originalWidth / d);
            for (let f = 0; f < s; f += 2)
              (i[f] = n + (1 - t[f + 1]) * o), (i[f + 1] = a + t[f] * l);
            return;
        }
        (n -= h.offsetX / u),
          (a -= (h.originalHeight - h.offsetY - h.height) / d),
          (o = h.originalWidth / u),
          (l = h.originalHeight / d);
      } else
        this.region
          ? ((o = this.region.u2 - n), (l = this.region.v2 - a))
          : ((n = a = 0), (o = l = 1));
      for (let h = 0; h < s; h += 2)
        (i[h] = n + t[h] * o), (i[h + 1] = a + t[h + 1] * l);
    }
    getParentMesh() {
      return this.parentMesh;
    }
    setParentMesh(t) {
      (this.parentMesh = t),
        t &&
          ((this.bones = t.bones),
          (this.vertices = t.vertices),
          (this.worldVerticesLength = t.worldVerticesLength),
          (this.regionUVs = t.regionUVs),
          (this.triangles = t.triangles),
          (this.hullLength = t.hullLength),
          (this.worldVerticesLength = t.worldVerticesLength));
    }
    copy() {
      if (this.parentMesh) return this.newLinkedMesh();
      let t = new Nn(this.name, this.path);
      return (
        (t.region = this.region),
        t.color.setFromColor(this.color),
        this.copyTo(t),
        (t.regionUVs = new Array(this.regionUVs.length)),
        pe.arrayCopy(this.regionUVs, 0, t.regionUVs, 0, this.regionUVs.length),
        (t.uvs = new Array(this.uvs.length)),
        pe.arrayCopy(this.uvs, 0, t.uvs, 0, this.uvs.length),
        (t.triangles = new Array(this.triangles.length)),
        pe.arrayCopy(this.triangles, 0, t.triangles, 0, this.triangles.length),
        (t.hullLength = this.hullLength),
        (t.sequence = this.sequence != null ? this.sequence.copy() : null),
        this.edges &&
          ((t.edges = new Array(this.edges.length)),
          pe.arrayCopy(this.edges, 0, t.edges, 0, this.edges.length)),
        (t.width = this.width),
        (t.height = this.height),
        t
      );
    }
    computeWorldVertices(t, i, s, n, a, o) {
      this.sequence != null && this.sequence.apply(t, this),
        super.computeWorldVertices(t, i, s, n, a, o);
    }
    newLinkedMesh() {
      let t = new Nn(this.name, this.path);
      return (
        (t.region = this.region),
        t.color.setFromColor(this.color),
        (t.timelineAttachment = this.timelineAttachment),
        t.setParentMesh(this.parentMesh ? this.parentMesh : this),
        t.region != null && t.updateRegion(),
        t
      );
    }
  }
  class Ha extends gi {
    constructor(t) {
      super(t);
      T(this, "lengths", []);
      T(this, "closed", !1);
      T(this, "constantSpeed", !1);
      T(this, "color", new Ve(1, 1, 1, 1));
    }
    copy() {
      let t = new Ha(this.name);
      return (
        this.copyTo(t),
        (t.lengths = new Array(this.lengths.length)),
        pe.arrayCopy(this.lengths, 0, t.lengths, 0, this.lengths.length),
        (t.closed = closed),
        (t.constantSpeed = this.constantSpeed),
        t.color.setFromColor(this.color),
        t
      );
    }
  }
  class fm extends gi {
    constructor(t) {
      super(t);
      T(this, "x", 0);
      T(this, "y", 0);
      T(this, "rotation", 0);
      T(this, "color", new Ve(0.38, 0.94, 0, 1));
    }
    computeWorldPosition(t, i) {
      return (
        (i.x = this.x * t.a + this.y * t.b + t.worldX),
        (i.y = this.x * t.c + this.y * t.d + t.worldY),
        i
      );
    }
    computeWorldRotation(t) {
      const i = this.rotation * ae.degRad,
        s = Math.cos(i),
        n = Math.sin(i),
        a = s * t.a + n * t.b,
        o = s * t.c + n * t.d;
      return ae.atan2Deg(o, a);
    }
    copy() {
      let t = new fm(this.name);
      return (
        (t.x = this.x),
        (t.y = this.y),
        (t.rotation = this.rotation),
        t.color.setFromColor(this.color),
        t
      );
    }
  }
  const Ke = class Ke extends Y_ {
    constructor(t, i) {
      super(t);
      T(this, "x", 0);
      T(this, "y", 0);
      T(this, "scaleX", 1);
      T(this, "scaleY", 1);
      T(this, "rotation", 0);
      T(this, "width", 0);
      T(this, "height", 0);
      T(this, "color", new Ve(1, 1, 1, 1));
      T(this, "path");
      T(this, "region", null);
      T(this, "sequence", null);
      T(this, "offset", pe.newFloatArray(8));
      T(this, "uvs", pe.newFloatArray(8));
      T(this, "tempColor", new Ve(1, 1, 1, 1));
      this.path = i;
    }
    updateRegion() {
      if (!this.region) throw new Error("Region not set.");
      let t = this.region,
        i = this.uvs;
      if (t == null) {
        (i[0] = 0),
          (i[1] = 0),
          (i[2] = 0),
          (i[3] = 1),
          (i[4] = 1),
          (i[5] = 1),
          (i[6] = 1),
          (i[7] = 0);
        return;
      }
      let s = (this.width / this.region.originalWidth) * this.scaleX,
        n = (this.height / this.region.originalHeight) * this.scaleY,
        a = (-this.width / 2) * this.scaleX + this.region.offsetX * s,
        o = (-this.height / 2) * this.scaleY + this.region.offsetY * n,
        l = a + this.region.width * s,
        h = o + this.region.height * n,
        c = this.rotation * ae.degRad,
        u = Math.cos(c),
        d = Math.sin(c),
        f = this.x,
        p = this.y,
        m = a * u + f,
        v = a * d,
        g = o * u + p,
        x = o * d,
        b = l * u + f,
        y = l * d,
        _ = h * u + p,
        w = h * d,
        E = this.offset;
      (E[0] = m - x),
        (E[1] = g + v),
        (E[2] = m - w),
        (E[3] = _ + v),
        (E[4] = b - w),
        (E[5] = _ + y),
        (E[6] = b - x),
        (E[7] = g + y),
        t.degrees == 90
          ? ((i[0] = t.u2),
            (i[1] = t.v2),
            (i[2] = t.u),
            (i[3] = t.v2),
            (i[4] = t.u),
            (i[5] = t.v),
            (i[6] = t.u2),
            (i[7] = t.v))
          : ((i[0] = t.u),
            (i[1] = t.v2),
            (i[2] = t.u),
            (i[3] = t.v),
            (i[4] = t.u2),
            (i[5] = t.v),
            (i[6] = t.u2),
            (i[7] = t.v2));
    }
    computeWorldVertices(t, i, s, n) {
      this.sequence != null && this.sequence.apply(t, this);
      let a = t.bone,
        o = this.offset,
        l = a.worldX,
        h = a.worldY,
        c = a.a,
        u = a.b,
        d = a.c,
        f = a.d,
        p = 0,
        m = 0;
      (p = o[0]),
        (m = o[1]),
        (i[s] = p * c + m * u + l),
        (i[s + 1] = p * d + m * f + h),
        (s += n),
        (p = o[2]),
        (m = o[3]),
        (i[s] = p * c + m * u + l),
        (i[s + 1] = p * d + m * f + h),
        (s += n),
        (p = o[4]),
        (m = o[5]),
        (i[s] = p * c + m * u + l),
        (i[s + 1] = p * d + m * f + h),
        (s += n),
        (p = o[6]),
        (m = o[7]),
        (i[s] = p * c + m * u + l),
        (i[s + 1] = p * d + m * f + h);
    }
    copy() {
      let t = new Ke(this.name, this.path);
      return (
        (t.region = this.region),
        (t.x = this.x),
        (t.y = this.y),
        (t.scaleX = this.scaleX),
        (t.scaleY = this.scaleY),
        (t.rotation = this.rotation),
        (t.width = this.width),
        (t.height = this.height),
        pe.arrayCopy(this.uvs, 0, t.uvs, 0, 8),
        pe.arrayCopy(this.offset, 0, t.offset, 0, 8),
        t.color.setFromColor(this.color),
        (t.sequence = this.sequence != null ? this.sequence.copy() : null),
        t
      );
    }
  };
  T(Ke, "X1", 0),
    T(Ke, "Y1", 1),
    T(Ke, "C1R", 2),
    T(Ke, "C1G", 3),
    T(Ke, "C1B", 4),
    T(Ke, "C1A", 5),
    T(Ke, "U1", 6),
    T(Ke, "V1", 7),
    T(Ke, "X2", 8),
    T(Ke, "Y2", 9),
    T(Ke, "C2R", 10),
    T(Ke, "C2G", 11),
    T(Ke, "C2B", 12),
    T(Ke, "C2A", 13),
    T(Ke, "U2", 14),
    T(Ke, "V2", 15),
    T(Ke, "X3", 16),
    T(Ke, "Y3", 17),
    T(Ke, "C3R", 18),
    T(Ke, "C3G", 19),
    T(Ke, "C3B", 20),
    T(Ke, "C3A", 21),
    T(Ke, "U3", 22),
    T(Ke, "V3", 23),
    T(Ke, "X4", 24),
    T(Ke, "Y4", 25),
    T(Ke, "C4R", 26),
    T(Ke, "C4G", 27),
    T(Ke, "C4B", 28),
    T(Ke, "C4A", 29),
    T(Ke, "U4", 30),
    T(Ke, "V4", 31);
  let sl = Ke;
  class P5 {
    constructor(e) {
      T(this, "atlas");
      this.atlas = e;
    }
    loadSequence(e, t, i) {
      let s = i.regions;
      for (let n = 0, a = s.length; n < a; n++) {
        let o = i.getPath(t, n),
          l = this.atlas.findRegion(o);
        if (l == null)
          throw new Error(
            "Region not found in atlas: " + o + " (sequence: " + e + ")"
          );
        s[n] = l;
      }
    }
    newRegionAttachment(e, t, i, s) {
      let n = new sl(t, i);
      if (s != null) this.loadSequence(t, i, s);
      else {
        let a = this.atlas.findRegion(i);
        if (!a)
          throw new Error(
            "Region not found in atlas: " +
              i +
              " (region attachment: " +
              t +
              ")"
          );
        n.region = a;
      }
      return n;
    }
    newMeshAttachment(e, t, i, s) {
      let n = new Nn(t, i);
      if (s != null) this.loadSequence(t, i, s);
      else {
        let a = this.atlas.findRegion(i);
        if (!a)
          throw new Error(
            "Region not found in atlas: " + i + " (mesh attachment: " + t + ")"
          );
        n.region = a;
      }
      return n;
    }
    newBoundingBoxAttachment(e, t) {
      return new dm(t);
    }
    newPathAttachment(e, t) {
      return new Ha(t);
    }
    newPointAttachment(e, t) {
      return new fm(t);
    }
    newClippingAttachment(e, t) {
      return new _l(t);
    }
  }
  class Ew {
    constructor(e, t, i) {
      T(this, "index", 0);
      T(this, "name");
      T(this, "parent", null);
      T(this, "length", 0);
      T(this, "x", 0);
      T(this, "y", 0);
      T(this, "rotation", 0);
      T(this, "scaleX", 1);
      T(this, "scaleY", 1);
      T(this, "shearX", 0);
      T(this, "shearY", 0);
      T(this, "inherit", Tt.Normal);
      T(this, "skinRequired", !1);
      T(this, "color", new Ve());
      T(this, "icon");
      T(this, "visible", !1);
      if (e < 0) throw new Error("index must be >= 0.");
      if (!t) throw new Error("name cannot be null.");
      (this.index = e), (this.name = t), (this.parent = i);
    }
  }
  var Tt;
  (function (r) {
    (r[(r.Normal = 0)] = "Normal"),
      (r[(r.OnlyTranslation = 1)] = "OnlyTranslation"),
      (r[(r.NoRotationOrReflection = 2)] = "NoRotationOrReflection"),
      (r[(r.NoScale = 3)] = "NoScale"),
      (r[(r.NoScaleOrReflection = 4)] = "NoScaleOrReflection");
  })(Tt || (Tt = {}));
  class cy {
    constructor(e, t, i) {
      T(this, "data");
      T(this, "skeleton");
      T(this, "parent", null);
      T(this, "children", new Array());
      T(this, "x", 0);
      T(this, "y", 0);
      T(this, "rotation", 0);
      T(this, "scaleX", 0);
      T(this, "scaleY", 0);
      T(this, "shearX", 0);
      T(this, "shearY", 0);
      T(this, "ax", 0);
      T(this, "ay", 0);
      T(this, "arotation", 0);
      T(this, "ascaleX", 0);
      T(this, "ascaleY", 0);
      T(this, "ashearX", 0);
      T(this, "ashearY", 0);
      T(this, "a", 0);
      T(this, "b", 0);
      T(this, "c", 0);
      T(this, "d", 0);
      T(this, "worldY", 0);
      T(this, "worldX", 0);
      T(this, "inherit", Tt.Normal);
      T(this, "sorted", !1);
      T(this, "active", !1);
      if (!e) throw new Error("data cannot be null.");
      if (!t) throw new Error("skeleton cannot be null.");
      (this.data = e),
        (this.skeleton = t),
        (this.parent = i),
        this.setToSetupPose();
    }
    isActive() {
      return this.active;
    }
    update(e) {
      this.updateWorldTransformWith(
        this.ax,
        this.ay,
        this.arotation,
        this.ascaleX,
        this.ascaleY,
        this.ashearX,
        this.ashearY
      );
    }
    updateWorldTransform() {
      this.updateWorldTransformWith(
        this.x,
        this.y,
        this.rotation,
        this.scaleX,
        this.scaleY,
        this.shearX,
        this.shearY
      );
    }
    updateWorldTransformWith(e, t, i, s, n, a, o) {
      (this.ax = e),
        (this.ay = t),
        (this.arotation = i),
        (this.ascaleX = s),
        (this.ascaleY = n),
        (this.ashearX = a),
        (this.ashearY = o);
      let l = this.parent;
      if (!l) {
        let f = this.skeleton;
        const p = f.scaleX,
          m = f.scaleY,
          v = (i + a) * ae.degRad,
          g = (i + 90 + o) * ae.degRad;
        (this.a = Math.cos(v) * s * p),
          (this.b = Math.cos(g) * n * p),
          (this.c = Math.sin(v) * s * m),
          (this.d = Math.sin(g) * n * m),
          (this.worldX = e * p + f.x),
          (this.worldY = t * m + f.y);
        return;
      }
      let h = l.a,
        c = l.b,
        u = l.c,
        d = l.d;
      switch (
        ((this.worldX = h * e + c * t + l.worldX),
        (this.worldY = u * e + d * t + l.worldY),
        this.inherit)
      ) {
        case Tt.Normal: {
          const f = (i + a) * ae.degRad,
            p = (i + 90 + o) * ae.degRad,
            m = Math.cos(f) * s,
            v = Math.cos(p) * n,
            g = Math.sin(f) * s,
            x = Math.sin(p) * n;
          (this.a = h * m + c * g),
            (this.b = h * v + c * x),
            (this.c = u * m + d * g),
            (this.d = u * v + d * x);
          return;
        }
        case Tt.OnlyTranslation: {
          const f = (i + a) * ae.degRad,
            p = (i + 90 + o) * ae.degRad;
          (this.a = Math.cos(f) * s),
            (this.b = Math.cos(p) * n),
            (this.c = Math.sin(f) * s),
            (this.d = Math.sin(p) * n);
          break;
        }
        case Tt.NoRotationOrReflection: {
          let f = 1 / this.skeleton.scaleX,
            p = 1 / this.skeleton.scaleY;
          (h *= f), (u *= p);
          let m = h * h + u * u,
            v = 0;
          m > 1e-4
            ? ((m = Math.abs(h * d * p - c * f * u) / m),
              (c = u * m),
              (d = h * m),
              (v = Math.atan2(u, h) * ae.radDeg))
            : ((h = 0), (u = 0), (v = 90 - Math.atan2(d, c) * ae.radDeg));
          const g = (i + a - v) * ae.degRad,
            x = (i + o - v + 90) * ae.degRad,
            b = Math.cos(g) * s,
            y = Math.cos(x) * n,
            _ = Math.sin(g) * s,
            w = Math.sin(x) * n;
          (this.a = h * b - c * _),
            (this.b = h * y - c * w),
            (this.c = u * b + d * _),
            (this.d = u * y + d * w);
          break;
        }
        case Tt.NoScale:
        case Tt.NoScaleOrReflection: {
          i *= ae.degRad;
          const f = Math.cos(i),
            p = Math.sin(i);
          let m = (h * f + c * p) / this.skeleton.scaleX,
            v = (u * f + d * p) / this.skeleton.scaleY,
            g = Math.sqrt(m * m + v * v);
          g > 1e-5 && (g = 1 / g),
            (m *= g),
            (v *= g),
            (g = Math.sqrt(m * m + v * v)),
            this.inherit == Tt.NoScale &&
              h * d - c * u < 0 !=
                (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) &&
              (g = -g),
            (i = Math.PI / 2 + Math.atan2(v, m));
          const x = Math.cos(i) * g,
            b = Math.sin(i) * g;
          (a *= ae.degRad), (o = (90 + o) * ae.degRad);
          const y = Math.cos(a) * s,
            _ = Math.cos(o) * n,
            w = Math.sin(a) * s,
            E = Math.sin(o) * n;
          (this.a = m * y + x * w),
            (this.b = m * _ + x * E),
            (this.c = v * y + b * w),
            (this.d = v * _ + b * E);
          break;
        }
      }
      (this.a *= this.skeleton.scaleX),
        (this.b *= this.skeleton.scaleX),
        (this.c *= this.skeleton.scaleY),
        (this.d *= this.skeleton.scaleY);
    }
    setToSetupPose() {
      let e = this.data;
      (this.x = e.x),
        (this.y = e.y),
        (this.rotation = e.rotation),
        (this.scaleX = e.scaleX),
        (this.scaleY = e.scaleY),
        (this.shearX = e.shearX),
        (this.shearY = e.shearY),
        (this.inherit = e.inherit);
    }
    updateAppliedTransform() {
      let e = this.parent;
      if (!e) {
        (this.ax = this.worldX - this.skeleton.x),
          (this.ay = this.worldY - this.skeleton.y),
          (this.arotation = Math.atan2(this.c, this.a) * ae.radDeg),
          (this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c)),
          (this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d)),
          (this.ashearX = 0),
          (this.ashearY =
            Math.atan2(
              this.a * this.b + this.c * this.d,
              this.a * this.d - this.b * this.c
            ) * ae.radDeg);
        return;
      }
      let t = e.a,
        i = e.b,
        s = e.c,
        n = e.d,
        a = 1 / (t * n - i * s),
        o = n * a,
        l = i * a,
        h = s * a,
        c = t * a,
        u = this.worldX - e.worldX,
        d = this.worldY - e.worldY;
      (this.ax = u * o - d * l), (this.ay = d * c - u * h);
      let f, p, m, v;
      if (this.inherit == Tt.OnlyTranslation)
        (f = this.a), (p = this.b), (m = this.c), (v = this.d);
      else {
        switch (this.inherit) {
          case Tt.NoRotationOrReflection: {
            let _ = Math.abs(t * n - i * s) / (t * t + s * s);
            (i = (-s * this.skeleton.scaleX * _) / this.skeleton.scaleY),
              (n = (t * this.skeleton.scaleY * _) / this.skeleton.scaleX),
              (a = 1 / (t * n - i * s)),
              (o = n * a),
              (l = i * a);
            break;
          }
          case Tt.NoScale:
          case Tt.NoScaleOrReflection:
            let g = ae.cosDeg(this.rotation),
              x = ae.sinDeg(this.rotation);
            (t = (t * g + i * x) / this.skeleton.scaleX),
              (s = (s * g + n * x) / this.skeleton.scaleY);
            let b = Math.sqrt(t * t + s * s);
            b > 1e-5 && (b = 1 / b),
              (t *= b),
              (s *= b),
              (b = Math.sqrt(t * t + s * s)),
              this.inherit == Tt.NoScale &&
                a < 0 !=
                  (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) &&
                (b = -b);
            let y = ae.PI / 2 + Math.atan2(s, t);
            (i = Math.cos(y) * b),
              (n = Math.sin(y) * b),
              (a = 1 / (t * n - i * s)),
              (o = n * a),
              (l = i * a),
              (h = s * a),
              (c = t * a);
        }
        (f = o * this.a - l * this.c),
          (p = o * this.b - l * this.d),
          (m = c * this.c - h * this.a),
          (v = c * this.d - h * this.b);
      }
      if (
        ((this.ashearX = 0),
        (this.ascaleX = Math.sqrt(f * f + m * m)),
        this.ascaleX > 1e-4)
      ) {
        let g = f * v - p * m;
        (this.ascaleY = g / this.ascaleX),
          (this.ashearY = -Math.atan2(f * p + m * v, g) * ae.radDeg),
          (this.arotation = Math.atan2(m, f) * ae.radDeg);
      } else
        (this.ascaleX = 0),
          (this.ascaleY = Math.sqrt(p * p + v * v)),
          (this.ashearY = 0),
          (this.arotation = 90 - Math.atan2(v, p) * ae.radDeg);
    }
    getWorldRotationX() {
      return Math.atan2(this.c, this.a) * ae.radDeg;
    }
    getWorldRotationY() {
      return Math.atan2(this.d, this.b) * ae.radDeg;
    }
    getWorldScaleX() {
      return Math.sqrt(this.a * this.a + this.c * this.c);
    }
    getWorldScaleY() {
      return Math.sqrt(this.b * this.b + this.d * this.d);
    }
    worldToLocal(e) {
      let t = 1 / (this.a * this.d - this.b * this.c),
        i = e.x - this.worldX,
        s = e.y - this.worldY;
      return (
        (e.x = i * this.d * t - s * this.b * t),
        (e.y = s * this.a * t - i * this.c * t),
        e
      );
    }
    localToWorld(e) {
      let t = e.x,
        i = e.y;
      return (
        (e.x = t * this.a + i * this.b + this.worldX),
        (e.y = t * this.c + i * this.d + this.worldY),
        e
      );
    }
    worldToParent(e) {
      if (e == null) throw new Error("world cannot be null.");
      return this.parent == null ? e : this.parent.worldToLocal(e);
    }
    parentToWorld(e) {
      if (e == null) throw new Error("world cannot be null.");
      return this.parent == null ? e : this.parent.localToWorld(e);
    }
    worldToLocalRotation(e) {
      let t = ae.sinDeg(e),
        i = ae.cosDeg(e);
      return (
        Math.atan2(this.a * t - this.c * i, this.d * i - this.b * t) *
          ae.radDeg +
        this.rotation -
        this.shearX
      );
    }
    localToWorldRotation(e) {
      e -= this.rotation - this.shearX;
      let t = ae.sinDeg(e),
        i = ae.cosDeg(e);
      return (
        Math.atan2(i * this.c + t * this.d, i * this.a + t * this.b) * ae.radDeg
      );
    }
    rotateWorld(e) {
      e *= ae.degRad;
      const t = Math.sin(e),
        i = Math.cos(e),
        s = this.a,
        n = this.b;
      (this.a = i * s - t * this.c),
        (this.b = i * n - t * this.d),
        (this.c = t * s + i * this.c),
        (this.d = t * n + i * this.d);
    }
  }
  class Yc {
    constructor(e, t, i) {
      T(this, "name");
      T(this, "order");
      T(this, "skinRequired");
      (this.name = e), (this.order = t), (this.skinRequired = i);
    }
  }
  let Sw = class {
    constructor(e, t) {
      T(this, "data");
      T(this, "intValue", 0);
      T(this, "floatValue", 0);
      T(this, "stringValue", null);
      T(this, "time", 0);
      T(this, "volume", 0);
      T(this, "balance", 0);
      if (!t) throw new Error("data cannot be null.");
      (this.time = e), (this.data = t);
    }
  };
  class Aw {
    constructor(e) {
      T(this, "name");
      T(this, "intValue", 0);
      T(this, "floatValue", 0);
      T(this, "stringValue", null);
      T(this, "audioPath", null);
      T(this, "volume", 0);
      T(this, "balance", 0);
      this.name = e;
    }
  }
  class R5 {
    constructor(e, t) {
      T(this, "data");
      T(this, "bones");
      T(this, "target");
      T(this, "bendDirection", 0);
      T(this, "compress", !1);
      T(this, "stretch", !1);
      T(this, "mix", 1);
      T(this, "softness", 0);
      T(this, "active", !1);
      if (!e) throw new Error("data cannot be null.");
      if (!t) throw new Error("skeleton cannot be null.");
      (this.data = e), (this.bones = new Array());
      for (let s = 0; s < e.bones.length; s++) {
        let n = t.findBone(e.bones[s].name);
        if (!n) throw new Error(`Couldn't find bone ${e.bones[s].name}`);
        this.bones.push(n);
      }
      let i = t.findBone(e.target.name);
      if (!i) throw new Error(`Couldn't find bone ${e.target.name}`);
      (this.target = i),
        (this.mix = e.mix),
        (this.softness = e.softness),
        (this.bendDirection = e.bendDirection),
        (this.compress = e.compress),
        (this.stretch = e.stretch);
    }
    isActive() {
      return this.active;
    }
    setToSetupPose() {
      const e = this.data;
      (this.mix = e.mix),
        (this.softness = e.softness),
        (this.bendDirection = e.bendDirection),
        (this.compress = e.compress),
        (this.stretch = e.stretch);
    }
    update(e) {
      if (this.mix == 0) return;
      let t = this.target,
        i = this.bones;
      switch (i.length) {
        case 1:
          this.apply1(
            i[0],
            t.worldX,
            t.worldY,
            this.compress,
            this.stretch,
            this.data.uniform,
            this.mix
          );
          break;
        case 2:
          this.apply2(
            i[0],
            i[1],
            t.worldX,
            t.worldY,
            this.bendDirection,
            this.stretch,
            this.data.uniform,
            this.softness,
            this.mix
          );
          break;
      }
    }
    apply1(e, t, i, s, n, a, o) {
      let l = e.parent;
      if (!l) throw new Error("IK bone must have parent.");
      let h = l.a,
        c = l.b,
        u = l.c,
        d = l.d,
        f = -e.ashearX - e.arotation,
        p = 0,
        m = 0;
      switch (e.inherit) {
        case Tt.OnlyTranslation:
          (p = (t - e.worldX) * ae.signum(e.skeleton.scaleX)),
            (m = (i - e.worldY) * ae.signum(e.skeleton.scaleY));
          break;
        case Tt.NoRotationOrReflection:
          let x = Math.abs(h * d - c * u) / Math.max(1e-4, h * h + u * u),
            b = h / e.skeleton.scaleX,
            y = u / e.skeleton.scaleY;
          (c = -y * x * e.skeleton.scaleX),
            (d = b * x * e.skeleton.scaleY),
            (f += Math.atan2(y, b) * ae.radDeg);
        default:
          let _ = t - l.worldX,
            w = i - l.worldY,
            E = h * d - c * u;
          Math.abs(E) <= 1e-4
            ? ((p = 0), (m = 0))
            : ((p = (_ * d - w * c) / E - e.ax),
              (m = (w * h - _ * u) / E - e.ay));
      }
      (f += Math.atan2(m, p) * ae.radDeg),
        e.ascaleX < 0 && (f += 180),
        f > 180 ? (f -= 360) : f < -180 && (f += 360);
      let v = e.ascaleX,
        g = e.ascaleY;
      if (s || n) {
        switch (e.inherit) {
          case Tt.NoScale:
          case Tt.NoScaleOrReflection:
            (p = t - e.worldX), (m = i - e.worldY);
        }
        const x = e.data.length * v;
        if (x > 1e-4) {
          const b = p * p + m * m;
          if ((s && b < x * x) || (n && b > x * x)) {
            const y = (Math.sqrt(b) / x - 1) * o + 1;
            (v *= y), a && (g *= y);
          }
        }
      }
      e.updateWorldTransformWith(
        e.ax,
        e.ay,
        e.arotation + f * o,
        v,
        g,
        e.ashearX,
        e.ashearY
      );
    }
    apply2(e, t, i, s, n, a, o, l, h) {
      if (e.inherit != Tt.Normal || t.inherit != Tt.Normal) return;
      let c = e.ax,
        u = e.ay,
        d = e.ascaleX,
        f = e.ascaleY,
        p = d,
        m = f,
        v = t.ascaleX,
        g = 0,
        x = 0,
        b = 0;
      d < 0 ? ((d = -d), (g = 180), (b = -1)) : ((g = 0), (b = 1)),
        f < 0 && ((f = -f), (b = -b)),
        v < 0 ? ((v = -v), (x = 180)) : (x = 0);
      let y = t.ax,
        _ = 0,
        w = 0,
        E = 0,
        A = e.a,
        C = e.b,
        F = e.c,
        B = e.d,
        R = Math.abs(d - f) <= 1e-4;
      !R || a
        ? ((_ = 0), (w = A * y + e.worldX), (E = F * y + e.worldY))
        : ((_ = t.ay),
          (w = A * y + C * _ + e.worldX),
          (E = F * y + B * _ + e.worldY));
      let I = e.parent;
      if (!I) throw new Error("IK parent must itself have a parent.");
      (A = I.a), (C = I.b), (F = I.c), (B = I.d);
      let P = A * B - C * F,
        M = w - I.worldX,
        L = E - I.worldY;
      P = Math.abs(P) <= 1e-4 ? 0 : 1 / P;
      let U = (M * B - L * C) * P - c,
        V = (L * A - M * F) * P - u,
        z = Math.sqrt(U * U + V * V),
        N = t.data.length * v,
        O,
        H;
      if (z < 1e-4) {
        this.apply1(e, i, s, !1, a, !1, h),
          t.updateWorldTransformWith(
            y,
            _,
            0,
            t.ascaleX,
            t.ascaleY,
            t.ashearX,
            t.ashearY
          );
        return;
      }
      (M = i - I.worldX), (L = s - I.worldY);
      let G = (M * B - L * C) * P - c,
        q = (L * A - M * F) * P - u,
        K = G * G + q * q;
      if (l != 0) {
        l *= d * (v + 1) * 0.5;
        let ee = Math.sqrt(K),
          ve = ee - z - N * d + l;
        if (ve > 0) {
          let ye = Math.min(1, ve / (l * 2)) - 1;
          (ye = (ve - l * (1 - ye * ye)) / ee),
            (G -= ye * G),
            (q -= ye * q),
            (K = G * G + q * q);
        }
      }
      e: if (R) {
        N *= d;
        let ee = (K - z * z - N * N) / (2 * z * N);
        ee < -1
          ? ((ee = -1), (H = Math.PI * n))
          : ee > 1
          ? ((ee = 1),
            (H = 0),
            a &&
              ((A = (Math.sqrt(K) / (z + N) - 1) * h + 1),
              (p *= A),
              o && (m *= A)))
          : (H = Math.acos(ee) * n),
          (A = z + N * ee),
          (C = N * Math.sin(H)),
          (O = Math.atan2(q * A - G * C, G * A + q * C));
      } else {
        (A = d * N), (C = f * N);
        let ee = A * A,
          ve = C * C,
          ye = Math.atan2(q, G);
        F = ve * z * z + ee * K - ee * ve;
        let _e = -2 * ve * z,
          ke = ve - ee;
        if (((B = _e * _e - 4 * ke * F), B >= 0)) {
          let se = Math.sqrt(B);
          _e < 0 && (se = -se), (se = -(_e + se) * 0.5);
          let re = se / ke,
            Pe = F / se,
            fe = Math.abs(re) < Math.abs(Pe) ? re : Pe;
          if (((re = K - fe * fe), re >= 0)) {
            (L = Math.sqrt(re) * n),
              (O = ye - Math.atan2(L, fe)),
              (H = Math.atan2(L / f, (fe - z) / d));
            break e;
          }
        }
        let k = ae.PI,
          D = z - A,
          W = D * D,
          te = 0,
          J = 0,
          Q = z + A,
          de = Q * Q,
          oe = 0;
        (F = (-A * z) / (ee - ve)),
          F >= -1 &&
            F <= 1 &&
            ((F = Math.acos(F)),
            (M = A * Math.cos(F) + z),
            (L = C * Math.sin(F)),
            (B = M * M + L * L),
            B < W && ((k = F), (W = B), (D = M), (te = L)),
            B > de && ((J = F), (de = B), (Q = M), (oe = L))),
          K <= (W + de) * 0.5
            ? ((O = ye - Math.atan2(te * n, D)), (H = k * n))
            : ((O = ye - Math.atan2(oe * n, Q)), (H = J * n));
      }
      let ue = Math.atan2(_, y) * b,
        ie = e.arotation;
      (O = (O - ue) * ae.radDeg + g - ie),
        O > 180 ? (O -= 360) : O < -180 && (O += 360),
        e.updateWorldTransformWith(c, u, ie + O * h, p, m, 0, 0),
        (ie = t.arotation),
        (H = ((H + ue) * ae.radDeg - t.ashearX) * b + x - ie),
        H > 180 ? (H -= 360) : H < -180 && (H += 360),
        t.updateWorldTransformWith(
          y,
          _,
          ie + H * h,
          t.ascaleX,
          t.ascaleY,
          t.ashearX,
          t.ashearY
        );
    }
  }
  class Cw extends Yc {
    constructor(t) {
      super(t, 0, !1);
      T(this, "bones", new Array());
      T(this, "_target", null);
      T(this, "bendDirection", 0);
      T(this, "compress", !1);
      T(this, "stretch", !1);
      T(this, "uniform", !1);
      T(this, "mix", 0);
      T(this, "softness", 0);
    }
    set target(t) {
      this._target = t;
    }
    get target() {
      if (this._target) return this._target;
      throw new Error("BoneData not set.");
    }
  }
  class Iw extends Yc {
    constructor(t) {
      super(t, 0, !1);
      T(this, "bones", new Array());
      T(this, "_target", null);
      T(this, "positionMode", Hi.Fixed);
      T(this, "spacingMode", Nt.Fixed);
      T(this, "rotateMode", In.Chain);
      T(this, "offsetRotation", 0);
      T(this, "position", 0);
      T(this, "spacing", 0);
      T(this, "mixRotate", 0);
      T(this, "mixX", 0);
      T(this, "mixY", 0);
    }
    set target(t) {
      this._target = t;
    }
    get target() {
      if (this._target) return this._target;
      throw new Error("SlotData not set.");
    }
  }
  var Hi;
  (function (r) {
    (r[(r.Fixed = 0)] = "Fixed"), (r[(r.Percent = 1)] = "Percent");
  })(Hi || (Hi = {}));
  var Nt;
  (function (r) {
    (r[(r.Length = 0)] = "Length"),
      (r[(r.Fixed = 1)] = "Fixed"),
      (r[(r.Percent = 2)] = "Percent"),
      (r[(r.Proportional = 3)] = "Proportional");
  })(Nt || (Nt = {}));
  var In;
  (function (r) {
    (r[(r.Tangent = 0)] = "Tangent"),
      (r[(r.Chain = 1)] = "Chain"),
      (r[(r.ChainScale = 2)] = "ChainScale");
  })(In || (In = {}));
  const Cr = class Cr {
    constructor(e, t) {
      T(this, "data");
      T(this, "bones");
      T(this, "target");
      T(this, "position", 0);
      T(this, "spacing", 0);
      T(this, "mixRotate", 0);
      T(this, "mixX", 0);
      T(this, "mixY", 0);
      T(this, "spaces", new Array());
      T(this, "positions", new Array());
      T(this, "world", new Array());
      T(this, "curves", new Array());
      T(this, "lengths", new Array());
      T(this, "segments", new Array());
      T(this, "active", !1);
      if (!e) throw new Error("data cannot be null.");
      if (!t) throw new Error("skeleton cannot be null.");
      (this.data = e), (this.bones = new Array());
      for (let s = 0, n = e.bones.length; s < n; s++) {
        let a = t.findBone(e.bones[s].name);
        if (!a) throw new Error(`Couldn't find bone ${e.bones[s].name}.`);
        this.bones.push(a);
      }
      let i = t.findSlot(e.target.name);
      if (!i) throw new Error(`Couldn't find target bone ${e.target.name}`);
      (this.target = i),
        (this.position = e.position),
        (this.spacing = e.spacing),
        (this.mixRotate = e.mixRotate),
        (this.mixX = e.mixX),
        (this.mixY = e.mixY);
    }
    isActive() {
      return this.active;
    }
    setToSetupPose() {
      const e = this.data;
      (this.position = e.position),
        (this.spacing = e.spacing),
        (this.mixRotate = e.mixRotate),
        (this.mixX = e.mixX),
        (this.mixY = e.mixY);
    }
    update(e) {
      let t = this.target.getAttachment();
      if (!(t instanceof Ha)) return;
      let i = this.mixRotate,
        s = this.mixX,
        n = this.mixY;
      if (i == 0 && s == 0 && n == 0) return;
      let a = this.data,
        o = a.rotateMode == In.Tangent,
        l = a.rotateMode == In.ChainScale,
        h = this.bones,
        c = h.length,
        u = o ? c : c + 1,
        d = pe.setArraySize(this.spaces, u),
        f = l ? (this.lengths = pe.setArraySize(this.lengths, c)) : [],
        p = this.spacing;
      switch (a.spacingMode) {
        case Nt.Percent:
          if (l)
            for (let w = 0, E = u - 1; w < E; w++) {
              let A = h[w],
                C = A.data.length,
                F = C * A.a,
                B = C * A.c;
              f[w] = Math.sqrt(F * F + B * B);
            }
          pe.arrayFill(d, 1, u, p);
          break;
        case Nt.Proportional:
          let y = 0;
          for (let w = 0, E = u - 1; w < E; ) {
            let A = h[w],
              C = A.data.length;
            if (C < Cr.epsilon) l && (f[w] = 0), (d[++w] = p);
            else {
              let F = C * A.a,
                B = C * A.c,
                R = Math.sqrt(F * F + B * B);
              l && (f[w] = R), (d[++w] = R), (y += R);
            }
          }
          if (y > 0) {
            y = (u / y) * p;
            for (let w = 1; w < u; w++) d[w] *= y;
          }
          break;
        default:
          let _ = a.spacingMode == Nt.Length;
          for (let w = 0, E = u - 1; w < E; ) {
            let A = h[w],
              C = A.data.length;
            if (C < Cr.epsilon) l && (f[w] = 0), (d[++w] = p);
            else {
              let F = C * A.a,
                B = C * A.c,
                R = Math.sqrt(F * F + B * B);
              l && (f[w] = R), (d[++w] = ((_ ? C + p : p) * R) / C);
            }
          }
      }
      let m = this.computeWorldPositions(t, u, o),
        v = m[0],
        g = m[1],
        x = a.offsetRotation,
        b = !1;
      if (x == 0) b = a.rotateMode == In.Chain;
      else {
        b = !1;
        let y = this.target.bone;
        x *= y.a * y.d - y.b * y.c > 0 ? ae.degRad : -ae.degRad;
      }
      for (let y = 0, _ = 3; y < c; y++, _ += 3) {
        let w = h[y];
        (w.worldX += (v - w.worldX) * s), (w.worldY += (g - w.worldY) * n);
        let E = m[_],
          A = m[_ + 1],
          C = E - v,
          F = A - g;
        if (l) {
          let B = f[y];
          if (B != 0) {
            let R = (Math.sqrt(C * C + F * F) / B - 1) * i + 1;
            (w.a *= R), (w.c *= R);
          }
        }
        if (((v = E), (g = A), i > 0)) {
          let B = w.a,
            R = w.b,
            I = w.c,
            P = w.d,
            M = 0,
            L = 0,
            U = 0;
          if (
            (o
              ? (M = m[_ - 1])
              : d[y + 1] == 0
              ? (M = m[_ + 2])
              : (M = Math.atan2(F, C)),
            (M -= Math.atan2(I, B)),
            b)
          ) {
            (L = Math.cos(M)), (U = Math.sin(M));
            let V = w.data.length;
            (v += (V * (L * B - U * I) - C) * i),
              (g += (V * (U * B + L * I) - F) * i);
          } else M += x;
          M > ae.PI ? (M -= ae.PI2) : M < -ae.PI && (M += ae.PI2),
            (M *= i),
            (L = Math.cos(M)),
            (U = Math.sin(M)),
            (w.a = L * B - U * I),
            (w.b = L * R - U * P),
            (w.c = U * B + L * I),
            (w.d = U * R + L * P);
        }
        w.updateAppliedTransform();
      }
    }
    computeWorldPositions(e, t, i) {
      let s = this.target,
        n = this.position,
        a = this.spaces,
        o = pe.setArraySize(this.positions, t * 3 + 2),
        l = this.world,
        h = e.closed,
        c = e.worldVerticesLength,
        u = c / 6,
        d = Cr.NONE;
      if (!e.constantSpeed) {
        let V = e.lengths;
        u -= h ? 1 : 2;
        let z = V[u];
        this.data.positionMode == Hi.Percent && (n *= z);
        let N;
        switch (this.data.spacingMode) {
          case Nt.Percent:
            N = z;
            break;
          case Nt.Proportional:
            N = z / t;
            break;
          default:
            N = 1;
        }
        l = pe.setArraySize(this.world, 8);
        for (let O = 0, H = 0, G = 0; O < t; O++, H += 3) {
          let q = a[O] * N;
          n += q;
          let K = n;
          if (h) (K %= z), K < 0 && (K += z), (G = 0);
          else if (K < 0) {
            d != Cr.BEFORE &&
              ((d = Cr.BEFORE), e.computeWorldVertices(s, 2, 4, l, 0, 2)),
              this.addBeforePosition(K, l, 0, o, H);
            continue;
          } else if (K > z) {
            d != Cr.AFTER &&
              ((d = Cr.AFTER), e.computeWorldVertices(s, c - 6, 4, l, 0, 2)),
              this.addAfterPosition(K - z, l, 0, o, H);
            continue;
          }
          for (; ; G++) {
            let ue = V[G];
            if (!(K > ue)) {
              if (G == 0) K /= ue;
              else {
                let ie = V[G - 1];
                K = (K - ie) / (ue - ie);
              }
              break;
            }
          }
          G != d &&
            ((d = G),
            h && G == u
              ? (e.computeWorldVertices(s, c - 4, 4, l, 0, 2),
                e.computeWorldVertices(s, 0, 4, l, 4, 2))
              : e.computeWorldVertices(s, G * 6 + 2, 8, l, 0, 2)),
            this.addCurvePosition(
              K,
              l[0],
              l[1],
              l[2],
              l[3],
              l[4],
              l[5],
              l[6],
              l[7],
              o,
              H,
              i || (O > 0 && q == 0)
            );
        }
        return o;
      }
      h
        ? ((c += 2),
          (l = pe.setArraySize(this.world, c)),
          e.computeWorldVertices(s, 2, c - 4, l, 0, 2),
          e.computeWorldVertices(s, 0, 2, l, c - 4, 2),
          (l[c - 2] = l[0]),
          (l[c - 1] = l[1]))
        : (u--,
          (c -= 4),
          (l = pe.setArraySize(this.world, c)),
          e.computeWorldVertices(s, 2, c, l, 0, 2));
      let f = pe.setArraySize(this.curves, u),
        p = 0,
        m = l[0],
        v = l[1],
        g = 0,
        x = 0,
        b = 0,
        y = 0,
        _ = 0,
        w = 0,
        E = 0,
        A = 0,
        C = 0,
        F = 0,
        B = 0,
        R = 0,
        I = 0,
        P = 0;
      for (let V = 0, z = 2; V < u; V++, z += 6)
        (g = l[z]),
          (x = l[z + 1]),
          (b = l[z + 2]),
          (y = l[z + 3]),
          (_ = l[z + 4]),
          (w = l[z + 5]),
          (E = (m - g * 2 + b) * 0.1875),
          (A = (v - x * 2 + y) * 0.1875),
          (C = ((g - b) * 3 - m + _) * 0.09375),
          (F = ((x - y) * 3 - v + w) * 0.09375),
          (B = E * 2 + C),
          (R = A * 2 + F),
          (I = (g - m) * 0.75 + E + C * 0.16666667),
          (P = (x - v) * 0.75 + A + F * 0.16666667),
          (p += Math.sqrt(I * I + P * P)),
          (I += B),
          (P += R),
          (B += C),
          (R += F),
          (p += Math.sqrt(I * I + P * P)),
          (I += B),
          (P += R),
          (p += Math.sqrt(I * I + P * P)),
          (I += B + C),
          (P += R + F),
          (p += Math.sqrt(I * I + P * P)),
          (f[V] = p),
          (m = _),
          (v = w);
      this.data.positionMode == Hi.Percent && (n *= p);
      let M;
      switch (this.data.spacingMode) {
        case Nt.Percent:
          M = p;
          break;
        case Nt.Proportional:
          M = p / t;
          break;
        default:
          M = 1;
      }
      let L = this.segments,
        U = 0;
      for (let V = 0, z = 0, N = 0, O = 0; V < t; V++, z += 3) {
        let H = a[V] * M;
        n += H;
        let G = n;
        if (h) (G %= p), G < 0 && (G += p), (N = 0);
        else if (G < 0) {
          this.addBeforePosition(G, l, 0, o, z);
          continue;
        } else if (G > p) {
          this.addAfterPosition(G - p, l, c - 4, o, z);
          continue;
        }
        for (; ; N++) {
          let q = f[N];
          if (!(G > q)) {
            if (N == 0) G /= q;
            else {
              let K = f[N - 1];
              G = (G - K) / (q - K);
            }
            break;
          }
        }
        if (N != d) {
          d = N;
          let q = N * 6;
          for (
            m = l[q],
              v = l[q + 1],
              g = l[q + 2],
              x = l[q + 3],
              b = l[q + 4],
              y = l[q + 5],
              _ = l[q + 6],
              w = l[q + 7],
              E = (m - g * 2 + b) * 0.03,
              A = (v - x * 2 + y) * 0.03,
              C = ((g - b) * 3 - m + _) * 0.006,
              F = ((x - y) * 3 - v + w) * 0.006,
              B = E * 2 + C,
              R = A * 2 + F,
              I = (g - m) * 0.3 + E + C * 0.16666667,
              P = (x - v) * 0.3 + A + F * 0.16666667,
              U = Math.sqrt(I * I + P * P),
              L[0] = U,
              q = 1;
            q < 8;
            q++
          )
            (I += B),
              (P += R),
              (B += C),
              (R += F),
              (U += Math.sqrt(I * I + P * P)),
              (L[q] = U);
          (I += B),
            (P += R),
            (U += Math.sqrt(I * I + P * P)),
            (L[8] = U),
            (I += B + C),
            (P += R + F),
            (U += Math.sqrt(I * I + P * P)),
            (L[9] = U),
            (O = 0);
        }
        for (G *= U; ; O++) {
          let q = L[O];
          if (!(G > q)) {
            if (O == 0) G /= q;
            else {
              let K = L[O - 1];
              G = O + (G - K) / (q - K);
            }
            break;
          }
        }
        this.addCurvePosition(
          G * 0.1,
          m,
          v,
          g,
          x,
          b,
          y,
          _,
          w,
          o,
          z,
          i || (V > 0 && H == 0)
        );
      }
      return o;
    }
    addBeforePosition(e, t, i, s, n) {
      let a = t[i],
        o = t[i + 1],
        l = t[i + 2] - a,
        h = t[i + 3] - o,
        c = Math.atan2(h, l);
      (s[n] = a + e * Math.cos(c)),
        (s[n + 1] = o + e * Math.sin(c)),
        (s[n + 2] = c);
    }
    addAfterPosition(e, t, i, s, n) {
      let a = t[i + 2],
        o = t[i + 3],
        l = a - t[i],
        h = o - t[i + 1],
        c = Math.atan2(h, l);
      (s[n] = a + e * Math.cos(c)),
        (s[n + 1] = o + e * Math.sin(c)),
        (s[n + 2] = c);
    }
    addCurvePosition(e, t, i, s, n, a, o, l, h, c, u, d) {
      if (e == 0 || isNaN(e)) {
        (c[u] = t), (c[u + 1] = i), (c[u + 2] = Math.atan2(n - i, s - t));
        return;
      }
      let f = e * e,
        p = f * e,
        m = 1 - e,
        v = m * m,
        g = v * m,
        x = m * e,
        b = x * 3,
        y = m * b,
        _ = b * e,
        w = t * g + s * y + a * _ + l * p,
        E = i * g + n * y + o * _ + h * p;
      (c[u] = w),
        (c[u + 1] = E),
        d &&
          (e < 0.001
            ? (c[u + 2] = Math.atan2(n - i, s - t))
            : (c[u + 2] = Math.atan2(
                E - (i * v + n * x * 2 + o * f),
                w - (t * v + s * x * 2 + a * f)
              )));
    }
  };
  T(Cr, "NONE", -1),
    T(Cr, "BEFORE", -2),
    T(Cr, "AFTER", -3),
    T(Cr, "epsilon", 1e-5);
  let Uf = Cr;
  class M5 {
    constructor(e, t) {
      T(this, "data");
      T(this, "_bone", null);
      T(this, "inertia", 0);
      T(this, "strength", 0);
      T(this, "damping", 0);
      T(this, "massInverse", 0);
      T(this, "wind", 0);
      T(this, "gravity", 0);
      T(this, "mix", 0);
      T(this, "_reset", !0);
      T(this, "ux", 0);
      T(this, "uy", 0);
      T(this, "cx", 0);
      T(this, "cy", 0);
      T(this, "tx", 0);
      T(this, "ty", 0);
      T(this, "xOffset", 0);
      T(this, "xVelocity", 0);
      T(this, "yOffset", 0);
      T(this, "yVelocity", 0);
      T(this, "rotateOffset", 0);
      T(this, "rotateVelocity", 0);
      T(this, "scaleOffset", 0);
      T(this, "scaleVelocity", 0);
      T(this, "active", !1);
      T(this, "skeleton");
      T(this, "remaining", 0);
      T(this, "lastTime", 0);
      (this.data = e),
        (this.skeleton = t),
        (this.bone = t.bones[e.bone.index]),
        (this.inertia = e.inertia),
        (this.strength = e.strength),
        (this.damping = e.damping),
        (this.massInverse = e.massInverse),
        (this.wind = e.wind),
        (this.gravity = e.gravity),
        (this.mix = e.mix);
    }
    set bone(e) {
      this._bone = e;
    }
    get bone() {
      if (this._bone) return this._bone;
      throw new Error("Bone not set.");
    }
    reset() {
      (this.remaining = 0),
        (this.lastTime = this.skeleton.time),
        (this._reset = !0),
        (this.xOffset = 0),
        (this.xVelocity = 0),
        (this.yOffset = 0),
        (this.yVelocity = 0),
        (this.rotateOffset = 0),
        (this.rotateVelocity = 0),
        (this.scaleOffset = 0),
        (this.scaleVelocity = 0);
    }
    setToSetupPose() {
      const e = this.data;
      (this.inertia = e.inertia),
        (this.strength = e.strength),
        (this.damping = e.damping),
        (this.massInverse = e.massInverse),
        (this.wind = e.wind),
        (this.gravity = e.gravity),
        (this.mix = e.mix);
    }
    isActive() {
      return this.active;
    }
    update(e) {
      const t = this.mix;
      if (t == 0) return;
      const i = this.data.x > 0,
        s = this.data.y > 0,
        n = this.data.rotate > 0 || this.data.shearX > 0,
        a = this.data.scaleX > 0,
        o = this.bone,
        l = o.data.length;
      switch (e) {
        case ls.none:
          return;
        case ls.reset:
          this.reset();
        case ls.update:
          const h = this.skeleton,
            c = Math.max(this.skeleton.time - this.lastTime, 0);
          (this.remaining += c), (this.lastTime = h.time);
          const u = o.worldX,
            d = o.worldY;
          if (this._reset) (this._reset = !1), (this.ux = u), (this.uy = d);
          else {
            let f = this.remaining,
              p = this.inertia,
              m = this.data.step,
              v = this.skeleton.data.referenceScale,
              g = -1,
              x = this.data.limit * c,
              b = x * Math.abs(h.scaleY);
            if (((x *= Math.abs(h.scaleX)), i || s)) {
              if (i) {
                const y = (this.ux - u) * p;
                (this.xOffset += y > x ? x : y < -x ? -x : y), (this.ux = u);
              }
              if (s) {
                const y = (this.uy - d) * p;
                (this.yOffset += y > b ? b : y < -b ? -b : y), (this.uy = d);
              }
              if (f >= m) {
                g = Math.pow(this.damping, 60 * m);
                const y = this.massInverse * m,
                  _ = this.strength,
                  w = this.wind * v,
                  E = (Xa.yDown ? -this.gravity : this.gravity) * v;
                do
                  i &&
                    ((this.xVelocity += (w - this.xOffset * _) * y),
                    (this.xOffset += this.xVelocity * m),
                    (this.xVelocity *= g)),
                    s &&
                      ((this.yVelocity -= (E + this.yOffset * _) * y),
                      (this.yOffset += this.yVelocity * m),
                      (this.yVelocity *= g)),
                    (f -= m);
                while (f >= m);
              }
              i && (o.worldX += this.xOffset * t * this.data.x),
                s && (o.worldY += this.yOffset * t * this.data.y);
            }
            if (n || a) {
              let y = Math.atan2(o.c, o.a),
                _ = 0,
                w = 0,
                E = 0,
                A = this.cx - o.worldX,
                C = this.cy - o.worldY;
              if (
                (A > x ? (A = x) : A < -x && (A = -x),
                C > b ? (C = b) : C < -b && (C = -b),
                n)
              ) {
                E = (this.data.rotate + this.data.shearX) * t;
                let F =
                  Math.atan2(C + this.ty, A + this.tx) -
                  y -
                  this.rotateOffset * E;
                (this.rotateOffset +=
                  (F - Math.ceil(F * ae.invPI2 - 0.5) * ae.PI2) * p),
                  (F = this.rotateOffset * E + y),
                  (_ = Math.cos(F)),
                  (w = Math.sin(F)),
                  a &&
                    ((F = l * o.getWorldScaleX()),
                    F > 0 && (this.scaleOffset += ((A * _ + C * w) * p) / F));
              } else {
                (_ = Math.cos(y)), (w = Math.sin(y));
                const F = l * o.getWorldScaleX();
                F > 0 && (this.scaleOffset += ((A * _ + C * w) * p) / F);
              }
              if (((f = this.remaining), f >= m)) {
                g == -1 && (g = Math.pow(this.damping, 60 * m));
                const F = this.massInverse * m,
                  B = this.strength,
                  R = this.wind,
                  I = Xa.yDown ? -this.gravity : this.gravity,
                  P = l / v;
                for (;;)
                  if (
                    ((f -= m),
                    a &&
                      ((this.scaleVelocity +=
                        (R * _ - I * w - this.scaleOffset * B) * F),
                      (this.scaleOffset += this.scaleVelocity * m),
                      (this.scaleVelocity *= g)),
                    n)
                  ) {
                    if (
                      ((this.rotateVelocity -=
                        ((R * w + I * _) * P + this.rotateOffset * B) * F),
                      (this.rotateOffset += this.rotateVelocity * m),
                      (this.rotateVelocity *= g),
                      f < m)
                    )
                      break;
                    const M = this.rotateOffset * E + y;
                    (_ = Math.cos(M)), (w = Math.sin(M));
                  } else if (f < m) break;
              }
            }
            this.remaining = f;
          }
          (this.cx = o.worldX), (this.cy = o.worldY);
          break;
        case ls.pose:
          i && (o.worldX += this.xOffset * t * this.data.x),
            s && (o.worldY += this.yOffset * t * this.data.y);
      }
      if (n) {
        let h = this.rotateOffset * t,
          c = 0,
          u = 0,
          d = 0;
        if (this.data.shearX > 0) {
          let f = 0;
          this.data.rotate > 0 &&
            ((f = h * this.data.rotate),
            (c = Math.sin(f)),
            (u = Math.cos(f)),
            (d = o.b),
            (o.b = u * d - c * o.d),
            (o.d = c * d + u * o.d)),
            (f += h * this.data.shearX),
            (c = Math.sin(f)),
            (u = Math.cos(f)),
            (d = o.a),
            (o.a = u * d - c * o.c),
            (o.c = c * d + u * o.c);
        } else
          (h *= this.data.rotate),
            (c = Math.sin(h)),
            (u = Math.cos(h)),
            (d = o.a),
            (o.a = u * d - c * o.c),
            (o.c = c * d + u * o.c),
            (d = o.b),
            (o.b = u * d - c * o.d),
            (o.d = c * d + u * o.d);
      }
      if (a) {
        const h = 1 + this.scaleOffset * t * this.data.scaleX;
        (o.a *= h), (o.c *= h);
      }
      e != ls.pose && ((this.tx = l * o.a), (this.ty = l * o.c)),
        o.updateAppliedTransform();
    }
    translate(e, t) {
      (this.ux -= e), (this.uy -= t), (this.cx -= e), (this.cy -= t);
    }
    rotate(e, t, i) {
      const s = i * ae.degRad,
        n = Math.cos(s),
        a = Math.sin(s),
        o = this.cx - e,
        l = this.cy - t;
      this.translate(o * n - l * a - o, o * a + l * n - l);
    }
  }
  class F5 {
    constructor(e, t) {
      T(this, "data");
      T(this, "bone");
      T(this, "color");
      T(this, "darkColor", null);
      T(this, "attachment", null);
      T(this, "attachmentState", 0);
      T(this, "sequenceIndex", -1);
      T(this, "deform", new Array());
      if (!e) throw new Error("data cannot be null.");
      if (!t) throw new Error("bone cannot be null.");
      (this.data = e),
        (this.bone = t),
        (this.color = new Ve()),
        (this.darkColor = e.darkColor ? new Ve() : null),
        this.setToSetupPose();
    }
    getSkeleton() {
      return this.bone.skeleton;
    }
    getAttachment() {
      return this.attachment;
    }
    setAttachment(e) {
      this.attachment != e &&
        ((!(e instanceof gi) ||
          !(this.attachment instanceof gi) ||
          e.timelineAttachment != this.attachment.timelineAttachment) &&
          (this.deform.length = 0),
        (this.attachment = e),
        (this.sequenceIndex = -1));
    }
    setToSetupPose() {
      this.color.setFromColor(this.data.color),
        this.darkColor && this.darkColor.setFromColor(this.data.darkColor),
        this.data.attachmentName
          ? ((this.attachment = null),
            this.setAttachment(
              this.bone.skeleton.getAttachment(
                this.data.index,
                this.data.attachmentName
              )
            ))
          : (this.attachment = null);
    }
  }
  class B5 {
    constructor(e, t) {
      T(this, "data");
      T(this, "bones");
      T(this, "target");
      T(this, "mixRotate", 0);
      T(this, "mixX", 0);
      T(this, "mixY", 0);
      T(this, "mixScaleX", 0);
      T(this, "mixScaleY", 0);
      T(this, "mixShearY", 0);
      T(this, "temp", new sc());
      T(this, "active", !1);
      if (!e) throw new Error("data cannot be null.");
      if (!t) throw new Error("skeleton cannot be null.");
      (this.data = e), (this.bones = new Array());
      for (let s = 0; s < e.bones.length; s++) {
        let n = t.findBone(e.bones[s].name);
        if (!n) throw new Error(`Couldn't find bone ${e.bones[s].name}.`);
        this.bones.push(n);
      }
      let i = t.findBone(e.target.name);
      if (!i) throw new Error(`Couldn't find target bone ${e.target.name}.`);
      (this.target = i),
        (this.mixRotate = e.mixRotate),
        (this.mixX = e.mixX),
        (this.mixY = e.mixY),
        (this.mixScaleX = e.mixScaleX),
        (this.mixScaleY = e.mixScaleY),
        (this.mixShearY = e.mixShearY);
    }
    isActive() {
      return this.active;
    }
    setToSetupPose() {
      const e = this.data;
      (this.mixRotate = e.mixRotate),
        (this.mixX = e.mixX),
        (this.mixY = e.mixY),
        (this.mixScaleX = e.mixScaleX),
        (this.mixScaleY = e.mixScaleY),
        (this.mixShearY = e.mixShearY);
    }
    update(e) {
      (this.mixRotate == 0 &&
        this.mixX == 0 &&
        this.mixY == 0 &&
        this.mixScaleX == 0 &&
        this.mixScaleY == 0 &&
        this.mixShearY == 0) ||
        (this.data.local
          ? this.data.relative
            ? this.applyRelativeLocal()
            : this.applyAbsoluteLocal()
          : this.data.relative
          ? this.applyRelativeWorld()
          : this.applyAbsoluteWorld());
    }
    applyAbsoluteWorld() {
      let e = this.mixRotate,
        t = this.mixX,
        i = this.mixY,
        s = this.mixScaleX,
        n = this.mixScaleY,
        a = this.mixShearY,
        o = t != 0 || i != 0,
        l = this.target,
        h = l.a,
        c = l.b,
        u = l.c,
        d = l.d,
        f = h * d - c * u > 0 ? ae.degRad : -ae.degRad,
        p = this.data.offsetRotation * f,
        m = this.data.offsetShearY * f,
        v = this.bones;
      for (let g = 0, x = v.length; g < x; g++) {
        let b = v[g];
        if (e != 0) {
          let y = b.a,
            _ = b.b,
            w = b.c,
            E = b.d,
            A = Math.atan2(u, h) - Math.atan2(w, y) + p;
          A > ae.PI ? (A -= ae.PI2) : A < -ae.PI && (A += ae.PI2), (A *= e);
          let C = Math.cos(A),
            F = Math.sin(A);
          (b.a = C * y - F * w),
            (b.b = C * _ - F * E),
            (b.c = F * y + C * w),
            (b.d = F * _ + C * E);
        }
        if (o) {
          let y = this.temp;
          l.localToWorld(y.set(this.data.offsetX, this.data.offsetY)),
            (b.worldX += (y.x - b.worldX) * t),
            (b.worldY += (y.y - b.worldY) * i);
        }
        if (s != 0) {
          let y = Math.sqrt(b.a * b.a + b.c * b.c);
          y != 0 &&
            (y =
              (y +
                (Math.sqrt(h * h + u * u) - y + this.data.offsetScaleX) * s) /
              y),
            (b.a *= y),
            (b.c *= y);
        }
        if (n != 0) {
          let y = Math.sqrt(b.b * b.b + b.d * b.d);
          y != 0 &&
            (y =
              (y +
                (Math.sqrt(c * c + d * d) - y + this.data.offsetScaleY) * n) /
              y),
            (b.b *= y),
            (b.d *= y);
        }
        if (a > 0) {
          let y = b.b,
            _ = b.d,
            w = Math.atan2(_, y),
            E =
              Math.atan2(d, c) - Math.atan2(u, h) - (w - Math.atan2(b.c, b.a));
          E > ae.PI ? (E -= ae.PI2) : E < -ae.PI && (E += ae.PI2),
            (E = w + (E + m) * a);
          let A = Math.sqrt(y * y + _ * _);
          (b.b = Math.cos(E) * A), (b.d = Math.sin(E) * A);
        }
        b.updateAppliedTransform();
      }
    }
    applyRelativeWorld() {
      let e = this.mixRotate,
        t = this.mixX,
        i = this.mixY,
        s = this.mixScaleX,
        n = this.mixScaleY,
        a = this.mixShearY,
        o = t != 0 || i != 0,
        l = this.target,
        h = l.a,
        c = l.b,
        u = l.c,
        d = l.d,
        f = h * d - c * u > 0 ? ae.degRad : -ae.degRad,
        p = this.data.offsetRotation * f,
        m = this.data.offsetShearY * f,
        v = this.bones;
      for (let g = 0, x = v.length; g < x; g++) {
        let b = v[g];
        if (e != 0) {
          let y = b.a,
            _ = b.b,
            w = b.c,
            E = b.d,
            A = Math.atan2(u, h) + p;
          A > ae.PI ? (A -= ae.PI2) : A < -ae.PI && (A += ae.PI2), (A *= e);
          let C = Math.cos(A),
            F = Math.sin(A);
          (b.a = C * y - F * w),
            (b.b = C * _ - F * E),
            (b.c = F * y + C * w),
            (b.d = F * _ + C * E);
        }
        if (o) {
          let y = this.temp;
          l.localToWorld(y.set(this.data.offsetX, this.data.offsetY)),
            (b.worldX += y.x * t),
            (b.worldY += y.y * i);
        }
        if (s != 0) {
          let y =
            (Math.sqrt(h * h + u * u) - 1 + this.data.offsetScaleX) * s + 1;
          (b.a *= y), (b.c *= y);
        }
        if (n != 0) {
          let y =
            (Math.sqrt(c * c + d * d) - 1 + this.data.offsetScaleY) * n + 1;
          (b.b *= y), (b.d *= y);
        }
        if (a > 0) {
          let y = Math.atan2(d, c) - Math.atan2(u, h);
          y > ae.PI ? (y -= ae.PI2) : y < -ae.PI && (y += ae.PI2);
          let _ = b.b,
            w = b.d;
          y = Math.atan2(w, _) + (y - ae.PI / 2 + m) * a;
          let E = Math.sqrt(_ * _ + w * w);
          (b.b = Math.cos(y) * E), (b.d = Math.sin(y) * E);
        }
        b.updateAppliedTransform();
      }
    }
    applyAbsoluteLocal() {
      let e = this.mixRotate,
        t = this.mixX,
        i = this.mixY,
        s = this.mixScaleX,
        n = this.mixScaleY,
        a = this.mixShearY,
        o = this.target,
        l = this.bones;
      for (let h = 0, c = l.length; h < c; h++) {
        let u = l[h],
          d = u.arotation;
        e != 0 && (d += (o.arotation - d + this.data.offsetRotation) * e);
        let f = u.ax,
          p = u.ay;
        (f += (o.ax - f + this.data.offsetX) * t),
          (p += (o.ay - p + this.data.offsetY) * i);
        let m = u.ascaleX,
          v = u.ascaleY;
        s != 0 &&
          m != 0 &&
          (m = (m + (o.ascaleX - m + this.data.offsetScaleX) * s) / m),
          n != 0 &&
            v != 0 &&
            (v = (v + (o.ascaleY - v + this.data.offsetScaleY) * n) / v);
        let g = u.ashearY;
        a != 0 && (g += (o.ashearY - g + this.data.offsetShearY) * a),
          u.updateWorldTransformWith(f, p, d, m, v, u.ashearX, g);
      }
    }
    applyRelativeLocal() {
      let e = this.mixRotate,
        t = this.mixX,
        i = this.mixY,
        s = this.mixScaleX,
        n = this.mixScaleY,
        a = this.mixShearY,
        o = this.target,
        l = this.bones;
      for (let h = 0, c = l.length; h < c; h++) {
        let u = l[h],
          d = u.arotation + (o.arotation + this.data.offsetRotation) * e,
          f = u.ax + (o.ax + this.data.offsetX) * t,
          p = u.ay + (o.ay + this.data.offsetY) * i,
          m = u.ascaleX * ((o.ascaleX - 1 + this.data.offsetScaleX) * s + 1),
          v = u.ascaleY * ((o.ascaleY - 1 + this.data.offsetScaleY) * n + 1),
          g = u.ashearY + (o.ashearY + this.data.offsetShearY) * a;
        u.updateWorldTransformWith(f, p, d, m, v, u.ashearX, g);
      }
    }
  }
  const pa = class pa {
    constructor(e) {
      T(this, "data");
      T(this, "bones");
      T(this, "slots");
      T(this, "drawOrder");
      T(this, "ikConstraints");
      T(this, "transformConstraints");
      T(this, "pathConstraints");
      T(this, "physicsConstraints");
      T(this, "_updateCache", new Array());
      T(this, "skin", null);
      T(this, "color");
      T(this, "scaleX", 1);
      T(this, "_scaleY", 1);
      T(this, "x", 0);
      T(this, "y", 0);
      T(this, "time", 0);
      if (!e) throw new Error("data cannot be null.");
      (this.data = e), (this.bones = new Array());
      for (let t = 0; t < e.bones.length; t++) {
        let i = e.bones[t],
          s;
        if (!i.parent) s = new cy(i, this, null);
        else {
          let n = this.bones[i.parent.index];
          (s = new cy(i, this, n)), n.children.push(s);
        }
        this.bones.push(s);
      }
      (this.slots = new Array()), (this.drawOrder = new Array());
      for (let t = 0; t < e.slots.length; t++) {
        let i = e.slots[t],
          s = this.bones[i.boneData.index],
          n = new F5(i, s);
        this.slots.push(n), this.drawOrder.push(n);
      }
      this.ikConstraints = new Array();
      for (let t = 0; t < e.ikConstraints.length; t++) {
        let i = e.ikConstraints[t];
        this.ikConstraints.push(new R5(i, this));
      }
      this.transformConstraints = new Array();
      for (let t = 0; t < e.transformConstraints.length; t++) {
        let i = e.transformConstraints[t];
        this.transformConstraints.push(new B5(i, this));
      }
      this.pathConstraints = new Array();
      for (let t = 0; t < e.pathConstraints.length; t++) {
        let i = e.pathConstraints[t];
        this.pathConstraints.push(new Uf(i, this));
      }
      this.physicsConstraints = new Array();
      for (let t = 0; t < e.physicsConstraints.length; t++) {
        let i = e.physicsConstraints[t];
        this.physicsConstraints.push(new M5(i, this));
      }
      (this.color = new Ve(1, 1, 1, 1)), this.updateCache();
    }
    get scaleY() {
      return pa.yDown ? -this._scaleY : this._scaleY;
    }
    set scaleY(e) {
      this._scaleY = e;
    }
    updateCache() {
      let e = this._updateCache;
      e.length = 0;
      let t = this.bones;
      for (let d = 0, f = t.length; d < f; d++) {
        let p = t[d];
        (p.sorted = p.data.skinRequired), (p.active = !p.sorted);
      }
      if (this.skin) {
        let d = this.skin.bones;
        for (let f = 0, p = this.skin.bones.length; f < p; f++) {
          let m = this.bones[d[f].index];
          do (m.sorted = !1), (m.active = !0), (m = m.parent);
          while (m);
        }
      }
      let i = this.ikConstraints,
        s = this.transformConstraints,
        n = this.pathConstraints,
        a = this.physicsConstraints,
        o = i.length,
        l = s.length,
        h = n.length,
        c = this.physicsConstraints.length,
        u = o + l + h + c;
      e: for (let d = 0; d < u; d++) {
        for (let f = 0; f < o; f++) {
          let p = i[f];
          if (p.data.order == d) {
            this.sortIkConstraint(p);
            continue e;
          }
        }
        for (let f = 0; f < l; f++) {
          let p = s[f];
          if (p.data.order == d) {
            this.sortTransformConstraint(p);
            continue e;
          }
        }
        for (let f = 0; f < h; f++) {
          let p = n[f];
          if (p.data.order == d) {
            this.sortPathConstraint(p);
            continue e;
          }
        }
        for (let f = 0; f < c; f++) {
          const p = a[f];
          if (p.data.order == d) {
            this.sortPhysicsConstraint(p);
            continue e;
          }
        }
      }
      for (let d = 0, f = t.length; d < f; d++) this.sortBone(t[d]);
    }
    sortIkConstraint(e) {
      if (
        ((e.active =
          e.target.isActive() &&
          (!e.data.skinRequired ||
            (this.skin && pe.contains(this.skin.constraints, e.data, !0)))),
        !e.active)
      )
        return;
      let t = e.target;
      this.sortBone(t);
      let i = e.bones,
        s = i[0];
      if ((this.sortBone(s), i.length == 1))
        this._updateCache.push(e), this.sortReset(s.children);
      else {
        let n = i[i.length - 1];
        this.sortBone(n),
          this._updateCache.push(e),
          this.sortReset(s.children),
          (n.sorted = !0);
      }
    }
    sortPathConstraint(e) {
      if (
        ((e.active =
          e.target.bone.isActive() &&
          (!e.data.skinRequired ||
            (this.skin && pe.contains(this.skin.constraints, e.data, !0)))),
        !e.active)
      )
        return;
      let t = e.target,
        i = t.data.index,
        s = t.bone;
      this.skin && this.sortPathConstraintAttachment(this.skin, i, s),
        this.data.defaultSkin &&
          this.data.defaultSkin != this.skin &&
          this.sortPathConstraintAttachment(this.data.defaultSkin, i, s);
      for (let l = 0, h = this.data.skins.length; l < h; l++)
        this.sortPathConstraintAttachment(this.data.skins[l], i, s);
      let n = t.getAttachment();
      n instanceof Ha && this.sortPathConstraintAttachmentWith(n, s);
      let a = e.bones,
        o = a.length;
      for (let l = 0; l < o; l++) this.sortBone(a[l]);
      this._updateCache.push(e);
      for (let l = 0; l < o; l++) this.sortReset(a[l].children);
      for (let l = 0; l < o; l++) a[l].sorted = !0;
    }
    sortTransformConstraint(e) {
      if (
        ((e.active =
          e.target.isActive() &&
          (!e.data.skinRequired ||
            (this.skin && pe.contains(this.skin.constraints, e.data, !0)))),
        !e.active)
      )
        return;
      this.sortBone(e.target);
      let t = e.bones,
        i = t.length;
      if (e.data.local)
        for (let s = 0; s < i; s++) {
          let n = t[s];
          this.sortBone(n.parent), this.sortBone(n);
        }
      else for (let s = 0; s < i; s++) this.sortBone(t[s]);
      this._updateCache.push(e);
      for (let s = 0; s < i; s++) this.sortReset(t[s].children);
      for (let s = 0; s < i; s++) t[s].sorted = !0;
    }
    sortPathConstraintAttachment(e, t, i) {
      let s = e.attachments[t];
      if (s) for (let n in s) this.sortPathConstraintAttachmentWith(s[n], i);
    }
    sortPathConstraintAttachmentWith(e, t) {
      if (!(e instanceof Ha)) return;
      let i = e.bones;
      if (!i) this.sortBone(t);
      else {
        let s = this.bones;
        for (let n = 0, a = i.length; n < a; ) {
          let o = i[n++];
          for (o += n; n < o; ) this.sortBone(s[i[n++]]);
        }
      }
    }
    sortPhysicsConstraint(e) {
      const t = e.bone;
      (e.active =
        t.active &&
        (!e.data.skinRequired ||
          (this.skin != null &&
            pe.contains(this.skin.constraints, e.data, !0)))),
        e.active &&
          (this.sortBone(t),
          this._updateCache.push(e),
          this.sortReset(t.children),
          (t.sorted = !0));
    }
    sortBone(e) {
      if (!e || e.sorted) return;
      let t = e.parent;
      t && this.sortBone(t), (e.sorted = !0), this._updateCache.push(e);
    }
    sortReset(e) {
      for (let t = 0, i = e.length; t < i; t++) {
        let s = e[t];
        s.active && (s.sorted && this.sortReset(s.children), (s.sorted = !1));
      }
    }
    updateWorldTransform(e) {
      if (e == null) throw new Error("physics is undefined");
      let t = this.bones;
      for (let s = 0, n = t.length; s < n; s++) {
        let a = t[s];
        (a.ax = a.x),
          (a.ay = a.y),
          (a.arotation = a.rotation),
          (a.ascaleX = a.scaleX),
          (a.ascaleY = a.scaleY),
          (a.ashearX = a.shearX),
          (a.ashearY = a.shearY);
      }
      let i = this._updateCache;
      for (let s = 0, n = i.length; s < n; s++) i[s].update(e);
    }
    updateWorldTransformWith(e, t) {
      let i = this.getRootBone();
      if (!i) throw new Error("Root bone must not be null.");
      let s = t.a,
        n = t.b,
        a = t.c,
        o = t.d;
      (i.worldX = s * this.x + n * this.y + t.worldX),
        (i.worldY = a * this.x + o * this.y + t.worldY);
      const l = (i.rotation + i.shearX) * ae.degRad,
        h = (i.rotation + 90 + i.shearY) * ae.degRad,
        c = Math.cos(l) * i.scaleX,
        u = Math.cos(h) * i.scaleY,
        d = Math.sin(l) * i.scaleX,
        f = Math.sin(h) * i.scaleY;
      (i.a = (s * c + n * d) * this.scaleX),
        (i.b = (s * u + n * f) * this.scaleX),
        (i.c = (a * c + o * d) * this.scaleY),
        (i.d = (a * u + o * f) * this.scaleY);
      let p = this._updateCache;
      for (let m = 0, v = p.length; m < v; m++) {
        let g = p[m];
        g != i && g.update(e);
      }
    }
    setToSetupPose() {
      this.setBonesToSetupPose(), this.setSlotsToSetupPose();
    }
    setBonesToSetupPose() {
      for (const e of this.bones) e.setToSetupPose();
      for (const e of this.ikConstraints) e.setToSetupPose();
      for (const e of this.transformConstraints) e.setToSetupPose();
      for (const e of this.pathConstraints) e.setToSetupPose();
      for (const e of this.physicsConstraints) e.setToSetupPose();
    }
    setSlotsToSetupPose() {
      let e = this.slots;
      pe.arrayCopy(e, 0, this.drawOrder, 0, e.length);
      for (let t = 0, i = e.length; t < i; t++) e[t].setToSetupPose();
    }
    getRootBone() {
      return this.bones.length == 0 ? null : this.bones[0];
    }
    findBone(e) {
      if (!e) throw new Error("boneName cannot be null.");
      let t = this.bones;
      for (let i = 0, s = t.length; i < s; i++) {
        let n = t[i];
        if (n.data.name == e) return n;
      }
      return null;
    }
    findSlot(e) {
      if (!e) throw new Error("slotName cannot be null.");
      let t = this.slots;
      for (let i = 0, s = t.length; i < s; i++) {
        let n = t[i];
        if (n.data.name == e) return n;
      }
      return null;
    }
    setSkinByName(e) {
      let t = this.data.findSkin(e);
      if (!t) throw new Error("Skin not found: " + e);
      this.setSkin(t);
    }
    setSkin(e) {
      if (e != this.skin) {
        if (e)
          if (this.skin) e.attachAll(this, this.skin);
          else {
            let t = this.slots;
            for (let i = 0, s = t.length; i < s; i++) {
              let n = t[i],
                a = n.data.attachmentName;
              if (a) {
                let o = e.getAttachment(i, a);
                o && n.setAttachment(o);
              }
            }
          }
        (this.skin = e), this.updateCache();
      }
    }
    getAttachmentByName(e, t) {
      let i = this.data.findSlot(e);
      if (!i) throw new Error(`Can't find slot with name ${e}`);
      return this.getAttachment(i.index, t);
    }
    getAttachment(e, t) {
      if (!t) throw new Error("attachmentName cannot be null.");
      if (this.skin) {
        let i = this.skin.getAttachment(e, t);
        if (i) return i;
      }
      return this.data.defaultSkin
        ? this.data.defaultSkin.getAttachment(e, t)
        : null;
    }
    setAttachment(e, t) {
      if (!e) throw new Error("slotName cannot be null.");
      let i = this.slots;
      for (let s = 0, n = i.length; s < n; s++) {
        let a = i[s];
        if (a.data.name == e) {
          let o = null;
          if (t && ((o = this.getAttachment(s, t)), !o))
            throw new Error("Attachment not found: " + t + ", for slot: " + e);
          a.setAttachment(o);
          return;
        }
      }
      throw new Error("Slot not found: " + e);
    }
    findIkConstraint(e) {
      if (!e) throw new Error("constraintName cannot be null.");
      return this.ikConstraints.find((t) => t.data.name == e) ?? null;
    }
    findTransformConstraint(e) {
      if (!e) throw new Error("constraintName cannot be null.");
      return this.transformConstraints.find((t) => t.data.name == e) ?? null;
    }
    findPathConstraint(e) {
      if (!e) throw new Error("constraintName cannot be null.");
      return this.pathConstraints.find((t) => t.data.name == e) ?? null;
    }
    findPhysicsConstraint(e) {
      if (e == null) throw new Error("constraintName cannot be null.");
      return this.physicsConstraints.find((t) => t.data.name == e) ?? null;
    }
    getBoundsRect() {
      let e = new sc(),
        t = new sc();
      return this.getBounds(e, t), { x: e.x, y: e.y, width: t.x, height: t.y };
    }
    getBounds(e, t, i = new Array(2), s = null) {
      if (!e) throw new Error("offset cannot be null.");
      if (!t) throw new Error("size cannot be null.");
      let n = this.drawOrder,
        a = Number.POSITIVE_INFINITY,
        o = Number.POSITIVE_INFINITY,
        l = Number.NEGATIVE_INFINITY,
        h = Number.NEGATIVE_INFINITY;
      for (let c = 0, u = n.length; c < u; c++) {
        let d = n[c];
        if (!d.bone.active) continue;
        let f = 0,
          p = null,
          m = null,
          v = d.getAttachment();
        if (v instanceof sl)
          (f = 8),
            (p = pe.setArraySize(i, f, 0)),
            v.computeWorldVertices(d, p, 0, 2),
            (m = pa.quadTriangles);
        else if (v instanceof Nn) {
          let g = v;
          (f = g.worldVerticesLength),
            (p = pe.setArraySize(i, f, 0)),
            g.computeWorldVertices(d, 0, f, p, 0, 2),
            (m = g.triangles);
        } else if (v instanceof _l && s != null) {
          s.clipStart(d, v);
          continue;
        }
        if (p && m) {
          s != null &&
            s.isClipping() &&
            (s.clipTriangles(p, m, m.length),
            (p = s.clippedVertices),
            (f = s.clippedVertices.length));
          for (let g = 0, x = p.length; g < x; g += 2) {
            let b = p[g],
              y = p[g + 1];
            (a = Math.min(a, b)),
              (o = Math.min(o, y)),
              (l = Math.max(l, b)),
              (h = Math.max(h, y));
          }
        }
        s != null && s.clipEndWithSlot(d);
      }
      s != null && s.clipEnd(), e.set(a, o), t.set(l - a, h - o);
    }
    update(e) {
      this.time += e;
    }
    physicsTranslate(e, t) {
      const i = this.physicsConstraints;
      for (let s = 0, n = i.length; s < n; s++) i[s].translate(e, t);
    }
    physicsRotate(e, t, i) {
      const s = this.physicsConstraints;
      for (let n = 0, a = s.length; n < a; n++) s[n].rotate(e, t, i);
    }
  };
  T(pa, "quadTriangles", [0, 1, 2, 2, 3, 0]), T(pa, "yDown", !1);
  let Xa = pa;
  var ls;
  (function (r) {
    (r[(r.none = 0)] = "none"),
      (r[(r.reset = 1)] = "reset"),
      (r[(r.update = 2)] = "update"),
      (r[(r.pose = 3)] = "pose");
  })(ls || (ls = {}));
  class Pw extends Yc {
    constructor(t) {
      super(t, 0, !1);
      T(this, "_bone", null);
      T(this, "x", 0);
      T(this, "y", 0);
      T(this, "rotate", 0);
      T(this, "scaleX", 0);
      T(this, "shearX", 0);
      T(this, "limit", 0);
      T(this, "step", 0);
      T(this, "inertia", 0);
      T(this, "strength", 0);
      T(this, "damping", 0);
      T(this, "massInverse", 0);
      T(this, "wind", 0);
      T(this, "gravity", 0);
      T(this, "mix", 0);
      T(this, "inertiaGlobal", !1);
      T(this, "strengthGlobal", !1);
      T(this, "dampingGlobal", !1);
      T(this, "massGlobal", !1);
      T(this, "windGlobal", !1);
      T(this, "gravityGlobal", !1);
      T(this, "mixGlobal", !1);
    }
    set bone(t) {
      this._bone = t;
    }
    get bone() {
      if (this._bone) return this._bone;
      throw new Error("BoneData not set.");
    }
  }
  class Rw {
    constructor() {
      T(this, "name", null);
      T(this, "bones", new Array());
      T(this, "slots", new Array());
      T(this, "skins", new Array());
      T(this, "defaultSkin", null);
      T(this, "events", new Array());
      T(this, "animations", new Array());
      T(this, "ikConstraints", new Array());
      T(this, "transformConstraints", new Array());
      T(this, "pathConstraints", new Array());
      T(this, "physicsConstraints", new Array());
      T(this, "x", 0);
      T(this, "y", 0);
      T(this, "width", 0);
      T(this, "height", 0);
      T(this, "referenceScale", 100);
      T(this, "version", null);
      T(this, "hash", null);
      T(this, "fps", 0);
      T(this, "imagesPath", null);
      T(this, "audioPath", null);
    }
    findBone(e) {
      if (!e) throw new Error("boneName cannot be null.");
      let t = this.bones;
      for (let i = 0, s = t.length; i < s; i++) {
        let n = t[i];
        if (n.name == e) return n;
      }
      return null;
    }
    findSlot(e) {
      if (!e) throw new Error("slotName cannot be null.");
      let t = this.slots;
      for (let i = 0, s = t.length; i < s; i++) {
        let n = t[i];
        if (n.name == e) return n;
      }
      return null;
    }
    findSkin(e) {
      if (!e) throw new Error("skinName cannot be null.");
      let t = this.skins;
      for (let i = 0, s = t.length; i < s; i++) {
        let n = t[i];
        if (n.name == e) return n;
      }
      return null;
    }
    findEvent(e) {
      if (!e) throw new Error("eventDataName cannot be null.");
      let t = this.events;
      for (let i = 0, s = t.length; i < s; i++) {
        let n = t[i];
        if (n.name == e) return n;
      }
      return null;
    }
    findAnimation(e) {
      if (!e) throw new Error("animationName cannot be null.");
      let t = this.animations;
      for (let i = 0, s = t.length; i < s; i++) {
        let n = t[i];
        if (n.name == e) return n;
      }
      return null;
    }
    findIkConstraint(e) {
      if (!e) throw new Error("constraintName cannot be null.");
      const t = this.ikConstraints;
      for (let i = 0, s = t.length; i < s; i++) {
        const n = t[i];
        if (n.name == e) return n;
      }
      return null;
    }
    findTransformConstraint(e) {
      if (!e) throw new Error("constraintName cannot be null.");
      const t = this.transformConstraints;
      for (let i = 0, s = t.length; i < s; i++) {
        const n = t[i];
        if (n.name == e) return n;
      }
      return null;
    }
    findPathConstraint(e) {
      if (!e) throw new Error("constraintName cannot be null.");
      const t = this.pathConstraints;
      for (let i = 0, s = t.length; i < s; i++) {
        const n = t[i];
        if (n.name == e) return n;
      }
      return null;
    }
    findPhysicsConstraint(e) {
      if (!e) throw new Error("constraintName cannot be null.");
      const t = this.physicsConstraints;
      for (let i = 0, s = t.length; i < s; i++) {
        const n = t[i];
        if (n.name == e) return n;
      }
      return null;
    }
  }
  class uy {
    constructor(e = 0, t, i) {
      T(this, "slotIndex");
      T(this, "name");
      T(this, "attachment");
      (this.slotIndex = e), (this.name = t), (this.attachment = i);
    }
  }
  class Vf {
    constructor(e) {
      T(this, "name");
      T(this, "attachments", new Array());
      T(this, "bones", Array());
      T(this, "constraints", new Array());
      T(this, "color", new Ve(0.99607843, 0.61960787, 0.30980393, 1));
      if (!e) throw new Error("name cannot be null.");
      this.name = e;
    }
    setAttachment(e, t, i) {
      if (!i) throw new Error("attachment cannot be null.");
      let s = this.attachments;
      e >= s.length && (s.length = e + 1), s[e] || (s[e] = {}), (s[e][t] = i);
    }
    addSkin(e) {
      for (let s = 0; s < e.bones.length; s++) {
        let n = e.bones[s],
          a = !1;
        for (let o = 0; o < this.bones.length; o++)
          if (this.bones[o] == n) {
            a = !0;
            break;
          }
        a || this.bones.push(n);
      }
      for (let s = 0; s < e.constraints.length; s++) {
        let n = e.constraints[s],
          a = !1;
        for (let o = 0; o < this.constraints.length; o++)
          if (this.constraints[o] == n) {
            a = !0;
            break;
          }
        a || this.constraints.push(n);
      }
      let t = e.getAttachments();
      for (let s = 0; s < t.length; s++) {
        var i = t[s];
        this.setAttachment(i.slotIndex, i.name, i.attachment);
      }
    }
    copySkin(e) {
      for (let s = 0; s < e.bones.length; s++) {
        let n = e.bones[s],
          a = !1;
        for (let o = 0; o < this.bones.length; o++)
          if (this.bones[o] == n) {
            a = !0;
            break;
          }
        a || this.bones.push(n);
      }
      for (let s = 0; s < e.constraints.length; s++) {
        let n = e.constraints[s],
          a = !1;
        for (let o = 0; o < this.constraints.length; o++)
          if (this.constraints[o] == n) {
            a = !0;
            break;
          }
        a || this.constraints.push(n);
      }
      let t = e.getAttachments();
      for (let s = 0; s < t.length; s++) {
        var i = t[s];
        i.attachment &&
          (i.attachment instanceof Nn
            ? ((i.attachment = i.attachment.newLinkedMesh()),
              this.setAttachment(i.slotIndex, i.name, i.attachment))
            : ((i.attachment = i.attachment.copy()),
              this.setAttachment(i.slotIndex, i.name, i.attachment)));
      }
    }
    getAttachment(e, t) {
      let i = this.attachments[e];
      return i ? i[t] : null;
    }
    removeAttachment(e, t) {
      let i = this.attachments[e];
      i && delete i[t];
    }
    getAttachments() {
      let e = new Array();
      for (var t = 0; t < this.attachments.length; t++) {
        let i = this.attachments[t];
        if (i)
          for (let s in i) {
            let n = i[s];
            n && e.push(new uy(t, s, n));
          }
      }
      return e;
    }
    getAttachmentsForSlot(e, t) {
      let i = this.attachments[e];
      if (i)
        for (let s in i) {
          let n = i[s];
          n && t.push(new uy(e, s, n));
        }
    }
    clear() {
      (this.attachments.length = 0),
        (this.bones.length = 0),
        (this.constraints.length = 0);
    }
    attachAll(e, t) {
      let i = 0;
      for (let s = 0; s < e.slots.length; s++) {
        let n = e.slots[s],
          a = n.getAttachment();
        if (a && i < t.attachments.length) {
          let o = t.attachments[i];
          for (let l in o) {
            let h = o[l];
            if (a == h) {
              let c = this.getAttachment(i, l);
              c && n.setAttachment(c);
              break;
            }
          }
        }
        i++;
      }
    }
  }
  class Mw {
    constructor(e, t, i) {
      T(this, "index", 0);
      T(this, "name");
      T(this, "boneData");
      T(this, "color", new Ve(1, 1, 1, 1));
      T(this, "darkColor", null);
      T(this, "attachmentName", null);
      T(this, "blendMode", Xs.Normal);
      T(this, "visible", !0);
      if (e < 0) throw new Error("index must be >= 0.");
      if (!t) throw new Error("name cannot be null.");
      if (!i) throw new Error("boneData cannot be null.");
      (this.index = e), (this.name = t), (this.boneData = i);
    }
  }
  var Xs;
  (function (r) {
    (r[(r.Normal = 0)] = "Normal"),
      (r[(r.Additive = 1)] = "Additive"),
      (r[(r.Multiply = 2)] = "Multiply"),
      (r[(r.Screen = 3)] = "Screen");
  })(Xs || (Xs = {}));
  class Fw extends Yc {
    constructor(t) {
      super(t, 0, !1);
      T(this, "bones", new Array());
      T(this, "_target", null);
      T(this, "mixRotate", 0);
      T(this, "mixX", 0);
      T(this, "mixY", 0);
      T(this, "mixScaleX", 0);
      T(this, "mixScaleY", 0);
      T(this, "mixShearY", 0);
      T(this, "offsetRotation", 0);
      T(this, "offsetX", 0);
      T(this, "offsetY", 0);
      T(this, "offsetScaleX", 0);
      T(this, "offsetScaleY", 0);
      T(this, "offsetShearY", 0);
      T(this, "relative", !1);
      T(this, "local", !1);
    }
    set target(t) {
      this._target = t;
    }
    get target() {
      if (this._target) return this._target;
      throw new Error("BoneData not set.");
    }
  }
  class O5 {
    constructor(e) {
      T(this, "scale", 1);
      T(this, "attachmentLoader");
      T(this, "linkedMeshes", new Array());
      this.attachmentLoader = e;
    }
    readSkeletonData(e) {
      let t = this.scale,
        i = new Rw();
      i.name = "";
      let s = new k5(e),
        n = s.readInt32(),
        a = s.readInt32();
      (i.hash = a == 0 && n == 0 ? null : a.toString(16) + n.toString(16)),
        (i.version = s.readString()),
        (i.x = s.readFloat()),
        (i.y = s.readFloat()),
        (i.width = s.readFloat()),
        (i.height = s.readFloat()),
        (i.referenceScale = s.readFloat() * t);
      let o = s.readBoolean();
      o &&
        ((i.fps = s.readFloat()),
        (i.imagesPath = s.readString()),
        (i.audioPath = s.readString()));
      let l = 0;
      l = s.readInt(!0);
      for (let c = 0; c < l; c++) {
        let u = s.readString();
        if (!u) throw new Error("String in string table must not be null.");
        s.strings.push(u);
      }
      l = s.readInt(!0);
      for (let c = 0; c < l; c++) {
        let u = s.readString();
        if (!u) throw new Error("Bone name must not be null.");
        let d = c == 0 ? null : i.bones[s.readInt(!0)],
          f = new Ew(c, u, d);
        (f.rotation = s.readFloat()),
          (f.x = s.readFloat() * t),
          (f.y = s.readFloat() * t),
          (f.scaleX = s.readFloat()),
          (f.scaleY = s.readFloat()),
          (f.shearX = s.readFloat()),
          (f.shearY = s.readFloat()),
          (f.length = s.readFloat() * t),
          (f.inherit = s.readByte()),
          (f.skinRequired = s.readBoolean()),
          o &&
            (Ve.rgba8888ToColor(f.color, s.readInt32()),
            (f.icon = s.readString() ?? void 0),
            (f.visible = s.readBoolean())),
          i.bones.push(f);
      }
      l = s.readInt(!0);
      for (let c = 0; c < l; c++) {
        let u = s.readString();
        if (!u) throw new Error("Slot name must not be null.");
        let d = i.bones[s.readInt(!0)],
          f = new Mw(c, u, d);
        Ve.rgba8888ToColor(f.color, s.readInt32());
        let p = s.readInt32();
        p != -1 && Ve.rgb888ToColor((f.darkColor = new Ve()), p),
          (f.attachmentName = s.readStringRef()),
          (f.blendMode = s.readInt(!0)),
          o && (f.visible = s.readBoolean()),
          i.slots.push(f);
      }
      l = s.readInt(!0);
      for (let c = 0, u; c < l; c++) {
        let d = s.readString();
        if (!d) throw new Error("IK constraint data name must not be null.");
        let f = new Cw(d);
        (f.order = s.readInt(!0)), (u = s.readInt(!0));
        for (let m = 0; m < u; m++) f.bones.push(i.bones[s.readInt(!0)]);
        f.target = i.bones[s.readInt(!0)];
        let p = s.readByte();
        (f.skinRequired = (p & 1) != 0),
          (f.bendDirection = p & 2 ? 1 : -1),
          (f.compress = (p & 4) != 0),
          (f.stretch = (p & 8) != 0),
          (f.uniform = (p & 16) != 0),
          p & 32 && (f.mix = p & 64 ? s.readFloat() : 1),
          p & 128 && (f.softness = s.readFloat() * t),
          i.ikConstraints.push(f);
      }
      l = s.readInt(!0);
      for (let c = 0, u; c < l; c++) {
        let d = s.readString();
        if (!d)
          throw new Error("Transform constraint data name must not be null.");
        let f = new Fw(d);
        (f.order = s.readInt(!0)), (u = s.readInt(!0));
        for (let m = 0; m < u; m++) f.bones.push(i.bones[s.readInt(!0)]);
        f.target = i.bones[s.readInt(!0)];
        let p = s.readByte();
        (f.skinRequired = (p & 1) != 0),
          (f.local = (p & 2) != 0),
          (f.relative = (p & 4) != 0),
          p & 8 && (f.offsetRotation = s.readFloat()),
          p & 16 && (f.offsetX = s.readFloat() * t),
          p & 32 && (f.offsetY = s.readFloat() * t),
          p & 64 && (f.offsetScaleX = s.readFloat()),
          p & 128 && (f.offsetScaleY = s.readFloat()),
          (p = s.readByte()),
          p & 1 && (f.offsetShearY = s.readFloat()),
          p & 2 && (f.mixRotate = s.readFloat()),
          p & 4 && (f.mixX = s.readFloat()),
          p & 8 && (f.mixY = s.readFloat()),
          p & 16 && (f.mixScaleX = s.readFloat()),
          p & 32 && (f.mixScaleY = s.readFloat()),
          p & 64 && (f.mixShearY = s.readFloat()),
          i.transformConstraints.push(f);
      }
      l = s.readInt(!0);
      for (let c = 0, u; c < l; c++) {
        let d = s.readString();
        if (!d) throw new Error("Path constraint data name must not be null.");
        let f = new Iw(d);
        (f.order = s.readInt(!0)),
          (f.skinRequired = s.readBoolean()),
          (u = s.readInt(!0));
        for (let m = 0; m < u; m++) f.bones.push(i.bones[s.readInt(!0)]);
        f.target = i.slots[s.readInt(!0)];
        const p = s.readByte();
        (f.positionMode = p & 1),
          (f.spacingMode = (p >> 1) & 3),
          (f.rotateMode = (p >> 3) & 3),
          p & 128 && (f.offsetRotation = s.readFloat()),
          (f.position = s.readFloat()),
          f.positionMode == Hi.Fixed && (f.position *= t),
          (f.spacing = s.readFloat()),
          (f.spacingMode == Nt.Length || f.spacingMode == Nt.Fixed) &&
            (f.spacing *= t),
          (f.mixRotate = s.readFloat()),
          (f.mixX = s.readFloat()),
          (f.mixY = s.readFloat()),
          i.pathConstraints.push(f);
      }
      l = s.readInt(!0);
      for (let c = 0, u; c < l; c++) {
        const d = s.readString();
        if (!d)
          throw new Error("Physics constraint data name must not be null.");
        const f = new Pw(d);
        (f.order = s.readInt(!0)), (f.bone = i.bones[s.readInt(!0)]);
        let p = s.readByte();
        (f.skinRequired = (p & 1) != 0),
          p & 2 && (f.x = s.readFloat()),
          p & 4 && (f.y = s.readFloat()),
          p & 8 && (f.rotate = s.readFloat()),
          p & 16 && (f.scaleX = s.readFloat()),
          p & 32 && (f.shearX = s.readFloat()),
          (f.limit = (p & 64 ? s.readFloat() : 5e3) * t),
          (f.step = 1 / s.readUnsignedByte()),
          (f.inertia = s.readFloat()),
          (f.strength = s.readFloat()),
          (f.damping = s.readFloat()),
          (f.massInverse = p & 128 ? s.readFloat() : 1),
          (f.wind = s.readFloat()),
          (f.gravity = s.readFloat()),
          (p = s.readByte()),
          p & 1 && (f.inertiaGlobal = !0),
          p & 2 && (f.strengthGlobal = !0),
          p & 4 && (f.dampingGlobal = !0),
          p & 8 && (f.massGlobal = !0),
          p & 16 && (f.windGlobal = !0),
          p & 32 && (f.gravityGlobal = !0),
          p & 64 && (f.mixGlobal = !0),
          (f.mix = p & 128 ? s.readFloat() : 1),
          i.physicsConstraints.push(f);
      }
      let h = this.readSkin(s, i, !0, o);
      h && ((i.defaultSkin = h), i.skins.push(h));
      {
        let c = i.skins.length;
        for (pe.setArraySize(i.skins, (l = c + s.readInt(!0))); c < l; c++) {
          let u = this.readSkin(s, i, !1, o);
          if (!u) throw new Error("readSkin() should not have returned null.");
          i.skins[c] = u;
        }
      }
      l = this.linkedMeshes.length;
      for (let c = 0; c < l; c++) {
        let u = this.linkedMeshes[c];
        const d = i.skins[u.skinIndex];
        if (!u.parent) throw new Error("Linked mesh parent must not be null");
        let f = d.getAttachment(u.slotIndex, u.parent);
        if (!f) throw new Error(`Parent mesh not found: ${u.parent}`);
        (u.mesh.timelineAttachment = u.inheritTimeline ? f : u.mesh),
          u.mesh.setParentMesh(f),
          u.mesh.region != null && u.mesh.updateRegion();
      }
      (this.linkedMeshes.length = 0), (l = s.readInt(!0));
      for (let c = 0; c < l; c++) {
        let u = s.readString();
        if (!u) throw new Error("Event data name must not be null");
        let d = new Aw(u);
        (d.intValue = s.readInt(!1)),
          (d.floatValue = s.readFloat()),
          (d.stringValue = s.readString()),
          (d.audioPath = s.readString()),
          d.audioPath &&
            ((d.volume = s.readFloat()), (d.balance = s.readFloat())),
          i.events.push(d);
      }
      l = s.readInt(!0);
      for (let c = 0; c < l; c++) {
        let u = s.readString();
        if (!u) throw new Error("Animatio name must not be null.");
        i.animations.push(this.readAnimation(s, u, i));
      }
      return i;
    }
    readSkin(e, t, i, s) {
      let n = null,
        a = 0;
      if (i) {
        if (((a = e.readInt(!0)), a == 0)) return null;
        n = new Vf("default");
      } else {
        let o = e.readString();
        if (!o) throw new Error("Skin name must not be null.");
        (n = new Vf(o)),
          s && Ve.rgba8888ToColor(n.color, e.readInt32()),
          (n.bones.length = e.readInt(!0));
        for (let l = 0, h = n.bones.length; l < h; l++)
          n.bones[l] = t.bones[e.readInt(!0)];
        for (let l = 0, h = e.readInt(!0); l < h; l++)
          n.constraints.push(t.ikConstraints[e.readInt(!0)]);
        for (let l = 0, h = e.readInt(!0); l < h; l++)
          n.constraints.push(t.transformConstraints[e.readInt(!0)]);
        for (let l = 0, h = e.readInt(!0); l < h; l++)
          n.constraints.push(t.pathConstraints[e.readInt(!0)]);
        for (let l = 0, h = e.readInt(!0); l < h; l++)
          n.constraints.push(t.physicsConstraints[e.readInt(!0)]);
        a = e.readInt(!0);
      }
      for (let o = 0; o < a; o++) {
        let l = e.readInt(!0);
        for (let h = 0, c = e.readInt(!0); h < c; h++) {
          let u = e.readStringRef();
          if (!u) throw new Error("Attachment name must not be null");
          let d = this.readAttachment(e, t, n, l, u, s);
          d && n.setAttachment(l, u, d);
        }
      }
      return n;
    }
    readAttachment(e, t, i, s, n, a) {
      let o = this.scale,
        l = e.readByte();
      const h = l & 8 ? e.readStringRef() : n;
      if (!h) throw new Error("Attachment name must not be null");
      switch (l & 7) {
        case is.Region: {
          let c = l & 16 ? e.readStringRef() : null;
          const u = l & 32 ? e.readInt32() : 4294967295,
            d = l & 64 ? this.readSequence(e) : null;
          let f = l & 128 ? e.readFloat() : 0,
            p = e.readFloat(),
            m = e.readFloat(),
            v = e.readFloat(),
            g = e.readFloat(),
            x = e.readFloat(),
            b = e.readFloat();
          c || (c = h);
          let y = this.attachmentLoader.newRegionAttachment(i, h, c, d);
          return y
            ? ((y.path = c),
              (y.x = p * o),
              (y.y = m * o),
              (y.scaleX = v),
              (y.scaleY = g),
              (y.rotation = f),
              (y.width = x * o),
              (y.height = b * o),
              Ve.rgba8888ToColor(y.color, u),
              (y.sequence = d),
              d == null && y.updateRegion(),
              y)
            : null;
        }
        case is.BoundingBox: {
          let c = this.readVertices(e, (l & 16) != 0),
            u = a ? e.readInt32() : 0,
            d = this.attachmentLoader.newBoundingBoxAttachment(i, h);
          return d
            ? ((d.worldVerticesLength = c.length),
              (d.vertices = c.vertices),
              (d.bones = c.bones),
              a && Ve.rgba8888ToColor(d.color, u),
              d)
            : null;
        }
        case is.Mesh: {
          let c = l & 16 ? e.readStringRef() : h;
          const u = l & 32 ? e.readInt32() : 4294967295,
            d = l & 64 ? this.readSequence(e) : null,
            f = e.readInt(!0),
            p = this.readVertices(e, (l & 128) != 0),
            m = this.readFloatArray(e, p.length, 1),
            v = this.readShortArray(e, (p.length - f - 2) * 3);
          let g = [],
            x = 0,
            b = 0;
          a &&
            ((g = this.readShortArray(e, e.readInt(!0))),
            (x = e.readFloat()),
            (b = e.readFloat())),
            c || (c = h);
          let y = this.attachmentLoader.newMeshAttachment(i, h, c, d);
          return y
            ? ((y.path = c),
              Ve.rgba8888ToColor(y.color, u),
              (y.bones = p.bones),
              (y.vertices = p.vertices),
              (y.worldVerticesLength = p.length),
              (y.triangles = v),
              (y.regionUVs = m),
              d == null && y.updateRegion(),
              (y.hullLength = f << 1),
              (y.sequence = d),
              a && ((y.edges = g), (y.width = x * o), (y.height = b * o)),
              y)
            : null;
        }
        case is.LinkedMesh: {
          const c = l & 16 ? e.readStringRef() : h;
          if (c == null)
            throw new Error("Path of linked mesh must not be null");
          const u = l & 32 ? e.readInt32() : 4294967295,
            d = l & 64 ? this.readSequence(e) : null,
            f = (l & 128) != 0,
            p = e.readInt(!0),
            m = e.readStringRef();
          let v = 0,
            g = 0;
          a && ((v = e.readFloat()), (g = e.readFloat()));
          let x = this.attachmentLoader.newMeshAttachment(i, h, c, d);
          return x
            ? ((x.path = c),
              Ve.rgba8888ToColor(x.color, u),
              (x.sequence = d),
              a && ((x.width = v * o), (x.height = g * o)),
              this.linkedMeshes.push(new D5(x, p, s, m, f)),
              x)
            : null;
        }
        case is.Path: {
          const c = (l & 16) != 0,
            u = (l & 32) != 0,
            d = this.readVertices(e, (l & 64) != 0),
            f = pe.newArray(d.length / 6, 0);
          for (let v = 0, g = f.length; v < g; v++) f[v] = e.readFloat() * o;
          const p = a ? e.readInt32() : 0,
            m = this.attachmentLoader.newPathAttachment(i, h);
          return m
            ? ((m.closed = c),
              (m.constantSpeed = u),
              (m.worldVerticesLength = d.length),
              (m.vertices = d.vertices),
              (m.bones = d.bones),
              (m.lengths = f),
              a && Ve.rgba8888ToColor(m.color, p),
              m)
            : null;
        }
        case is.Point: {
          const c = e.readFloat(),
            u = e.readFloat(),
            d = e.readFloat(),
            f = a ? e.readInt32() : 0,
            p = this.attachmentLoader.newPointAttachment(i, h);
          return p
            ? ((p.x = u * o),
              (p.y = d * o),
              (p.rotation = c),
              a && Ve.rgba8888ToColor(p.color, f),
              p)
            : null;
        }
        case is.Clipping: {
          const c = e.readInt(!0),
            u = this.readVertices(e, (l & 16) != 0);
          let d = a ? e.readInt32() : 0,
            f = this.attachmentLoader.newClippingAttachment(i, h);
          return f
            ? ((f.endSlot = t.slots[c]),
              (f.worldVerticesLength = u.length),
              (f.vertices = u.vertices),
              (f.bones = u.bones),
              a && Ve.rgba8888ToColor(f.color, d),
              f)
            : null;
        }
      }
      return null;
    }
    readSequence(e) {
      let t = new nc(e.readInt(!0));
      return (
        (t.start = e.readInt(!0)),
        (t.digits = e.readInt(!0)),
        (t.setupIndex = e.readInt(!0)),
        t
      );
    }
    readVertices(e, t) {
      const i = this.scale,
        s = e.readInt(!0),
        n = new L5();
      if (((n.length = s << 1), !t))
        return (n.vertices = this.readFloatArray(e, n.length, i)), n;
      let a = new Array(),
        o = new Array();
      for (let l = 0; l < s; l++) {
        let h = e.readInt(!0);
        o.push(h);
        for (let c = 0; c < h; c++)
          o.push(e.readInt(!0)),
            a.push(e.readFloat() * i),
            a.push(e.readFloat() * i),
            a.push(e.readFloat());
      }
      return (n.vertices = pe.toFloatArray(a)), (n.bones = o), n;
    }
    readFloatArray(e, t, i) {
      let s = new Array(t);
      if (i == 1) for (let n = 0; n < t; n++) s[n] = e.readFloat();
      else for (let n = 0; n < t; n++) s[n] = e.readFloat() * i;
      return s;
    }
    readShortArray(e, t) {
      let i = new Array(t);
      for (let s = 0; s < t; s++) i[s] = e.readInt(!0);
      return i;
    }
    readAnimation(e, t, i) {
      e.readInt(!0);
      let s = new Array(),
        n = this.scale;
      for (let h = 0, c = e.readInt(!0); h < c; h++) {
        let u = e.readInt(!0);
        for (let d = 0, f = e.readInt(!0); d < f; d++) {
          let p = e.readByte(),
            m = e.readInt(!0),
            v = m - 1;
          switch (p) {
            case q5: {
              let g = new ua(m, u);
              for (let x = 0; x < m; x++)
                g.setFrame(x, e.readFloat(), e.readStringRef());
              s.push(g);
              break;
            }
            case K5: {
              let g = e.readInt(!0),
                x = new nw(m, g, u),
                b = e.readFloat(),
                y = e.readUnsignedByte() / 255,
                _ = e.readUnsignedByte() / 255,
                w = e.readUnsignedByte() / 255,
                E = e.readUnsignedByte() / 255;
              for (
                let A = 0, C = 0;
                x.setFrame(A, b, y, _, w, E), A != v;
                A++
              ) {
                let F = e.readFloat(),
                  B = e.readUnsignedByte() / 255,
                  R = e.readUnsignedByte() / 255,
                  I = e.readUnsignedByte() / 255,
                  P = e.readUnsignedByte() / 255;
                switch (e.readByte()) {
                  case Ri:
                    x.setStepped(A);
                    break;
                  case Mi:
                    je(e, x, C++, A, 0, b, F, y, B, 1),
                      je(e, x, C++, A, 1, b, F, _, R, 1),
                      je(e, x, C++, A, 2, b, F, w, I, 1),
                      je(e, x, C++, A, 3, b, F, E, P, 1);
                }
                (b = F), (y = B), (_ = R), (w = I), (E = P);
              }
              s.push(x);
              break;
            }
            case Z5: {
              let g = e.readInt(!0),
                x = new aw(m, g, u),
                b = e.readFloat(),
                y = e.readUnsignedByte() / 255,
                _ = e.readUnsignedByte() / 255,
                w = e.readUnsignedByte() / 255;
              for (let E = 0, A = 0; x.setFrame(E, b, y, _, w), E != v; E++) {
                let C = e.readFloat(),
                  F = e.readUnsignedByte() / 255,
                  B = e.readUnsignedByte() / 255,
                  R = e.readUnsignedByte() / 255;
                switch (e.readByte()) {
                  case Ri:
                    x.setStepped(E);
                    break;
                  case Mi:
                    je(e, x, A++, E, 0, b, C, y, F, 1),
                      je(e, x, A++, E, 1, b, C, _, B, 1),
                      je(e, x, A++, E, 2, b, C, w, R, 1);
                }
                (b = C), (y = F), (_ = B), (w = R);
              }
              s.push(x);
              break;
            }
            case J5: {
              let g = e.readInt(!0),
                x = new lw(m, g, u),
                b = e.readFloat(),
                y = e.readUnsignedByte() / 255,
                _ = e.readUnsignedByte() / 255,
                w = e.readUnsignedByte() / 255,
                E = e.readUnsignedByte() / 255,
                A = e.readUnsignedByte() / 255,
                C = e.readUnsignedByte() / 255,
                F = e.readUnsignedByte() / 255;
              for (
                let B = 0, R = 0;
                x.setFrame(B, b, y, _, w, E, A, C, F), B != v;
                B++
              ) {
                let I = e.readFloat(),
                  P = e.readUnsignedByte() / 255,
                  M = e.readUnsignedByte() / 255,
                  L = e.readUnsignedByte() / 255,
                  U = e.readUnsignedByte() / 255,
                  V = e.readUnsignedByte() / 255,
                  z = e.readUnsignedByte() / 255,
                  N = e.readUnsignedByte() / 255;
                switch (e.readByte()) {
                  case Ri:
                    x.setStepped(B);
                    break;
                  case Mi:
                    je(e, x, R++, B, 0, b, I, y, P, 1),
                      je(e, x, R++, B, 1, b, I, _, M, 1),
                      je(e, x, R++, B, 2, b, I, w, L, 1),
                      je(e, x, R++, B, 3, b, I, E, U, 1),
                      je(e, x, R++, B, 4, b, I, A, V, 1),
                      je(e, x, R++, B, 5, b, I, C, z, 1),
                      je(e, x, R++, B, 6, b, I, F, N, 1);
                }
                (b = I),
                  (y = P),
                  (_ = M),
                  (w = L),
                  (E = U),
                  (A = V),
                  (C = z),
                  (F = N);
              }
              s.push(x);
              break;
            }
            case Q5: {
              let g = e.readInt(!0),
                x = new hw(m, g, u),
                b = e.readFloat(),
                y = e.readUnsignedByte() / 255,
                _ = e.readUnsignedByte() / 255,
                w = e.readUnsignedByte() / 255,
                E = e.readUnsignedByte() / 255,
                A = e.readUnsignedByte() / 255,
                C = e.readUnsignedByte() / 255;
              for (
                let F = 0, B = 0;
                x.setFrame(F, b, y, _, w, E, A, C), F != v;
                F++
              ) {
                let R = e.readFloat(),
                  I = e.readUnsignedByte() / 255,
                  P = e.readUnsignedByte() / 255,
                  M = e.readUnsignedByte() / 255,
                  L = e.readUnsignedByte() / 255,
                  U = e.readUnsignedByte() / 255,
                  V = e.readUnsignedByte() / 255;
                switch (e.readByte()) {
                  case Ri:
                    x.setStepped(F);
                    break;
                  case Mi:
                    je(e, x, B++, F, 0, b, R, y, I, 1),
                      je(e, x, B++, F, 1, b, R, _, P, 1),
                      je(e, x, B++, F, 2, b, R, w, M, 1),
                      je(e, x, B++, F, 3, b, R, E, L, 1),
                      je(e, x, B++, F, 4, b, R, A, U, 1),
                      je(e, x, B++, F, 5, b, R, C, V, 1);
                }
                (b = R), (y = I), (_ = P), (w = M), (E = L), (A = U), (C = V);
              }
              s.push(x);
              break;
            }
            case eU: {
              let g = new ow(m, e.readInt(!0), u),
                x = e.readFloat(),
                b = e.readUnsignedByte() / 255;
              for (let y = 0, _ = 0; g.setFrame(y, x, b), y != v; y++) {
                let w = e.readFloat(),
                  E = e.readUnsignedByte() / 255;
                switch (e.readByte()) {
                  case Ri:
                    g.setStepped(y);
                    break;
                  case Mi:
                    je(e, g, _++, y, 0, x, w, b, E, 1);
                }
                (x = w), (b = E);
              }
              s.push(g);
            }
          }
        }
      }
      for (let h = 0, c = e.readInt(!0); h < c; h++) {
        let u = e.readInt(!0);
        for (let d = 0, f = e.readInt(!0); d < f; d++) {
          let p = e.readByte(),
            m = e.readInt(!0);
          if (p == j5) {
            let g = new sw(m, u);
            for (let x = 0; x < m; x++)
              g.setFrame(x, e.readFloat(), e.readByte());
            s.push(g);
            continue;
          }
          let v = e.readInt(!0);
          switch (p) {
            case N5:
              s.push(tr(e, new ac(m, v, u), 1));
              break;
            case U5:
              s.push(hd(e, new q_(m, v, u), n));
              break;
            case V5:
              s.push(tr(e, new K_(m, v, u), n));
              break;
            case $5:
              s.push(tr(e, new Z_(m, v, u), n));
              break;
            case G5:
              s.push(hd(e, new J_(m, v, u), 1));
              break;
            case H5:
              s.push(tr(e, new Q_(m, v, u), 1));
              break;
            case X5:
              s.push(tr(e, new ew(m, v, u), 1));
              break;
            case z5:
              s.push(hd(e, new tw(m, v, u), 1));
              break;
            case W5:
              s.push(tr(e, new rw(m, v, u), 1));
              break;
            case Y5:
              s.push(tr(e, new iw(m, v, u), 1));
          }
        }
      }
      for (let h = 0, c = e.readInt(!0); h < c; h++) {
        let u = e.readInt(!0),
          d = e.readInt(!0),
          f = d - 1,
          p = new uw(d, e.readInt(!0), u),
          m = e.readByte(),
          v = e.readFloat(),
          g = m & 1 ? (m & 2 ? e.readFloat() : 1) : 0,
          x = m & 4 ? e.readFloat() * n : 0;
        for (
          let b = 0, y = 0;
          p.setFrame(b, v, g, x, m & 8 ? 1 : -1, (m & 16) != 0, (m & 32) != 0),
            b != f;
          b++
        ) {
          m = e.readByte();
          const _ = e.readFloat(),
            w = m & 1 ? (m & 2 ? e.readFloat() : 1) : 0,
            E = m & 4 ? e.readFloat() * n : 0;
          m & 64
            ? p.setStepped(b)
            : m & 128 &&
              (je(e, p, y++, b, 0, v, _, g, w, 1),
              je(e, p, y++, b, 1, v, _, x, E, n)),
            (v = _),
            (g = w),
            (x = E);
        }
        s.push(p);
      }
      for (let h = 0, c = e.readInt(!0); h < c; h++) {
        let u = e.readInt(!0),
          d = e.readInt(!0),
          f = d - 1,
          p = new dw(d, e.readInt(!0), u),
          m = e.readFloat(),
          v = e.readFloat(),
          g = e.readFloat(),
          x = e.readFloat(),
          b = e.readFloat(),
          y = e.readFloat(),
          _ = e.readFloat();
        for (
          let w = 0, E = 0;
          p.setFrame(w, m, v, g, x, b, y, _), w != f;
          w++
        ) {
          let A = e.readFloat(),
            C = e.readFloat(),
            F = e.readFloat(),
            B = e.readFloat(),
            R = e.readFloat(),
            I = e.readFloat(),
            P = e.readFloat();
          switch (e.readByte()) {
            case Ri:
              p.setStepped(w);
              break;
            case Mi:
              je(e, p, E++, w, 0, m, A, v, C, 1),
                je(e, p, E++, w, 1, m, A, g, F, 1),
                je(e, p, E++, w, 2, m, A, x, B, 1),
                je(e, p, E++, w, 3, m, A, b, R, 1),
                je(e, p, E++, w, 4, m, A, y, I, 1),
                je(e, p, E++, w, 5, m, A, _, P, 1);
          }
          (m = A), (v = C), (g = F), (x = B), (b = R), (y = I), (_ = P);
        }
        s.push(p);
      }
      for (let h = 0, c = e.readInt(!0); h < c; h++) {
        let u = e.readInt(!0),
          d = i.pathConstraints[u];
        for (let f = 0, p = e.readInt(!0); f < p; f++) {
          const m = e.readByte(),
            v = e.readInt(!0),
            g = e.readInt(!0);
          switch (m) {
            case iU:
              s.push(
                tr(e, new fw(v, g, u), d.positionMode == Hi.Fixed ? n : 1)
              );
              break;
            case sU:
              s.push(
                tr(
                  e,
                  new pw(v, g, u),
                  d.spacingMode == Nt.Length || d.spacingMode == Nt.Fixed
                    ? n
                    : 1
                )
              );
              break;
            case nU:
              let x = new mw(v, g, u),
                b = e.readFloat(),
                y = e.readFloat(),
                _ = e.readFloat(),
                w = e.readFloat();
              for (
                let E = 0, A = 0, C = x.getFrameCount() - 1;
                x.setFrame(E, b, y, _, w), E != C;
                E++
              ) {
                let F = e.readFloat(),
                  B = e.readFloat(),
                  R = e.readFloat(),
                  I = e.readFloat();
                switch (e.readByte()) {
                  case Ri:
                    x.setStepped(E);
                    break;
                  case Mi:
                    je(e, x, A++, E, 0, b, F, y, B, 1),
                      je(e, x, A++, E, 1, b, F, _, R, 1),
                      je(e, x, A++, E, 2, b, F, w, I, 1);
                }
                (b = F), (y = B), (_ = R), (w = I);
              }
              s.push(x);
          }
        }
      }
      for (let h = 0, c = e.readInt(!0); h < c; h++) {
        const u = e.readInt(!0) - 1;
        for (let d = 0, f = e.readInt(!0); d < f; d++) {
          const p = e.readByte(),
            m = e.readInt(!0);
          if (p == fU) {
            const g = new oc(m, u);
            for (let x = 0; x < m; x++) g.setFrame(x, e.readFloat());
            s.push(g);
            continue;
          }
          const v = e.readInt(!0);
          switch (p) {
            case aU:
              s.push(tr(e, new gw(m, v, u), 1));
              break;
            case oU:
              s.push(tr(e, new vw(m, v, u), 1));
              break;
            case lU:
              s.push(tr(e, new yw(m, v, u), 1));
              break;
            case hU:
              s.push(tr(e, new bw(m, v, u), 1));
              break;
            case cU:
              s.push(tr(e, new xw(m, v, u), 1));
              break;
            case uU:
              s.push(tr(e, new _w(m, v, u), 1));
              break;
            case dU:
              s.push(tr(e, new ww(m, v, u), 1));
          }
        }
      }
      for (let h = 0, c = e.readInt(!0); h < c; h++) {
        let u = i.skins[e.readInt(!0)];
        for (let d = 0, f = e.readInt(!0); d < f; d++) {
          let p = e.readInt(!0);
          for (let m = 0, v = e.readInt(!0); m < v; m++) {
            let g = e.readStringRef();
            if (!g) throw new Error("attachmentName must not be null.");
            let x = u.getAttachment(p, g),
              b = e.readByte(),
              y = e.readInt(!0),
              _ = y - 1;
            switch (b) {
              case tU: {
                let w = x,
                  E = w.bones,
                  A = w.vertices,
                  C = E ? (A.length / 3) * 2 : A.length,
                  F = e.readInt(!0),
                  B = new cw(y, F, p, w),
                  R = e.readFloat();
                for (let I = 0, P = 0; ; I++) {
                  let M,
                    L = e.readInt(!0);
                  if (L == 0) M = E ? pe.newFloatArray(C) : A;
                  else {
                    M = pe.newFloatArray(C);
                    let V = e.readInt(!0);
                    if (((L += V), n == 1))
                      for (let z = V; z < L; z++) M[z] = e.readFloat();
                    else for (let z = V; z < L; z++) M[z] = e.readFloat() * n;
                    if (!E)
                      for (let z = 0, N = M.length; z < N; z++) M[z] += A[z];
                  }
                  if ((B.setFrame(I, R, M), I == _)) break;
                  let U = e.readFloat();
                  switch (e.readByte()) {
                    case Ri:
                      B.setStepped(I);
                      break;
                    case Mi:
                      je(e, B, P++, I, 0, R, U, 0, 1, 1);
                  }
                  R = U;
                }
                s.push(B);
                break;
              }
              case rU: {
                let w = new lc(y, p, x);
                for (let E = 0; E < y; E++) {
                  let A = e.readFloat(),
                    C = e.readInt32();
                  w.setFrame(E, A, j_[C & 15], C >> 4, e.readFloat());
                }
                s.push(w);
                break;
              }
            }
          }
        }
      }
      let a = e.readInt(!0);
      if (a > 0) {
        let h = new Cn(a),
          c = i.slots.length;
        for (let u = 0; u < a; u++) {
          let d = e.readFloat(),
            f = e.readInt(!0),
            p = pe.newArray(c, 0);
          for (let x = c - 1; x >= 0; x--) p[x] = -1;
          let m = pe.newArray(c - f, 0),
            v = 0,
            g = 0;
          for (let x = 0; x < f; x++) {
            let b = e.readInt(!0);
            for (; v != b; ) m[g++] = v++;
            p[v + e.readInt(!0)] = v++;
          }
          for (; v < c; ) m[g++] = v++;
          for (let x = c - 1; x >= 0; x--) p[x] == -1 && (p[x] = m[--g]);
          h.setFrame(u, d, p);
        }
        s.push(h);
      }
      let o = e.readInt(!0);
      if (o > 0) {
        let h = new il(o);
        for (let c = 0; c < o; c++) {
          let u = e.readFloat(),
            d = i.events[e.readInt(!0)],
            f = new Sw(u, d);
          (f.intValue = e.readInt(!1)),
            (f.floatValue = e.readFloat()),
            (f.stringValue = e.readString()),
            f.stringValue == null && (f.stringValue = d.stringValue),
            f.data.audioPath &&
              ((f.volume = e.readFloat()), (f.balance = e.readFloat())),
            h.setFrame(c, f);
        }
        s.push(h);
      }
      let l = 0;
      for (let h = 0, c = s.length; h < c; h++)
        l = Math.max(l, s[h].getDuration());
      return new cm(t, s, l);
    }
  }
  class k5 {
    constructor(
      e,
      t = new Array(),
      i = 0,
      s = new DataView(e instanceof ArrayBuffer ? e : e.buffer)
    ) {
      T(this, "strings");
      T(this, "index");
      T(this, "buffer");
      (this.strings = t), (this.index = i), (this.buffer = s);
    }
    readByte() {
      return this.buffer.getInt8(this.index++);
    }
    readUnsignedByte() {
      return this.buffer.getUint8(this.index++);
    }
    readShort() {
      let e = this.buffer.getInt16(this.index);
      return (this.index += 2), e;
    }
    readInt32() {
      let e = this.buffer.getInt32(this.index);
      return (this.index += 4), e;
    }
    readInt(e) {
      let t = this.readByte(),
        i = t & 127;
      return (
        t & 128 &&
          ((t = this.readByte()),
          (i |= (t & 127) << 7),
          t & 128 &&
            ((t = this.readByte()),
            (i |= (t & 127) << 14),
            t & 128 &&
              ((t = this.readByte()),
              (i |= (t & 127) << 21),
              t & 128 && ((t = this.readByte()), (i |= (t & 127) << 28))))),
        e ? i : (i >>> 1) ^ -(i & 1)
      );
    }
    readStringRef() {
      let e = this.readInt(!0);
      return e == 0 ? null : this.strings[e - 1];
    }
    readString() {
      let e = this.readInt(!0);
      switch (e) {
        case 0:
          return null;
        case 1:
          return "";
      }
      e--;
      let t = "";
      for (let i = 0; i < e; ) {
        let s = this.readUnsignedByte();
        switch (s >> 4) {
          case 12:
          case 13:
            (t += String.fromCharCode(
              ((s & 31) << 6) | (this.readByte() & 63)
            )),
              (i += 2);
            break;
          case 14:
            (t += String.fromCharCode(
              ((s & 15) << 12) |
                ((this.readByte() & 63) << 6) |
                (this.readByte() & 63)
            )),
              (i += 3);
            break;
          default:
            (t += String.fromCharCode(s)), i++;
        }
      }
      return t;
    }
    readFloat() {
      let e = this.buffer.getFloat32(this.index);
      return (this.index += 4), e;
    }
    readBoolean() {
      return this.readByte() != 0;
    }
  }
  let D5 = class {
    constructor(e, t, i, s, n) {
      T(this, "parent");
      T(this, "skinIndex");
      T(this, "slotIndex");
      T(this, "mesh");
      T(this, "inheritTimeline");
      (this.mesh = e),
        (this.skinIndex = t),
        (this.slotIndex = i),
        (this.parent = s),
        (this.inheritTimeline = n);
    }
  };
  class L5 {
    constructor(e = null, t = null, i = 0) {
      T(this, "bones");
      T(this, "vertices");
      T(this, "length");
      (this.bones = e), (this.vertices = t), (this.length = i);
    }
  }
  var is;
  (function (r) {
    (r[(r.Region = 0)] = "Region"),
      (r[(r.BoundingBox = 1)] = "BoundingBox"),
      (r[(r.Mesh = 2)] = "Mesh"),
      (r[(r.LinkedMesh = 3)] = "LinkedMesh"),
      (r[(r.Path = 4)] = "Path"),
      (r[(r.Point = 5)] = "Point"),
      (r[(r.Clipping = 6)] = "Clipping");
  })(is || (is = {}));
  function tr(r, e, t) {
    let i = r.readFloat(),
      s = r.readFloat() * t;
    for (
      let n = 0, a = 0, o = e.getFrameCount() - 1;
      e.setFrame(n, i, s), n != o;
      n++
    ) {
      let l = r.readFloat(),
        h = r.readFloat() * t;
      switch (r.readByte()) {
        case Ri:
          e.setStepped(n);
          break;
        case Mi:
          je(r, e, a++, n, 0, i, l, s, h, t);
      }
      (i = l), (s = h);
    }
    return e;
  }
  function hd(r, e, t) {
    let i = r.readFloat(),
      s = r.readFloat() * t,
      n = r.readFloat() * t;
    for (
      let a = 0, o = 0, l = e.getFrameCount() - 1;
      e.setFrame(a, i, s, n), a != l;
      a++
    ) {
      let h = r.readFloat(),
        c = r.readFloat() * t,
        u = r.readFloat() * t;
      switch (r.readByte()) {
        case Ri:
          e.setStepped(a);
          break;
        case Mi:
          je(r, e, o++, a, 0, i, h, s, c, t),
            je(r, e, o++, a, 1, i, h, n, u, t);
      }
      (i = h), (s = c), (n = u);
    }
    return e;
  }
  function je(r, e, t, i, s, n, a, o, l, h) {
    e.setBezier(
      t,
      i,
      s,
      n,
      o,
      r.readFloat(),
      r.readFloat() * h,
      r.readFloat(),
      r.readFloat() * h,
      a,
      l
    );
  }
  const N5 = 0,
    U5 = 1,
    V5 = 2,
    $5 = 3,
    G5 = 4,
    H5 = 5,
    X5 = 6,
    z5 = 7,
    W5 = 8,
    Y5 = 9,
    j5 = 10,
    q5 = 0,
    K5 = 1,
    Z5 = 2,
    J5 = 3,
    Q5 = 4,
    eU = 5,
    tU = 0,
    rU = 1,
    iU = 0,
    sU = 1,
    nU = 2,
    aU = 0,
    oU = 1,
    lU = 2,
    hU = 4,
    cU = 5,
    uU = 6,
    dU = 7,
    fU = 8,
    Ri = 1,
    Mi = 2;
  class mr {
    constructor() {
      T(this, "convexPolygons", new Array());
      T(this, "convexPolygonsIndices", new Array());
      T(this, "indicesArray", new Array());
      T(this, "isConcaveArray", new Array());
      T(this, "triangles", new Array());
      T(this, "polygonPool", new Lf(() => new Array()));
      T(this, "polygonIndicesPool", new Lf(() => new Array()));
    }
    triangulate(e) {
      let t = e,
        i = e.length >> 1,
        s = this.indicesArray;
      s.length = 0;
      for (let o = 0; o < i; o++) s[o] = o;
      let n = this.isConcaveArray;
      n.length = 0;
      for (let o = 0, l = i; o < l; ++o) n[o] = mr.isConcave(o, i, t, s);
      let a = this.triangles;
      for (a.length = 0; i > 3; ) {
        let o = i - 1,
          l = 0,
          h = 1;
        for (;;) {
          e: if (!n[l]) {
            let d = s[o] << 1,
              f = s[l] << 1,
              p = s[h] << 1,
              m = t[d],
              v = t[d + 1],
              g = t[f],
              x = t[f + 1],
              b = t[p],
              y = t[p + 1];
            for (let _ = (h + 1) % i; _ != o; _ = (_ + 1) % i) {
              if (!n[_]) continue;
              let w = s[_] << 1,
                E = t[w],
                A = t[w + 1];
              if (
                mr.positiveArea(b, y, m, v, E, A) &&
                mr.positiveArea(m, v, g, x, E, A) &&
                mr.positiveArea(g, x, b, y, E, A)
              )
                break e;
            }
            break;
          }
          if (h == 0) {
            do {
              if (!n[l]) break;
              l--;
            } while (l > 0);
            break;
          }
          (o = l), (l = h), (h = (h + 1) % i);
        }
        a.push(s[(i + l - 1) % i]),
          a.push(s[l]),
          a.push(s[(l + 1) % i]),
          s.splice(l, 1),
          n.splice(l, 1),
          i--;
        let c = (i + l - 1) % i,
          u = l == i ? 0 : l;
        (n[c] = mr.isConcave(c, i, t, s)), (n[u] = mr.isConcave(u, i, t, s));
      }
      return i == 3 && (a.push(s[2]), a.push(s[0]), a.push(s[1])), a;
    }
    decompose(e, t) {
      let i = e,
        s = this.convexPolygons;
      this.polygonPool.freeAll(s), (s.length = 0);
      let n = this.convexPolygonsIndices;
      this.polygonIndicesPool.freeAll(n), (n.length = 0);
      let a = this.polygonIndicesPool.obtain();
      a.length = 0;
      let o = this.polygonPool.obtain();
      o.length = 0;
      let l = -1,
        h = 0;
      for (let c = 0, u = t.length; c < u; c += 3) {
        let d = t[c] << 1,
          f = t[c + 1] << 1,
          p = t[c + 2] << 1,
          m = i[d],
          v = i[d + 1],
          g = i[f],
          x = i[f + 1],
          b = i[p],
          y = i[p + 1],
          _ = !1;
        if (l == d) {
          let w = o.length - 4,
            E = mr.winding(o[w], o[w + 1], o[w + 2], o[w + 3], b, y),
            A = mr.winding(b, y, o[0], o[1], o[2], o[3]);
          E == h && A == h && (o.push(b), o.push(y), a.push(p), (_ = !0));
        }
        _ ||
          (o.length > 0
            ? (s.push(o), n.push(a))
            : (this.polygonPool.free(o), this.polygonIndicesPool.free(a)),
          (o = this.polygonPool.obtain()),
          (o.length = 0),
          o.push(m),
          o.push(v),
          o.push(g),
          o.push(x),
          o.push(b),
          o.push(y),
          (a = this.polygonIndicesPool.obtain()),
          (a.length = 0),
          a.push(d),
          a.push(f),
          a.push(p),
          (h = mr.winding(m, v, g, x, b, y)),
          (l = d));
      }
      o.length > 0 && (s.push(o), n.push(a));
      for (let c = 0, u = s.length; c < u; c++) {
        if (((a = n[c]), a.length == 0)) continue;
        let d = a[0],
          f = a[a.length - 1];
        o = s[c];
        let p = o.length - 4,
          m = o[p],
          v = o[p + 1],
          g = o[p + 2],
          x = o[p + 3],
          b = o[0],
          y = o[1],
          _ = o[2],
          w = o[3],
          E = mr.winding(m, v, g, x, b, y);
        for (let A = 0; A < u; A++) {
          if (A == c) continue;
          let C = n[A];
          if (C.length != 3) continue;
          let F = C[0],
            B = C[1],
            R = C[2],
            I = s[A],
            P = I[I.length - 2],
            M = I[I.length - 1];
          if (F != d || B != f) continue;
          let L = mr.winding(m, v, g, x, P, M),
            U = mr.winding(P, M, b, y, _, w);
          L == E &&
            U == E &&
            ((I.length = 0),
            (C.length = 0),
            o.push(P),
            o.push(M),
            a.push(R),
            (m = g),
            (v = x),
            (g = P),
            (x = M),
            (A = 0));
        }
      }
      for (let c = s.length - 1; c >= 0; c--)
        (o = s[c]),
          o.length == 0 &&
            (s.splice(c, 1),
            this.polygonPool.free(o),
            (a = n[c]),
            n.splice(c, 1),
            this.polygonIndicesPool.free(a));
      return s;
    }
    static isConcave(e, t, i, s) {
      let n = s[(t + e - 1) % t] << 1,
        a = s[e] << 1,
        o = s[(e + 1) % t] << 1;
      return !this.positiveArea(i[n], i[n + 1], i[a], i[a + 1], i[o], i[o + 1]);
    }
    static positiveArea(e, t, i, s, n, a) {
      return e * (a - s) + i * (t - a) + n * (s - t) >= 0;
    }
    static winding(e, t, i, s, n, a) {
      let o = i - e,
        l = s - t;
      return n * l - a * o + o * t - e * l >= 0 ? 1 : -1;
    }
  }
  class hc {
    constructor() {
      T(this, "triangulator", new mr());
      T(this, "clippingPolygon", new Array());
      T(this, "clipOutput", new Array());
      T(this, "clippedVertices", new Array());
      T(this, "clippedUVs", new Array());
      T(this, "clippedTriangles", new Array());
      T(this, "scratch", new Array());
      T(this, "clipAttachment", null);
      T(this, "clippingPolygons", null);
    }
    clipStart(e, t) {
      if (this.clipAttachment) return 0;
      this.clipAttachment = t;
      let i = t.worldVerticesLength,
        s = pe.setArraySize(this.clippingPolygon, i);
      t.computeWorldVertices(e, 0, i, s, 0, 2);
      let n = this.clippingPolygon;
      hc.makeClockwise(n);
      let a = (this.clippingPolygons = this.triangulator.decompose(
        n,
        this.triangulator.triangulate(n)
      ));
      for (let o = 0, l = a.length; o < l; o++) {
        let h = a[o];
        hc.makeClockwise(h), h.push(h[0]), h.push(h[1]);
      }
      return a.length;
    }
    clipEndWithSlot(e) {
      this.clipAttachment &&
        this.clipAttachment.endSlot == e.data &&
        this.clipEnd();
    }
    clipEnd() {
      this.clipAttachment &&
        ((this.clipAttachment = null),
        (this.clippingPolygons = null),
        (this.clippedVertices.length = 0),
        (this.clippedTriangles.length = 0),
        (this.clippingPolygon.length = 0));
    }
    isClipping() {
      return this.clipAttachment != null;
    }
    clipTriangles(e, t, i, s, n, a, o, l) {
      let h, c, u, d, f, p;
      typeof t == "number"
        ? ((h = i), (c = s), (u = n), (d = a), (f = o), (p = l))
        : ((h = t), (c = i), (u = s), (d = n), (f = a), (p = o)),
        u && d && f && typeof p == "boolean"
          ? this.clipTrianglesRender(e, h, c, u, d, f, p)
          : this.clipTrianglesNoRender(e, h, c);
    }
    clipTrianglesNoRender(e, t, i) {
      let s = this.clipOutput,
        n = this.clippedVertices,
        a = this.clippedTriangles,
        o = this.clippingPolygons,
        l = o.length,
        h = 0;
      (n.length = 0), (a.length = 0);
      for (let c = 0; c < i; c += 3) {
        let u = t[c] << 1,
          d = e[u],
          f = e[u + 1];
        u = t[c + 1] << 1;
        let p = e[u],
          m = e[u + 1];
        u = t[c + 2] << 1;
        let v = e[u],
          g = e[u + 1];
        for (let x = 0; x < l; x++) {
          let b = n.length;
          if (this.clip(d, f, p, m, v, g, o[x], s)) {
            let y = s.length;
            if (y == 0) continue;
            let _ = y >> 1,
              w = this.clipOutput,
              E = pe.setArraySize(n, b + _ * 2);
            for (let C = 0; C < y; C += 2, b += 2) {
              let F = w[C],
                B = w[C + 1];
              (E[b] = F), (E[b + 1] = B);
            }
            b = a.length;
            let A = pe.setArraySize(a, b + 3 * (_ - 2));
            _--;
            for (let C = 1; C < _; C++, b += 3)
              (A[b] = h), (A[b + 1] = h + C), (A[b + 2] = h + C + 1);
            h += _ + 1;
          } else {
            let y = pe.setArraySize(n, b + 6);
            (y[b] = d),
              (y[b + 1] = f),
              (y[b + 2] = p),
              (y[b + 3] = m),
              (y[b + 4] = v),
              (y[b + 5] = g),
              (b = a.length);
            let _ = pe.setArraySize(a, b + 3);
            (_[b] = h), (_[b + 1] = h + 1), (_[b + 2] = h + 2), (h += 3);
            break;
          }
        }
      }
    }
    clipTrianglesRender(e, t, i, s, n, a, o) {
      let l = this.clipOutput,
        h = this.clippedVertices,
        c = this.clippedTriangles,
        u = this.clippingPolygons,
        d = u.length,
        f = o ? 12 : 8,
        p = 0;
      (h.length = 0), (c.length = 0);
      for (let m = 0; m < i; m += 3) {
        let v = t[m] << 1,
          g = e[v],
          x = e[v + 1],
          b = s[v],
          y = s[v + 1];
        v = t[m + 1] << 1;
        let _ = e[v],
          w = e[v + 1],
          E = s[v],
          A = s[v + 1];
        v = t[m + 2] << 1;
        let C = e[v],
          F = e[v + 1],
          B = s[v],
          R = s[v + 1];
        for (let I = 0; I < d; I++) {
          let P = h.length;
          if (this.clip(g, x, _, w, C, F, u[I], l)) {
            let M = l.length;
            if (M == 0) continue;
            let L = w - F,
              U = C - _,
              V = g - C,
              z = F - x,
              N = 1 / (L * V + U * (x - F)),
              O = M >> 1,
              H = this.clipOutput,
              G = pe.setArraySize(h, P + O * f);
            for (let K = 0; K < M; K += 2, P += f) {
              let ue = H[K],
                ie = H[K + 1];
              (G[P] = ue),
                (G[P + 1] = ie),
                (G[P + 2] = n.r),
                (G[P + 3] = n.g),
                (G[P + 4] = n.b),
                (G[P + 5] = n.a);
              let ee = ue - C,
                ve = ie - F,
                ye = (L * ee + U * ve) * N,
                _e = (z * ee + V * ve) * N,
                ke = 1 - ye - _e;
              (G[P + 6] = b * ye + E * _e + B * ke),
                (G[P + 7] = y * ye + A * _e + R * ke),
                o &&
                  ((G[P + 8] = a.r),
                  (G[P + 9] = a.g),
                  (G[P + 10] = a.b),
                  (G[P + 11] = a.a));
            }
            P = c.length;
            let q = pe.setArraySize(c, P + 3 * (O - 2));
            O--;
            for (let K = 1; K < O; K++, P += 3)
              (q[P] = p), (q[P + 1] = p + K), (q[P + 2] = p + K + 1);
            p += O + 1;
          } else {
            let M = pe.setArraySize(h, P + 3 * f);
            (M[P] = g),
              (M[P + 1] = x),
              (M[P + 2] = n.r),
              (M[P + 3] = n.g),
              (M[P + 4] = n.b),
              (M[P + 5] = n.a),
              o
                ? ((M[P + 6] = b),
                  (M[P + 7] = y),
                  (M[P + 8] = a.r),
                  (M[P + 9] = a.g),
                  (M[P + 10] = a.b),
                  (M[P + 11] = a.a),
                  (M[P + 12] = _),
                  (M[P + 13] = w),
                  (M[P + 14] = n.r),
                  (M[P + 15] = n.g),
                  (M[P + 16] = n.b),
                  (M[P + 17] = n.a),
                  (M[P + 18] = E),
                  (M[P + 19] = A),
                  (M[P + 20] = a.r),
                  (M[P + 21] = a.g),
                  (M[P + 22] = a.b),
                  (M[P + 23] = a.a),
                  (M[P + 24] = C),
                  (M[P + 25] = F),
                  (M[P + 26] = n.r),
                  (M[P + 27] = n.g),
                  (M[P + 28] = n.b),
                  (M[P + 29] = n.a),
                  (M[P + 30] = B),
                  (M[P + 31] = R),
                  (M[P + 32] = a.r),
                  (M[P + 33] = a.g),
                  (M[P + 34] = a.b),
                  (M[P + 35] = a.a))
                : ((M[P + 6] = b),
                  (M[P + 7] = y),
                  (M[P + 8] = _),
                  (M[P + 9] = w),
                  (M[P + 10] = n.r),
                  (M[P + 11] = n.g),
                  (M[P + 12] = n.b),
                  (M[P + 13] = n.a),
                  (M[P + 14] = E),
                  (M[P + 15] = A),
                  (M[P + 16] = C),
                  (M[P + 17] = F),
                  (M[P + 18] = n.r),
                  (M[P + 19] = n.g),
                  (M[P + 20] = n.b),
                  (M[P + 21] = n.a),
                  (M[P + 22] = B),
                  (M[P + 23] = R)),
              (P = c.length);
            let L = pe.setArraySize(c, P + 3);
            (L[P] = p), (L[P + 1] = p + 1), (L[P + 2] = p + 2), (p += 3);
            break;
          }
        }
      }
    }
    clipTrianglesUnpacked(e, t, i, s) {
      let n = this.clipOutput,
        a = this.clippedVertices,
        o = this.clippedUVs,
        l = this.clippedTriangles,
        h = this.clippingPolygons,
        c = h.length,
        u = 0;
      (a.length = 0), (o.length = 0), (l.length = 0);
      for (let d = 0; d < i; d += 3) {
        let f = t[d] << 1,
          p = e[f],
          m = e[f + 1],
          v = s[f],
          g = s[f + 1];
        f = t[d + 1] << 1;
        let x = e[f],
          b = e[f + 1],
          y = s[f],
          _ = s[f + 1];
        f = t[d + 2] << 1;
        let w = e[f],
          E = e[f + 1],
          A = s[f],
          C = s[f + 1];
        for (let F = 0; F < c; F++) {
          let B = a.length;
          if (this.clip(p, m, x, b, w, E, h[F], n)) {
            let R = n.length;
            if (R == 0) continue;
            let I = b - E,
              P = w - x,
              M = p - w,
              L = E - m,
              U = 1 / (I * M + P * (m - E)),
              V = R >> 1,
              z = this.clipOutput,
              N = pe.setArraySize(a, B + V * 2),
              O = pe.setArraySize(o, B + V * 2);
            for (let G = 0; G < R; G += 2, B += 2) {
              let q = z[G],
                K = z[G + 1];
              (N[B] = q), (N[B + 1] = K);
              let ue = q - w,
                ie = K - E,
                ee = (I * ue + P * ie) * U,
                ve = (L * ue + M * ie) * U,
                ye = 1 - ee - ve;
              (O[B] = v * ee + y * ve + A * ye),
                (O[B + 1] = g * ee + _ * ve + C * ye);
            }
            B = l.length;
            let H = pe.setArraySize(l, B + 3 * (V - 2));
            V--;
            for (let G = 1; G < V; G++, B += 3)
              (H[B] = u), (H[B + 1] = u + G), (H[B + 2] = u + G + 1);
            u += V + 1;
          } else {
            let R = pe.setArraySize(a, B + 6);
            (R[B] = p),
              (R[B + 1] = m),
              (R[B + 2] = x),
              (R[B + 3] = b),
              (R[B + 4] = w),
              (R[B + 5] = E);
            let I = pe.setArraySize(o, B + 3 * 2);
            (I[B] = v),
              (I[B + 1] = g),
              (I[B + 2] = y),
              (I[B + 3] = _),
              (I[B + 4] = A),
              (I[B + 5] = C),
              (B = l.length);
            let P = pe.setArraySize(l, B + 3);
            (P[B] = u), (P[B + 1] = u + 1), (P[B + 2] = u + 2), (u += 3);
            break;
          }
        }
      }
    }
    clip(e, t, i, s, n, a, o, l) {
      let h = l,
        c = !1,
        u;
      o.length % 4 >= 2 ? ((u = l), (l = this.scratch)) : (u = this.scratch),
        (u.length = 0),
        u.push(e),
        u.push(t),
        u.push(i),
        u.push(s),
        u.push(n),
        u.push(a),
        u.push(e),
        u.push(t),
        (l.length = 0);
      let d = o.length - 4,
        f = o;
      for (let p = 0; ; p += 2) {
        let m = f[p],
          v = f[p + 1],
          g = m - f[p + 2],
          x = v - f[p + 3],
          b = l.length,
          y = u;
        for (let w = 0, E = u.length - 2; w < E; ) {
          let A = y[w],
            C = y[w + 1];
          w += 2;
          let F = y[w],
            B = y[w + 1],
            R = x * (m - F) > g * (v - B),
            I = x * (m - A) - g * (v - C);
          if (I > 0) {
            if (R) {
              l.push(F), l.push(B);
              continue;
            }
            let P = F - A,
              M = B - C,
              L = I / (P * x - M * g);
            if (L >= 0 && L <= 1) l.push(A + P * L), l.push(C + M * L);
            else {
              l.push(F), l.push(B);
              continue;
            }
          } else if (R) {
            let P = F - A,
              M = B - C,
              L = I / (P * x - M * g);
            if (L >= 0 && L <= 1)
              l.push(A + P * L), l.push(C + M * L), l.push(F), l.push(B);
            else {
              l.push(F), l.push(B);
              continue;
            }
          }
          c = !0;
        }
        if (b == l.length) return (h.length = 0), !0;
        if ((l.push(l[0]), l.push(l[1]), p == d)) break;
        let _ = l;
        (l = u), (l.length = 0), (u = _);
      }
      if (h != l) {
        h.length = 0;
        for (let p = 0, m = l.length - 2; p < m; p++) h[p] = l[p];
      } else h.length = h.length - 2;
      return c;
    }
    static makeClockwise(e) {
      let t = e,
        i = e.length,
        s = t[i - 2] * t[1] - t[0] * t[i - 1],
        n = 0,
        a = 0,
        o = 0,
        l = 0;
      for (let h = 0, c = i - 3; h < c; h += 2)
        (n = t[h]),
          (a = t[h + 1]),
          (o = t[h + 2]),
          (l = t[h + 3]),
          (s += n * l - o * a);
      if (!(s < 0))
        for (let h = 0, c = i - 2, u = i >> 1; h < u; h += 2) {
          let d = t[h],
            f = t[h + 1],
            p = c - h;
          (t[h] = t[p]), (t[h + 1] = t[p + 1]), (t[p] = d), (t[p + 1] = f);
        }
    }
  }
  class pU {
    constructor(e) {
      T(this, "attachmentLoader");
      T(this, "scale", 1);
      T(this, "linkedMeshes", new Array());
      this.attachmentLoader = e;
    }
    readSkeletonData(e) {
      let t = this.scale,
        i = new Rw(),
        s = typeof e == "string" ? JSON.parse(e) : e,
        n = s.skeleton;
      if (
        (n &&
          ((i.hash = n.hash),
          (i.version = n.spine),
          (i.x = n.x),
          (i.y = n.y),
          (i.width = n.width),
          (i.height = n.height),
          (i.referenceScale = $(n, "referenceScale", 100) * t),
          (i.fps = n.fps),
          (i.imagesPath = n.images ?? null),
          (i.audioPath = n.audio ?? null)),
        s.bones)
      )
        for (let a = 0; a < s.bones.length; a++) {
          let o = s.bones[a],
            l = null,
            h = $(o, "parent", null);
          h && (l = i.findBone(h));
          let c = new Ew(i.bones.length, o.name, l);
          (c.length = $(o, "length", 0) * t),
            (c.x = $(o, "x", 0) * t),
            (c.y = $(o, "y", 0) * t),
            (c.rotation = $(o, "rotation", 0)),
            (c.scaleX = $(o, "scaleX", 1)),
            (c.scaleY = $(o, "scaleY", 1)),
            (c.shearX = $(o, "shearX", 0)),
            (c.shearY = $(o, "shearY", 0)),
            (c.inherit = pe.enumValue(Tt, $(o, "inherit", "Normal"))),
            (c.skinRequired = $(o, "skin", !1));
          let u = $(o, "color", null);
          u && c.color.setFromString(u), i.bones.push(c);
        }
      if (s.slots)
        for (let a = 0; a < s.slots.length; a++) {
          let o = s.slots[a],
            l = o.name,
            h = i.findBone(o.bone);
          if (!h) throw new Error(`Couldn't find bone ${o.bone} for slot ${l}`);
          let c = new Mw(i.slots.length, l, h),
            u = $(o, "color", null);
          u && c.color.setFromString(u);
          let d = $(o, "dark", null);
          d && (c.darkColor = Ve.fromString(d)),
            (c.attachmentName = $(o, "attachment", null)),
            (c.blendMode = pe.enumValue(Xs, $(o, "blend", "normal"))),
            (c.visible = $(o, "visible", !0)),
            i.slots.push(c);
        }
      if (s.ik)
        for (let a = 0; a < s.ik.length; a++) {
          let o = s.ik[a],
            l = new Cw(o.name);
          (l.order = $(o, "order", 0)), (l.skinRequired = $(o, "skin", !1));
          for (let c = 0; c < o.bones.length; c++) {
            let u = i.findBone(o.bones[c]);
            if (!u)
              throw new Error(
                `Couldn't find bone ${o.bones[c]} for IK constraint ${o.name}.`
              );
            l.bones.push(u);
          }
          let h = i.findBone(o.target);
          if (!h)
            throw new Error(
              `Couldn't find target bone ${o.target} for IK constraint ${o.name}.`
            );
          (l.target = h),
            (l.mix = $(o, "mix", 1)),
            (l.softness = $(o, "softness", 0) * t),
            (l.bendDirection = $(o, "bendPositive", !0) ? 1 : -1),
            (l.compress = $(o, "compress", !1)),
            (l.stretch = $(o, "stretch", !1)),
            (l.uniform = $(o, "uniform", !1)),
            i.ikConstraints.push(l);
        }
      if (s.transform)
        for (let a = 0; a < s.transform.length; a++) {
          let o = s.transform[a],
            l = new Fw(o.name);
          (l.order = $(o, "order", 0)), (l.skinRequired = $(o, "skin", !1));
          for (let u = 0; u < o.bones.length; u++) {
            let d = o.bones[u],
              f = i.findBone(d);
            if (!f)
              throw new Error(
                `Couldn't find bone ${d} for transform constraint ${o.name}.`
              );
            l.bones.push(f);
          }
          let h = o.target,
            c = i.findBone(h);
          if (!c)
            throw new Error(
              `Couldn't find target bone ${h} for transform constraint ${o.name}.`
            );
          (l.target = c),
            (l.local = $(o, "local", !1)),
            (l.relative = $(o, "relative", !1)),
            (l.offsetRotation = $(o, "rotation", 0)),
            (l.offsetX = $(o, "x", 0) * t),
            (l.offsetY = $(o, "y", 0) * t),
            (l.offsetScaleX = $(o, "scaleX", 0)),
            (l.offsetScaleY = $(o, "scaleY", 0)),
            (l.offsetShearY = $(o, "shearY", 0)),
            (l.mixRotate = $(o, "mixRotate", 1)),
            (l.mixX = $(o, "mixX", 1)),
            (l.mixY = $(o, "mixY", l.mixX)),
            (l.mixScaleX = $(o, "mixScaleX", 1)),
            (l.mixScaleY = $(o, "mixScaleY", l.mixScaleX)),
            (l.mixShearY = $(o, "mixShearY", 1)),
            i.transformConstraints.push(l);
        }
      if (s.path)
        for (let a = 0; a < s.path.length; a++) {
          let o = s.path[a],
            l = new Iw(o.name);
          (l.order = $(o, "order", 0)), (l.skinRequired = $(o, "skin", !1));
          for (let u = 0; u < o.bones.length; u++) {
            let d = o.bones[u],
              f = i.findBone(d);
            if (!f)
              throw new Error(
                `Couldn't find bone ${d} for path constraint ${o.name}.`
              );
            l.bones.push(f);
          }
          let h = o.target,
            c = i.findSlot(h);
          if (!c)
            throw new Error(
              `Couldn't find target slot ${h} for path constraint ${o.name}.`
            );
          (l.target = c),
            (l.positionMode = pe.enumValue(
              Hi,
              $(o, "positionMode", "Percent")
            )),
            (l.spacingMode = pe.enumValue(Nt, $(o, "spacingMode", "Length"))),
            (l.rotateMode = pe.enumValue(In, $(o, "rotateMode", "Tangent"))),
            (l.offsetRotation = $(o, "rotation", 0)),
            (l.position = $(o, "position", 0)),
            l.positionMode == Hi.Fixed && (l.position *= t),
            (l.spacing = $(o, "spacing", 0)),
            (l.spacingMode == Nt.Length || l.spacingMode == Nt.Fixed) &&
              (l.spacing *= t),
            (l.mixRotate = $(o, "mixRotate", 1)),
            (l.mixX = $(o, "mixX", 1)),
            (l.mixY = $(o, "mixY", l.mixX)),
            i.pathConstraints.push(l);
        }
      if (s.physics)
        for (let a = 0; a < s.physics.length; a++) {
          const o = s.physics[a],
            l = new Pw(o.name);
          (l.order = $(o, "order", 0)), (l.skinRequired = $(o, "skin", !1));
          const h = o.bone,
            c = i.findBone(h);
          if (c == null) throw new Error("Physics bone not found: " + h);
          (l.bone = c),
            (l.x = $(o, "x", 0)),
            (l.y = $(o, "y", 0)),
            (l.rotate = $(o, "rotate", 0)),
            (l.scaleX = $(o, "scaleX", 0)),
            (l.shearX = $(o, "shearX", 0)),
            (l.limit = $(o, "limit", 5e3) * t),
            (l.step = 1 / $(o, "fps", 60)),
            (l.inertia = $(o, "inertia", 1)),
            (l.strength = $(o, "strength", 100)),
            (l.damping = $(o, "damping", 1)),
            (l.massInverse = 1 / $(o, "mass", 1)),
            (l.wind = $(o, "wind", 0)),
            (l.gravity = $(o, "gravity", 0)),
            (l.mix = $(o, "mix", 1)),
            (l.inertiaGlobal = $(o, "inertiaGlobal", !1)),
            (l.strengthGlobal = $(o, "strengthGlobal", !1)),
            (l.dampingGlobal = $(o, "dampingGlobal", !1)),
            (l.massGlobal = $(o, "massGlobal", !1)),
            (l.windGlobal = $(o, "windGlobal", !1)),
            (l.gravityGlobal = $(o, "gravityGlobal", !1)),
            (l.mixGlobal = $(o, "mixGlobal", !1)),
            i.physicsConstraints.push(l);
        }
      if (s.skins)
        for (let a = 0; a < s.skins.length; a++) {
          let o = s.skins[a],
            l = new Vf(o.name);
          if (o.bones)
            for (let h = 0; h < o.bones.length; h++) {
              let c = o.bones[h],
                u = i.findBone(c);
              if (!u)
                throw new Error(`Couldn't find bone ${c} for skin ${o.name}.`);
              l.bones.push(u);
            }
          if (o.ik)
            for (let h = 0; h < o.ik.length; h++) {
              let c = o.ik[h],
                u = i.findIkConstraint(c);
              if (!u)
                throw new Error(
                  `Couldn't find IK constraint ${c} for skin ${o.name}.`
                );
              l.constraints.push(u);
            }
          if (o.transform)
            for (let h = 0; h < o.transform.length; h++) {
              let c = o.transform[h],
                u = i.findTransformConstraint(c);
              if (!u)
                throw new Error(
                  `Couldn't find transform constraint ${c} for skin ${o.name}.`
                );
              l.constraints.push(u);
            }
          if (o.path)
            for (let h = 0; h < o.path.length; h++) {
              let c = o.path[h],
                u = i.findPathConstraint(c);
              if (!u)
                throw new Error(
                  `Couldn't find path constraint ${c} for skin ${o.name}.`
                );
              l.constraints.push(u);
            }
          if (o.physics)
            for (let h = 0; h < o.physics.length; h++) {
              let c = o.physics[h],
                u = i.findPhysicsConstraint(c);
              if (!u)
                throw new Error(
                  `Couldn't find physics constraint ${c} for skin ${o.name}.`
                );
              l.constraints.push(u);
            }
          for (let h in o.attachments) {
            let c = i.findSlot(h);
            if (!c)
              throw new Error(`Couldn't find slot ${h} for skin ${o.name}.`);
            let u = o.attachments[h];
            for (let d in u) {
              let f = this.readAttachment(u[d], l, c.index, d, i);
              f && l.setAttachment(c.index, d, f);
            }
          }
          i.skins.push(l), l.name == "default" && (i.defaultSkin = l);
        }
      for (let a = 0, o = this.linkedMeshes.length; a < o; a++) {
        let l = this.linkedMeshes[a],
          h = l.skin ? i.findSkin(l.skin) : i.defaultSkin;
        if (!h) throw new Error(`Skin not found: ${l.skin}`);
        let c = h.getAttachment(l.slotIndex, l.parent);
        if (!c) throw new Error(`Parent mesh not found: ${l.parent}`);
        (l.mesh.timelineAttachment = l.inheritTimeline ? c : l.mesh),
          l.mesh.setParentMesh(c),
          l.mesh.region != null && l.mesh.updateRegion();
      }
      if (((this.linkedMeshes.length = 0), s.events))
        for (let a in s.events) {
          let o = s.events[a],
            l = new Aw(a);
          (l.intValue = $(o, "int", 0)),
            (l.floatValue = $(o, "float", 0)),
            (l.stringValue = $(o, "string", "")),
            (l.audioPath = $(o, "audio", null)),
            l.audioPath &&
              ((l.volume = $(o, "volume", 1)),
              (l.balance = $(o, "balance", 0))),
            i.events.push(l);
        }
      if (s.animations)
        for (let a in s.animations) {
          let o = s.animations[a];
          this.readAnimation(o, a, i);
        }
      return i;
    }
    readAttachment(e, t, i, s, n) {
      let a = this.scale;
      switch (((s = $(e, "name", s)), $(e, "type", "region"))) {
        case "region": {
          let o = $(e, "path", s),
            l = this.readSequence($(e, "sequence", null)),
            h = this.attachmentLoader.newRegionAttachment(t, s, o, l);
          if (!h) return null;
          (h.path = o),
            (h.x = $(e, "x", 0) * a),
            (h.y = $(e, "y", 0) * a),
            (h.scaleX = $(e, "scaleX", 1)),
            (h.scaleY = $(e, "scaleY", 1)),
            (h.rotation = $(e, "rotation", 0)),
            (h.width = e.width * a),
            (h.height = e.height * a),
            (h.sequence = l);
          let c = $(e, "color", null);
          return (
            c && h.color.setFromString(c),
            h.region != null && h.updateRegion(),
            h
          );
        }
        case "boundingbox": {
          let o = this.attachmentLoader.newBoundingBoxAttachment(t, s);
          if (!o) return null;
          this.readVertices(e, o, e.vertexCount << 1);
          let l = $(e, "color", null);
          return l && o.color.setFromString(l), o;
        }
        case "mesh":
        case "linkedmesh": {
          let o = $(e, "path", s),
            l = this.readSequence($(e, "sequence", null)),
            h = this.attachmentLoader.newMeshAttachment(t, s, o, l);
          if (!h) return null;
          h.path = o;
          let c = $(e, "color", null);
          c && h.color.setFromString(c),
            (h.width = $(e, "width", 0) * a),
            (h.height = $(e, "height", 0) * a),
            (h.sequence = l);
          let u = $(e, "parent", null);
          if (u)
            return (
              this.linkedMeshes.push(
                new mU(h, $(e, "skin", null), i, u, $(e, "timelines", !0))
              ),
              h
            );
          let d = e.uvs;
          return (
            this.readVertices(e, h, d.length),
            (h.triangles = e.triangles),
            (h.regionUVs = d),
            h.region != null && h.updateRegion(),
            (h.edges = $(e, "edges", null)),
            (h.hullLength = $(e, "hull", 0) * 2),
            h
          );
        }
        case "path": {
          let o = this.attachmentLoader.newPathAttachment(t, s);
          if (!o) return null;
          (o.closed = $(e, "closed", !1)),
            (o.constantSpeed = $(e, "constantSpeed", !0));
          let l = e.vertexCount;
          this.readVertices(e, o, l << 1);
          let h = pe.newArray(l / 3, 0);
          for (let u = 0; u < e.lengths.length; u++) h[u] = e.lengths[u] * a;
          o.lengths = h;
          let c = $(e, "color", null);
          return c && o.color.setFromString(c), o;
        }
        case "point": {
          let o = this.attachmentLoader.newPointAttachment(t, s);
          if (!o) return null;
          (o.x = $(e, "x", 0) * a),
            (o.y = $(e, "y", 0) * a),
            (o.rotation = $(e, "rotation", 0));
          let l = $(e, "color", null);
          return l && o.color.setFromString(l), o;
        }
        case "clipping": {
          let o = this.attachmentLoader.newClippingAttachment(t, s);
          if (!o) return null;
          let l = $(e, "end", null);
          l && (o.endSlot = n.findSlot(l));
          let h = e.vertexCount;
          this.readVertices(e, o, h << 1);
          let c = $(e, "color", null);
          return c && o.color.setFromString(c), o;
        }
      }
      return null;
    }
    readSequence(e) {
      if (e == null) return null;
      let t = new nc($(e, "count", 0));
      return (
        (t.start = $(e, "start", 1)),
        (t.digits = $(e, "digits", 0)),
        (t.setupIndex = $(e, "setup", 0)),
        t
      );
    }
    readVertices(e, t, i) {
      let s = this.scale;
      t.worldVerticesLength = i;
      let n = e.vertices;
      if (i == n.length) {
        let l = pe.toFloatArray(n);
        if (s != 1) for (let h = 0, c = n.length; h < c; h++) l[h] *= s;
        t.vertices = l;
        return;
      }
      let a = new Array(),
        o = new Array();
      for (let l = 0, h = n.length; l < h; ) {
        let c = n[l++];
        o.push(c);
        for (let u = l + c * 4; l < u; l += 4)
          o.push(n[l]),
            a.push(n[l + 1] * s),
            a.push(n[l + 2] * s),
            a.push(n[l + 3]);
      }
      (t.bones = o), (t.vertices = pe.toFloatArray(a));
    }
    readAnimation(e, t, i) {
      let s = this.scale,
        n = new Array();
      if (e.slots)
        for (let o in e.slots) {
          let l = e.slots[o],
            h = i.findSlot(o);
          if (!h) throw new Error("Slot not found: " + o);
          let c = h.index;
          for (let u in l) {
            let d = l[u];
            if (!d) continue;
            let f = d.length;
            if (u == "attachment") {
              let p = new ua(f, c);
              for (let m = 0; m < f; m++) {
                let v = d[m];
                p.setFrame(m, $(v, "time", 0), $(v, "name", null));
              }
              n.push(p);
            } else if (u == "rgba") {
              let p = new nw(f, f << 2, c),
                m = d[0],
                v = $(m, "time", 0),
                g = Ve.fromString(m.color);
              for (let x = 0, b = 0; ; x++) {
                p.setFrame(x, v, g.r, g.g, g.b, g.a);
                let y = d[x + 1];
                if (!y) {
                  p.shrink(b);
                  break;
                }
                let _ = $(y, "time", 0),
                  w = Ve.fromString(y.color),
                  E = m.curve;
                E &&
                  ((b = Ze(E, p, b, x, 0, v, _, g.r, w.r, 1)),
                  (b = Ze(E, p, b, x, 1, v, _, g.g, w.g, 1)),
                  (b = Ze(E, p, b, x, 2, v, _, g.b, w.b, 1)),
                  (b = Ze(E, p, b, x, 3, v, _, g.a, w.a, 1))),
                  (v = _),
                  (g = w),
                  (m = y);
              }
              n.push(p);
            } else if (u == "rgb") {
              let p = new aw(f, f * 3, c),
                m = d[0],
                v = $(m, "time", 0),
                g = Ve.fromString(m.color);
              for (let x = 0, b = 0; ; x++) {
                p.setFrame(x, v, g.r, g.g, g.b);
                let y = d[x + 1];
                if (!y) {
                  p.shrink(b);
                  break;
                }
                let _ = $(y, "time", 0),
                  w = Ve.fromString(y.color),
                  E = m.curve;
                E &&
                  ((b = Ze(E, p, b, x, 0, v, _, g.r, w.r, 1)),
                  (b = Ze(E, p, b, x, 1, v, _, g.g, w.g, 1)),
                  (b = Ze(E, p, b, x, 2, v, _, g.b, w.b, 1))),
                  (v = _),
                  (g = w),
                  (m = y);
              }
              n.push(p);
            } else if (u == "alpha") n.push(Qr(d, new ow(f, f, c), 0, 1));
            else if (u == "rgba2") {
              let p = new lw(f, f * 7, c),
                m = d[0],
                v = $(m, "time", 0),
                g = Ve.fromString(m.light),
                x = Ve.fromString(m.dark);
              for (let b = 0, y = 0; ; b++) {
                p.setFrame(b, v, g.r, g.g, g.b, g.a, x.r, x.g, x.b);
                let _ = d[b + 1];
                if (!_) {
                  p.shrink(y);
                  break;
                }
                let w = $(_, "time", 0),
                  E = Ve.fromString(_.light),
                  A = Ve.fromString(_.dark),
                  C = m.curve;
                C &&
                  ((y = Ze(C, p, y, b, 0, v, w, g.r, E.r, 1)),
                  (y = Ze(C, p, y, b, 1, v, w, g.g, E.g, 1)),
                  (y = Ze(C, p, y, b, 2, v, w, g.b, E.b, 1)),
                  (y = Ze(C, p, y, b, 3, v, w, g.a, E.a, 1)),
                  (y = Ze(C, p, y, b, 4, v, w, x.r, A.r, 1)),
                  (y = Ze(C, p, y, b, 5, v, w, x.g, A.g, 1)),
                  (y = Ze(C, p, y, b, 6, v, w, x.b, A.b, 1))),
                  (v = w),
                  (g = E),
                  (x = A),
                  (m = _);
              }
              n.push(p);
            } else if (u == "rgb2") {
              let p = new hw(f, f * 6, c),
                m = d[0],
                v = $(m, "time", 0),
                g = Ve.fromString(m.light),
                x = Ve.fromString(m.dark);
              for (let b = 0, y = 0; ; b++) {
                p.setFrame(b, v, g.r, g.g, g.b, x.r, x.g, x.b);
                let _ = d[b + 1];
                if (!_) {
                  p.shrink(y);
                  break;
                }
                let w = $(_, "time", 0),
                  E = Ve.fromString(_.light),
                  A = Ve.fromString(_.dark),
                  C = m.curve;
                C &&
                  ((y = Ze(C, p, y, b, 0, v, w, g.r, E.r, 1)),
                  (y = Ze(C, p, y, b, 1, v, w, g.g, E.g, 1)),
                  (y = Ze(C, p, y, b, 2, v, w, g.b, E.b, 1)),
                  (y = Ze(C, p, y, b, 3, v, w, x.r, A.r, 1)),
                  (y = Ze(C, p, y, b, 4, v, w, x.g, A.g, 1)),
                  (y = Ze(C, p, y, b, 5, v, w, x.b, A.b, 1))),
                  (v = w),
                  (g = E),
                  (x = A),
                  (m = _);
              }
              n.push(p);
            }
          }
        }
      if (e.bones)
        for (let o in e.bones) {
          let l = e.bones[o],
            h = i.findBone(o);
          if (!h) throw new Error("Bone not found: " + o);
          let c = h.index;
          for (let u in l) {
            let d = l[u],
              f = d.length;
            if (f != 0) {
              if (u === "rotate") n.push(Qr(d, new ac(f, f, c), 0, 1));
              else if (u === "translate") {
                let p = new q_(f, f << 1, c);
                n.push(cd(d, p, "x", "y", 0, s));
              } else if (u === "translatex") {
                let p = new K_(f, f, c);
                n.push(Qr(d, p, 0, s));
              } else if (u === "translatey") {
                let p = new Z_(f, f, c);
                n.push(Qr(d, p, 0, s));
              } else if (u === "scale") {
                let p = new J_(f, f << 1, c);
                n.push(cd(d, p, "x", "y", 1, 1));
              } else if (u === "scalex") {
                let p = new Q_(f, f, c);
                n.push(Qr(d, p, 1, 1));
              } else if (u === "scaley") {
                let p = new ew(f, f, c);
                n.push(Qr(d, p, 1, 1));
              } else if (u === "shear") {
                let p = new tw(f, f << 1, c);
                n.push(cd(d, p, "x", "y", 0, 1));
              } else if (u === "shearx") {
                let p = new rw(f, f, c);
                n.push(Qr(d, p, 0, 1));
              } else if (u === "sheary") {
                let p = new iw(f, f, c);
                n.push(Qr(d, p, 0, 1));
              } else if (u === "inherit") {
                let p = new sw(f, h.index);
                for (let m = 0; m < d.length; m++) {
                  let v = d[m];
                  p.setFrame(
                    m,
                    $(v, "time", 0),
                    pe.enumValue(Tt, $(v, "inherit", "Normal"))
                  );
                }
                n.push(p);
              }
            }
          }
        }
      if (e.ik)
        for (let o in e.ik) {
          let l = e.ik[o],
            h = l[0];
          if (!h) continue;
          let c = i.findIkConstraint(o);
          if (!c) throw new Error("IK Constraint not found: " + o);
          let u = i.ikConstraints.indexOf(c),
            d = new uw(l.length, l.length << 1, u),
            f = $(h, "time", 0),
            p = $(h, "mix", 1),
            m = $(h, "softness", 0) * s;
          for (let v = 0, g = 0; ; v++) {
            d.setFrame(
              v,
              f,
              p,
              m,
              $(h, "bendPositive", !0) ? 1 : -1,
              $(h, "compress", !1),
              $(h, "stretch", !1)
            );
            let x = l[v + 1];
            if (!x) {
              d.shrink(g);
              break;
            }
            let b = $(x, "time", 0),
              y = $(x, "mix", 1),
              _ = $(x, "softness", 0) * s,
              w = h.curve;
            w &&
              ((g = Ze(w, d, g, v, 0, f, b, p, y, 1)),
              (g = Ze(w, d, g, v, 1, f, b, m, _, s))),
              (f = b),
              (p = y),
              (m = _),
              (h = x);
          }
          n.push(d);
        }
      if (e.transform)
        for (let o in e.transform) {
          let l = e.transform[o],
            h = l[0];
          if (!h) continue;
          let c = i.findTransformConstraint(o);
          if (!c) throw new Error("Transform constraint not found: " + o);
          let u = i.transformConstraints.indexOf(c),
            d = new dw(l.length, l.length * 6, u),
            f = $(h, "time", 0),
            p = $(h, "mixRotate", 1),
            m = $(h, "mixX", 1),
            v = $(h, "mixY", m),
            g = $(h, "mixScaleX", 1),
            x = $(h, "mixScaleY", g),
            b = $(h, "mixShearY", 1);
          for (let y = 0, _ = 0; ; y++) {
            d.setFrame(y, f, p, m, v, g, x, b);
            let w = l[y + 1];
            if (!w) {
              d.shrink(_);
              break;
            }
            let E = $(w, "time", 0),
              A = $(w, "mixRotate", 1),
              C = $(w, "mixX", 1),
              F = $(w, "mixY", C),
              B = $(w, "mixScaleX", 1),
              R = $(w, "mixScaleY", B),
              I = $(w, "mixShearY", 1),
              P = h.curve;
            P &&
              ((_ = Ze(P, d, _, y, 0, f, E, p, A, 1)),
              (_ = Ze(P, d, _, y, 1, f, E, m, C, 1)),
              (_ = Ze(P, d, _, y, 2, f, E, v, F, 1)),
              (_ = Ze(P, d, _, y, 3, f, E, g, B, 1)),
              (_ = Ze(P, d, _, y, 4, f, E, x, R, 1)),
              (_ = Ze(P, d, _, y, 5, f, E, b, I, 1))),
              (f = E),
              (p = A),
              (m = C),
              (v = F),
              (g = B),
              (x = R),
              (g = B),
              (h = w);
          }
          n.push(d);
        }
      if (e.path)
        for (let o in e.path) {
          let l = e.path[o],
            h = i.findPathConstraint(o);
          if (!h) throw new Error("Path constraint not found: " + o);
          let c = i.pathConstraints.indexOf(h);
          for (let u in l) {
            let d = l[u],
              f = d[0];
            if (!f) continue;
            let p = d.length;
            if (u === "position") {
              let m = new fw(p, p, c);
              n.push(Qr(d, m, 0, h.positionMode == Hi.Fixed ? s : 1));
            } else if (u === "spacing") {
              let m = new pw(p, p, c);
              n.push(
                Qr(
                  d,
                  m,
                  0,
                  h.spacingMode == Nt.Length || h.spacingMode == Nt.Fixed
                    ? s
                    : 1
                )
              );
            } else if (u === "mix") {
              let m = new mw(p, p * 3, c),
                v = $(f, "time", 0),
                g = $(f, "mixRotate", 1),
                x = $(f, "mixX", 1),
                b = $(f, "mixY", x);
              for (let y = 0, _ = 0; ; y++) {
                m.setFrame(y, v, g, x, b);
                let w = d[y + 1];
                if (!w) {
                  m.shrink(_);
                  break;
                }
                let E = $(w, "time", 0),
                  A = $(w, "mixRotate", 1),
                  C = $(w, "mixX", 1),
                  F = $(w, "mixY", C),
                  B = f.curve;
                B &&
                  ((_ = Ze(B, m, _, y, 0, v, E, g, A, 1)),
                  (_ = Ze(B, m, _, y, 1, v, E, x, C, 1)),
                  (_ = Ze(B, m, _, y, 2, v, E, b, F, 1))),
                  (v = E),
                  (g = A),
                  (x = C),
                  (b = F),
                  (f = w);
              }
              n.push(m);
            }
          }
        }
      if (e.physics)
        for (let o in e.physics) {
          let l = e.physics[o],
            h = -1;
          if (o.length > 0) {
            let c = i.findPhysicsConstraint(o);
            if (!c) throw new Error("Physics constraint not found: " + o);
            h = i.physicsConstraints.indexOf(c);
          }
          for (let c in l) {
            let u = l[c],
              d = u[0];
            if (!d) continue;
            let f = u.length;
            if (c == "reset") {
              const m = new oc(f, h);
              for (let v = 0; d != null; d = u[v + 1], v++)
                m.setFrame(v, $(d, "time", 0));
              n.push(m);
              continue;
            }
            let p;
            if (c == "inertia") p = new gw(f, f, h);
            else if (c == "strength") p = new vw(f, f, h);
            else if (c == "damping") p = new yw(f, f, h);
            else if (c == "mass") p = new bw(f, f, h);
            else if (c == "wind") p = new xw(f, f, h);
            else if (c == "gravity") p = new _w(f, f, h);
            else if (c == "mix") p = new ww(f, f, h);
            else continue;
            n.push(Qr(u, p, 0, 1));
          }
        }
      if (e.attachments)
        for (let o in e.attachments) {
          let l = e.attachments[o],
            h = i.findSkin(o);
          if (!h) throw new Error("Skin not found: " + o);
          for (let c in l) {
            let u = l[c],
              d = i.findSlot(c);
            if (!d) throw new Error("Slot not found: " + c);
            let f = d.index;
            for (let p in u) {
              let m = u[p],
                v = h.getAttachment(f, p);
              for (let g in m) {
                let x = m[g],
                  b = x[0];
                if (b) {
                  if (g == "deform") {
                    let y = v.bones,
                      _ = v.vertices,
                      w = y ? (_.length / 3) * 2 : _.length,
                      E = new cw(x.length, x.length, f, v),
                      A = $(b, "time", 0);
                    for (let C = 0, F = 0; ; C++) {
                      let B,
                        R = $(b, "vertices", null);
                      if (!R) B = y ? pe.newFloatArray(w) : _;
                      else {
                        B = pe.newFloatArray(w);
                        let L = $(b, "offset", 0);
                        if ((pe.arrayCopy(R, 0, B, L, R.length), s != 1))
                          for (let U = L, V = U + R.length; U < V; U++)
                            B[U] *= s;
                        if (!y) for (let U = 0; U < w; U++) B[U] += _[U];
                      }
                      E.setFrame(C, A, B);
                      let I = x[C + 1];
                      if (!I) {
                        E.shrink(F);
                        break;
                      }
                      let P = $(I, "time", 0),
                        M = b.curve;
                      M && (F = Ze(M, E, F, C, 0, A, P, 0, 1, 1)),
                        (A = P),
                        (b = I);
                    }
                    n.push(E);
                  } else if (g == "sequence") {
                    let y = new lc(x.length, f, v),
                      _ = 0;
                    for (let w = 0; w < x.length; w++) {
                      let E = $(b, "delay", _),
                        A = $(b, "time", 0),
                        C = jt[$(b, "mode", "hold")],
                        F = $(b, "index", 0);
                      y.setFrame(w, A, C, F, E), (_ = E), (b = x[w + 1]);
                    }
                    n.push(y);
                  }
                }
              }
            }
          }
        }
      if (e.drawOrder) {
        let o = new Cn(e.drawOrder.length),
          l = i.slots.length,
          h = 0;
        for (let c = 0; c < e.drawOrder.length; c++, h++) {
          let u = e.drawOrder[c],
            d = null,
            f = $(u, "offsets", null);
          if (f) {
            d = pe.newArray(l, -1);
            let p = pe.newArray(l - f.length, 0),
              m = 0,
              v = 0;
            for (let g = 0; g < f.length; g++) {
              let x = f[g],
                b = i.findSlot(x.slot);
              if (!b) throw new Error("Slot not found: " + b);
              let y = b.index;
              for (; m != y; ) p[v++] = m++;
              d[m + x.offset] = m++;
            }
            for (; m < l; ) p[v++] = m++;
            for (let g = l - 1; g >= 0; g--) d[g] == -1 && (d[g] = p[--v]);
          }
          o.setFrame(h, $(u, "time", 0), d);
        }
        n.push(o);
      }
      if (e.events) {
        let o = new il(e.events.length),
          l = 0;
        for (let h = 0; h < e.events.length; h++, l++) {
          let c = e.events[h],
            u = i.findEvent(c.name);
          if (!u) throw new Error("Event not found: " + c.name);
          let d = new Sw(pe.toSinglePrecision($(c, "time", 0)), u);
          (d.intValue = $(c, "int", u.intValue)),
            (d.floatValue = $(c, "float", u.floatValue)),
            (d.stringValue = $(c, "string", u.stringValue)),
            d.data.audioPath &&
              ((d.volume = $(c, "volume", 1)),
              (d.balance = $(c, "balance", 0))),
            o.setFrame(l, d);
        }
        n.push(o);
      }
      let a = 0;
      for (let o = 0, l = n.length; o < l; o++)
        a = Math.max(a, n[o].getDuration());
      i.animations.push(new cm(t, n, a));
    }
  }
  class mU {
    constructor(e, t, i, s, n) {
      T(this, "parent");
      T(this, "skin");
      T(this, "slotIndex");
      T(this, "mesh");
      T(this, "inheritTimeline");
      (this.mesh = e),
        (this.skin = t),
        (this.slotIndex = i),
        (this.parent = s),
        (this.inheritTimeline = n);
    }
  }
  function Qr(r, e, t, i) {
    let s = r[0],
      n = $(s, "time", 0),
      a = $(s, "value", t) * i,
      o = 0;
    for (let l = 0; ; l++) {
      e.setFrame(l, n, a);
      let h = r[l + 1];
      if (!h) return e.shrink(o), e;
      let c = $(h, "time", 0),
        u = $(h, "value", t) * i;
      s.curve && (o = Ze(s.curve, e, o, l, 0, n, c, a, u, i)),
        (n = c),
        (a = u),
        (s = h);
    }
  }
  function cd(r, e, t, i, s, n) {
    let a = r[0],
      o = $(a, "time", 0),
      l = $(a, t, s) * n,
      h = $(a, i, s) * n,
      c = 0;
    for (let u = 0; ; u++) {
      e.setFrame(u, o, l, h);
      let d = r[u + 1];
      if (!d) return e.shrink(c), e;
      let f = $(d, "time", 0),
        p = $(d, t, s) * n,
        m = $(d, i, s) * n,
        v = a.curve;
      v &&
        ((c = Ze(v, e, c, u, 0, o, f, l, p, n)),
        (c = Ze(v, e, c, u, 1, o, f, h, m, n))),
        (o = f),
        (l = p),
        (h = m),
        (a = d);
    }
  }
  function Ze(r, e, t, i, s, n, a, o, l, h) {
    if (r == "stepped") return e.setStepped(i), t;
    let c = s << 2,
      u = r[c],
      d = r[c + 1] * h,
      f = r[c + 2],
      p = r[c + 3] * h;
    return e.setBezier(t, i, s, n, o, u, d, f, p, a, l), t + 1;
  }
  function $(r, e, t) {
    return r[e] !== void 0 ? r[e] : t;
  }
  typeof Math.fround > "u" &&
    (Math.fround = (function (r) {
      return function (e) {
        return (r[0] = e), r[0];
      };
    })(new Float32Array(1)));
  const ss = class ss extends E5 {
    constructor(t) {
      super(t.resource.source);
      T(this, "texture");
      this.texture = ze.from(t);
    }
    static from(t) {
      return ss.textureMap.has(t) ? ss.textureMap.get(t) : new ss(t);
    }
    setFilters(t, i) {
      (this.texture.baseTexture.scaleMode = ss.toPixiTextureFilter(t)),
        (this.texture.baseTexture.mipmap = ss.toPixiMipMap(t));
    }
    setWraps(t, i) {
      this.texture.baseTexture.wrapMode = ss.toPixiTextureWrap(t);
    }
    dispose() {
      this.texture.destroy();
    }
    static toPixiTextureFilter(t) {
      switch (t) {
        case Ht.Nearest:
        case Ht.MipMapNearestLinear:
        case Ht.MipMapNearestNearest:
          return ai.NEAREST;
        case Ht.Linear:
        case Ht.MipMapLinearLinear:
        case Ht.MipMapLinearNearest:
          return ai.LINEAR;
        default:
          throw new Error(`Unknown texture filter: ${String(t)}`);
      }
    }
    static toPixiMipMap(t) {
      switch (t) {
        case Ht.Nearest:
        case Ht.Linear:
          return Yr.OFF;
        case Ht.MipMapNearestLinear:
        case Ht.MipMapNearestNearest:
        case Ht.MipMapLinearLinear:
        case Ht.MipMapLinearNearest:
          return Yr.ON;
        default:
          throw new Error(`Unknown texture filter: ${String(t)}`);
      }
    }
    static toPixiTextureWrap(t) {
      switch (t) {
        case ps.ClampToEdge:
          return ci.CLAMP;
        case ps.MirroredRepeat:
          return ci.MIRRORED_REPEAT;
        case ps.Repeat:
          return ci.REPEAT;
        default:
          throw new Error(`Unknown texture wrap: ${String(t)}`);
      }
    }
    static toPixiBlending(t) {
      switch (t) {
        case Xs.Normal:
          return Be.NORMAL;
        case Xs.Additive:
          return Be.ADD;
        case Xs.Multiply:
          return Be.MULTIPLY;
        case Xs.Screen:
          return Be.SCREEN;
        default:
          throw new Error(`Unknown blendMode: ${String(t)}`);
      }
    }
  };
  T(ss, "textureMap", new Map());
  let za = ss;
  const ns = class ns extends rc {
    constructor() {
      const t = new F_();
      (t.getBuffer("aVertexPosition").static = !1),
        (t.getBuffer("aTextureCoord").static = !1);
      const i = new Mf(ze.EMPTY);
      super(t, i);
      T(this, "name", "");
      T(this, "warnedTwoTint", !1);
    }
    updateFromSpineData(t, i, s, n, a, o, l, h) {
      var g, x;
      this.texture = t.texture;
      const c = (a / (h ? 12 : 8)) * 2,
        u = this.geometry.getBuffer("aTextureCoord");
      ((g = u.data) == null ? void 0 : g.length) !== c &&
        (u.data = new Float32Array(c));
      const d = this.geometry.getBuffer("aVertexPosition");
      ((x = d.data) == null ? void 0 : x.length) !== c &&
        (d.data = new Float32Array(c));
      let f = 0,
        p = u.data,
        m = d.data;
      for (let b = 0; b < a; b += h ? 12 : 8) {
        let y = b;
        (m[f] = n[y++]),
          (m[f + 1] = n[y++]),
          (y += 4),
          (p[f] = n[y++]),
          (p[f + 1] = n[y++]),
          (f += 2);
      }
      h &&
        !this.warnedTwoTint &&
        (console.warn(
          "DarkTint is not enabled by default. To enable use a DarkSlotMesh factory while creating the Spine object."
        ),
        (this.warnedTwoTint = !0)),
        (ns.auxColor[0] = n[2]),
        (ns.auxColor[1] = n[3]),
        (ns.auxColor[2] = n[4]),
        (ns.auxColor[3] = n[5]),
        (this.tint = ns.auxColor),
        (this.alpha = ns.auxColor[3]),
        (this.blendMode = za.toPixiBlending(i));
      const v = this.geometry.indexBuffer;
      if (v.data.length !== o.length) v.data = new Uint32Array(o);
      else {
        const b = v.data;
        for (let y = 0; y < l; y++) b[y] = o[y];
      }
      (this.name = s), u.update(), d.update(), v.update();
    }
  };
  T(ns, "auxColor", [0, 0, 0, 0]);
  let $f = ns;
  class gU extends Yi {
    constructor(e = !1) {
      super();
      const t = new gt(void 0),
        i = new gt(void 0, !0),
        s = new gt(void 0, !0, !0);
      this.addAttribute("aVertexPosition", t, 2, !1, Ae.FLOAT),
        this.addAttribute("aTextureCoord", i, 2, !1, Ae.FLOAT),
        this.addIndex(s);
    }
  }
  const vU = `
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`,
    yU = `
varying vec2 vTextureCoord;
uniform vec4 uColor;
uniform vec4 uDarkColor;

uniform sampler2D uSampler;

void main(void)
{
	vec4 texColor = texture2D(uSampler, vTextureCoord);
    gl_FragColor.a = texColor.a * uColor.a;
    gl_FragColor.rgb = ((texColor.a - 1.0) * uDarkColor.a + 1.0 - texColor.rgb) * uDarkColor.rgb + texColor.rgb * uColor.rgb;
}
`;
  class bU extends fi {
    constructor(t) {
      const i = {
          uSampler: t ?? ze.EMPTY,
          alpha: 1,
          uTextureMatrix: vt.IDENTITY,
          uColor: new Float32Array([1, 1, 1, 1]),
          uDarkColor: new Float32Array([0, 0, 0, 0]),
        },
        s = {
          tint: 16777215,
          darkTint: 0,
          alpha: 1,
          pluginName: "darkTintBatch",
        };
      super(Li.from(vU, yU), i);
      T(this, "uvMatrix");
      T(this, "batchable");
      T(this, "pluginName");
      T(this, "_tintRGB");
      T(this, "_darkTintRGB");
      T(this, "_colorDirty");
      T(this, "_alpha");
      T(this, "_tintColor");
      T(this, "_darkTintColor");
      (this._colorDirty = !1),
        (this.uvMatrix = new sm(i.uSampler)),
        (this.batchable = !0),
        (this.pluginName = s.pluginName),
        (this._tintColor = new lt(s.tint)),
        (this._darkTintColor = new lt(s.darkTint)),
        (this._tintRGB = this._tintColor.toLittleEndianNumber()),
        (this._darkTintRGB = this._darkTintColor.toLittleEndianNumber()),
        (this._alpha = s.alpha),
        (this._colorDirty = !0);
    }
    get texture() {
      return this.uniforms.uSampler;
    }
    set texture(t) {
      this.uniforms.uSampler !== t &&
        (!this.uniforms.uSampler.baseTexture.alphaMode !=
          !t.baseTexture.alphaMode && (this._colorDirty = !0),
        (this.uniforms.uSampler = t),
        (this.uvMatrix.texture = t));
    }
    set alpha(t) {
      t !== this._alpha && ((this._alpha = t), (this._colorDirty = !0));
    }
    get alpha() {
      return this._alpha;
    }
    set tint(t) {
      t !== this.tint &&
        (this._tintColor.setValue(t),
        (this._tintRGB = this._tintColor.toLittleEndianNumber()),
        (this._colorDirty = !0));
    }
    get tint() {
      return this._tintColor.value;
    }
    set darkTint(t) {
      t !== this.darkTint &&
        (this._darkTintColor.setValue(t),
        (this._darkTintRGB = this._darkTintColor.toLittleEndianNumber()),
        (this._colorDirty = !0));
    }
    get darkTint() {
      return this._darkTintColor.value;
    }
    get tintValue() {
      return this._tintColor.toNumber();
    }
    get darkTintValue() {
      return this._darkTintColor.toNumber();
    }
    update() {
      this._colorDirty &&
        ((this._colorDirty = !1),
        lt.shared
          .setValue(this._tintColor)
          .premultiply(this._alpha, !0)
          .toArray(this.uniforms.uColor),
        lt.shared
          .setValue(this._darkTintColor)
          .premultiply(this._alpha, !0)
          .premultiply(1, !1)
          .toArray(this.uniforms.uDarkColor)),
        this.uvMatrix.update() &&
          (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
    }
  }
  class xU extends rc {
    constructor(t) {
      super(new gU(), new bU(t), void 0, void 0);
      T(this, "_darkTintRGB", 0);
    }
    get darkTint() {
      return "darkTint" in this.shader ? this.shader.darkTint : null;
    }
    set darkTint(t) {
      this.shader.darkTint = t;
    }
    get darkTintValue() {
      return this.shader.darkTintValue;
    }
    _renderToBatch(t) {
      const i = this.geometry,
        s = this.shader;
      s.uvMatrix && (s.uvMatrix.update(), this.calculateUvs()),
        this.calculateVertices(),
        (this.indices = i.indexBuffer.data),
        (this._tintRGB = s._tintRGB),
        (this._darkTintRGB = s._darkTintRGB),
        (this._texture = s.texture);
      const n = this.material.pluginName;
      t.batch.setObjectRenderer(t.plugins[n]), t.plugins[n].render(this);
    }
  }
  const kt = class kt extends xU {
    constructor() {
      super();
      T(this, "name", "");
    }
    updateFromSpineData(t, i, s, n, a, o, l, h) {
      var g, x;
      this.texture = t.texture;
      const c = (a / (h ? 12 : 8)) * 2,
        u = this.geometry.getBuffer("aTextureCoord");
      ((g = u.data) == null ? void 0 : g.length) !== c &&
        (u.data = new Float32Array(c));
      const d = this.geometry.getBuffer("aVertexPosition");
      ((x = d.data) == null ? void 0 : x.length) !== c &&
        (d.data = new Float32Array(c));
      let f = 0,
        p = u.data,
        m = d.data;
      for (let b = 0; b < a; b += h ? 12 : 8) {
        let y = b;
        (m[f] = n[y++]),
          (m[f + 1] = n[y++]),
          (y += 4),
          (p[f] = n[y++]),
          (p[f + 1] = n[y++]),
          (f += 2);
      }
      h
        ? ((kt.auxColor[0] = n[8]),
          (kt.auxColor[1] = n[9]),
          (kt.auxColor[2] = n[10]),
          (kt.auxColor[3] = n[11]),
          (this.darkTint = kt.auxColor),
          (kt.auxColor[0] = n[2]),
          (kt.auxColor[1] = n[3]),
          (kt.auxColor[2] = n[4]),
          (kt.auxColor[3] = n[5]),
          (this.tint = kt.auxColor))
        : ((kt.auxColor[0] = n[2]),
          (kt.auxColor[1] = n[3]),
          (kt.auxColor[2] = n[4]),
          (kt.auxColor[3] = n[5]),
          (this.tint = kt.auxColor)),
        (this.blendMode = za.toPixiBlending(i)),
        (this.alpha = kt.auxColor[3]);
      const v = this.geometry.indexBuffer;
      if (v.data.length !== o.length) v.data = new Uint32Array(o);
      else {
        const b = v.data;
        for (let y = 0; y < l; y++) b[y] = o[y];
      }
      (this.name = s), u.update(), d.update(), v.update();
    }
  };
  T(kt, "auxColor", [0, 0, 0, 0]);
  let Gf = kt;
  const ht = class ht extends jr {
    constructor(t, i) {
      super();
      T(this, "skeleton");
      T(this, "state");
      T(this, "_debug");
      T(this, "slotMeshFactory", () => new $f());
      T(this, "beforeUpdateWorldTransforms", () => {});
      T(this, "afterUpdateWorldTransforms", () => {});
      T(this, "autoUpdateWarned", !1);
      T(this, "_autoUpdate", !0);
      T(this, "meshesCache", new Map());
      T(this, "lightColor", new Ve());
      T(this, "darkColor", new Ve());
      T(this, "clippingVertAux", new Float32Array(6));
      T(this, "slotsObject", new Map());
      T(this, "verticesCache", pe.newFloatArray(1024));
      T(this, "clippingSlotToPixiMasks", {});
      this.skeleton = new Xa(t);
      const s = new T5(t);
      (this.state = new Nf(s)),
        (this.autoUpdate = (i == null ? void 0 : i.autoUpdate) ?? !0),
        this.initializeMeshFactory(i),
        this.skeleton.setToSetupPose(),
        this.skeleton.updateWorldTransform(ls.update);
    }
    get debug() {
      return this._debug;
    }
    set debug(t) {
      this._debug && this._debug.unregisterSpine(this),
        t && t.registerSpine(this),
        (this._debug = t);
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(t) {
      t
        ? (nr.shared.add(this.internalUpdate, this),
          (this.autoUpdateWarned = !1))
        : nr.shared.remove(this.internalUpdate, this),
        (this._autoUpdate = t);
    }
    initializeMeshFactory(t) {
      if (t != null && t.slotMeshFactory)
        this.slotMeshFactory = t == null ? void 0 : t.slotMeshFactory;
      else
        for (let i = 0; i < this.skeleton.slots.length; i++)
          if (this.skeleton.slots[i].data.darkColor) {
            this.slotMeshFactory =
              (t == null ? void 0 : t.slotMeshFactory) ?? (() => new Gf());
            break;
          }
    }
    update(t) {
      this.autoUpdate &&
        !this.autoUpdateWarned &&
        (console.warn(
          "You are calling update on a Spine instance that has autoUpdate set to true. This is probably not what you want."
        ),
        (this.autoUpdateWarned = !0)),
        this.internalUpdate(0, t);
    }
    internalUpdate(t, i) {
      const s = i ?? nr.shared.deltaMS / 1e3;
      this.state.update(s),
        this.state.apply(this.skeleton),
        this.beforeUpdateWorldTransforms(this),
        this.skeleton.update(s),
        this.skeleton.updateWorldTransform(ls.update),
        this.afterUpdateWorldTransforms(this);
    }
    updateTransform() {
      var t;
      this.renderMeshes(),
        this.sortChildren(),
        (t = this.debug) == null || t.renderDebug(this),
        super.updateTransform();
    }
    destroy(t) {
      this.autoUpdate && (this.autoUpdate = !1);
      for (const [, i] of this.meshesCache) i == null || i.destroy();
      this.state.clearListeners(),
        (this.debug = void 0),
        this.meshesCache.clear(),
        this.slotsObject.clear();
      for (let i in this.clippingSlotToPixiMasks)
        this.clippingSlotToPixiMasks[i].destroy(),
          delete this.clippingSlotToPixiMasks[i];
      super.destroy(t);
    }
    resetMeshes() {
      for (const [, t] of this.meshesCache) (t.zIndex = -1), (t.visible = !1);
    }
    hasMeshForSlot(t) {
      return this.meshesCache.has(t);
    }
    getMeshForSlot(t) {
      if (this.hasMeshForSlot(t)) {
        let i = this.meshesCache.get(t);
        return (i.visible = !0), i;
      } else {
        let i = this.slotMeshFactory();
        return this.addChild(i), this.meshesCache.set(t, i), i;
      }
    }
    getSlotFromRef(t) {
      let i;
      if (
        (typeof t == "number"
          ? (i = this.skeleton.slots[t])
          : typeof t == "string"
          ? (i = this.skeleton.findSlot(t))
          : (i = t),
        !i)
      )
        throw new Error(`No slot found with the given slot reference: ${t}`);
      return i;
    }
    addSlotObject(t, i) {
      let s = this.getSlotFromRef(t),
        n = this.slotsObject.get(s);
      if (n !== i) {
        for (const [a, o] of this.slotsObject)
          if (a !== s && o === i) {
            this.removeSlotObject(a, i);
            break;
          }
        n && this.removeChild(n), this.slotsObject.set(s, i), this.addChild(i);
      }
    }
    getSlotObject(t) {
      return this.slotsObject.get(this.getSlotFromRef(t));
    }
    removeSlotObject(t, i) {
      let s = this.getSlotFromRef(t),
        n = this.slotsObject.get(s);
      n &&
        ((i && i !== n) || (this.removeChild(n), this.slotsObject.delete(s)));
    }
    pixiMaskCleanup(t) {
      let i = this.clippingSlotToPixiMasks[t.data.name];
      i && (delete this.clippingSlotToPixiMasks[t.data.name], i.destroy());
    }
    updatePixiObject(t, i, s) {
      t.position.set(i.bone.worldX, i.bone.worldY),
        t.scale.set(i.bone.getWorldScaleX(), i.bone.getWorldScaleX()),
        (t.rotation = i.bone.getWorldRotationX() * ae.degRad),
        (t.zIndex = s + 1),
        (t.alpha = this.skeleton.color.a * i.color.a);
    }
    updateAndSetPixiMask(t, i) {
      if (ht.clipper.isClipping() && t) {
        let s = this.clippingSlotToPixiMasks[t.slot.data.name];
        if (
          (s ||
            ((s = new zc()),
            (this.clippingSlotToPixiMasks[t.slot.data.name] = s),
            this.addChild(s)),
          !t.computed)
        ) {
          t.computed = !0;
          const n = t.slot.attachment,
            a = n.worldVerticesLength;
          this.clippingVertAux.length < a &&
            (this.clippingVertAux = new Float32Array(a)),
            n.computeWorldVertices(t.slot, 0, a, this.clippingVertAux, 0, 2),
            s.clear().lineStyle(0).beginFill(0),
            s.moveTo(this.clippingVertAux[0], this.clippingVertAux[1]);
          for (let o = 2; o < a; o += 2)
            s.lineTo(this.clippingVertAux[o], this.clippingVertAux[o + 1]);
          s.finishPoly();
        }
        i.mask = s;
      } else i.mask && (i.mask = null);
    }
    renderMeshes() {
      var a, o;
      this.resetMeshes();
      let t = null,
        i = null,
        s = null;
      const n = this.skeleton.drawOrder;
      for (let l = 0, h = n.length, c = 0; l < h; l++) {
        const u = n[l];
        let d = this.slotsObject.get(u),
          f = l + c;
        d &&
          (this.updatePixiObject(d, u, f + 1),
          c++,
          this.updateAndSetPixiMask(s, d));
        const p = u.darkColor != null,
          m = ht.clipper.isClipping()
            ? 2
            : p
            ? ht.DARK_VERTEX_SIZE
            : ht.VERTEX_SIZE;
        if (!u.bone.active) {
          ht.clipper.clipEndWithSlot(u), this.pixiMaskCleanup(u);
          continue;
        }
        const v = u.getAttachment();
        let g,
          x,
          b = 0;
        if (v instanceof sl) {
          const y = v;
          (g = y.color),
            (b = m * 4),
            y.computeWorldVertices(u, this.verticesCache, 0, m),
            (t = ht.QUAD_TRIANGLES),
            (i = y.uvs),
            (x = (a = y.region) == null ? void 0 : a.texture);
        } else if (v instanceof Nn) {
          const y = v;
          (g = y.color),
            (b = (y.worldVerticesLength >> 1) * m),
            b > this.verticesCache.length &&
              (this.verticesCache = pe.newFloatArray(b)),
            y.computeWorldVertices(
              u,
              0,
              y.worldVerticesLength,
              this.verticesCache,
              0,
              m
            ),
            (t = y.triangles),
            (i = y.uvs),
            (x = (o = y.region) == null ? void 0 : o.texture);
        } else if (v instanceof _l) {
          ht.clipper.clipStart(u, v), (s = { slot: u, computed: !1 });
          continue;
        } else {
          this.hasMeshForSlot(u) && (this.getMeshForSlot(u).visible = !1),
            ht.clipper.clipEndWithSlot(u),
            this.pixiMaskCleanup(u);
          continue;
        }
        if (x != null) {
          const _ = u.bone.skeleton.color,
            w = u.color,
            E = _.a * w.a * g.a;
          this.lightColor.set(
            _.r * w.r * g.r,
            _.g * w.g * g.g,
            _.b * w.b * g.b,
            E
          ),
            u.darkColor != null
              ? this.darkColor.set(
                  u.darkColor.r,
                  u.darkColor.g,
                  u.darkColor.b,
                  1
                )
              : this.darkColor.set(0, 0, 0, 1);
          let A, C, F, B;
          if (ht.clipper.isClipping())
            ht.clipper.clipTriangles(
              this.verticesCache,
              t,
              t.length,
              i,
              this.lightColor,
              this.darkColor,
              p
            ),
              (A = ht.clipper.clippedVertices),
              (C = A.length),
              (F = ht.clipper.clippedTriangles),
              (B = F.length);
          else {
            const I = this.verticesCache;
            for (let P = 2, M = 0, L = b; P < L; P += m, M += 2) {
              let U = P;
              (I[U++] = this.lightColor.r),
                (I[U++] = this.lightColor.g),
                (I[U++] = this.lightColor.b),
                (I[U++] = this.lightColor.a),
                (I[U++] = i[M]),
                (I[U++] = i[M + 1]),
                p &&
                  ((I[U++] = this.darkColor.r),
                  (I[U++] = this.darkColor.g),
                  (I[U++] = this.darkColor.b),
                  (I[U++] = this.darkColor.a));
            }
            (A = this.verticesCache), (C = b), (F = t), (B = t.length);
          }
          if (C == 0 || B == 0) {
            ht.clipper.clipEndWithSlot(u);
            continue;
          }
          const R = this.getMeshForSlot(u);
          (R.renderable = !0),
            (R.zIndex = f),
            R.updateFromSpineData(
              x,
              u.data.blendMode,
              u.data.name,
              A,
              C,
              F,
              B,
              p
            );
        }
        ht.clipper.clipEndWithSlot(u), this.pixiMaskCleanup(u);
      }
      ht.clipper.clipEnd();
    }
    setBonePosition(t, i) {
      const s = t;
      if ((typeof t == "string" && (t = this.skeleton.findBone(t)), !t))
        throw Error(`Cannot set bone position, bone ${String(s)} not found`);
      if ((ht.vectorAux.set(i.x, i.y), t.parent)) {
        const n = t.parent.worldToLocal(ht.vectorAux);
        (t.x = n.x), (t.y = n.y);
      } else (t.x = ht.vectorAux.x), (t.y = ht.vectorAux.y);
    }
    getBonePosition(t, i) {
      const s = t;
      return (
        typeof t == "string" && (t = this.skeleton.findBone(t)),
        t
          ? (i || (i = { x: 0, y: 0 }), (i.x = t.worldX), (i.y = t.worldY), i)
          : (console.error(
              `Cannot get bone position! Bone ${String(s)} not found`
            ),
            i)
      );
    }
    skeletonToPixiWorldCoordinates(t) {
      this.worldTransform.apply(t, t);
    }
    pixiWorldCoordinatesToSkeleton(t) {
      this.worldTransform.applyInverse(t, t);
    }
    pixiWorldCoordinatesToBone(t, i) {
      this.pixiWorldCoordinatesToSkeleton(t),
        i.parent ? i.parent.worldToLocal(t) : i.worldToLocal(t);
    }
    static from(t, i, s) {
      const n = `${t}-${i}-${(s == null ? void 0 : s.scale) ?? 1}`;
      let a = ht.skeletonCache[n];
      if (a) return new ht(a, s);
      const o = oi.get(t),
        l = oi.get(i),
        h = new P5(l);
      let c = o instanceof Uint8Array ? new O5(h) : new pU(h);
      return (
        (c.scale = (s == null ? void 0 : s.scale) ?? 1),
        (a = c.readSkeletonData(o)),
        (ht.skeletonCache[n] = a),
        new this(a, s)
      );
    }
    get tint() {
      return this.skeleton.color.toRgb888();
    }
    set tint(t) {
      Ve.rgb888ToColor(this.skeleton.color, t);
    }
  };
  T(ht, "vectorAux", new sc()),
    T(ht, "clipper", new hc()),
    T(ht, "QUAD_TRIANGLES", [0, 1, 2, 2, 3, 0]),
    T(ht, "VERTEX_SIZE", 8),
    T(ht, "DARK_VERTEX_SIZE", 12),
    T(ht, "skeletonCache", Object.create(null));
  let Hf = ht;
  Xa.yDown = !0;
  const _U = {
    extension: me.Asset,
    resolver: {
      test: (r) => xr(r, ".atlas"),
      parse: (r) => {
        var t, i;
        const e = r.split(".");
        return {
          resolution: parseFloat(
            ((i = (t = we.RETINA_PREFIX) == null ? void 0 : t.exec(r)) == null
              ? void 0
              : i[1]) ?? "1"
          ),
          format: e[e.length - 2],
          src: r,
        };
      },
    },
    loader: {
      extension: {
        type: me.LoadParser,
        priority: kr.Normal,
        name: "spineTextureAtlasLoader",
      },
      test(r) {
        return xr(r, ".atlas");
      },
      async load(r) {
        return await (await we.ADAPTER.fetch(r)).text();
      },
      testParse(r, e) {
        const t = xr(e.src, ".atlas"),
          i = typeof r == "string";
        return Promise.resolve(t && i);
      },
      unload(r) {
        r.dispose();
      },
      async parse(r, e, t) {
        var l;
        const i = e.data || {};
        let s = Pt.dirname(e.src);
        s && s.lastIndexOf("/") !== s.length - 1 && (s += "/");
        const n = new A5(r);
        if (i.images instanceof Le || typeof i.images == "string") {
          const h = i.images;
          (i.images = {}), (i.images[n.pages[0].name] = h);
        }
        const a = [];
        let o = !0;
        for (const h of t.parsers)
          if (h.name == "loadTextures") {
            o = (l = h.config) == null ? void 0 : l.preferCreateImageBitmap;
            break;
          }
        oi.setPreferences({ preferCreateImageBitmap: !1 });
        for (const h of n.pages) {
          const c = h.name,
            u = i != null && i.images ? i.images[c] : void 0;
          if (u instanceof Le) h.setTexture(za.from(u));
          else {
            const f = {
                src: u ?? Pt.normalize([...s.split(Pt.sep), c].join(Pt.sep)),
                data: {
                  ...i.imageMetadata,
                  alphaMode: h.pma ? sr.PMA : sr.UNPACK,
                },
              },
              p = t.load(f).then((m) => {
                h.setTexture(za.from(m.baseTexture));
              });
            a.push(p);
          }
        }
        return (
          await Promise.all(a),
          oi.setPreferences({ preferCreateImageBitmap: o }),
          n
        );
      },
    },
  };
  Ce.add(_U);
  function wU(r) {
    return r.hasOwnProperty("bones");
  }
  function TU(r) {
    return r instanceof Uint8Array;
  }
  const EU = {
    extension: me.Asset,
    loader: {
      extension: { type: me.LoadParser, priority: kr.Normal },
      test(r) {
        return xr(r, ".skel");
      },
      async load(r) {
        const e = await we.ADAPTER.fetch(r);
        return new Uint8Array(await e.arrayBuffer());
      },
      testParse(r, e) {
        const t = xr(e.src, ".json") && wU(r),
          i = xr(e.src, ".skel") && TU(r);
        return Promise.resolve(t || i);
      },
    },
  };
  Ce.add(EU);
  class SU extends Yi {
    constructor(t = !1) {
      super();
      T(this, "_buffer");
      T(this, "_indexBuffer");
      (this._buffer = new gt(void 0, t, !1)),
        (this._indexBuffer = new gt(void 0, t, !0)),
        this.addAttribute("aVertexPosition", this._buffer, 2, !1, Ae.FLOAT)
          .addAttribute("aTextureCoord", this._buffer, 2, !1, Ae.FLOAT)
          .addAttribute("aColor", this._buffer, 4, !0, Ae.UNSIGNED_BYTE)
          .addAttribute("aDarkColor", this._buffer, 4, !0, Ae.UNSIGNED_BYTE)
          .addAttribute("aTextureId", this._buffer, 1, !0, Ae.FLOAT)
          .addIndex(this._indexBuffer);
    }
  }
  const AU = `
precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute vec4 aDarkColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying vec4 vDarkColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
    vDarkColor = aDarkColor * tint;

}
`,
    CU = `
varying vec2 vTextureCoord;
varying vec4 vColor;
varying vec4 vDarkColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%


    gl_FragColor.a = color.a * vColor.a;
    gl_FragColor.rgb = ((color.a - 1.0) * vDarkColor.a + 1.0 - color.rgb) * vDarkColor.rgb + color.rgb * vColor.rgb;
}
`;
  class Bw extends ks {
    constructor(e) {
      super(e),
        (this.shaderGenerator = new U1(AU, CU)),
        (this.geometryClass = SU),
        (this.vertexSize = 7);
    }
    packInterleavedGeometry(e, t, i, s, n) {
      const { uint32View: a, float32View: o } = t,
        l = s / this.vertexSize,
        h = e.uvs,
        c = e.indices,
        u = e.vertexData,
        d = e._texture.baseTexture._batchLocation,
        f = Math.min(e.worldAlpha, 1),
        p = lt.shared.setValue(e._tintRGB).toPremultiplied(f, !0),
        m = lt.shared
          .setValue(e._darkTintRGB)
          .premultiply(f, !0)
          .toPremultiplied(1, !1);
      for (let v = 0; v < u.length; v += 2)
        (o[s++] = u[v]),
          (o[s++] = u[v + 1]),
          (o[s++] = h[v]),
          (o[s++] = h[v + 1]),
          (a[s++] = p),
          (a[s++] = m),
          (o[s++] = d);
      for (let v = 0; v < c.length; v++) i[n++] = l + c[v];
    }
  }
  T(Bw, "extension", { name: "darkTintBatch", type: me.RendererPlugin });
  Ce.add(Bw);
  class pm {
    constructor(e, t, i, s, n, a, o) {
      T(this, "name");
      T(this, "atlasPath");
      T(this, "skelPath");
      T(this, "spineBody");
      T(this, "_scale");
      T(this, "_x");
      T(this, "_y");
      T(this, "_angle");
      T(this, "eventInfos");
      (this.atlasPath = t),
        (this.skelPath = i),
        (this.name = e),
        (this._scale = s),
        (this._x = n),
        (this._y = a),
        (this._angle = 0),
        (this.eventInfos = o);
    }
    static async CreateSpineAsync(e, t, i, s, n, a, o) {
      const l = new pm(e, t, i, s, n, a, o);
      return await l.InitAsync(), l;
    }
    async InitAsync() {
      oi.add({ alias: `${this.name}Data`, src: this.atlasPath }),
        oi.add({ alias: `${this.name}Atlas`, src: this.skelPath }),
        await oi.load([`${this.name}Data`, `${this.name}Atlas`]),
        (this.spineBody = Hf.from(`${this.name}Data`, `${this.name}Atlas`, {
          scale: this._scale,
        })),
        (this.spineBody.state.data.defaultMix = 0.2),
        (this.spineBody.x = this._x),
        (this.spineBody.y = this._y);
    }
    GetSpine() {
      return this.spineBody;
    }
    GetEntryAnimationIsComplete(e) {
      var t;
      return (
        this.spineBody.state.tracks[e] != null &&
        !((t = this.spineBody.state.tracks[e]) != null && t.isComplete())
      );
    }
    SetAnimation(e, t, i) {
      var s;
      (s = this.spineBody) == null || s.state.setAnimation(e, t, i);
    }
    AddAnimation(e, t, i, s) {
      this.spineBody.state.addAnimation(e, t, i, s);
    }
    AddEmptyAnimation(e, t, i) {
      this.spineBody.state.addEmptyAnimation(e, t, i);
    }
    SetEmptyAnimation(e, t) {
      this.spineBody.state.setEmptyAnimation(e, t);
    }
    get x() {
      return this._x;
    }
    set x(e) {
      (this.spineBody.x = e), (this._x = e);
    }
    get y() {
      return this._y;
    }
    set y(e) {
      (this.spineBody.y = e), (this._y = e);
    }
    get scale() {
      return this._scale;
    }
    set scale(e) {
      (this.spineBody.scale = { x: e, y: e }), (this._scale = e);
    }
    get angle() {
      return this._angle;
    }
    set angle(e) {
      (this.spineBody.angle = e), (this._angle = e);
    }
  }
  function IU(r) {
    let e = new XMLHttpRequest();
    return (
      e.open("GET", r, !1),
      e.overrideMimeType("text/html:charset=utf-8"),
      e.send(null),
      e.status == 200 ? e.responseText : ""
    );
  }
  const PU = { class: "loading-container", id: "loading" },
    RU = ge({
      __name: "BA",
      setup(r) {
        const e = he({
          startAnimation: "",
          startScene: !1,
          skel: "",
          atlas: "",
          version: 0,
          idol: "",
          eyeTouch: "",
          x: 100,
          y: 0,
          scale: 1,
          angle: 0,
          bgmVolume: 0,
          talkVolume: 0,
          showTouch: !0,
          panelDisplay: !0,
          showTalkDialog: !0,
          textX: 0,
          textY: 0,
          textSize: 0,
          autoTalk: 0,
          trackMouse: !1,
          resolution: "2k",
          language: "中文",
          skipStart: !1,
        });
        let t = [],
          i,
          s = null,
          n = window.innerWidth,
          a = window.innerHeight;
        const o = [];
        let l, h;
        const c = new __({
          width: n,
          height: a,
          resolution: window.devicePixelRatio || 1,
          autoDensity: !0,
          resizeTo: window,
          backgroundColor: 2899536,
          hello: !0,
        });
        let u = null,
          d,
          f,
          p,
          m = null,
          v = !1,
          g = { x: 0, y: 0 },
          x = 0;
        Rt(async () => {
          let N = IU("./loadJson.json"),
            O = JSON.parse(N);
          (t = O.EventInfos), (i = O.AnimationsTexts);
          let H = _(O.SettingModel.skel);
          H != null &&
            O.SettingModel.version == H.SettingModel.version &&
            (O = H),
            (e.value = O.SettingModel),
            console.log(t),
            (d = document.getElementById("talk")),
            (f = document.getElementById("bgm")),
            (p = document.getElementById("badialog")),
            await w(),
            (x = setInterval(y, 5e3));
        });
        function b() {
          clearInterval(x), localStorage.removeItem(e.value.skel);
        }
        function y() {
          let N = { SettingModel: e.value, EventInfos: t, AnimationsTexts: i };
          localStorage.setItem(e.value.skel, JSON.stringify(N));
        }
        function _(N) {
          let O = localStorage.getItem(N);
          return O != null ? JSON.parse(O) : null;
        }
        async function w() {
          (c.stage.eventMode = "static"), (c.stage.hitArea = c.screen);
          let N = document.getElementById("main");
          N == null || N.appendChild(c.view);
          let O = "./" + e.value.resolution + "/" + e.value.skel,
            H = "./" + e.value.resolution + "/" + e.value.atlas;
          (u = await pm.CreateSpineAsync(
            e.value.skel,
            O,
            H,
            1,
            window.innerWidth / 2,
            window.innerHeight / 2,
            t
          )),
            console.log(u),
            (u.scale = e.value.scale),
            (u.x = e.value.x),
            (u.y = e.value.y),
            u.SetAnimation(0, e.value.idol, !0),
            F(e.value.panelDisplay),
            u.GetSpine().state.addListener({ complete: M, event: P }),
            c.stage.addChild(u.GetSpine()),
            u.GetSpine().updateTransform();
          for (let G = 0; G < (u == null ? void 0 : u.eventInfos.length); G++) {
            const q = u
                .GetSpine()
                .skeleton.findBone(
                  u == null ? void 0 : u.eventInfos[G].BoneName
                ),
              K = { x: q.worldX, y: q.worldY };
            u.GetSpine().skeletonToPixiWorldCoordinates(K);
            let ue = new zc()
              .lineStyle(2, "0xff0000", 1)
              .beginFill("ff00ff", 0.1)
              .drawRect(
                -(u == null ? void 0 : u.eventInfos[G].Width) / 2,
                -(u == null ? void 0 : u.eventInfos[G].Height) / 2,
                u == null ? void 0 : u.eventInfos[G].Width,
                u == null ? void 0 : u.eventInfos[G].Height
              );
            (ue.x = K.x),
              (ue.y = K.y),
              (ue.scale = { x: e.value.scale, y: e.value.scale }),
              (ue.angle = e.value.angle),
              (ue.eventMode = "static"),
              ue.on(u == null ? void 0 : u.eventInfos[G].ClickType, () => {
                L(
                  G,
                  (u == null ? void 0 : u.eventInfos[G].EmptyAnimation) ?? !0
                );
              }),
              o.push({ graph: ue, bone: q }),
              c.stage.addChild(ue),
              (m = u.GetSpine().skeleton.findBone(e.value.eyeTouch)),
              (g.x = m.x),
              (g.y = m.y),
              (l = g);
          }
          (u.GetSpine().beforeUpdateWorldTransforms = () => {
            for (let G of o) {
              let q = { x: G.bone.worldX, y: G.bone.worldY };
              u.GetSpine().skeletonToPixiWorldCoordinates(q),
                (G.graph.x = q.x),
                (G.graph.y = q.y),
                (G.graph.scale = { x: e.value.scale, y: e.value.scale }),
                (G.graph.angle = e.value.angle);
            }
            !v &&
              m != null &&
              (Math.abs(m.x - g.x) > 1 || Math.abs(m.y - g.y) > 1) &&
              ((m.x -= (m.x - g.x) / 15), (m.y -= (m.y - g.y) / 15));
          }),
            F(e.value.panelDisplay),
            A(e.value.showTouch),
            B(e.value.textX),
            R(e.value.textY),
            I(e.value.textSize),
            V(),
            (u.angle = e.value.angle),
            (f.src = "BGM.wav"),
            (f.volume = e.value.bgmVolume),
            (d.volume = e.value.talkVolume);
          try {
            await f.play();
          } catch (G) {
            console.log(G);
          }
          e.value.startScene &&
            (u.AddAnimation(1, e.value.startAnimation, !1, 0),
            u.AddEmptyAnimation(1, 1, 0)),
            c.stage
              .on("pointerup", () => {
                u.AddEmptyAnimation(20, 0.5, 0.1),
                  u.AddEmptyAnimation(21, 0.5, 0.1),
                  (l = g),
                  (v = !1),
                  (h = null);
              })
              .on("pointerdown", ({ x: G, y: q }) => {
                if (((h = Date.now()), (v = !0), m != null)) {
                  let K = { x: G, y: q };
                  u == null || u.GetSpine().pixiWorldCoordinatesToBone(K, m),
                    (l = K);
                }
              })
              .on("pointermove", ({ x: G, y: q }) => {
                let K = v || e.value.trackMouse;
                if (m != null && K) {
                  let ue = { x: G, y: q };
                  u == null || u.GetSpine().pixiWorldCoordinatesToBone(ue, m),
                    (l = ue);
                }
              }),
            setInterval(E, 20),
            z();
        }
        function E() {
          if (m != null) {
            if (Math.abs(m.x - l.x) / 30 < 1 && Math.abs(m.y - l.y) / 30 < 1) {
              console.log((m.x - l.x) / 30, (m.y - l.y) / 30);
              return;
            }
            if (e.value.trackMouse) {
              (m.x -= (m.x - l.x) / 30), (m.y -= (m.y - l.y) / 30);
              return;
            }
            h != null &&
              Date.now() - h > 500 &&
              ((m.x -= (m.x - l.x) / 30), (m.y -= (m.y - l.y) / 30));
          }
        }
        function A(N) {
          for (let O of o) O.graph.alpha = N ? 1 : 0;
        }
        function C() {
          (e.value.panelDisplay = !e.value.panelDisplay),
            F(e.value.panelDisplay);
        }
        function F(N) {
          let O = document.getElementById("basetting");
          (O = O.parentElement.parentElement),
            N ? (O.style.display = "block") : (O.style.display = "none");
        }
        function B(N) {
          p.style.marginLeft = `${N}px`;
        }
        function R(N) {
          p.style.marginTop = `${N}px`;
        }
        function I(N) {
          p != null && (p.style.fontSize = `${N}px`);
        }
        function P(N, O) {
          var H;
          O.data.name == null ||
            O.data.name == "Talk" ||
            (O.data.audioPath != null &&
              ((d.src = O.data.audioPath),
              console.log(O.data.audioPath),
              d.play()),
            (p.innerHTML = i[e.value.language][O.data.name]),
            N.trackIndex != 0 &&
              ((H = N.animation) == null ? void 0 : H.name) != "<empty>" &&
              e.value.showTalkDialog &&
              p.classList.add("opacity-in"));
        }
        function M(N) {
          var O;
          N.trackIndex != 0 &&
            ((O = N.animation) == null ? void 0 : O.name) != "<empty>" &&
            p.classList.remove("opacity-in");
        }
        function L(N, O) {
          if (
            !u.GetEntryAnimationIsComplete(
              u == null ? void 0 : u.eventInfos[N].AnimationIndex
            ) &&
            (u.SetEmptyAnimation(
              u == null ? void 0 : u.eventInfos[N].AnimationIndex,
              0.5
            ),
            (u == null ? void 0 : u.eventInfos[N].Animations.length) > 0)
          ) {
            if (
              u != null &&
              u.eventInfos[N].Animations[
                u == null ? void 0 : u.eventInfos[N].TextIndex
              ]
            ) {
              let H =
                (u == null
                  ? void 0
                  : u.eventInfos[N].Animations[
                      u == null ? void 0 : u.eventInfos[N].TextIndex
                    ].slice(0, -1)) + "A";
              u.SetAnimation(
                (u == null ? void 0 : u.eventInfos[N].AnimationIndex) + 1,
                H,
                !1
              ),
                O &&
                  u.AddEmptyAnimation(
                    (u == null ? void 0 : u.eventInfos[N].AnimationIndex) + 1,
                    0.5,
                    0
                  );
            }
            u.SetAnimation(
              u == null ? void 0 : u.eventInfos[N].AnimationIndex,
              u == null
                ? void 0
                : u.eventInfos[N].Animations[
                    u == null ? void 0 : u.eventInfos[N].TextIndex
                  ],
              !1
            ),
              O &&
                u.AddEmptyAnimation(
                  u == null ? void 0 : u.eventInfos[N].AnimationIndex,
                  0.5,
                  0
                ),
              (u.eventInfos[N].TextIndex += 1),
              u.eventInfos[N].TextIndex >=
                (u == null ? void 0 : u.eventInfos[N].Animations.length) &&
                (u.eventInfos[N].TextIndex = 0);
          }
        }
        function U() {
          s != null && clearInterval(s),
            e.value.autoTalk > 0 &&
              (s = setInterval(() => {
                L(0, !0);
              }, e.value.autoTalk * 1e3));
        }
        function V() {
          e.value.language == "中文"
            ? (p.style.fontFamily = "MyFont,sans-serif")
            : (p.style.fontFamily = "Microsoft YaHei,sans-serif");
        }
        function z() {
          document.getElementById("loading").remove();
        }
        return (N, O) => {
          const H = tO,
            G = Nd,
            q = ZO,
            K = SF,
            ue = VO,
            ie = LB,
            ee = NB,
            ve = WO,
            ye = HB,
            _e = fO,
            ke = EF,
            k = qF;
          return (
            j(),
            xe(
              ot,
              null,
              [
                Se("div", PU, [
                  ne(H, {
                    src: "./loading.webp",
                    alt: "Loading Image",
                    class: "loading-image",
                  }),
                ]),
                ne(
                  G,
                  {
                    id: "setting-button",
                    class: "setting-button",
                    type: "primary",
                    onClick: C,
                  },
                  { default: be(() => O[22] || (O[22] = [vr("设置")])), _: 1 }
                ),
                ne(
                  k,
                  { id: "basetting", class: "setting" },
                  {
                    default: be(() => [
                      ne(
                        ke,
                        { "label-width": "250px", "label-position": "left" },
                        {
                          default: be(() => [
                            ne(
                              K,
                              { label: "Hint" },
                              {
                                default: be(() => [
                                  ne(
                                    q,
                                    { size: "large" },
                                    {
                                      default: be(
                                        () =>
                                          O[23] ||
                                          (O[23] = [
                                            vr(
                                              "屏幕的右上角点击开关面板 (Click the switch panel in the upper screen right corner.)"
                                            ),
                                          ])
                                      ),
                                      _: 1,
                                    }
                                  ),
                                ]),
                                _: 1,
                              }
                            ),
                            ne(
                              K,
                              { label: "Scale" },
                              {
                                default: be(() => [
                                  ne(
                                    ue,
                                    {
                                      modelValue: e.value.scale,
                                      "onUpdate:modelValue":
                                        O[0] ||
                                        (O[0] = (D) => (e.value.scale = D)),
                                      min: 0,
                                      max: 2,
                                      step: 0.01,
                                      onInput:
                                        O[1] ||
                                        (O[1] = (D) => (S(u).scale = D)),
                                    },
                                    null,
                                    8,
                                    ["modelValue"]
                                  ),
                                ]),
                                _: 1,
                              }
                            ),
                            ne(
                              K,
                              { label: "Screen(x)" },
                              {
                                default: be(() => [
                                  ne(
                                    ue,
                                    {
                                      modelValue: e.value.x,
                                      "onUpdate:modelValue":
                                        O[2] || (O[2] = (D) => (e.value.x = D)),
                                      min: -3e3,
                                      max: S(c).view.width + 2e3,
                                      onInput:
                                        O[3] ||
                                        (O[3] = (D) => {
                                          S(u).x = D;
                                        }),
                                    },
                                    null,
                                    8,
                                    ["modelValue", "max"]
                                  ),
                                ]),
                                _: 1,
                              }
                            ),
                            ne(
                              K,
                              { label: "Screen(y)" },
                              {
                                default: be(() => [
                                  ne(
                                    ue,
                                    {
                                      modelValue: e.value.y,
                                      "onUpdate:modelValue":
                                        O[4] || (O[4] = (D) => (e.value.y = D)),
                                      min: -3e3,
                                      max: 3e3,
                                      onInput:
                                        O[5] ||
                                        (O[5] = (D) => {
                                          S(u).y = D;
                                        }),
                                    },
                                    null,
                                    8,
                                    ["modelValue"]
                                  ),
                                ]),
                                _: 1,
                              }
                            ),
                            ne(
                              K,
                              { label: "Rotation" },
                              {
                                default: be(() => [
                                  ne(
                                    ue,
                                    {
                                      modelValue: e.value.angle,
                                      "onUpdate:modelValue":
                                        O[6] ||
                                        (O[6] = (D) => (e.value.angle = D)),
                                      min: 0,
                                      max: 360,
                                      step: 1,
                                      onInput:
                                        O[7] ||
                                        (O[7] = (D) => (S(u).angle = D)),
                                    },
                                    null,
                                    8,
                                    ["modelValue"]
                                  ),
                                ]),
                                _: 1,
                              }
                            ),
                            ne(
                              K,
                              { label: "Bgm" },
                              {
                                default: be(() => [
                                  ne(
                                    ue,
                                    {
                                      modelValue: e.value.bgmVolume,
                                      "onUpdate:modelValue":
                                        O[8] ||
                                        (O[8] = (D) => (e.value.bgmVolume = D)),
                                      min: 0,
                                      max: 1,
                                      step: 0.01,
                                      onInput:
                                        O[9] ||
                                        (O[9] = (D) => (S(f).volume = D)),
                                    },
                                    null,
                                    8,
                                    ["modelValue"]
                                  ),
                                ]),
                                _: 1,
                              }
                            ),
                            ne(
                              K,
                              { label: "Voice" },
                              {
                                default: be(() => [
                                  ne(
                                    ue,
                                    {
                                      modelValue: e.value.talkVolume,
                                      "onUpdate:modelValue":
                                        O[10] ||
                                        (O[10] = (D) =>
                                          (e.value.talkVolume = D)),
                                      min: 0,
                                      max: 1,
                                      step: 0.01,
                                      onInput:
                                        O[11] ||
                                        (O[11] = (D) => (S(d).volume = D)),
                                    },
                                    null,
                                    8,
                                    ["modelValue"]
                                  ),
                                ]),
                                _: 1,
                              }
                            ),
                            ne(
                              K,
                              { label: "Text(x)" },
                              {
                                default: be(() => [
                                  ne(
                                    ue,
                                    {
                                      modelValue: e.value.textX,
                                      "onUpdate:modelValue":
                                        O[12] ||
                                        (O[12] = (D) => (e.value.textX = D)),
                                      min: 0,
                                      max: S(n),
                                      onInput: B,
                                    },
                                    null,
                                    8,
                                    ["modelValue", "max"]
                                  ),
                                ]),
                                _: 1,
                              }
                            ),
                            ne(
                              K,
                              { label: "Text(y)" },
                              {
                                default: be(() => [
                                  ne(
                                    ue,
                                    {
                                      modelValue: e.value.textY,
                                      "onUpdate:modelValue":
                                        O[13] ||
                                        (O[13] = (D) => (e.value.textY = D)),
                                      min: 0,
                                      max: S(a),
                                      onInput: R,
                                    },
                                    null,
                                    8,
                                    ["modelValue", "max"]
                                  ),
                                ]),
                                _: 1,
                              }
                            ),
                            ne(
                              K,
                              { label: "FontSize" },
                              {
                                default: be(() => [
                                  ne(
                                    ue,
                                    {
                                      modelValue: e.value.textSize,
                                      "onUpdate:modelValue":
                                        O[14] ||
                                        (O[14] = (D) => (e.value.textSize = D)),
                                      min: 5,
                                      max: 100,
                                      onInput: I,
                                    },
                                    null,
                                    8,
                                    ["modelValue"]
                                  ),
                                ]),
                                _: 1,
                              }
                            ),
                            ne(
                              K,
                              { label: "Texture(Restart)" },
                              {
                                default: be(() => [
                                  ne(
                                    ee,
                                    {
                                      modelValue: e.value.resolution,
                                      "onUpdate:modelValue":
                                        O[15] ||
                                        (O[15] = (D) =>
                                          (e.value.resolution = D)),
                                    },
                                    {
                                      default: be(() => [
                                        ne(
                                          ie,
                                          { value: "2k" },
                                          {
                                            default: be(
                                              () =>
                                                O[24] || (O[24] = [vr("2k")])
                                            ),
                                            _: 1,
                                          }
                                        ),
                                        ne(
                                          ie,
                                          { value: "4k" },
                                          {
                                            default: be(
                                              () =>
                                                O[25] || (O[25] = [vr("4k")])
                                            ),
                                            _: 1,
                                          }
                                        ),
                                        ne(
                                          ie,
                                          { value: "8k" },
                                          {
                                            default: be(
                                              () =>
                                                O[26] || (O[26] = [vr("8k")])
                                            ),
                                            _: 1,
                                          }
                                        ),
                                      ]),
                                      _: 1,
                                    },
                                    8,
                                    ["modelValue"]
                                  ),
                                ]),
                                _: 1,
                              }
                            ),
                            ne(
                              K,
                              { label: "Language" },
                              {
                                default: be(() => [
                                  ne(
                                    ee,
                                    {
                                      onChange: V,
                                      modelValue: e.value.language,
                                      "onUpdate:modelValue":
                                        O[16] ||
                                        (O[16] = (D) => (e.value.language = D)),
                                    },
                                    {
                                      default: be(() => [
                                        (j(!0),
                                        xe(
                                          ot,
                                          null,
                                          Io(
                                            S(i),
                                            (D, W) => (
                                              j(),
                                              Me(
                                                ie,
                                                { value: W },
                                                {
                                                  default: be(() => [
                                                    vr(Ut(W), 1),
                                                  ]),
                                                  _: 2,
                                                },
                                                1032,
                                                ["value"]
                                              )
                                            )
                                          ),
                                          256
                                        )),
                                      ]),
                                      _: 1,
                                    },
                                    8,
                                    ["modelValue"]
                                  ),
                                ]),
                                _: 1,
                              }
                            ),
                            ne(
                              K,
                              { label: "AutoTalk(s)" },
                              {
                                default: be(() => [
                                  ne(
                                    ue,
                                    {
                                      modelValue: e.value.autoTalk,
                                      "onUpdate:modelValue":
                                        O[17] ||
                                        (O[17] = (D) => (e.value.autoTalk = D)),
                                      min: 0,
                                      max: 300,
                                      step: 1,
                                      onChange: U,
                                    },
                                    null,
                                    8,
                                    ["modelValue"]
                                  ),
                                ]),
                                _: 1,
                              }
                            ),
                            ne(
                              K,
                              { label: "Other" },
                              {
                                default: be(() => [
                                  ne(
                                    ve,
                                    {
                                      modelValue: e.value.showTouch,
                                      "onUpdate:modelValue":
                                        O[18] ||
                                        (O[18] = (D) =>
                                          (e.value.showTouch = D)),
                                      "inactive-text":
                                        "ShowTouchArea(显示触摸区域)",
                                      onInput: O[19] || (O[19] = (D) => A(D)),
                                    },
                                    null,
                                    8,
                                    ["modelValue"]
                                  ),
                                  ne(ye, { direction: "vertical" }),
                                  ne(
                                    ve,
                                    {
                                      modelValue: e.value.showTalkDialog,
                                      "onUpdate:modelValue":
                                        O[20] ||
                                        (O[20] = (D) =>
                                          (e.value.showTalkDialog = D)),
                                      "inactive-text": "ShowText(显示文本框)",
                                    },
                                    null,
                                    8,
                                    ["modelValue"]
                                  ),
                                  ne(ye, { direction: "vertical" }),
                                  ne(
                                    ve,
                                    {
                                      modelValue: e.value.startScene,
                                      "onUpdate:modelValue":
                                        O[21] ||
                                        (O[21] = (D) =>
                                          (e.value.startScene = D)),
                                      "inactive-text": "StartScene(开始场景)",
                                    },
                                    null,
                                    8,
                                    ["modelValue"]
                                  ),
                                ]),
                                _: 1,
                              }
                            ),
                            ne(
                              _e,
                              {
                                onConfirm: b,
                                title: "初始化设定(需要切换壁纸才能生效)",
                              },
                              {
                                reference: be(() => [
                                  ne(
                                    G,
                                    { type: "danger" },
                                    {
                                      default: be(
                                        () =>
                                          O[27] ||
                                          (O[27] = [
                                            vr("初始化设定(InitSetting)"),
                                          ])
                                      ),
                                      _: 1,
                                    }
                                  ),
                                ]),
                                _: 1,
                              }
                            ),
                          ]),
                          _: 1,
                        }
                      ),
                    ]),
                    _: 1,
                  }
                ),
                O[28] ||
                  (O[28] = Se(
                    "div",
                    { id: "badialog", class: "badialog" },
                    "测试文本",
                    -1
                  )),
                O[29] || (O[29] = Se("div", { id: "main" }, null, -1)),
                O[30] ||
                  (O[30] = Se("audio", { loop: "", id: "bgm" }, null, -1)),
                O[31] || (O[31] = Se("audio", { id: "talk" }, null, -1)),
              ],
              64
            )
          );
        };
      },
    }),
    Ow = (r, e) => {
      const t = r.__vccOpts || r;
      for (const [i, s] of e) t[i] = s;
      return t;
    },
    MU = Ow(RU, [["__scopeId", "data-v-3a6098c4"]]),
    FU = ge({
      __name: "App",
      setup(r) {
        return (e, t) => (j(), Me(MU, { msg: "Vite + Vue" }));
      },
    }),
    BU = Ow(FU, [["__scopeId", "data-v-767ce650"]]);
  pS(BU).mount("#app");
});
export default OU();
